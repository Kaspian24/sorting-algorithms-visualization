function _mergeNamespaces(n2, m2) {
  for (var i2 = 0; i2 < m2.length; i2++) {
    const e2 = m2[i2];
    if (typeof e2 !== "string" && !Array.isArray(e2)) {
      for (const k2 in e2) {
        if (k2 !== "default" && !(k2 in n2)) {
          const d2 = Object.getOwnPropertyDescriptor(e2, k2);
          if (d2) {
            Object.defineProperty(n2, k2, d2.get ? d2 : {
              enumerable: true,
              get: () => e2[k2]
            });
          }
        }
      }
    }
  }
  return Object.freeze(Object.defineProperty(n2, Symbol.toStringTag, { value: "Module" }));
}
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var jsxRuntime = { exports: {} };
var reactJsxRuntime_production_min = {};
var react = { exports: {} };
var react_production_min = {};
/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l$3 = Symbol.for("react.element"), n$5 = Symbol.for("react.portal"), p$5 = Symbol.for("react.fragment"), q$4 = Symbol.for("react.strict_mode"), r$6 = Symbol.for("react.profiler"), t$3 = Symbol.for("react.provider"), u$4 = Symbol.for("react.context"), v$4 = Symbol.for("react.forward_ref"), w$2 = Symbol.for("react.suspense"), x$1 = Symbol.for("react.memo"), y$2 = Symbol.for("react.lazy"), z$2 = Symbol.iterator;
function A$2(a2) {
  if (null === a2 || "object" !== typeof a2) return null;
  a2 = z$2 && a2[z$2] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var B$1 = { isMounted: function() {
  return false;
}, enqueueForceUpdate: function() {
}, enqueueReplaceState: function() {
}, enqueueSetState: function() {
} }, C$2 = Object.assign, D$2 = {};
function E$2(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$1;
}
E$2.prototype.isReactComponent = {};
E$2.prototype.setState = function(a2, b2) {
  if ("object" !== typeof a2 && "function" !== typeof a2 && null != a2) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");
  this.updater.enqueueSetState(this, a2, b2, "setState");
};
E$2.prototype.forceUpdate = function(a2) {
  this.updater.enqueueForceUpdate(this, a2, "forceUpdate");
};
function F$1() {
}
F$1.prototype = E$2.prototype;
function G$1(a2, b2, e2) {
  this.props = a2;
  this.context = b2;
  this.refs = D$2;
  this.updater = e2 || B$1;
}
var H$1 = G$1.prototype = new F$1();
H$1.constructor = G$1;
C$2(H$1, E$2.prototype);
H$1.isPureReactComponent = true;
var I$2 = Array.isArray, J = Object.prototype.hasOwnProperty, K$1 = { current: null }, L$2 = { key: true, ref: true, __self: true, __source: true };
function M$2(a2, b2, e2) {
  var d2, c2 = {}, k2 = null, h2 = null;
  if (null != b2) for (d2 in void 0 !== b2.ref && (h2 = b2.ref), void 0 !== b2.key && (k2 = "" + b2.key), b2) J.call(b2, d2) && !L$2.hasOwnProperty(d2) && (c2[d2] = b2[d2]);
  var g2 = arguments.length - 2;
  if (1 === g2) c2.children = e2;
  else if (1 < g2) {
    for (var f2 = Array(g2), m2 = 0; m2 < g2; m2++) f2[m2] = arguments[m2 + 2];
    c2.children = f2;
  }
  if (a2 && a2.defaultProps) for (d2 in g2 = a2.defaultProps, g2) void 0 === c2[d2] && (c2[d2] = g2[d2]);
  return { $$typeof: l$3, type: a2, key: k2, ref: h2, props: c2, _owner: K$1.current };
}
function N$1(a2, b2) {
  return { $$typeof: l$3, type: a2.type, key: b2, ref: a2.ref, props: a2.props, _owner: a2._owner };
}
function O$2(a2) {
  return "object" === typeof a2 && null !== a2 && a2.$$typeof === l$3;
}
function escape$1(a2) {
  var b2 = { "=": "=0", ":": "=2" };
  return "$" + a2.replace(/[=:]/g, function(a3) {
    return b2[a3];
  });
}
var P$2 = /\/+/g;
function Q$1(a2, b2) {
  return "object" === typeof a2 && null !== a2 && null != a2.key ? escape$1("" + a2.key) : b2.toString(36);
}
function R$2(a2, b2, e2, d2, c2) {
  var k2 = typeof a2;
  if ("undefined" === k2 || "boolean" === k2) a2 = null;
  var h2 = false;
  if (null === a2) h2 = true;
  else switch (k2) {
    case "string":
    case "number":
      h2 = true;
      break;
    case "object":
      switch (a2.$$typeof) {
        case l$3:
        case n$5:
          h2 = true;
      }
  }
  if (h2) return h2 = a2, c2 = c2(h2), a2 = "" === d2 ? "." + Q$1(h2, 0) : d2, I$2(c2) ? (e2 = "", null != a2 && (e2 = a2.replace(P$2, "$&/") + "/"), R$2(c2, b2, e2, "", function(a3) {
    return a3;
  })) : null != c2 && (O$2(c2) && (c2 = N$1(c2, e2 + (!c2.key || h2 && h2.key === c2.key ? "" : ("" + c2.key).replace(P$2, "$&/") + "/") + a2)), b2.push(c2)), 1;
  h2 = 0;
  d2 = "" === d2 ? "." : d2 + ":";
  if (I$2(a2)) for (var g2 = 0; g2 < a2.length; g2++) {
    k2 = a2[g2];
    var f2 = d2 + Q$1(k2, g2);
    h2 += R$2(k2, b2, e2, f2, c2);
  }
  else if (f2 = A$2(a2), "function" === typeof f2) for (a2 = f2.call(a2), g2 = 0; !(k2 = a2.next()).done; ) k2 = k2.value, f2 = d2 + Q$1(k2, g2++), h2 += R$2(k2, b2, e2, f2, c2);
  else if ("object" === k2) throw b2 = String(a2), Error("Objects are not valid as a React child (found: " + ("[object Object]" === b2 ? "object with keys {" + Object.keys(a2).join(", ") + "}" : b2) + "). If you meant to render a collection of children, use an array instead.");
  return h2;
}
function S$2(a2, b2, e2) {
  if (null == a2) return a2;
  var d2 = [], c2 = 0;
  R$2(a2, d2, "", "", function(a3) {
    return b2.call(e2, a3, c2++);
  });
  return d2;
}
function T$2(a2) {
  if (-1 === a2._status) {
    var b2 = a2._result;
    b2 = b2();
    b2.then(function(b3) {
      if (0 === a2._status || -1 === a2._status) a2._status = 1, a2._result = b3;
    }, function(b3) {
      if (0 === a2._status || -1 === a2._status) a2._status = 2, a2._result = b3;
    });
    -1 === a2._status && (a2._status = 0, a2._result = b2);
  }
  if (1 === a2._status) return a2._result.default;
  throw a2._result;
}
var U$2 = { current: null }, V$2 = { transition: null }, W$1 = { ReactCurrentDispatcher: U$2, ReactCurrentBatchConfig: V$2, ReactCurrentOwner: K$1 };
function X$2() {
  throw Error("act(...) is not supported in production builds of React.");
}
react_production_min.Children = { map: S$2, forEach: function(a2, b2, e2) {
  S$2(a2, function() {
    b2.apply(this, arguments);
  }, e2);
}, count: function(a2) {
  var b2 = 0;
  S$2(a2, function() {
    b2++;
  });
  return b2;
}, toArray: function(a2) {
  return S$2(a2, function(a3) {
    return a3;
  }) || [];
}, only: function(a2) {
  if (!O$2(a2)) throw Error("React.Children.only expected to receive a single React element child.");
  return a2;
} };
react_production_min.Component = E$2;
react_production_min.Fragment = p$5;
react_production_min.Profiler = r$6;
react_production_min.PureComponent = G$1;
react_production_min.StrictMode = q$4;
react_production_min.Suspense = w$2;
react_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = W$1;
react_production_min.act = X$2;
react_production_min.cloneElement = function(a2, b2, e2) {
  if (null === a2 || void 0 === a2) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + a2 + ".");
  var d2 = C$2({}, a2.props), c2 = a2.key, k2 = a2.ref, h2 = a2._owner;
  if (null != b2) {
    void 0 !== b2.ref && (k2 = b2.ref, h2 = K$1.current);
    void 0 !== b2.key && (c2 = "" + b2.key);
    if (a2.type && a2.type.defaultProps) var g2 = a2.type.defaultProps;
    for (f2 in b2) J.call(b2, f2) && !L$2.hasOwnProperty(f2) && (d2[f2] = void 0 === b2[f2] && void 0 !== g2 ? g2[f2] : b2[f2]);
  }
  var f2 = arguments.length - 2;
  if (1 === f2) d2.children = e2;
  else if (1 < f2) {
    g2 = Array(f2);
    for (var m2 = 0; m2 < f2; m2++) g2[m2] = arguments[m2 + 2];
    d2.children = g2;
  }
  return { $$typeof: l$3, type: a2.type, key: c2, ref: k2, props: d2, _owner: h2 };
};
react_production_min.createContext = function(a2) {
  a2 = { $$typeof: u$4, _currentValue: a2, _currentValue2: a2, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null };
  a2.Provider = { $$typeof: t$3, _context: a2 };
  return a2.Consumer = a2;
};
react_production_min.createElement = M$2;
react_production_min.createFactory = function(a2) {
  var b2 = M$2.bind(null, a2);
  b2.type = a2;
  return b2;
};
react_production_min.createRef = function() {
  return { current: null };
};
react_production_min.forwardRef = function(a2) {
  return { $$typeof: v$4, render: a2 };
};
react_production_min.isValidElement = O$2;
react_production_min.lazy = function(a2) {
  return { $$typeof: y$2, _payload: { _status: -1, _result: a2 }, _init: T$2 };
};
react_production_min.memo = function(a2, b2) {
  return { $$typeof: x$1, type: a2, compare: void 0 === b2 ? null : b2 };
};
react_production_min.startTransition = function(a2) {
  var b2 = V$2.transition;
  V$2.transition = {};
  try {
    a2();
  } finally {
    V$2.transition = b2;
  }
};
react_production_min.unstable_act = X$2;
react_production_min.useCallback = function(a2, b2) {
  return U$2.current.useCallback(a2, b2);
};
react_production_min.useContext = function(a2) {
  return U$2.current.useContext(a2);
};
react_production_min.useDebugValue = function() {
};
react_production_min.useDeferredValue = function(a2) {
  return U$2.current.useDeferredValue(a2);
};
react_production_min.useEffect = function(a2, b2) {
  return U$2.current.useEffect(a2, b2);
};
react_production_min.useId = function() {
  return U$2.current.useId();
};
react_production_min.useImperativeHandle = function(a2, b2, e2) {
  return U$2.current.useImperativeHandle(a2, b2, e2);
};
react_production_min.useInsertionEffect = function(a2, b2) {
  return U$2.current.useInsertionEffect(a2, b2);
};
react_production_min.useLayoutEffect = function(a2, b2) {
  return U$2.current.useLayoutEffect(a2, b2);
};
react_production_min.useMemo = function(a2, b2) {
  return U$2.current.useMemo(a2, b2);
};
react_production_min.useReducer = function(a2, b2, e2) {
  return U$2.current.useReducer(a2, b2, e2);
};
react_production_min.useRef = function(a2) {
  return U$2.current.useRef(a2);
};
react_production_min.useState = function(a2) {
  return U$2.current.useState(a2);
};
react_production_min.useSyncExternalStore = function(a2, b2, e2) {
  return U$2.current.useSyncExternalStore(a2, b2, e2);
};
react_production_min.useTransition = function() {
  return U$2.current.useTransition();
};
react_production_min.version = "18.3.1";
{
  react.exports = react_production_min;
}
var reactExports = react.exports;
const React = /* @__PURE__ */ getDefaultExportFromCjs(reactExports);
const React$1 = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  default: React
}, [reactExports]);
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var f$2 = reactExports, k$1 = Symbol.for("react.element"), l$2 = Symbol.for("react.fragment"), m$4 = Object.prototype.hasOwnProperty, n$4 = f$2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, p$4 = { key: true, ref: true, __self: true, __source: true };
function q$3(c2, a2, g2) {
  var b2, d2 = {}, e2 = null, h2 = null;
  void 0 !== g2 && (e2 = "" + g2);
  void 0 !== a2.key && (e2 = "" + a2.key);
  void 0 !== a2.ref && (h2 = a2.ref);
  for (b2 in a2) m$4.call(a2, b2) && !p$4.hasOwnProperty(b2) && (d2[b2] = a2[b2]);
  if (c2 && c2.defaultProps) for (b2 in a2 = c2.defaultProps, a2) void 0 === d2[b2] && (d2[b2] = a2[b2]);
  return { $$typeof: k$1, type: c2, key: e2, ref: h2, props: d2, _owner: n$4.current };
}
reactJsxRuntime_production_min.Fragment = l$2;
reactJsxRuntime_production_min.jsx = q$3;
reactJsxRuntime_production_min.jsxs = q$3;
{
  jsxRuntime.exports = reactJsxRuntime_production_min;
}
var jsxRuntimeExports = jsxRuntime.exports;
var client = {};
var reactDom = { exports: {} };
var reactDom_production_min = {};
var scheduler = { exports: {} };
var scheduler_production_min = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(exports) {
  function f2(a2, b2) {
    var c2 = a2.length;
    a2.push(b2);
    a: for (; 0 < c2; ) {
      var d2 = c2 - 1 >>> 1, e2 = a2[d2];
      if (0 < g2(e2, b2)) a2[d2] = b2, a2[c2] = e2, c2 = d2;
      else break a;
    }
  }
  function h2(a2) {
    return 0 === a2.length ? null : a2[0];
  }
  function k2(a2) {
    if (0 === a2.length) return null;
    var b2 = a2[0], c2 = a2.pop();
    if (c2 !== b2) {
      a2[0] = c2;
      a: for (var d2 = 0, e2 = a2.length, w2 = e2 >>> 1; d2 < w2; ) {
        var m2 = 2 * (d2 + 1) - 1, C2 = a2[m2], n2 = m2 + 1, x2 = a2[n2];
        if (0 > g2(C2, c2)) n2 < e2 && 0 > g2(x2, C2) ? (a2[d2] = x2, a2[n2] = c2, d2 = n2) : (a2[d2] = C2, a2[m2] = c2, d2 = m2);
        else if (n2 < e2 && 0 > g2(x2, c2)) a2[d2] = x2, a2[n2] = c2, d2 = n2;
        else break a;
      }
    }
    return b2;
  }
  function g2(a2, b2) {
    var c2 = a2.sortIndex - b2.sortIndex;
    return 0 !== c2 ? c2 : a2.id - b2.id;
  }
  if ("object" === typeof performance && "function" === typeof performance.now) {
    var l2 = performance;
    exports.unstable_now = function() {
      return l2.now();
    };
  } else {
    var p2 = Date, q2 = p2.now();
    exports.unstable_now = function() {
      return p2.now() - q2;
    };
  }
  var r2 = [], t2 = [], u2 = 1, v2 = null, y2 = 3, z2 = false, A2 = false, B2 = false, D2 = "function" === typeof setTimeout ? setTimeout : null, E2 = "function" === typeof clearTimeout ? clearTimeout : null, F2 = "undefined" !== typeof setImmediate ? setImmediate : null;
  "undefined" !== typeof navigator && void 0 !== navigator.scheduling && void 0 !== navigator.scheduling.isInputPending && navigator.scheduling.isInputPending.bind(navigator.scheduling);
  function G2(a2) {
    for (var b2 = h2(t2); null !== b2; ) {
      if (null === b2.callback) k2(t2);
      else if (b2.startTime <= a2) k2(t2), b2.sortIndex = b2.expirationTime, f2(r2, b2);
      else break;
      b2 = h2(t2);
    }
  }
  function H2(a2) {
    B2 = false;
    G2(a2);
    if (!A2) if (null !== h2(r2)) A2 = true, I2(J2);
    else {
      var b2 = h2(t2);
      null !== b2 && K2(H2, b2.startTime - a2);
    }
  }
  function J2(a2, b2) {
    A2 = false;
    B2 && (B2 = false, E2(L2), L2 = -1);
    z2 = true;
    var c2 = y2;
    try {
      G2(b2);
      for (v2 = h2(r2); null !== v2 && (!(v2.expirationTime > b2) || a2 && !M2()); ) {
        var d2 = v2.callback;
        if ("function" === typeof d2) {
          v2.callback = null;
          y2 = v2.priorityLevel;
          var e2 = d2(v2.expirationTime <= b2);
          b2 = exports.unstable_now();
          "function" === typeof e2 ? v2.callback = e2 : v2 === h2(r2) && k2(r2);
          G2(b2);
        } else k2(r2);
        v2 = h2(r2);
      }
      if (null !== v2) var w2 = true;
      else {
        var m2 = h2(t2);
        null !== m2 && K2(H2, m2.startTime - b2);
        w2 = false;
      }
      return w2;
    } finally {
      v2 = null, y2 = c2, z2 = false;
    }
  }
  var N2 = false, O2 = null, L2 = -1, P2 = 5, Q2 = -1;
  function M2() {
    return exports.unstable_now() - Q2 < P2 ? false : true;
  }
  function R2() {
    if (null !== O2) {
      var a2 = exports.unstable_now();
      Q2 = a2;
      var b2 = true;
      try {
        b2 = O2(true, a2);
      } finally {
        b2 ? S2() : (N2 = false, O2 = null);
      }
    } else N2 = false;
  }
  var S2;
  if ("function" === typeof F2) S2 = function() {
    F2(R2);
  };
  else if ("undefined" !== typeof MessageChannel) {
    var T2 = new MessageChannel(), U2 = T2.port2;
    T2.port1.onmessage = R2;
    S2 = function() {
      U2.postMessage(null);
    };
  } else S2 = function() {
    D2(R2, 0);
  };
  function I2(a2) {
    O2 = a2;
    N2 || (N2 = true, S2());
  }
  function K2(a2, b2) {
    L2 = D2(function() {
      a2(exports.unstable_now());
    }, b2);
  }
  exports.unstable_IdlePriority = 5;
  exports.unstable_ImmediatePriority = 1;
  exports.unstable_LowPriority = 4;
  exports.unstable_NormalPriority = 3;
  exports.unstable_Profiling = null;
  exports.unstable_UserBlockingPriority = 2;
  exports.unstable_cancelCallback = function(a2) {
    a2.callback = null;
  };
  exports.unstable_continueExecution = function() {
    A2 || z2 || (A2 = true, I2(J2));
  };
  exports.unstable_forceFrameRate = function(a2) {
    0 > a2 || 125 < a2 ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : P2 = 0 < a2 ? Math.floor(1e3 / a2) : 5;
  };
  exports.unstable_getCurrentPriorityLevel = function() {
    return y2;
  };
  exports.unstable_getFirstCallbackNode = function() {
    return h2(r2);
  };
  exports.unstable_next = function(a2) {
    switch (y2) {
      case 1:
      case 2:
      case 3:
        var b2 = 3;
        break;
      default:
        b2 = y2;
    }
    var c2 = y2;
    y2 = b2;
    try {
      return a2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_pauseExecution = function() {
  };
  exports.unstable_requestPaint = function() {
  };
  exports.unstable_runWithPriority = function(a2, b2) {
    switch (a2) {
      case 1:
      case 2:
      case 3:
      case 4:
      case 5:
        break;
      default:
        a2 = 3;
    }
    var c2 = y2;
    y2 = a2;
    try {
      return b2();
    } finally {
      y2 = c2;
    }
  };
  exports.unstable_scheduleCallback = function(a2, b2, c2) {
    var d2 = exports.unstable_now();
    "object" === typeof c2 && null !== c2 ? (c2 = c2.delay, c2 = "number" === typeof c2 && 0 < c2 ? d2 + c2 : d2) : c2 = d2;
    switch (a2) {
      case 1:
        var e2 = -1;
        break;
      case 2:
        e2 = 250;
        break;
      case 5:
        e2 = 1073741823;
        break;
      case 4:
        e2 = 1e4;
        break;
      default:
        e2 = 5e3;
    }
    e2 = c2 + e2;
    a2 = { id: u2++, callback: b2, priorityLevel: a2, startTime: c2, expirationTime: e2, sortIndex: -1 };
    c2 > d2 ? (a2.sortIndex = c2, f2(t2, a2), null === h2(r2) && a2 === h2(t2) && (B2 ? (E2(L2), L2 = -1) : B2 = true, K2(H2, c2 - d2))) : (a2.sortIndex = e2, f2(r2, a2), A2 || z2 || (A2 = true, I2(J2)));
    return a2;
  };
  exports.unstable_shouldYield = M2;
  exports.unstable_wrapCallback = function(a2) {
    var b2 = y2;
    return function() {
      var c2 = y2;
      y2 = b2;
      try {
        return a2.apply(this, arguments);
      } finally {
        y2 = c2;
      }
    };
  };
})(scheduler_production_min);
{
  scheduler.exports = scheduler_production_min;
}
var schedulerExports = scheduler.exports;
/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aa = reactExports, ca = schedulerExports;
function p$3(a2) {
  for (var b2 = "https://reactjs.org/docs/error-decoder.html?invariant=" + a2, c2 = 1; c2 < arguments.length; c2++) b2 += "&args[]=" + encodeURIComponent(arguments[c2]);
  return "Minified React error #" + a2 + "; visit " + b2 + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings.";
}
var da = /* @__PURE__ */ new Set(), ea = {};
function fa(a2, b2) {
  ha(a2, b2);
  ha(a2 + "Capture", b2);
}
function ha(a2, b2) {
  ea[a2] = b2;
  for (a2 = 0; a2 < b2.length; a2++) da.add(b2[a2]);
}
var ia = !("undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement), ja = Object.prototype.hasOwnProperty, ka = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, la = {}, ma = {};
function oa(a2) {
  if (ja.call(ma, a2)) return true;
  if (ja.call(la, a2)) return false;
  if (ka.test(a2)) return ma[a2] = true;
  la[a2] = true;
  return false;
}
function pa(a2, b2, c2, d2) {
  if (null !== c2 && 0 === c2.type) return false;
  switch (typeof b2) {
    case "function":
    case "symbol":
      return true;
    case "boolean":
      if (d2) return false;
      if (null !== c2) return !c2.acceptsBooleans;
      a2 = a2.toLowerCase().slice(0, 5);
      return "data-" !== a2 && "aria-" !== a2;
    default:
      return false;
  }
}
function qa(a2, b2, c2, d2) {
  if (null === b2 || "undefined" === typeof b2 || pa(a2, b2, c2, d2)) return true;
  if (d2) return false;
  if (null !== c2) switch (c2.type) {
    case 3:
      return !b2;
    case 4:
      return false === b2;
    case 5:
      return isNaN(b2);
    case 6:
      return isNaN(b2) || 1 > b2;
  }
  return false;
}
function v$3(a2, b2, c2, d2, e2, f2, g2) {
  this.acceptsBooleans = 2 === b2 || 3 === b2 || 4 === b2;
  this.attributeName = d2;
  this.attributeNamespace = e2;
  this.mustUseProperty = c2;
  this.propertyName = a2;
  this.type = b2;
  this.sanitizeURL = f2;
  this.removeEmptyString = g2;
}
var z$1 = {};
"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(a2) {
  z$1[a2] = new v$3(a2, 0, false, a2, null, false, false);
});
[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(a2) {
  var b2 = a2[0];
  z$1[b2] = new v$3(b2, 1, false, a2[1], null, false, false);
});
["contentEditable", "draggable", "spellCheck", "value"].forEach(function(a2) {
  z$1[a2] = new v$3(a2, 2, false, a2.toLowerCase(), null, false, false);
});
["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(a2) {
  z$1[a2] = new v$3(a2, 2, false, a2, null, false, false);
});
"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(a2) {
  z$1[a2] = new v$3(a2, 3, false, a2.toLowerCase(), null, false, false);
});
["checked", "multiple", "muted", "selected"].forEach(function(a2) {
  z$1[a2] = new v$3(a2, 3, true, a2, null, false, false);
});
["capture", "download"].forEach(function(a2) {
  z$1[a2] = new v$3(a2, 4, false, a2, null, false, false);
});
["cols", "rows", "size", "span"].forEach(function(a2) {
  z$1[a2] = new v$3(a2, 6, false, a2, null, false, false);
});
["rowSpan", "start"].forEach(function(a2) {
  z$1[a2] = new v$3(a2, 5, false, a2.toLowerCase(), null, false, false);
});
var ra = /[\-:]([a-z])/g;
function sa(a2) {
  return a2[1].toUpperCase();
}
"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(a2) {
  var b2 = a2.replace(
    ra,
    sa
  );
  z$1[b2] = new v$3(b2, 1, false, a2, null, false, false);
});
"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$1[b2] = new v$3(b2, 1, false, a2, "http://www.w3.org/1999/xlink", false, false);
});
["xml:base", "xml:lang", "xml:space"].forEach(function(a2) {
  var b2 = a2.replace(ra, sa);
  z$1[b2] = new v$3(b2, 1, false, a2, "http://www.w3.org/XML/1998/namespace", false, false);
});
["tabIndex", "crossOrigin"].forEach(function(a2) {
  z$1[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, false, false);
});
z$1.xlinkHref = new v$3("xlinkHref", 1, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
["src", "href", "action", "formAction"].forEach(function(a2) {
  z$1[a2] = new v$3(a2, 1, false, a2.toLowerCase(), null, true, true);
});
function ta(a2, b2, c2, d2) {
  var e2 = z$1.hasOwnProperty(b2) ? z$1[b2] : null;
  if (null !== e2 ? 0 !== e2.type : d2 || !(2 < b2.length) || "o" !== b2[0] && "O" !== b2[0] || "n" !== b2[1] && "N" !== b2[1]) qa(b2, c2, e2, d2) && (c2 = null), d2 || null === e2 ? oa(b2) && (null === c2 ? a2.removeAttribute(b2) : a2.setAttribute(b2, "" + c2)) : e2.mustUseProperty ? a2[e2.propertyName] = null === c2 ? 3 === e2.type ? false : "" : c2 : (b2 = e2.attributeName, d2 = e2.attributeNamespace, null === c2 ? a2.removeAttribute(b2) : (e2 = e2.type, c2 = 3 === e2 || 4 === e2 && true === c2 ? "" : "" + c2, d2 ? a2.setAttributeNS(d2, b2, c2) : a2.setAttribute(b2, c2)));
}
var ua = aa.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, va = Symbol.for("react.element"), wa = Symbol.for("react.portal"), ya = Symbol.for("react.fragment"), za = Symbol.for("react.strict_mode"), Aa = Symbol.for("react.profiler"), Ba = Symbol.for("react.provider"), Ca = Symbol.for("react.context"), Da = Symbol.for("react.forward_ref"), Ea = Symbol.for("react.suspense"), Fa = Symbol.for("react.suspense_list"), Ga = Symbol.for("react.memo"), Ha = Symbol.for("react.lazy");
var Ia = Symbol.for("react.offscreen");
var Ja = Symbol.iterator;
function Ka(a2) {
  if (null === a2 || "object" !== typeof a2) return null;
  a2 = Ja && a2[Ja] || a2["@@iterator"];
  return "function" === typeof a2 ? a2 : null;
}
var A$1 = Object.assign, La;
function Ma(a2) {
  if (void 0 === La) try {
    throw Error();
  } catch (c2) {
    var b2 = c2.stack.trim().match(/\n( *(at )?)/);
    La = b2 && b2[1] || "";
  }
  return "\n" + La + a2;
}
var Na = false;
function Oa(a2, b2) {
  if (!a2 || Na) return "";
  Na = true;
  var c2 = Error.prepareStackTrace;
  Error.prepareStackTrace = void 0;
  try {
    if (b2) if (b2 = function() {
      throw Error();
    }, Object.defineProperty(b2.prototype, "props", { set: function() {
      throw Error();
    } }), "object" === typeof Reflect && Reflect.construct) {
      try {
        Reflect.construct(b2, []);
      } catch (l2) {
        var d2 = l2;
      }
      Reflect.construct(a2, [], b2);
    } else {
      try {
        b2.call();
      } catch (l2) {
        d2 = l2;
      }
      a2.call(b2.prototype);
    }
    else {
      try {
        throw Error();
      } catch (l2) {
        d2 = l2;
      }
      a2();
    }
  } catch (l2) {
    if (l2 && d2 && "string" === typeof l2.stack) {
      for (var e2 = l2.stack.split("\n"), f2 = d2.stack.split("\n"), g2 = e2.length - 1, h2 = f2.length - 1; 1 <= g2 && 0 <= h2 && e2[g2] !== f2[h2]; ) h2--;
      for (; 1 <= g2 && 0 <= h2; g2--, h2--) if (e2[g2] !== f2[h2]) {
        if (1 !== g2 || 1 !== h2) {
          do
            if (g2--, h2--, 0 > h2 || e2[g2] !== f2[h2]) {
              var k2 = "\n" + e2[g2].replace(" at new ", " at ");
              a2.displayName && k2.includes("<anonymous>") && (k2 = k2.replace("<anonymous>", a2.displayName));
              return k2;
            }
          while (1 <= g2 && 0 <= h2);
        }
        break;
      }
    }
  } finally {
    Na = false, Error.prepareStackTrace = c2;
  }
  return (a2 = a2 ? a2.displayName || a2.name : "") ? Ma(a2) : "";
}
function Pa(a2) {
  switch (a2.tag) {
    case 5:
      return Ma(a2.type);
    case 16:
      return Ma("Lazy");
    case 13:
      return Ma("Suspense");
    case 19:
      return Ma("SuspenseList");
    case 0:
    case 2:
    case 15:
      return a2 = Oa(a2.type, false), a2;
    case 11:
      return a2 = Oa(a2.type.render, false), a2;
    case 1:
      return a2 = Oa(a2.type, true), a2;
    default:
      return "";
  }
}
function Qa(a2) {
  if (null == a2) return null;
  if ("function" === typeof a2) return a2.displayName || a2.name || null;
  if ("string" === typeof a2) return a2;
  switch (a2) {
    case ya:
      return "Fragment";
    case wa:
      return "Portal";
    case Aa:
      return "Profiler";
    case za:
      return "StrictMode";
    case Ea:
      return "Suspense";
    case Fa:
      return "SuspenseList";
  }
  if ("object" === typeof a2) switch (a2.$$typeof) {
    case Ca:
      return (a2.displayName || "Context") + ".Consumer";
    case Ba:
      return (a2._context.displayName || "Context") + ".Provider";
    case Da:
      var b2 = a2.render;
      a2 = a2.displayName;
      a2 || (a2 = b2.displayName || b2.name || "", a2 = "" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
      return a2;
    case Ga:
      return b2 = a2.displayName || null, null !== b2 ? b2 : Qa(a2.type) || "Memo";
    case Ha:
      b2 = a2._payload;
      a2 = a2._init;
      try {
        return Qa(a2(b2));
      } catch (c2) {
      }
  }
  return null;
}
function Ra(a2) {
  var b2 = a2.type;
  switch (a2.tag) {
    case 24:
      return "Cache";
    case 9:
      return (b2.displayName || "Context") + ".Consumer";
    case 10:
      return (b2._context.displayName || "Context") + ".Provider";
    case 18:
      return "DehydratedFragment";
    case 11:
      return a2 = b2.render, a2 = a2.displayName || a2.name || "", b2.displayName || ("" !== a2 ? "ForwardRef(" + a2 + ")" : "ForwardRef");
    case 7:
      return "Fragment";
    case 5:
      return b2;
    case 4:
      return "Portal";
    case 3:
      return "Root";
    case 6:
      return "Text";
    case 16:
      return Qa(b2);
    case 8:
      return b2 === za ? "StrictMode" : "Mode";
    case 22:
      return "Offscreen";
    case 12:
      return "Profiler";
    case 21:
      return "Scope";
    case 13:
      return "Suspense";
    case 19:
      return "SuspenseList";
    case 25:
      return "TracingMarker";
    case 1:
    case 0:
    case 17:
    case 2:
    case 14:
    case 15:
      if ("function" === typeof b2) return b2.displayName || b2.name || null;
      if ("string" === typeof b2) return b2;
  }
  return null;
}
function Sa(a2) {
  switch (typeof a2) {
    case "boolean":
    case "number":
    case "string":
    case "undefined":
      return a2;
    case "object":
      return a2;
    default:
      return "";
  }
}
function Ta(a2) {
  var b2 = a2.type;
  return (a2 = a2.nodeName) && "input" === a2.toLowerCase() && ("checkbox" === b2 || "radio" === b2);
}
function Ua(a2) {
  var b2 = Ta(a2) ? "checked" : "value", c2 = Object.getOwnPropertyDescriptor(a2.constructor.prototype, b2), d2 = "" + a2[b2];
  if (!a2.hasOwnProperty(b2) && "undefined" !== typeof c2 && "function" === typeof c2.get && "function" === typeof c2.set) {
    var e2 = c2.get, f2 = c2.set;
    Object.defineProperty(a2, b2, { configurable: true, get: function() {
      return e2.call(this);
    }, set: function(a3) {
      d2 = "" + a3;
      f2.call(this, a3);
    } });
    Object.defineProperty(a2, b2, { enumerable: c2.enumerable });
    return { getValue: function() {
      return d2;
    }, setValue: function(a3) {
      d2 = "" + a3;
    }, stopTracking: function() {
      a2._valueTracker = null;
      delete a2[b2];
    } };
  }
}
function Va(a2) {
  a2._valueTracker || (a2._valueTracker = Ua(a2));
}
function Wa(a2) {
  if (!a2) return false;
  var b2 = a2._valueTracker;
  if (!b2) return true;
  var c2 = b2.getValue();
  var d2 = "";
  a2 && (d2 = Ta(a2) ? a2.checked ? "true" : "false" : a2.value);
  a2 = d2;
  return a2 !== c2 ? (b2.setValue(a2), true) : false;
}
function Xa(a2) {
  a2 = a2 || ("undefined" !== typeof document ? document : void 0);
  if ("undefined" === typeof a2) return null;
  try {
    return a2.activeElement || a2.body;
  } catch (b2) {
    return a2.body;
  }
}
function Ya(a2, b2) {
  var c2 = b2.checked;
  return A$1({}, b2, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: null != c2 ? c2 : a2._wrapperState.initialChecked });
}
function Za(a2, b2) {
  var c2 = null == b2.defaultValue ? "" : b2.defaultValue, d2 = null != b2.checked ? b2.checked : b2.defaultChecked;
  c2 = Sa(null != b2.value ? b2.value : c2);
  a2._wrapperState = { initialChecked: d2, initialValue: c2, controlled: "checkbox" === b2.type || "radio" === b2.type ? null != b2.checked : null != b2.value };
}
function ab(a2, b2) {
  b2 = b2.checked;
  null != b2 && ta(a2, "checked", b2, false);
}
function bb(a2, b2) {
  ab(a2, b2);
  var c2 = Sa(b2.value), d2 = b2.type;
  if (null != c2) if ("number" === d2) {
    if (0 === c2 && "" === a2.value || a2.value != c2) a2.value = "" + c2;
  } else a2.value !== "" + c2 && (a2.value = "" + c2);
  else if ("submit" === d2 || "reset" === d2) {
    a2.removeAttribute("value");
    return;
  }
  b2.hasOwnProperty("value") ? cb(a2, b2.type, c2) : b2.hasOwnProperty("defaultValue") && cb(a2, b2.type, Sa(b2.defaultValue));
  null == b2.checked && null != b2.defaultChecked && (a2.defaultChecked = !!b2.defaultChecked);
}
function db(a2, b2, c2) {
  if (b2.hasOwnProperty("value") || b2.hasOwnProperty("defaultValue")) {
    var d2 = b2.type;
    if (!("submit" !== d2 && "reset" !== d2 || void 0 !== b2.value && null !== b2.value)) return;
    b2 = "" + a2._wrapperState.initialValue;
    c2 || b2 === a2.value || (a2.value = b2);
    a2.defaultValue = b2;
  }
  c2 = a2.name;
  "" !== c2 && (a2.name = "");
  a2.defaultChecked = !!a2._wrapperState.initialChecked;
  "" !== c2 && (a2.name = c2);
}
function cb(a2, b2, c2) {
  if ("number" !== b2 || Xa(a2.ownerDocument) !== a2) null == c2 ? a2.defaultValue = "" + a2._wrapperState.initialValue : a2.defaultValue !== "" + c2 && (a2.defaultValue = "" + c2);
}
var eb = Array.isArray;
function fb(a2, b2, c2, d2) {
  a2 = a2.options;
  if (b2) {
    b2 = {};
    for (var e2 = 0; e2 < c2.length; e2++) b2["$" + c2[e2]] = true;
    for (c2 = 0; c2 < a2.length; c2++) e2 = b2.hasOwnProperty("$" + a2[c2].value), a2[c2].selected !== e2 && (a2[c2].selected = e2), e2 && d2 && (a2[c2].defaultSelected = true);
  } else {
    c2 = "" + Sa(c2);
    b2 = null;
    for (e2 = 0; e2 < a2.length; e2++) {
      if (a2[e2].value === c2) {
        a2[e2].selected = true;
        d2 && (a2[e2].defaultSelected = true);
        return;
      }
      null !== b2 || a2[e2].disabled || (b2 = a2[e2]);
    }
    null !== b2 && (b2.selected = true);
  }
}
function gb(a2, b2) {
  if (null != b2.dangerouslySetInnerHTML) throw Error(p$3(91));
  return A$1({}, b2, { value: void 0, defaultValue: void 0, children: "" + a2._wrapperState.initialValue });
}
function hb(a2, b2) {
  var c2 = b2.value;
  if (null == c2) {
    c2 = b2.children;
    b2 = b2.defaultValue;
    if (null != c2) {
      if (null != b2) throw Error(p$3(92));
      if (eb(c2)) {
        if (1 < c2.length) throw Error(p$3(93));
        c2 = c2[0];
      }
      b2 = c2;
    }
    null == b2 && (b2 = "");
    c2 = b2;
  }
  a2._wrapperState = { initialValue: Sa(c2) };
}
function ib(a2, b2) {
  var c2 = Sa(b2.value), d2 = Sa(b2.defaultValue);
  null != c2 && (c2 = "" + c2, c2 !== a2.value && (a2.value = c2), null == b2.defaultValue && a2.defaultValue !== c2 && (a2.defaultValue = c2));
  null != d2 && (a2.defaultValue = "" + d2);
}
function jb(a2) {
  var b2 = a2.textContent;
  b2 === a2._wrapperState.initialValue && "" !== b2 && null !== b2 && (a2.value = b2);
}
function kb(a2) {
  switch (a2) {
    case "svg":
      return "http://www.w3.org/2000/svg";
    case "math":
      return "http://www.w3.org/1998/Math/MathML";
    default:
      return "http://www.w3.org/1999/xhtml";
  }
}
function lb(a2, b2) {
  return null == a2 || "http://www.w3.org/1999/xhtml" === a2 ? kb(b2) : "http://www.w3.org/2000/svg" === a2 && "foreignObject" === b2 ? "http://www.w3.org/1999/xhtml" : a2;
}
var mb, nb = function(a2) {
  return "undefined" !== typeof MSApp && MSApp.execUnsafeLocalFunction ? function(b2, c2, d2, e2) {
    MSApp.execUnsafeLocalFunction(function() {
      return a2(b2, c2, d2, e2);
    });
  } : a2;
}(function(a2, b2) {
  if ("http://www.w3.org/2000/svg" !== a2.namespaceURI || "innerHTML" in a2) a2.innerHTML = b2;
  else {
    mb = mb || document.createElement("div");
    mb.innerHTML = "<svg>" + b2.valueOf().toString() + "</svg>";
    for (b2 = mb.firstChild; a2.firstChild; ) a2.removeChild(a2.firstChild);
    for (; b2.firstChild; ) a2.appendChild(b2.firstChild);
  }
});
function ob(a2, b2) {
  if (b2) {
    var c2 = a2.firstChild;
    if (c2 && c2 === a2.lastChild && 3 === c2.nodeType) {
      c2.nodeValue = b2;
      return;
    }
  }
  a2.textContent = b2;
}
var pb = {
  animationIterationCount: true,
  aspectRatio: true,
  borderImageOutset: true,
  borderImageSlice: true,
  borderImageWidth: true,
  boxFlex: true,
  boxFlexGroup: true,
  boxOrdinalGroup: true,
  columnCount: true,
  columns: true,
  flex: true,
  flexGrow: true,
  flexPositive: true,
  flexShrink: true,
  flexNegative: true,
  flexOrder: true,
  gridArea: true,
  gridRow: true,
  gridRowEnd: true,
  gridRowSpan: true,
  gridRowStart: true,
  gridColumn: true,
  gridColumnEnd: true,
  gridColumnSpan: true,
  gridColumnStart: true,
  fontWeight: true,
  lineClamp: true,
  lineHeight: true,
  opacity: true,
  order: true,
  orphans: true,
  tabSize: true,
  widows: true,
  zIndex: true,
  zoom: true,
  fillOpacity: true,
  floodOpacity: true,
  stopOpacity: true,
  strokeDasharray: true,
  strokeDashoffset: true,
  strokeMiterlimit: true,
  strokeOpacity: true,
  strokeWidth: true
}, qb = ["Webkit", "ms", "Moz", "O"];
Object.keys(pb).forEach(function(a2) {
  qb.forEach(function(b2) {
    b2 = b2 + a2.charAt(0).toUpperCase() + a2.substring(1);
    pb[b2] = pb[a2];
  });
});
function rb(a2, b2, c2) {
  return null == b2 || "boolean" === typeof b2 || "" === b2 ? "" : c2 || "number" !== typeof b2 || 0 === b2 || pb.hasOwnProperty(a2) && pb[a2] ? ("" + b2).trim() : b2 + "px";
}
function sb(a2, b2) {
  a2 = a2.style;
  for (var c2 in b2) if (b2.hasOwnProperty(c2)) {
    var d2 = 0 === c2.indexOf("--"), e2 = rb(c2, b2[c2], d2);
    "float" === c2 && (c2 = "cssFloat");
    d2 ? a2.setProperty(c2, e2) : a2[c2] = e2;
  }
}
var tb = A$1({ menuitem: true }, { area: true, base: true, br: true, col: true, embed: true, hr: true, img: true, input: true, keygen: true, link: true, meta: true, param: true, source: true, track: true, wbr: true });
function ub(a2, b2) {
  if (b2) {
    if (tb[a2] && (null != b2.children || null != b2.dangerouslySetInnerHTML)) throw Error(p$3(137, a2));
    if (null != b2.dangerouslySetInnerHTML) {
      if (null != b2.children) throw Error(p$3(60));
      if ("object" !== typeof b2.dangerouslySetInnerHTML || !("__html" in b2.dangerouslySetInnerHTML)) throw Error(p$3(61));
    }
    if (null != b2.style && "object" !== typeof b2.style) throw Error(p$3(62));
  }
}
function vb(a2, b2) {
  if (-1 === a2.indexOf("-")) return "string" === typeof b2.is;
  switch (a2) {
    case "annotation-xml":
    case "color-profile":
    case "font-face":
    case "font-face-src":
    case "font-face-uri":
    case "font-face-format":
    case "font-face-name":
    case "missing-glyph":
      return false;
    default:
      return true;
  }
}
var wb = null;
function xb(a2) {
  a2 = a2.target || a2.srcElement || window;
  a2.correspondingUseElement && (a2 = a2.correspondingUseElement);
  return 3 === a2.nodeType ? a2.parentNode : a2;
}
var yb = null, zb = null, Ab = null;
function Bb(a2) {
  if (a2 = Cb(a2)) {
    if ("function" !== typeof yb) throw Error(p$3(280));
    var b2 = a2.stateNode;
    b2 && (b2 = Db(b2), yb(a2.stateNode, a2.type, b2));
  }
}
function Eb(a2) {
  zb ? Ab ? Ab.push(a2) : Ab = [a2] : zb = a2;
}
function Fb() {
  if (zb) {
    var a2 = zb, b2 = Ab;
    Ab = zb = null;
    Bb(a2);
    if (b2) for (a2 = 0; a2 < b2.length; a2++) Bb(b2[a2]);
  }
}
function Gb(a2, b2) {
  return a2(b2);
}
function Hb() {
}
var Ib = false;
function Jb(a2, b2, c2) {
  if (Ib) return a2(b2, c2);
  Ib = true;
  try {
    return Gb(a2, b2, c2);
  } finally {
    if (Ib = false, null !== zb || null !== Ab) Hb(), Fb();
  }
}
function Kb(a2, b2) {
  var c2 = a2.stateNode;
  if (null === c2) return null;
  var d2 = Db(c2);
  if (null === d2) return null;
  c2 = d2[b2];
  a: switch (b2) {
    case "onClick":
    case "onClickCapture":
    case "onDoubleClick":
    case "onDoubleClickCapture":
    case "onMouseDown":
    case "onMouseDownCapture":
    case "onMouseMove":
    case "onMouseMoveCapture":
    case "onMouseUp":
    case "onMouseUpCapture":
    case "onMouseEnter":
      (d2 = !d2.disabled) || (a2 = a2.type, d2 = !("button" === a2 || "input" === a2 || "select" === a2 || "textarea" === a2));
      a2 = !d2;
      break a;
    default:
      a2 = false;
  }
  if (a2) return null;
  if (c2 && "function" !== typeof c2) throw Error(p$3(231, b2, typeof c2));
  return c2;
}
var Lb = false;
if (ia) try {
  var Mb = {};
  Object.defineProperty(Mb, "passive", { get: function() {
    Lb = true;
  } });
  window.addEventListener("test", Mb, Mb);
  window.removeEventListener("test", Mb, Mb);
} catch (a2) {
  Lb = false;
}
function Nb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  var l2 = Array.prototype.slice.call(arguments, 3);
  try {
    b2.apply(c2, l2);
  } catch (m2) {
    this.onError(m2);
  }
}
var Ob = false, Pb = null, Qb = false, Rb = null, Sb = { onError: function(a2) {
  Ob = true;
  Pb = a2;
} };
function Tb(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Ob = false;
  Pb = null;
  Nb.apply(Sb, arguments);
}
function Ub(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  Tb.apply(this, arguments);
  if (Ob) {
    if (Ob) {
      var l2 = Pb;
      Ob = false;
      Pb = null;
    } else throw Error(p$3(198));
    Qb || (Qb = true, Rb = l2);
  }
}
function Vb(a2) {
  var b2 = a2, c2 = a2;
  if (a2.alternate) for (; b2.return; ) b2 = b2.return;
  else {
    a2 = b2;
    do
      b2 = a2, 0 !== (b2.flags & 4098) && (c2 = b2.return), a2 = b2.return;
    while (a2);
  }
  return 3 === b2.tag ? c2 : null;
}
function Wb(a2) {
  if (13 === a2.tag) {
    var b2 = a2.memoizedState;
    null === b2 && (a2 = a2.alternate, null !== a2 && (b2 = a2.memoizedState));
    if (null !== b2) return b2.dehydrated;
  }
  return null;
}
function Xb(a2) {
  if (Vb(a2) !== a2) throw Error(p$3(188));
}
function Yb(a2) {
  var b2 = a2.alternate;
  if (!b2) {
    b2 = Vb(a2);
    if (null === b2) throw Error(p$3(188));
    return b2 !== a2 ? null : a2;
  }
  for (var c2 = a2, d2 = b2; ; ) {
    var e2 = c2.return;
    if (null === e2) break;
    var f2 = e2.alternate;
    if (null === f2) {
      d2 = e2.return;
      if (null !== d2) {
        c2 = d2;
        continue;
      }
      break;
    }
    if (e2.child === f2.child) {
      for (f2 = e2.child; f2; ) {
        if (f2 === c2) return Xb(e2), a2;
        if (f2 === d2) return Xb(e2), b2;
        f2 = f2.sibling;
      }
      throw Error(p$3(188));
    }
    if (c2.return !== d2.return) c2 = e2, d2 = f2;
    else {
      for (var g2 = false, h2 = e2.child; h2; ) {
        if (h2 === c2) {
          g2 = true;
          c2 = e2;
          d2 = f2;
          break;
        }
        if (h2 === d2) {
          g2 = true;
          d2 = e2;
          c2 = f2;
          break;
        }
        h2 = h2.sibling;
      }
      if (!g2) {
        for (h2 = f2.child; h2; ) {
          if (h2 === c2) {
            g2 = true;
            c2 = f2;
            d2 = e2;
            break;
          }
          if (h2 === d2) {
            g2 = true;
            d2 = f2;
            c2 = e2;
            break;
          }
          h2 = h2.sibling;
        }
        if (!g2) throw Error(p$3(189));
      }
    }
    if (c2.alternate !== d2) throw Error(p$3(190));
  }
  if (3 !== c2.tag) throw Error(p$3(188));
  return c2.stateNode.current === c2 ? a2 : b2;
}
function Zb(a2) {
  a2 = Yb(a2);
  return null !== a2 ? $b(a2) : null;
}
function $b(a2) {
  if (5 === a2.tag || 6 === a2.tag) return a2;
  for (a2 = a2.child; null !== a2; ) {
    var b2 = $b(a2);
    if (null !== b2) return b2;
    a2 = a2.sibling;
  }
  return null;
}
var ac = ca.unstable_scheduleCallback, bc = ca.unstable_cancelCallback, cc = ca.unstable_shouldYield, dc = ca.unstable_requestPaint, B = ca.unstable_now, ec = ca.unstable_getCurrentPriorityLevel, fc = ca.unstable_ImmediatePriority, gc = ca.unstable_UserBlockingPriority, hc = ca.unstable_NormalPriority, ic = ca.unstable_LowPriority, jc = ca.unstable_IdlePriority, kc = null, lc = null;
function mc(a2) {
  if (lc && "function" === typeof lc.onCommitFiberRoot) try {
    lc.onCommitFiberRoot(kc, a2, void 0, 128 === (a2.current.flags & 128));
  } catch (b2) {
  }
}
var oc = Math.clz32 ? Math.clz32 : nc, pc = Math.log, qc = Math.LN2;
function nc(a2) {
  a2 >>>= 0;
  return 0 === a2 ? 32 : 31 - (pc(a2) / qc | 0) | 0;
}
var rc = 64, sc = 4194304;
function tc(a2) {
  switch (a2 & -a2) {
    case 1:
      return 1;
    case 2:
      return 2;
    case 4:
      return 4;
    case 8:
      return 8;
    case 16:
      return 16;
    case 32:
      return 32;
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return a2 & 4194240;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return a2 & 130023424;
    case 134217728:
      return 134217728;
    case 268435456:
      return 268435456;
    case 536870912:
      return 536870912;
    case 1073741824:
      return 1073741824;
    default:
      return a2;
  }
}
function uc(a2, b2) {
  var c2 = a2.pendingLanes;
  if (0 === c2) return 0;
  var d2 = 0, e2 = a2.suspendedLanes, f2 = a2.pingedLanes, g2 = c2 & 268435455;
  if (0 !== g2) {
    var h2 = g2 & ~e2;
    0 !== h2 ? d2 = tc(h2) : (f2 &= g2, 0 !== f2 && (d2 = tc(f2)));
  } else g2 = c2 & ~e2, 0 !== g2 ? d2 = tc(g2) : 0 !== f2 && (d2 = tc(f2));
  if (0 === d2) return 0;
  if (0 !== b2 && b2 !== d2 && 0 === (b2 & e2) && (e2 = d2 & -d2, f2 = b2 & -b2, e2 >= f2 || 16 === e2 && 0 !== (f2 & 4194240))) return b2;
  0 !== (d2 & 4) && (d2 |= c2 & 16);
  b2 = a2.entangledLanes;
  if (0 !== b2) for (a2 = a2.entanglements, b2 &= d2; 0 < b2; ) c2 = 31 - oc(b2), e2 = 1 << c2, d2 |= a2[c2], b2 &= ~e2;
  return d2;
}
function vc(a2, b2) {
  switch (a2) {
    case 1:
    case 2:
    case 4:
      return b2 + 250;
    case 8:
    case 16:
    case 32:
    case 64:
    case 128:
    case 256:
    case 512:
    case 1024:
    case 2048:
    case 4096:
    case 8192:
    case 16384:
    case 32768:
    case 65536:
    case 131072:
    case 262144:
    case 524288:
    case 1048576:
    case 2097152:
      return b2 + 5e3;
    case 4194304:
    case 8388608:
    case 16777216:
    case 33554432:
    case 67108864:
      return -1;
    case 134217728:
    case 268435456:
    case 536870912:
    case 1073741824:
      return -1;
    default:
      return -1;
  }
}
function wc(a2, b2) {
  for (var c2 = a2.suspendedLanes, d2 = a2.pingedLanes, e2 = a2.expirationTimes, f2 = a2.pendingLanes; 0 < f2; ) {
    var g2 = 31 - oc(f2), h2 = 1 << g2, k2 = e2[g2];
    if (-1 === k2) {
      if (0 === (h2 & c2) || 0 !== (h2 & d2)) e2[g2] = vc(h2, b2);
    } else k2 <= b2 && (a2.expiredLanes |= h2);
    f2 &= ~h2;
  }
}
function xc(a2) {
  a2 = a2.pendingLanes & -1073741825;
  return 0 !== a2 ? a2 : a2 & 1073741824 ? 1073741824 : 0;
}
function yc() {
  var a2 = rc;
  rc <<= 1;
  0 === (rc & 4194240) && (rc = 64);
  return a2;
}
function zc(a2) {
  for (var b2 = [], c2 = 0; 31 > c2; c2++) b2.push(a2);
  return b2;
}
function Ac(a2, b2, c2) {
  a2.pendingLanes |= b2;
  536870912 !== b2 && (a2.suspendedLanes = 0, a2.pingedLanes = 0);
  a2 = a2.eventTimes;
  b2 = 31 - oc(b2);
  a2[b2] = c2;
}
function Bc(a2, b2) {
  var c2 = a2.pendingLanes & ~b2;
  a2.pendingLanes = b2;
  a2.suspendedLanes = 0;
  a2.pingedLanes = 0;
  a2.expiredLanes &= b2;
  a2.mutableReadLanes &= b2;
  a2.entangledLanes &= b2;
  b2 = a2.entanglements;
  var d2 = a2.eventTimes;
  for (a2 = a2.expirationTimes; 0 < c2; ) {
    var e2 = 31 - oc(c2), f2 = 1 << e2;
    b2[e2] = 0;
    d2[e2] = -1;
    a2[e2] = -1;
    c2 &= ~f2;
  }
}
function Cc(a2, b2) {
  var c2 = a2.entangledLanes |= b2;
  for (a2 = a2.entanglements; c2; ) {
    var d2 = 31 - oc(c2), e2 = 1 << d2;
    e2 & b2 | a2[d2] & b2 && (a2[d2] |= b2);
    c2 &= ~e2;
  }
}
var C$1 = 0;
function Dc(a2) {
  a2 &= -a2;
  return 1 < a2 ? 4 < a2 ? 0 !== (a2 & 268435455) ? 16 : 536870912 : 4 : 1;
}
var Ec, Fc, Gc, Hc, Ic, Jc = false, Kc = [], Lc = null, Mc = null, Nc = null, Oc = /* @__PURE__ */ new Map(), Pc = /* @__PURE__ */ new Map(), Qc = [], Rc = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");
function Sc(a2, b2) {
  switch (a2) {
    case "focusin":
    case "focusout":
      Lc = null;
      break;
    case "dragenter":
    case "dragleave":
      Mc = null;
      break;
    case "mouseover":
    case "mouseout":
      Nc = null;
      break;
    case "pointerover":
    case "pointerout":
      Oc.delete(b2.pointerId);
      break;
    case "gotpointercapture":
    case "lostpointercapture":
      Pc.delete(b2.pointerId);
  }
}
function Tc(a2, b2, c2, d2, e2, f2) {
  if (null === a2 || a2.nativeEvent !== f2) return a2 = { blockedOn: b2, domEventName: c2, eventSystemFlags: d2, nativeEvent: f2, targetContainers: [e2] }, null !== b2 && (b2 = Cb(b2), null !== b2 && Fc(b2)), a2;
  a2.eventSystemFlags |= d2;
  b2 = a2.targetContainers;
  null !== e2 && -1 === b2.indexOf(e2) && b2.push(e2);
  return a2;
}
function Uc(a2, b2, c2, d2, e2) {
  switch (b2) {
    case "focusin":
      return Lc = Tc(Lc, a2, b2, c2, d2, e2), true;
    case "dragenter":
      return Mc = Tc(Mc, a2, b2, c2, d2, e2), true;
    case "mouseover":
      return Nc = Tc(Nc, a2, b2, c2, d2, e2), true;
    case "pointerover":
      var f2 = e2.pointerId;
      Oc.set(f2, Tc(Oc.get(f2) || null, a2, b2, c2, d2, e2));
      return true;
    case "gotpointercapture":
      return f2 = e2.pointerId, Pc.set(f2, Tc(Pc.get(f2) || null, a2, b2, c2, d2, e2)), true;
  }
  return false;
}
function Vc(a2) {
  var b2 = Wc(a2.target);
  if (null !== b2) {
    var c2 = Vb(b2);
    if (null !== c2) {
      if (b2 = c2.tag, 13 === b2) {
        if (b2 = Wb(c2), null !== b2) {
          a2.blockedOn = b2;
          Ic(a2.priority, function() {
            Gc(c2);
          });
          return;
        }
      } else if (3 === b2 && c2.stateNode.current.memoizedState.isDehydrated) {
        a2.blockedOn = 3 === c2.tag ? c2.stateNode.containerInfo : null;
        return;
      }
    }
  }
  a2.blockedOn = null;
}
function Xc(a2) {
  if (null !== a2.blockedOn) return false;
  for (var b2 = a2.targetContainers; 0 < b2.length; ) {
    var c2 = Yc(a2.domEventName, a2.eventSystemFlags, b2[0], a2.nativeEvent);
    if (null === c2) {
      c2 = a2.nativeEvent;
      var d2 = new c2.constructor(c2.type, c2);
      wb = d2;
      c2.target.dispatchEvent(d2);
      wb = null;
    } else return b2 = Cb(c2), null !== b2 && Fc(b2), a2.blockedOn = c2, false;
    b2.shift();
  }
  return true;
}
function Zc(a2, b2, c2) {
  Xc(a2) && c2.delete(b2);
}
function $c() {
  Jc = false;
  null !== Lc && Xc(Lc) && (Lc = null);
  null !== Mc && Xc(Mc) && (Mc = null);
  null !== Nc && Xc(Nc) && (Nc = null);
  Oc.forEach(Zc);
  Pc.forEach(Zc);
}
function ad(a2, b2) {
  a2.blockedOn === b2 && (a2.blockedOn = null, Jc || (Jc = true, ca.unstable_scheduleCallback(ca.unstable_NormalPriority, $c)));
}
function bd(a2) {
  function b2(b3) {
    return ad(b3, a2);
  }
  if (0 < Kc.length) {
    ad(Kc[0], a2);
    for (var c2 = 1; c2 < Kc.length; c2++) {
      var d2 = Kc[c2];
      d2.blockedOn === a2 && (d2.blockedOn = null);
    }
  }
  null !== Lc && ad(Lc, a2);
  null !== Mc && ad(Mc, a2);
  null !== Nc && ad(Nc, a2);
  Oc.forEach(b2);
  Pc.forEach(b2);
  for (c2 = 0; c2 < Qc.length; c2++) d2 = Qc[c2], d2.blockedOn === a2 && (d2.blockedOn = null);
  for (; 0 < Qc.length && (c2 = Qc[0], null === c2.blockedOn); ) Vc(c2), null === c2.blockedOn && Qc.shift();
}
var cd = ua.ReactCurrentBatchConfig, dd = true;
function ed(a2, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 1, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function gd(a2, b2, c2, d2) {
  var e2 = C$1, f2 = cd.transition;
  cd.transition = null;
  try {
    C$1 = 4, fd(a2, b2, c2, d2);
  } finally {
    C$1 = e2, cd.transition = f2;
  }
}
function fd(a2, b2, c2, d2) {
  if (dd) {
    var e2 = Yc(a2, b2, c2, d2);
    if (null === e2) hd(a2, b2, d2, id, c2), Sc(a2, d2);
    else if (Uc(e2, a2, b2, c2, d2)) d2.stopPropagation();
    else if (Sc(a2, d2), b2 & 4 && -1 < Rc.indexOf(a2)) {
      for (; null !== e2; ) {
        var f2 = Cb(e2);
        null !== f2 && Ec(f2);
        f2 = Yc(a2, b2, c2, d2);
        null === f2 && hd(a2, b2, d2, id, c2);
        if (f2 === e2) break;
        e2 = f2;
      }
      null !== e2 && d2.stopPropagation();
    } else hd(a2, b2, d2, null, c2);
  }
}
var id = null;
function Yc(a2, b2, c2, d2) {
  id = null;
  a2 = xb(d2);
  a2 = Wc(a2);
  if (null !== a2) if (b2 = Vb(a2), null === b2) a2 = null;
  else if (c2 = b2.tag, 13 === c2) {
    a2 = Wb(b2);
    if (null !== a2) return a2;
    a2 = null;
  } else if (3 === c2) {
    if (b2.stateNode.current.memoizedState.isDehydrated) return 3 === b2.tag ? b2.stateNode.containerInfo : null;
    a2 = null;
  } else b2 !== a2 && (a2 = null);
  id = a2;
  return null;
}
function jd(a2) {
  switch (a2) {
    case "cancel":
    case "click":
    case "close":
    case "contextmenu":
    case "copy":
    case "cut":
    case "auxclick":
    case "dblclick":
    case "dragend":
    case "dragstart":
    case "drop":
    case "focusin":
    case "focusout":
    case "input":
    case "invalid":
    case "keydown":
    case "keypress":
    case "keyup":
    case "mousedown":
    case "mouseup":
    case "paste":
    case "pause":
    case "play":
    case "pointercancel":
    case "pointerdown":
    case "pointerup":
    case "ratechange":
    case "reset":
    case "resize":
    case "seeked":
    case "submit":
    case "touchcancel":
    case "touchend":
    case "touchstart":
    case "volumechange":
    case "change":
    case "selectionchange":
    case "textInput":
    case "compositionstart":
    case "compositionend":
    case "compositionupdate":
    case "beforeblur":
    case "afterblur":
    case "beforeinput":
    case "blur":
    case "fullscreenchange":
    case "focus":
    case "hashchange":
    case "popstate":
    case "select":
    case "selectstart":
      return 1;
    case "drag":
    case "dragenter":
    case "dragexit":
    case "dragleave":
    case "dragover":
    case "mousemove":
    case "mouseout":
    case "mouseover":
    case "pointermove":
    case "pointerout":
    case "pointerover":
    case "scroll":
    case "toggle":
    case "touchmove":
    case "wheel":
    case "mouseenter":
    case "mouseleave":
    case "pointerenter":
    case "pointerleave":
      return 4;
    case "message":
      switch (ec()) {
        case fc:
          return 1;
        case gc:
          return 4;
        case hc:
        case ic:
          return 16;
        case jc:
          return 536870912;
        default:
          return 16;
      }
    default:
      return 16;
  }
}
var kd = null, ld = null, md = null;
function nd() {
  if (md) return md;
  var a2, b2 = ld, c2 = b2.length, d2, e2 = "value" in kd ? kd.value : kd.textContent, f2 = e2.length;
  for (a2 = 0; a2 < c2 && b2[a2] === e2[a2]; a2++) ;
  var g2 = c2 - a2;
  for (d2 = 1; d2 <= g2 && b2[c2 - d2] === e2[f2 - d2]; d2++) ;
  return md = e2.slice(a2, 1 < d2 ? 1 - d2 : void 0);
}
function od(a2) {
  var b2 = a2.keyCode;
  "charCode" in a2 ? (a2 = a2.charCode, 0 === a2 && 13 === b2 && (a2 = 13)) : a2 = b2;
  10 === a2 && (a2 = 13);
  return 32 <= a2 || 13 === a2 ? a2 : 0;
}
function pd() {
  return true;
}
function qd() {
  return false;
}
function rd(a2) {
  function b2(b3, d2, e2, f2, g2) {
    this._reactName = b3;
    this._targetInst = e2;
    this.type = d2;
    this.nativeEvent = f2;
    this.target = g2;
    this.currentTarget = null;
    for (var c2 in a2) a2.hasOwnProperty(c2) && (b3 = a2[c2], this[c2] = b3 ? b3(f2) : f2[c2]);
    this.isDefaultPrevented = (null != f2.defaultPrevented ? f2.defaultPrevented : false === f2.returnValue) ? pd : qd;
    this.isPropagationStopped = qd;
    return this;
  }
  A$1(b2.prototype, { preventDefault: function() {
    this.defaultPrevented = true;
    var a3 = this.nativeEvent;
    a3 && (a3.preventDefault ? a3.preventDefault() : "unknown" !== typeof a3.returnValue && (a3.returnValue = false), this.isDefaultPrevented = pd);
  }, stopPropagation: function() {
    var a3 = this.nativeEvent;
    a3 && (a3.stopPropagation ? a3.stopPropagation() : "unknown" !== typeof a3.cancelBubble && (a3.cancelBubble = true), this.isPropagationStopped = pd);
  }, persist: function() {
  }, isPersistent: pd });
  return b2;
}
var sd = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function(a2) {
  return a2.timeStamp || Date.now();
}, defaultPrevented: 0, isTrusted: 0 }, td = rd(sd), ud = A$1({}, sd, { view: 0, detail: 0 }), vd = rd(ud), wd, xd, yd, Ad = A$1({}, ud, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: zd, button: 0, buttons: 0, relatedTarget: function(a2) {
  return void 0 === a2.relatedTarget ? a2.fromElement === a2.srcElement ? a2.toElement : a2.fromElement : a2.relatedTarget;
}, movementX: function(a2) {
  if ("movementX" in a2) return a2.movementX;
  a2 !== yd && (yd && "mousemove" === a2.type ? (wd = a2.screenX - yd.screenX, xd = a2.screenY - yd.screenY) : xd = wd = 0, yd = a2);
  return wd;
}, movementY: function(a2) {
  return "movementY" in a2 ? a2.movementY : xd;
} }), Bd = rd(Ad), Cd = A$1({}, Ad, { dataTransfer: 0 }), Dd = rd(Cd), Ed = A$1({}, ud, { relatedTarget: 0 }), Fd = rd(Ed), Gd = A$1({}, sd, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Hd = rd(Gd), Id = A$1({}, sd, { clipboardData: function(a2) {
  return "clipboardData" in a2 ? a2.clipboardData : window.clipboardData;
} }), Jd = rd(Id), Kd = A$1({}, sd, { data: 0 }), Ld = rd(Kd), Md = {
  Esc: "Escape",
  Spacebar: " ",
  Left: "ArrowLeft",
  Up: "ArrowUp",
  Right: "ArrowRight",
  Down: "ArrowDown",
  Del: "Delete",
  Win: "OS",
  Menu: "ContextMenu",
  Apps: "ContextMenu",
  Scroll: "ScrollLock",
  MozPrintableKey: "Unidentified"
}, Nd = {
  8: "Backspace",
  9: "Tab",
  12: "Clear",
  13: "Enter",
  16: "Shift",
  17: "Control",
  18: "Alt",
  19: "Pause",
  20: "CapsLock",
  27: "Escape",
  32: " ",
  33: "PageUp",
  34: "PageDown",
  35: "End",
  36: "Home",
  37: "ArrowLeft",
  38: "ArrowUp",
  39: "ArrowRight",
  40: "ArrowDown",
  45: "Insert",
  46: "Delete",
  112: "F1",
  113: "F2",
  114: "F3",
  115: "F4",
  116: "F5",
  117: "F6",
  118: "F7",
  119: "F8",
  120: "F9",
  121: "F10",
  122: "F11",
  123: "F12",
  144: "NumLock",
  145: "ScrollLock",
  224: "Meta"
}, Od = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" };
function Pd(a2) {
  var b2 = this.nativeEvent;
  return b2.getModifierState ? b2.getModifierState(a2) : (a2 = Od[a2]) ? !!b2[a2] : false;
}
function zd() {
  return Pd;
}
var Qd = A$1({}, ud, { key: function(a2) {
  if (a2.key) {
    var b2 = Md[a2.key] || a2.key;
    if ("Unidentified" !== b2) return b2;
  }
  return "keypress" === a2.type ? (a2 = od(a2), 13 === a2 ? "Enter" : String.fromCharCode(a2)) : "keydown" === a2.type || "keyup" === a2.type ? Nd[a2.keyCode] || "Unidentified" : "";
}, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: zd, charCode: function(a2) {
  return "keypress" === a2.type ? od(a2) : 0;
}, keyCode: function(a2) {
  return "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
}, which: function(a2) {
  return "keypress" === a2.type ? od(a2) : "keydown" === a2.type || "keyup" === a2.type ? a2.keyCode : 0;
} }), Rd = rd(Qd), Sd = A$1({}, Ad, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), Td = rd(Sd), Ud = A$1({}, ud, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: zd }), Vd = rd(Ud), Wd = A$1({}, sd, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Xd = rd(Wd), Yd = A$1({}, Ad, {
  deltaX: function(a2) {
    return "deltaX" in a2 ? a2.deltaX : "wheelDeltaX" in a2 ? -a2.wheelDeltaX : 0;
  },
  deltaY: function(a2) {
    return "deltaY" in a2 ? a2.deltaY : "wheelDeltaY" in a2 ? -a2.wheelDeltaY : "wheelDelta" in a2 ? -a2.wheelDelta : 0;
  },
  deltaZ: 0,
  deltaMode: 0
}), Zd = rd(Yd), $d = [9, 13, 27, 32], ae = ia && "CompositionEvent" in window, be = null;
ia && "documentMode" in document && (be = document.documentMode);
var ce = ia && "TextEvent" in window && !be, de = ia && (!ae || be && 8 < be && 11 >= be), ee = String.fromCharCode(32), fe = false;
function ge(a2, b2) {
  switch (a2) {
    case "keyup":
      return -1 !== $d.indexOf(b2.keyCode);
    case "keydown":
      return 229 !== b2.keyCode;
    case "keypress":
    case "mousedown":
    case "focusout":
      return true;
    default:
      return false;
  }
}
function he(a2) {
  a2 = a2.detail;
  return "object" === typeof a2 && "data" in a2 ? a2.data : null;
}
var ie = false;
function je(a2, b2) {
  switch (a2) {
    case "compositionend":
      return he(b2);
    case "keypress":
      if (32 !== b2.which) return null;
      fe = true;
      return ee;
    case "textInput":
      return a2 = b2.data, a2 === ee && fe ? null : a2;
    default:
      return null;
  }
}
function ke(a2, b2) {
  if (ie) return "compositionend" === a2 || !ae && ge(a2, b2) ? (a2 = nd(), md = ld = kd = null, ie = false, a2) : null;
  switch (a2) {
    case "paste":
      return null;
    case "keypress":
      if (!(b2.ctrlKey || b2.altKey || b2.metaKey) || b2.ctrlKey && b2.altKey) {
        if (b2.char && 1 < b2.char.length) return b2.char;
        if (b2.which) return String.fromCharCode(b2.which);
      }
      return null;
    case "compositionend":
      return de && "ko" !== b2.locale ? null : b2.data;
    default:
      return null;
  }
}
var le = { color: true, date: true, datetime: true, "datetime-local": true, email: true, month: true, number: true, password: true, range: true, search: true, tel: true, text: true, time: true, url: true, week: true };
function me(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return "input" === b2 ? !!le[a2.type] : "textarea" === b2 ? true : false;
}
function ne(a2, b2, c2, d2) {
  Eb(d2);
  b2 = oe(b2, "onChange");
  0 < b2.length && (c2 = new td("onChange", "change", null, c2, d2), a2.push({ event: c2, listeners: b2 }));
}
var pe = null, qe = null;
function re(a2) {
  se(a2, 0);
}
function te(a2) {
  var b2 = ue(a2);
  if (Wa(b2)) return a2;
}
function ve(a2, b2) {
  if ("change" === a2) return b2;
}
var we = false;
if (ia) {
  var xe;
  if (ia) {
    var ye = "oninput" in document;
    if (!ye) {
      var ze = document.createElement("div");
      ze.setAttribute("oninput", "return;");
      ye = "function" === typeof ze.oninput;
    }
    xe = ye;
  } else xe = false;
  we = xe && (!document.documentMode || 9 < document.documentMode);
}
function Ae() {
  pe && (pe.detachEvent("onpropertychange", Be), qe = pe = null);
}
function Be(a2) {
  if ("value" === a2.propertyName && te(qe)) {
    var b2 = [];
    ne(b2, qe, a2, xb(a2));
    Jb(re, b2);
  }
}
function Ce(a2, b2, c2) {
  "focusin" === a2 ? (Ae(), pe = b2, qe = c2, pe.attachEvent("onpropertychange", Be)) : "focusout" === a2 && Ae();
}
function De(a2) {
  if ("selectionchange" === a2 || "keyup" === a2 || "keydown" === a2) return te(qe);
}
function Ee(a2, b2) {
  if ("click" === a2) return te(b2);
}
function Fe(a2, b2) {
  if ("input" === a2 || "change" === a2) return te(b2);
}
function Ge(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var He = "function" === typeof Object.is ? Object.is : Ge;
function Ie(a2, b2) {
  if (He(a2, b2)) return true;
  if ("object" !== typeof a2 || null === a2 || "object" !== typeof b2 || null === b2) return false;
  var c2 = Object.keys(a2), d2 = Object.keys(b2);
  if (c2.length !== d2.length) return false;
  for (d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    if (!ja.call(b2, e2) || !He(a2[e2], b2[e2])) return false;
  }
  return true;
}
function Je(a2) {
  for (; a2 && a2.firstChild; ) a2 = a2.firstChild;
  return a2;
}
function Ke(a2, b2) {
  var c2 = Je(a2);
  a2 = 0;
  for (var d2; c2; ) {
    if (3 === c2.nodeType) {
      d2 = a2 + c2.textContent.length;
      if (a2 <= b2 && d2 >= b2) return { node: c2, offset: b2 - a2 };
      a2 = d2;
    }
    a: {
      for (; c2; ) {
        if (c2.nextSibling) {
          c2 = c2.nextSibling;
          break a;
        }
        c2 = c2.parentNode;
      }
      c2 = void 0;
    }
    c2 = Je(c2);
  }
}
function Le(a2, b2) {
  return a2 && b2 ? a2 === b2 ? true : a2 && 3 === a2.nodeType ? false : b2 && 3 === b2.nodeType ? Le(a2, b2.parentNode) : "contains" in a2 ? a2.contains(b2) : a2.compareDocumentPosition ? !!(a2.compareDocumentPosition(b2) & 16) : false : false;
}
function Me() {
  for (var a2 = window, b2 = Xa(); b2 instanceof a2.HTMLIFrameElement; ) {
    try {
      var c2 = "string" === typeof b2.contentWindow.location.href;
    } catch (d2) {
      c2 = false;
    }
    if (c2) a2 = b2.contentWindow;
    else break;
    b2 = Xa(a2.document);
  }
  return b2;
}
function Ne(a2) {
  var b2 = a2 && a2.nodeName && a2.nodeName.toLowerCase();
  return b2 && ("input" === b2 && ("text" === a2.type || "search" === a2.type || "tel" === a2.type || "url" === a2.type || "password" === a2.type) || "textarea" === b2 || "true" === a2.contentEditable);
}
function Oe(a2) {
  var b2 = Me(), c2 = a2.focusedElem, d2 = a2.selectionRange;
  if (b2 !== c2 && c2 && c2.ownerDocument && Le(c2.ownerDocument.documentElement, c2)) {
    if (null !== d2 && Ne(c2)) {
      if (b2 = d2.start, a2 = d2.end, void 0 === a2 && (a2 = b2), "selectionStart" in c2) c2.selectionStart = b2, c2.selectionEnd = Math.min(a2, c2.value.length);
      else if (a2 = (b2 = c2.ownerDocument || document) && b2.defaultView || window, a2.getSelection) {
        a2 = a2.getSelection();
        var e2 = c2.textContent.length, f2 = Math.min(d2.start, e2);
        d2 = void 0 === d2.end ? f2 : Math.min(d2.end, e2);
        !a2.extend && f2 > d2 && (e2 = d2, d2 = f2, f2 = e2);
        e2 = Ke(c2, f2);
        var g2 = Ke(
          c2,
          d2
        );
        e2 && g2 && (1 !== a2.rangeCount || a2.anchorNode !== e2.node || a2.anchorOffset !== e2.offset || a2.focusNode !== g2.node || a2.focusOffset !== g2.offset) && (b2 = b2.createRange(), b2.setStart(e2.node, e2.offset), a2.removeAllRanges(), f2 > d2 ? (a2.addRange(b2), a2.extend(g2.node, g2.offset)) : (b2.setEnd(g2.node, g2.offset), a2.addRange(b2)));
      }
    }
    b2 = [];
    for (a2 = c2; a2 = a2.parentNode; ) 1 === a2.nodeType && b2.push({ element: a2, left: a2.scrollLeft, top: a2.scrollTop });
    "function" === typeof c2.focus && c2.focus();
    for (c2 = 0; c2 < b2.length; c2++) a2 = b2[c2], a2.element.scrollLeft = a2.left, a2.element.scrollTop = a2.top;
  }
}
var Pe = ia && "documentMode" in document && 11 >= document.documentMode, Qe = null, Re = null, Se = null, Te = false;
function Ue(a2, b2, c2) {
  var d2 = c2.window === c2 ? c2.document : 9 === c2.nodeType ? c2 : c2.ownerDocument;
  Te || null == Qe || Qe !== Xa(d2) || (d2 = Qe, "selectionStart" in d2 && Ne(d2) ? d2 = { start: d2.selectionStart, end: d2.selectionEnd } : (d2 = (d2.ownerDocument && d2.ownerDocument.defaultView || window).getSelection(), d2 = { anchorNode: d2.anchorNode, anchorOffset: d2.anchorOffset, focusNode: d2.focusNode, focusOffset: d2.focusOffset }), Se && Ie(Se, d2) || (Se = d2, d2 = oe(Re, "onSelect"), 0 < d2.length && (b2 = new td("onSelect", "select", null, b2, c2), a2.push({ event: b2, listeners: d2 }), b2.target = Qe)));
}
function Ve(a2, b2) {
  var c2 = {};
  c2[a2.toLowerCase()] = b2.toLowerCase();
  c2["Webkit" + a2] = "webkit" + b2;
  c2["Moz" + a2] = "moz" + b2;
  return c2;
}
var We = { animationend: Ve("Animation", "AnimationEnd"), animationiteration: Ve("Animation", "AnimationIteration"), animationstart: Ve("Animation", "AnimationStart"), transitionend: Ve("Transition", "TransitionEnd") }, Xe = {}, Ye = {};
ia && (Ye = document.createElement("div").style, "AnimationEvent" in window || (delete We.animationend.animation, delete We.animationiteration.animation, delete We.animationstart.animation), "TransitionEvent" in window || delete We.transitionend.transition);
function Ze(a2) {
  if (Xe[a2]) return Xe[a2];
  if (!We[a2]) return a2;
  var b2 = We[a2], c2;
  for (c2 in b2) if (b2.hasOwnProperty(c2) && c2 in Ye) return Xe[a2] = b2[c2];
  return a2;
}
var $e = Ze("animationend"), af = Ze("animationiteration"), bf = Ze("animationstart"), cf = Ze("transitionend"), df = /* @__PURE__ */ new Map(), ef = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");
function ff(a2, b2) {
  df.set(a2, b2);
  fa(b2, [a2]);
}
for (var gf = 0; gf < ef.length; gf++) {
  var hf = ef[gf], jf = hf.toLowerCase(), kf = hf[0].toUpperCase() + hf.slice(1);
  ff(jf, "on" + kf);
}
ff($e, "onAnimationEnd");
ff(af, "onAnimationIteration");
ff(bf, "onAnimationStart");
ff("dblclick", "onDoubleClick");
ff("focusin", "onFocus");
ff("focusout", "onBlur");
ff(cf, "onTransitionEnd");
ha("onMouseEnter", ["mouseout", "mouseover"]);
ha("onMouseLeave", ["mouseout", "mouseover"]);
ha("onPointerEnter", ["pointerout", "pointerover"]);
ha("onPointerLeave", ["pointerout", "pointerover"]);
fa("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" "));
fa("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" "));
fa("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
fa("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" "));
fa("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" "));
var lf = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), mf = new Set("cancel close invalid load scroll toggle".split(" ").concat(lf));
function nf(a2, b2, c2) {
  var d2 = a2.type || "unknown-event";
  a2.currentTarget = c2;
  Ub(d2, b2, void 0, a2);
  a2.currentTarget = null;
}
function se(a2, b2) {
  b2 = 0 !== (b2 & 4);
  for (var c2 = 0; c2 < a2.length; c2++) {
    var d2 = a2[c2], e2 = d2.event;
    d2 = d2.listeners;
    a: {
      var f2 = void 0;
      if (b2) for (var g2 = d2.length - 1; 0 <= g2; g2--) {
        var h2 = d2[g2], k2 = h2.instance, l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
      else for (g2 = 0; g2 < d2.length; g2++) {
        h2 = d2[g2];
        k2 = h2.instance;
        l2 = h2.currentTarget;
        h2 = h2.listener;
        if (k2 !== f2 && e2.isPropagationStopped()) break a;
        nf(e2, h2, l2);
        f2 = k2;
      }
    }
  }
  if (Qb) throw a2 = Rb, Qb = false, Rb = null, a2;
}
function D$1(a2, b2) {
  var c2 = b2[of];
  void 0 === c2 && (c2 = b2[of] = /* @__PURE__ */ new Set());
  var d2 = a2 + "__bubble";
  c2.has(d2) || (pf(b2, a2, 2, false), c2.add(d2));
}
function qf(a2, b2, c2) {
  var d2 = 0;
  b2 && (d2 |= 4);
  pf(c2, a2, d2, b2);
}
var rf = "_reactListening" + Math.random().toString(36).slice(2);
function sf(a2) {
  if (!a2[rf]) {
    a2[rf] = true;
    da.forEach(function(b3) {
      "selectionchange" !== b3 && (mf.has(b3) || qf(b3, false, a2), qf(b3, true, a2));
    });
    var b2 = 9 === a2.nodeType ? a2 : a2.ownerDocument;
    null === b2 || b2[rf] || (b2[rf] = true, qf("selectionchange", false, b2));
  }
}
function pf(a2, b2, c2, d2) {
  switch (jd(b2)) {
    case 1:
      var e2 = ed;
      break;
    case 4:
      e2 = gd;
      break;
    default:
      e2 = fd;
  }
  c2 = e2.bind(null, b2, c2, a2);
  e2 = void 0;
  !Lb || "touchstart" !== b2 && "touchmove" !== b2 && "wheel" !== b2 || (e2 = true);
  d2 ? void 0 !== e2 ? a2.addEventListener(b2, c2, { capture: true, passive: e2 }) : a2.addEventListener(b2, c2, true) : void 0 !== e2 ? a2.addEventListener(b2, c2, { passive: e2 }) : a2.addEventListener(b2, c2, false);
}
function hd(a2, b2, c2, d2, e2) {
  var f2 = d2;
  if (0 === (b2 & 1) && 0 === (b2 & 2) && null !== d2) a: for (; ; ) {
    if (null === d2) return;
    var g2 = d2.tag;
    if (3 === g2 || 4 === g2) {
      var h2 = d2.stateNode.containerInfo;
      if (h2 === e2 || 8 === h2.nodeType && h2.parentNode === e2) break;
      if (4 === g2) for (g2 = d2.return; null !== g2; ) {
        var k2 = g2.tag;
        if (3 === k2 || 4 === k2) {
          if (k2 = g2.stateNode.containerInfo, k2 === e2 || 8 === k2.nodeType && k2.parentNode === e2) return;
        }
        g2 = g2.return;
      }
      for (; null !== h2; ) {
        g2 = Wc(h2);
        if (null === g2) return;
        k2 = g2.tag;
        if (5 === k2 || 6 === k2) {
          d2 = f2 = g2;
          continue a;
        }
        h2 = h2.parentNode;
      }
    }
    d2 = d2.return;
  }
  Jb(function() {
    var d3 = f2, e3 = xb(c2), g3 = [];
    a: {
      var h3 = df.get(a2);
      if (void 0 !== h3) {
        var k3 = td, n2 = a2;
        switch (a2) {
          case "keypress":
            if (0 === od(c2)) break a;
          case "keydown":
          case "keyup":
            k3 = Rd;
            break;
          case "focusin":
            n2 = "focus";
            k3 = Fd;
            break;
          case "focusout":
            n2 = "blur";
            k3 = Fd;
            break;
          case "beforeblur":
          case "afterblur":
            k3 = Fd;
            break;
          case "click":
            if (2 === c2.button) break a;
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            k3 = Bd;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            k3 = Dd;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            k3 = Vd;
            break;
          case $e:
          case af:
          case bf:
            k3 = Hd;
            break;
          case cf:
            k3 = Xd;
            break;
          case "scroll":
            k3 = vd;
            break;
          case "wheel":
            k3 = Zd;
            break;
          case "copy":
          case "cut":
          case "paste":
            k3 = Jd;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            k3 = Td;
        }
        var t2 = 0 !== (b2 & 4), J2 = !t2 && "scroll" === a2, x2 = t2 ? null !== h3 ? h3 + "Capture" : null : h3;
        t2 = [];
        for (var w2 = d3, u2; null !== w2; ) {
          u2 = w2;
          var F2 = u2.stateNode;
          5 === u2.tag && null !== F2 && (u2 = F2, null !== x2 && (F2 = Kb(w2, x2), null != F2 && t2.push(tf(w2, F2, u2))));
          if (J2) break;
          w2 = w2.return;
        }
        0 < t2.length && (h3 = new k3(h3, n2, null, c2, e3), g3.push({ event: h3, listeners: t2 }));
      }
    }
    if (0 === (b2 & 7)) {
      a: {
        h3 = "mouseover" === a2 || "pointerover" === a2;
        k3 = "mouseout" === a2 || "pointerout" === a2;
        if (h3 && c2 !== wb && (n2 = c2.relatedTarget || c2.fromElement) && (Wc(n2) || n2[uf])) break a;
        if (k3 || h3) {
          h3 = e3.window === e3 ? e3 : (h3 = e3.ownerDocument) ? h3.defaultView || h3.parentWindow : window;
          if (k3) {
            if (n2 = c2.relatedTarget || c2.toElement, k3 = d3, n2 = n2 ? Wc(n2) : null, null !== n2 && (J2 = Vb(n2), n2 !== J2 || 5 !== n2.tag && 6 !== n2.tag)) n2 = null;
          } else k3 = null, n2 = d3;
          if (k3 !== n2) {
            t2 = Bd;
            F2 = "onMouseLeave";
            x2 = "onMouseEnter";
            w2 = "mouse";
            if ("pointerout" === a2 || "pointerover" === a2) t2 = Td, F2 = "onPointerLeave", x2 = "onPointerEnter", w2 = "pointer";
            J2 = null == k3 ? h3 : ue(k3);
            u2 = null == n2 ? h3 : ue(n2);
            h3 = new t2(F2, w2 + "leave", k3, c2, e3);
            h3.target = J2;
            h3.relatedTarget = u2;
            F2 = null;
            Wc(e3) === d3 && (t2 = new t2(x2, w2 + "enter", n2, c2, e3), t2.target = u2, t2.relatedTarget = J2, F2 = t2);
            J2 = F2;
            if (k3 && n2) b: {
              t2 = k3;
              x2 = n2;
              w2 = 0;
              for (u2 = t2; u2; u2 = vf(u2)) w2++;
              u2 = 0;
              for (F2 = x2; F2; F2 = vf(F2)) u2++;
              for (; 0 < w2 - u2; ) t2 = vf(t2), w2--;
              for (; 0 < u2 - w2; ) x2 = vf(x2), u2--;
              for (; w2--; ) {
                if (t2 === x2 || null !== x2 && t2 === x2.alternate) break b;
                t2 = vf(t2);
                x2 = vf(x2);
              }
              t2 = null;
            }
            else t2 = null;
            null !== k3 && wf(g3, h3, k3, t2, false);
            null !== n2 && null !== J2 && wf(g3, J2, n2, t2, true);
          }
        }
      }
      a: {
        h3 = d3 ? ue(d3) : window;
        k3 = h3.nodeName && h3.nodeName.toLowerCase();
        if ("select" === k3 || "input" === k3 && "file" === h3.type) var na = ve;
        else if (me(h3)) if (we) na = Fe;
        else {
          na = De;
          var xa = Ce;
        }
        else (k3 = h3.nodeName) && "input" === k3.toLowerCase() && ("checkbox" === h3.type || "radio" === h3.type) && (na = Ee);
        if (na && (na = na(a2, d3))) {
          ne(g3, na, c2, e3);
          break a;
        }
        xa && xa(a2, h3, d3);
        "focusout" === a2 && (xa = h3._wrapperState) && xa.controlled && "number" === h3.type && cb(h3, "number", h3.value);
      }
      xa = d3 ? ue(d3) : window;
      switch (a2) {
        case "focusin":
          if (me(xa) || "true" === xa.contentEditable) Qe = xa, Re = d3, Se = null;
          break;
        case "focusout":
          Se = Re = Qe = null;
          break;
        case "mousedown":
          Te = true;
          break;
        case "contextmenu":
        case "mouseup":
        case "dragend":
          Te = false;
          Ue(g3, c2, e3);
          break;
        case "selectionchange":
          if (Pe) break;
        case "keydown":
        case "keyup":
          Ue(g3, c2, e3);
      }
      var $a;
      if (ae) b: {
        switch (a2) {
          case "compositionstart":
            var ba = "onCompositionStart";
            break b;
          case "compositionend":
            ba = "onCompositionEnd";
            break b;
          case "compositionupdate":
            ba = "onCompositionUpdate";
            break b;
        }
        ba = void 0;
      }
      else ie ? ge(a2, c2) && (ba = "onCompositionEnd") : "keydown" === a2 && 229 === c2.keyCode && (ba = "onCompositionStart");
      ba && (de && "ko" !== c2.locale && (ie || "onCompositionStart" !== ba ? "onCompositionEnd" === ba && ie && ($a = nd()) : (kd = e3, ld = "value" in kd ? kd.value : kd.textContent, ie = true)), xa = oe(d3, ba), 0 < xa.length && (ba = new Ld(ba, a2, null, c2, e3), g3.push({ event: ba, listeners: xa }), $a ? ba.data = $a : ($a = he(c2), null !== $a && (ba.data = $a))));
      if ($a = ce ? je(a2, c2) : ke(a2, c2)) d3 = oe(d3, "onBeforeInput"), 0 < d3.length && (e3 = new Ld("onBeforeInput", "beforeinput", null, c2, e3), g3.push({ event: e3, listeners: d3 }), e3.data = $a);
    }
    se(g3, b2);
  });
}
function tf(a2, b2, c2) {
  return { instance: a2, listener: b2, currentTarget: c2 };
}
function oe(a2, b2) {
  for (var c2 = b2 + "Capture", d2 = []; null !== a2; ) {
    var e2 = a2, f2 = e2.stateNode;
    5 === e2.tag && null !== f2 && (e2 = f2, f2 = Kb(a2, c2), null != f2 && d2.unshift(tf(a2, f2, e2)), f2 = Kb(a2, b2), null != f2 && d2.push(tf(a2, f2, e2)));
    a2 = a2.return;
  }
  return d2;
}
function vf(a2) {
  if (null === a2) return null;
  do
    a2 = a2.return;
  while (a2 && 5 !== a2.tag);
  return a2 ? a2 : null;
}
function wf(a2, b2, c2, d2, e2) {
  for (var f2 = b2._reactName, g2 = []; null !== c2 && c2 !== d2; ) {
    var h2 = c2, k2 = h2.alternate, l2 = h2.stateNode;
    if (null !== k2 && k2 === d2) break;
    5 === h2.tag && null !== l2 && (h2 = l2, e2 ? (k2 = Kb(c2, f2), null != k2 && g2.unshift(tf(c2, k2, h2))) : e2 || (k2 = Kb(c2, f2), null != k2 && g2.push(tf(c2, k2, h2))));
    c2 = c2.return;
  }
  0 !== g2.length && a2.push({ event: b2, listeners: g2 });
}
var xf = /\r\n?/g, yf = /\u0000|\uFFFD/g;
function zf(a2) {
  return ("string" === typeof a2 ? a2 : "" + a2).replace(xf, "\n").replace(yf, "");
}
function Af(a2, b2, c2) {
  b2 = zf(b2);
  if (zf(a2) !== b2 && c2) throw Error(p$3(425));
}
function Bf() {
}
var Cf = null, Df = null;
function Ef(a2, b2) {
  return "textarea" === a2 || "noscript" === a2 || "string" === typeof b2.children || "number" === typeof b2.children || "object" === typeof b2.dangerouslySetInnerHTML && null !== b2.dangerouslySetInnerHTML && null != b2.dangerouslySetInnerHTML.__html;
}
var Ff = "function" === typeof setTimeout ? setTimeout : void 0, Gf = "function" === typeof clearTimeout ? clearTimeout : void 0, Hf = "function" === typeof Promise ? Promise : void 0, Jf = "function" === typeof queueMicrotask ? queueMicrotask : "undefined" !== typeof Hf ? function(a2) {
  return Hf.resolve(null).then(a2).catch(If);
} : Ff;
function If(a2) {
  setTimeout(function() {
    throw a2;
  });
}
function Kf(a2, b2) {
  var c2 = b2, d2 = 0;
  do {
    var e2 = c2.nextSibling;
    a2.removeChild(c2);
    if (e2 && 8 === e2.nodeType) if (c2 = e2.data, "/$" === c2) {
      if (0 === d2) {
        a2.removeChild(e2);
        bd(b2);
        return;
      }
      d2--;
    } else "$" !== c2 && "$?" !== c2 && "$!" !== c2 || d2++;
    c2 = e2;
  } while (c2);
  bd(b2);
}
function Lf(a2) {
  for (; null != a2; a2 = a2.nextSibling) {
    var b2 = a2.nodeType;
    if (1 === b2 || 3 === b2) break;
    if (8 === b2) {
      b2 = a2.data;
      if ("$" === b2 || "$!" === b2 || "$?" === b2) break;
      if ("/$" === b2) return null;
    }
  }
  return a2;
}
function Mf(a2) {
  a2 = a2.previousSibling;
  for (var b2 = 0; a2; ) {
    if (8 === a2.nodeType) {
      var c2 = a2.data;
      if ("$" === c2 || "$!" === c2 || "$?" === c2) {
        if (0 === b2) return a2;
        b2--;
      } else "/$" === c2 && b2++;
    }
    a2 = a2.previousSibling;
  }
  return null;
}
var Nf = Math.random().toString(36).slice(2), Of = "__reactFiber$" + Nf, Pf = "__reactProps$" + Nf, uf = "__reactContainer$" + Nf, of = "__reactEvents$" + Nf, Qf = "__reactListeners$" + Nf, Rf = "__reactHandles$" + Nf;
function Wc(a2) {
  var b2 = a2[Of];
  if (b2) return b2;
  for (var c2 = a2.parentNode; c2; ) {
    if (b2 = c2[uf] || c2[Of]) {
      c2 = b2.alternate;
      if (null !== b2.child || null !== c2 && null !== c2.child) for (a2 = Mf(a2); null !== a2; ) {
        if (c2 = a2[Of]) return c2;
        a2 = Mf(a2);
      }
      return b2;
    }
    a2 = c2;
    c2 = a2.parentNode;
  }
  return null;
}
function Cb(a2) {
  a2 = a2[Of] || a2[uf];
  return !a2 || 5 !== a2.tag && 6 !== a2.tag && 13 !== a2.tag && 3 !== a2.tag ? null : a2;
}
function ue(a2) {
  if (5 === a2.tag || 6 === a2.tag) return a2.stateNode;
  throw Error(p$3(33));
}
function Db(a2) {
  return a2[Pf] || null;
}
var Sf = [], Tf = -1;
function Uf(a2) {
  return { current: a2 };
}
function E$1(a2) {
  0 > Tf || (a2.current = Sf[Tf], Sf[Tf] = null, Tf--);
}
function G(a2, b2) {
  Tf++;
  Sf[Tf] = a2.current;
  a2.current = b2;
}
var Vf = {}, H = Uf(Vf), Wf = Uf(false), Xf = Vf;
function Yf(a2, b2) {
  var c2 = a2.type.contextTypes;
  if (!c2) return Vf;
  var d2 = a2.stateNode;
  if (d2 && d2.__reactInternalMemoizedUnmaskedChildContext === b2) return d2.__reactInternalMemoizedMaskedChildContext;
  var e2 = {}, f2;
  for (f2 in c2) e2[f2] = b2[f2];
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = b2, a2.__reactInternalMemoizedMaskedChildContext = e2);
  return e2;
}
function Zf(a2) {
  a2 = a2.childContextTypes;
  return null !== a2 && void 0 !== a2;
}
function $f() {
  E$1(Wf);
  E$1(H);
}
function ag(a2, b2, c2) {
  if (H.current !== Vf) throw Error(p$3(168));
  G(H, b2);
  G(Wf, c2);
}
function bg(a2, b2, c2) {
  var d2 = a2.stateNode;
  b2 = b2.childContextTypes;
  if ("function" !== typeof d2.getChildContext) return c2;
  d2 = d2.getChildContext();
  for (var e2 in d2) if (!(e2 in b2)) throw Error(p$3(108, Ra(a2) || "Unknown", e2));
  return A$1({}, c2, d2);
}
function cg(a2) {
  a2 = (a2 = a2.stateNode) && a2.__reactInternalMemoizedMergedChildContext || Vf;
  Xf = H.current;
  G(H, a2);
  G(Wf, Wf.current);
  return true;
}
function dg(a2, b2, c2) {
  var d2 = a2.stateNode;
  if (!d2) throw Error(p$3(169));
  c2 ? (a2 = bg(a2, b2, Xf), d2.__reactInternalMemoizedMergedChildContext = a2, E$1(Wf), E$1(H), G(H, a2)) : E$1(Wf);
  G(Wf, c2);
}
var eg = null, fg = false, gg = false;
function hg(a2) {
  null === eg ? eg = [a2] : eg.push(a2);
}
function ig(a2) {
  fg = true;
  hg(a2);
}
function jg() {
  if (!gg && null !== eg) {
    gg = true;
    var a2 = 0, b2 = C$1;
    try {
      var c2 = eg;
      for (C$1 = 1; a2 < c2.length; a2++) {
        var d2 = c2[a2];
        do
          d2 = d2(true);
        while (null !== d2);
      }
      eg = null;
      fg = false;
    } catch (e2) {
      throw null !== eg && (eg = eg.slice(a2 + 1)), ac(fc, jg), e2;
    } finally {
      C$1 = b2, gg = false;
    }
  }
  return null;
}
var kg = [], lg = 0, mg = null, ng = 0, og = [], pg = 0, qg = null, rg = 1, sg = "";
function tg(a2, b2) {
  kg[lg++] = ng;
  kg[lg++] = mg;
  mg = a2;
  ng = b2;
}
function ug(a2, b2, c2) {
  og[pg++] = rg;
  og[pg++] = sg;
  og[pg++] = qg;
  qg = a2;
  var d2 = rg;
  a2 = sg;
  var e2 = 32 - oc(d2) - 1;
  d2 &= ~(1 << e2);
  c2 += 1;
  var f2 = 32 - oc(b2) + e2;
  if (30 < f2) {
    var g2 = e2 - e2 % 5;
    f2 = (d2 & (1 << g2) - 1).toString(32);
    d2 >>= g2;
    e2 -= g2;
    rg = 1 << 32 - oc(b2) + e2 | c2 << e2 | d2;
    sg = f2 + a2;
  } else rg = 1 << f2 | c2 << e2 | d2, sg = a2;
}
function vg(a2) {
  null !== a2.return && (tg(a2, 1), ug(a2, 1, 0));
}
function wg(a2) {
  for (; a2 === mg; ) mg = kg[--lg], kg[lg] = null, ng = kg[--lg], kg[lg] = null;
  for (; a2 === qg; ) qg = og[--pg], og[pg] = null, sg = og[--pg], og[pg] = null, rg = og[--pg], og[pg] = null;
}
var xg = null, yg = null, I$1 = false, zg = null;
function Ag(a2, b2) {
  var c2 = Bg(5, null, null, 0);
  c2.elementType = "DELETED";
  c2.stateNode = b2;
  c2.return = a2;
  b2 = a2.deletions;
  null === b2 ? (a2.deletions = [c2], a2.flags |= 16) : b2.push(c2);
}
function Cg(a2, b2) {
  switch (a2.tag) {
    case 5:
      var c2 = a2.type;
      b2 = 1 !== b2.nodeType || c2.toLowerCase() !== b2.nodeName.toLowerCase() ? null : b2;
      return null !== b2 ? (a2.stateNode = b2, xg = a2, yg = Lf(b2.firstChild), true) : false;
    case 6:
      return b2 = "" === a2.pendingProps || 3 !== b2.nodeType ? null : b2, null !== b2 ? (a2.stateNode = b2, xg = a2, yg = null, true) : false;
    case 13:
      return b2 = 8 !== b2.nodeType ? null : b2, null !== b2 ? (c2 = null !== qg ? { id: rg, overflow: sg } : null, a2.memoizedState = { dehydrated: b2, treeContext: c2, retryLane: 1073741824 }, c2 = Bg(18, null, null, 0), c2.stateNode = b2, c2.return = a2, a2.child = c2, xg = a2, yg = null, true) : false;
    default:
      return false;
  }
}
function Dg(a2) {
  return 0 !== (a2.mode & 1) && 0 === (a2.flags & 128);
}
function Eg(a2) {
  if (I$1) {
    var b2 = yg;
    if (b2) {
      var c2 = b2;
      if (!Cg(a2, b2)) {
        if (Dg(a2)) throw Error(p$3(418));
        b2 = Lf(c2.nextSibling);
        var d2 = xg;
        b2 && Cg(a2, b2) ? Ag(d2, c2) : (a2.flags = a2.flags & -4097 | 2, I$1 = false, xg = a2);
      }
    } else {
      if (Dg(a2)) throw Error(p$3(418));
      a2.flags = a2.flags & -4097 | 2;
      I$1 = false;
      xg = a2;
    }
  }
}
function Fg(a2) {
  for (a2 = a2.return; null !== a2 && 5 !== a2.tag && 3 !== a2.tag && 13 !== a2.tag; ) a2 = a2.return;
  xg = a2;
}
function Gg(a2) {
  if (a2 !== xg) return false;
  if (!I$1) return Fg(a2), I$1 = true, false;
  var b2;
  (b2 = 3 !== a2.tag) && !(b2 = 5 !== a2.tag) && (b2 = a2.type, b2 = "head" !== b2 && "body" !== b2 && !Ef(a2.type, a2.memoizedProps));
  if (b2 && (b2 = yg)) {
    if (Dg(a2)) throw Hg(), Error(p$3(418));
    for (; b2; ) Ag(a2, b2), b2 = Lf(b2.nextSibling);
  }
  Fg(a2);
  if (13 === a2.tag) {
    a2 = a2.memoizedState;
    a2 = null !== a2 ? a2.dehydrated : null;
    if (!a2) throw Error(p$3(317));
    a: {
      a2 = a2.nextSibling;
      for (b2 = 0; a2; ) {
        if (8 === a2.nodeType) {
          var c2 = a2.data;
          if ("/$" === c2) {
            if (0 === b2) {
              yg = Lf(a2.nextSibling);
              break a;
            }
            b2--;
          } else "$" !== c2 && "$!" !== c2 && "$?" !== c2 || b2++;
        }
        a2 = a2.nextSibling;
      }
      yg = null;
    }
  } else yg = xg ? Lf(a2.stateNode.nextSibling) : null;
  return true;
}
function Hg() {
  for (var a2 = yg; a2; ) a2 = Lf(a2.nextSibling);
}
function Ig() {
  yg = xg = null;
  I$1 = false;
}
function Jg(a2) {
  null === zg ? zg = [a2] : zg.push(a2);
}
var Kg = ua.ReactCurrentBatchConfig;
function Lg(a2, b2, c2) {
  a2 = c2.ref;
  if (null !== a2 && "function" !== typeof a2 && "object" !== typeof a2) {
    if (c2._owner) {
      c2 = c2._owner;
      if (c2) {
        if (1 !== c2.tag) throw Error(p$3(309));
        var d2 = c2.stateNode;
      }
      if (!d2) throw Error(p$3(147, a2));
      var e2 = d2, f2 = "" + a2;
      if (null !== b2 && null !== b2.ref && "function" === typeof b2.ref && b2.ref._stringRef === f2) return b2.ref;
      b2 = function(a3) {
        var b3 = e2.refs;
        null === a3 ? delete b3[f2] : b3[f2] = a3;
      };
      b2._stringRef = f2;
      return b2;
    }
    if ("string" !== typeof a2) throw Error(p$3(284));
    if (!c2._owner) throw Error(p$3(290, a2));
  }
  return a2;
}
function Mg(a2, b2) {
  a2 = Object.prototype.toString.call(b2);
  throw Error(p$3(31, "[object Object]" === a2 ? "object with keys {" + Object.keys(b2).join(", ") + "}" : a2));
}
function Ng(a2) {
  var b2 = a2._init;
  return b2(a2._payload);
}
function Og(a2) {
  function b2(b3, c3) {
    if (a2) {
      var d3 = b3.deletions;
      null === d3 ? (b3.deletions = [c3], b3.flags |= 16) : d3.push(c3);
    }
  }
  function c2(c3, d3) {
    if (!a2) return null;
    for (; null !== d3; ) b2(c3, d3), d3 = d3.sibling;
    return null;
  }
  function d2(a3, b3) {
    for (a3 = /* @__PURE__ */ new Map(); null !== b3; ) null !== b3.key ? a3.set(b3.key, b3) : a3.set(b3.index, b3), b3 = b3.sibling;
    return a3;
  }
  function e2(a3, b3) {
    a3 = Pg(a3, b3);
    a3.index = 0;
    a3.sibling = null;
    return a3;
  }
  function f2(b3, c3, d3) {
    b3.index = d3;
    if (!a2) return b3.flags |= 1048576, c3;
    d3 = b3.alternate;
    if (null !== d3) return d3 = d3.index, d3 < c3 ? (b3.flags |= 2, c3) : d3;
    b3.flags |= 2;
    return c3;
  }
  function g2(b3) {
    a2 && null === b3.alternate && (b3.flags |= 2);
    return b3;
  }
  function h2(a3, b3, c3, d3) {
    if (null === b3 || 6 !== b3.tag) return b3 = Qg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function k2(a3, b3, c3, d3) {
    var f3 = c3.type;
    if (f3 === ya) return m2(a3, b3, c3.props.children, d3, c3.key);
    if (null !== b3 && (b3.elementType === f3 || "object" === typeof f3 && null !== f3 && f3.$$typeof === Ha && Ng(f3) === b3.type)) return d3 = e2(b3, c3.props), d3.ref = Lg(a3, b3, c3), d3.return = a3, d3;
    d3 = Rg(c3.type, c3.key, c3.props, null, a3.mode, d3);
    d3.ref = Lg(a3, b3, c3);
    d3.return = a3;
    return d3;
  }
  function l2(a3, b3, c3, d3) {
    if (null === b3 || 4 !== b3.tag || b3.stateNode.containerInfo !== c3.containerInfo || b3.stateNode.implementation !== c3.implementation) return b3 = Sg(c3, a3.mode, d3), b3.return = a3, b3;
    b3 = e2(b3, c3.children || []);
    b3.return = a3;
    return b3;
  }
  function m2(a3, b3, c3, d3, f3) {
    if (null === b3 || 7 !== b3.tag) return b3 = Tg(c3, a3.mode, d3, f3), b3.return = a3, b3;
    b3 = e2(b3, c3);
    b3.return = a3;
    return b3;
  }
  function q2(a3, b3, c3) {
    if ("string" === typeof b3 && "" !== b3 || "number" === typeof b3) return b3 = Qg("" + b3, a3.mode, c3), b3.return = a3, b3;
    if ("object" === typeof b3 && null !== b3) {
      switch (b3.$$typeof) {
        case va:
          return c3 = Rg(b3.type, b3.key, b3.props, null, a3.mode, c3), c3.ref = Lg(a3, null, b3), c3.return = a3, c3;
        case wa:
          return b3 = Sg(b3, a3.mode, c3), b3.return = a3, b3;
        case Ha:
          var d3 = b3._init;
          return q2(a3, d3(b3._payload), c3);
      }
      if (eb(b3) || Ka(b3)) return b3 = Tg(b3, a3.mode, c3, null), b3.return = a3, b3;
      Mg(a3, b3);
    }
    return null;
  }
  function r2(a3, b3, c3, d3) {
    var e3 = null !== b3 ? b3.key : null;
    if ("string" === typeof c3 && "" !== c3 || "number" === typeof c3) return null !== e3 ? null : h2(a3, b3, "" + c3, d3);
    if ("object" === typeof c3 && null !== c3) {
      switch (c3.$$typeof) {
        case va:
          return c3.key === e3 ? k2(a3, b3, c3, d3) : null;
        case wa:
          return c3.key === e3 ? l2(a3, b3, c3, d3) : null;
        case Ha:
          return e3 = c3._init, r2(
            a3,
            b3,
            e3(c3._payload),
            d3
          );
      }
      if (eb(c3) || Ka(c3)) return null !== e3 ? null : m2(a3, b3, c3, d3, null);
      Mg(a3, c3);
    }
    return null;
  }
  function y2(a3, b3, c3, d3, e3) {
    if ("string" === typeof d3 && "" !== d3 || "number" === typeof d3) return a3 = a3.get(c3) || null, h2(b3, a3, "" + d3, e3);
    if ("object" === typeof d3 && null !== d3) {
      switch (d3.$$typeof) {
        case va:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, k2(b3, a3, d3, e3);
        case wa:
          return a3 = a3.get(null === d3.key ? c3 : d3.key) || null, l2(b3, a3, d3, e3);
        case Ha:
          var f3 = d3._init;
          return y2(a3, b3, c3, f3(d3._payload), e3);
      }
      if (eb(d3) || Ka(d3)) return a3 = a3.get(c3) || null, m2(b3, a3, d3, e3, null);
      Mg(b3, d3);
    }
    return null;
  }
  function n2(e3, g3, h3, k3) {
    for (var l3 = null, m3 = null, u2 = g3, w2 = g3 = 0, x2 = null; null !== u2 && w2 < h3.length; w2++) {
      u2.index > w2 ? (x2 = u2, u2 = null) : x2 = u2.sibling;
      var n3 = r2(e3, u2, h3[w2], k3);
      if (null === n3) {
        null === u2 && (u2 = x2);
        break;
      }
      a2 && u2 && null === n3.alternate && b2(e3, u2);
      g3 = f2(n3, g3, w2);
      null === m3 ? l3 = n3 : m3.sibling = n3;
      m3 = n3;
      u2 = x2;
    }
    if (w2 === h3.length) return c2(e3, u2), I$1 && tg(e3, w2), l3;
    if (null === u2) {
      for (; w2 < h3.length; w2++) u2 = q2(e3, h3[w2], k3), null !== u2 && (g3 = f2(u2, g3, w2), null === m3 ? l3 = u2 : m3.sibling = u2, m3 = u2);
      I$1 && tg(e3, w2);
      return l3;
    }
    for (u2 = d2(e3, u2); w2 < h3.length; w2++) x2 = y2(u2, e3, w2, h3[w2], k3), null !== x2 && (a2 && null !== x2.alternate && u2.delete(null === x2.key ? w2 : x2.key), g3 = f2(x2, g3, w2), null === m3 ? l3 = x2 : m3.sibling = x2, m3 = x2);
    a2 && u2.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$1 && tg(e3, w2);
    return l3;
  }
  function t2(e3, g3, h3, k3) {
    var l3 = Ka(h3);
    if ("function" !== typeof l3) throw Error(p$3(150));
    h3 = l3.call(h3);
    if (null == h3) throw Error(p$3(151));
    for (var u2 = l3 = null, m3 = g3, w2 = g3 = 0, x2 = null, n3 = h3.next(); null !== m3 && !n3.done; w2++, n3 = h3.next()) {
      m3.index > w2 ? (x2 = m3, m3 = null) : x2 = m3.sibling;
      var t3 = r2(e3, m3, n3.value, k3);
      if (null === t3) {
        null === m3 && (m3 = x2);
        break;
      }
      a2 && m3 && null === t3.alternate && b2(e3, m3);
      g3 = f2(t3, g3, w2);
      null === u2 ? l3 = t3 : u2.sibling = t3;
      u2 = t3;
      m3 = x2;
    }
    if (n3.done) return c2(
      e3,
      m3
    ), I$1 && tg(e3, w2), l3;
    if (null === m3) {
      for (; !n3.done; w2++, n3 = h3.next()) n3 = q2(e3, n3.value, k3), null !== n3 && (g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
      I$1 && tg(e3, w2);
      return l3;
    }
    for (m3 = d2(e3, m3); !n3.done; w2++, n3 = h3.next()) n3 = y2(m3, e3, w2, n3.value, k3), null !== n3 && (a2 && null !== n3.alternate && m3.delete(null === n3.key ? w2 : n3.key), g3 = f2(n3, g3, w2), null === u2 ? l3 = n3 : u2.sibling = n3, u2 = n3);
    a2 && m3.forEach(function(a3) {
      return b2(e3, a3);
    });
    I$1 && tg(e3, w2);
    return l3;
  }
  function J2(a3, d3, f3, h3) {
    "object" === typeof f3 && null !== f3 && f3.type === ya && null === f3.key && (f3 = f3.props.children);
    if ("object" === typeof f3 && null !== f3) {
      switch (f3.$$typeof) {
        case va:
          a: {
            for (var k3 = f3.key, l3 = d3; null !== l3; ) {
              if (l3.key === k3) {
                k3 = f3.type;
                if (k3 === ya) {
                  if (7 === l3.tag) {
                    c2(a3, l3.sibling);
                    d3 = e2(l3, f3.props.children);
                    d3.return = a3;
                    a3 = d3;
                    break a;
                  }
                } else if (l3.elementType === k3 || "object" === typeof k3 && null !== k3 && k3.$$typeof === Ha && Ng(k3) === l3.type) {
                  c2(a3, l3.sibling);
                  d3 = e2(l3, f3.props);
                  d3.ref = Lg(a3, l3, f3);
                  d3.return = a3;
                  a3 = d3;
                  break a;
                }
                c2(a3, l3);
                break;
              } else b2(a3, l3);
              l3 = l3.sibling;
            }
            f3.type === ya ? (d3 = Tg(f3.props.children, a3.mode, h3, f3.key), d3.return = a3, a3 = d3) : (h3 = Rg(f3.type, f3.key, f3.props, null, a3.mode, h3), h3.ref = Lg(a3, d3, f3), h3.return = a3, a3 = h3);
          }
          return g2(a3);
        case wa:
          a: {
            for (l3 = f3.key; null !== d3; ) {
              if (d3.key === l3) if (4 === d3.tag && d3.stateNode.containerInfo === f3.containerInfo && d3.stateNode.implementation === f3.implementation) {
                c2(a3, d3.sibling);
                d3 = e2(d3, f3.children || []);
                d3.return = a3;
                a3 = d3;
                break a;
              } else {
                c2(a3, d3);
                break;
              }
              else b2(a3, d3);
              d3 = d3.sibling;
            }
            d3 = Sg(f3, a3.mode, h3);
            d3.return = a3;
            a3 = d3;
          }
          return g2(a3);
        case Ha:
          return l3 = f3._init, J2(a3, d3, l3(f3._payload), h3);
      }
      if (eb(f3)) return n2(a3, d3, f3, h3);
      if (Ka(f3)) return t2(a3, d3, f3, h3);
      Mg(a3, f3);
    }
    return "string" === typeof f3 && "" !== f3 || "number" === typeof f3 ? (f3 = "" + f3, null !== d3 && 6 === d3.tag ? (c2(a3, d3.sibling), d3 = e2(d3, f3), d3.return = a3, a3 = d3) : (c2(a3, d3), d3 = Qg(f3, a3.mode, h3), d3.return = a3, a3 = d3), g2(a3)) : c2(a3, d3);
  }
  return J2;
}
var Ug = Og(true), Vg = Og(false), Wg = Uf(null), Xg = null, Yg = null, Zg = null;
function $g() {
  Zg = Yg = Xg = null;
}
function ah(a2) {
  var b2 = Wg.current;
  E$1(Wg);
  a2._currentValue = b2;
}
function bh(a2, b2, c2) {
  for (; null !== a2; ) {
    var d2 = a2.alternate;
    (a2.childLanes & b2) !== b2 ? (a2.childLanes |= b2, null !== d2 && (d2.childLanes |= b2)) : null !== d2 && (d2.childLanes & b2) !== b2 && (d2.childLanes |= b2);
    if (a2 === c2) break;
    a2 = a2.return;
  }
}
function ch(a2, b2) {
  Xg = a2;
  Zg = Yg = null;
  a2 = a2.dependencies;
  null !== a2 && null !== a2.firstContext && (0 !== (a2.lanes & b2) && (dh = true), a2.firstContext = null);
}
function eh(a2) {
  var b2 = a2._currentValue;
  if (Zg !== a2) if (a2 = { context: a2, memoizedValue: b2, next: null }, null === Yg) {
    if (null === Xg) throw Error(p$3(308));
    Yg = a2;
    Xg.dependencies = { lanes: 0, firstContext: a2 };
  } else Yg = Yg.next = a2;
  return b2;
}
var fh = null;
function gh(a2) {
  null === fh ? fh = [a2] : fh.push(a2);
}
function hh(a2, b2, c2, d2) {
  var e2 = b2.interleaved;
  null === e2 ? (c2.next = c2, gh(b2)) : (c2.next = e2.next, e2.next = c2);
  b2.interleaved = c2;
  return ih(a2, d2);
}
function ih(a2, b2) {
  a2.lanes |= b2;
  var c2 = a2.alternate;
  null !== c2 && (c2.lanes |= b2);
  c2 = a2;
  for (a2 = a2.return; null !== a2; ) a2.childLanes |= b2, c2 = a2.alternate, null !== c2 && (c2.childLanes |= b2), c2 = a2, a2 = a2.return;
  return 3 === c2.tag ? c2.stateNode : null;
}
var jh = false;
function kh(a2) {
  a2.updateQueue = { baseState: a2.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null };
}
function lh(a2, b2) {
  a2 = a2.updateQueue;
  b2.updateQueue === a2 && (b2.updateQueue = { baseState: a2.baseState, firstBaseUpdate: a2.firstBaseUpdate, lastBaseUpdate: a2.lastBaseUpdate, shared: a2.shared, effects: a2.effects });
}
function mh(a2, b2) {
  return { eventTime: a2, lane: b2, tag: 0, payload: null, callback: null, next: null };
}
function nh(a2, b2, c2) {
  var d2 = a2.updateQueue;
  if (null === d2) return null;
  d2 = d2.shared;
  if (0 !== (K & 2)) {
    var e2 = d2.pending;
    null === e2 ? b2.next = b2 : (b2.next = e2.next, e2.next = b2);
    d2.pending = b2;
    return ih(a2, c2);
  }
  e2 = d2.interleaved;
  null === e2 ? (b2.next = b2, gh(d2)) : (b2.next = e2.next, e2.next = b2);
  d2.interleaved = b2;
  return ih(a2, c2);
}
function oh(a2, b2, c2) {
  b2 = b2.updateQueue;
  if (null !== b2 && (b2 = b2.shared, 0 !== (c2 & 4194240))) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
function ph(a2, b2) {
  var c2 = a2.updateQueue, d2 = a2.alternate;
  if (null !== d2 && (d2 = d2.updateQueue, c2 === d2)) {
    var e2 = null, f2 = null;
    c2 = c2.firstBaseUpdate;
    if (null !== c2) {
      do {
        var g2 = { eventTime: c2.eventTime, lane: c2.lane, tag: c2.tag, payload: c2.payload, callback: c2.callback, next: null };
        null === f2 ? e2 = f2 = g2 : f2 = f2.next = g2;
        c2 = c2.next;
      } while (null !== c2);
      null === f2 ? e2 = f2 = b2 : f2 = f2.next = b2;
    } else e2 = f2 = b2;
    c2 = { baseState: d2.baseState, firstBaseUpdate: e2, lastBaseUpdate: f2, shared: d2.shared, effects: d2.effects };
    a2.updateQueue = c2;
    return;
  }
  a2 = c2.lastBaseUpdate;
  null === a2 ? c2.firstBaseUpdate = b2 : a2.next = b2;
  c2.lastBaseUpdate = b2;
}
function qh(a2, b2, c2, d2) {
  var e2 = a2.updateQueue;
  jh = false;
  var f2 = e2.firstBaseUpdate, g2 = e2.lastBaseUpdate, h2 = e2.shared.pending;
  if (null !== h2) {
    e2.shared.pending = null;
    var k2 = h2, l2 = k2.next;
    k2.next = null;
    null === g2 ? f2 = l2 : g2.next = l2;
    g2 = k2;
    var m2 = a2.alternate;
    null !== m2 && (m2 = m2.updateQueue, h2 = m2.lastBaseUpdate, h2 !== g2 && (null === h2 ? m2.firstBaseUpdate = l2 : h2.next = l2, m2.lastBaseUpdate = k2));
  }
  if (null !== f2) {
    var q2 = e2.baseState;
    g2 = 0;
    m2 = l2 = k2 = null;
    h2 = f2;
    do {
      var r2 = h2.lane, y2 = h2.eventTime;
      if ((d2 & r2) === r2) {
        null !== m2 && (m2 = m2.next = {
          eventTime: y2,
          lane: 0,
          tag: h2.tag,
          payload: h2.payload,
          callback: h2.callback,
          next: null
        });
        a: {
          var n2 = a2, t2 = h2;
          r2 = b2;
          y2 = c2;
          switch (t2.tag) {
            case 1:
              n2 = t2.payload;
              if ("function" === typeof n2) {
                q2 = n2.call(y2, q2, r2);
                break a;
              }
              q2 = n2;
              break a;
            case 3:
              n2.flags = n2.flags & -65537 | 128;
            case 0:
              n2 = t2.payload;
              r2 = "function" === typeof n2 ? n2.call(y2, q2, r2) : n2;
              if (null === r2 || void 0 === r2) break a;
              q2 = A$1({}, q2, r2);
              break a;
            case 2:
              jh = true;
          }
        }
        null !== h2.callback && 0 !== h2.lane && (a2.flags |= 64, r2 = e2.effects, null === r2 ? e2.effects = [h2] : r2.push(h2));
      } else y2 = { eventTime: y2, lane: r2, tag: h2.tag, payload: h2.payload, callback: h2.callback, next: null }, null === m2 ? (l2 = m2 = y2, k2 = q2) : m2 = m2.next = y2, g2 |= r2;
      h2 = h2.next;
      if (null === h2) if (h2 = e2.shared.pending, null === h2) break;
      else r2 = h2, h2 = r2.next, r2.next = null, e2.lastBaseUpdate = r2, e2.shared.pending = null;
    } while (1);
    null === m2 && (k2 = q2);
    e2.baseState = k2;
    e2.firstBaseUpdate = l2;
    e2.lastBaseUpdate = m2;
    b2 = e2.shared.interleaved;
    if (null !== b2) {
      e2 = b2;
      do
        g2 |= e2.lane, e2 = e2.next;
      while (e2 !== b2);
    } else null === f2 && (e2.shared.lanes = 0);
    rh |= g2;
    a2.lanes = g2;
    a2.memoizedState = q2;
  }
}
function sh(a2, b2, c2) {
  a2 = b2.effects;
  b2.effects = null;
  if (null !== a2) for (b2 = 0; b2 < a2.length; b2++) {
    var d2 = a2[b2], e2 = d2.callback;
    if (null !== e2) {
      d2.callback = null;
      d2 = c2;
      if ("function" !== typeof e2) throw Error(p$3(191, e2));
      e2.call(d2);
    }
  }
}
var th = {}, uh = Uf(th), vh = Uf(th), wh = Uf(th);
function xh(a2) {
  if (a2 === th) throw Error(p$3(174));
  return a2;
}
function yh(a2, b2) {
  G(wh, b2);
  G(vh, a2);
  G(uh, th);
  a2 = b2.nodeType;
  switch (a2) {
    case 9:
    case 11:
      b2 = (b2 = b2.documentElement) ? b2.namespaceURI : lb(null, "");
      break;
    default:
      a2 = 8 === a2 ? b2.parentNode : b2, b2 = a2.namespaceURI || null, a2 = a2.tagName, b2 = lb(b2, a2);
  }
  E$1(uh);
  G(uh, b2);
}
function zh() {
  E$1(uh);
  E$1(vh);
  E$1(wh);
}
function Ah(a2) {
  xh(wh.current);
  var b2 = xh(uh.current);
  var c2 = lb(b2, a2.type);
  b2 !== c2 && (G(vh, a2), G(uh, c2));
}
function Bh(a2) {
  vh.current === a2 && (E$1(uh), E$1(vh));
}
var L$1 = Uf(0);
function Ch(a2) {
  for (var b2 = a2; null !== b2; ) {
    if (13 === b2.tag) {
      var c2 = b2.memoizedState;
      if (null !== c2 && (c2 = c2.dehydrated, null === c2 || "$?" === c2.data || "$!" === c2.data)) return b2;
    } else if (19 === b2.tag && void 0 !== b2.memoizedProps.revealOrder) {
      if (0 !== (b2.flags & 128)) return b2;
    } else if (null !== b2.child) {
      b2.child.return = b2;
      b2 = b2.child;
      continue;
    }
    if (b2 === a2) break;
    for (; null === b2.sibling; ) {
      if (null === b2.return || b2.return === a2) return null;
      b2 = b2.return;
    }
    b2.sibling.return = b2.return;
    b2 = b2.sibling;
  }
  return null;
}
var Dh = [];
function Eh() {
  for (var a2 = 0; a2 < Dh.length; a2++) Dh[a2]._workInProgressVersionPrimary = null;
  Dh.length = 0;
}
var Fh = ua.ReactCurrentDispatcher, Gh = ua.ReactCurrentBatchConfig, Hh = 0, M$1 = null, N = null, O$1 = null, Ih = false, Jh = false, Kh = 0, Lh = 0;
function P$1() {
  throw Error(p$3(321));
}
function Mh(a2, b2) {
  if (null === b2) return false;
  for (var c2 = 0; c2 < b2.length && c2 < a2.length; c2++) if (!He(a2[c2], b2[c2])) return false;
  return true;
}
function Nh(a2, b2, c2, d2, e2, f2) {
  Hh = f2;
  M$1 = b2;
  b2.memoizedState = null;
  b2.updateQueue = null;
  b2.lanes = 0;
  Fh.current = null === a2 || null === a2.memoizedState ? Oh : Ph;
  a2 = c2(d2, e2);
  if (Jh) {
    f2 = 0;
    do {
      Jh = false;
      Kh = 0;
      if (25 <= f2) throw Error(p$3(301));
      f2 += 1;
      O$1 = N = null;
      b2.updateQueue = null;
      Fh.current = Qh;
      a2 = c2(d2, e2);
    } while (Jh);
  }
  Fh.current = Rh;
  b2 = null !== N && null !== N.next;
  Hh = 0;
  O$1 = N = M$1 = null;
  Ih = false;
  if (b2) throw Error(p$3(300));
  return a2;
}
function Sh() {
  var a2 = 0 !== Kh;
  Kh = 0;
  return a2;
}
function Th() {
  var a2 = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null };
  null === O$1 ? M$1.memoizedState = O$1 = a2 : O$1 = O$1.next = a2;
  return O$1;
}
function Uh() {
  if (null === N) {
    var a2 = M$1.alternate;
    a2 = null !== a2 ? a2.memoizedState : null;
  } else a2 = N.next;
  var b2 = null === O$1 ? M$1.memoizedState : O$1.next;
  if (null !== b2) O$1 = b2, N = a2;
  else {
    if (null === a2) throw Error(p$3(310));
    N = a2;
    a2 = { memoizedState: N.memoizedState, baseState: N.baseState, baseQueue: N.baseQueue, queue: N.queue, next: null };
    null === O$1 ? M$1.memoizedState = O$1 = a2 : O$1 = O$1.next = a2;
  }
  return O$1;
}
function Vh(a2, b2) {
  return "function" === typeof b2 ? b2(a2) : b2;
}
function Wh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = N, e2 = d2.baseQueue, f2 = c2.pending;
  if (null !== f2) {
    if (null !== e2) {
      var g2 = e2.next;
      e2.next = f2.next;
      f2.next = g2;
    }
    d2.baseQueue = e2 = f2;
    c2.pending = null;
  }
  if (null !== e2) {
    f2 = e2.next;
    d2 = d2.baseState;
    var h2 = g2 = null, k2 = null, l2 = f2;
    do {
      var m2 = l2.lane;
      if ((Hh & m2) === m2) null !== k2 && (k2 = k2.next = { lane: 0, action: l2.action, hasEagerState: l2.hasEagerState, eagerState: l2.eagerState, next: null }), d2 = l2.hasEagerState ? l2.eagerState : a2(d2, l2.action);
      else {
        var q2 = {
          lane: m2,
          action: l2.action,
          hasEagerState: l2.hasEagerState,
          eagerState: l2.eagerState,
          next: null
        };
        null === k2 ? (h2 = k2 = q2, g2 = d2) : k2 = k2.next = q2;
        M$1.lanes |= m2;
        rh |= m2;
      }
      l2 = l2.next;
    } while (null !== l2 && l2 !== f2);
    null === k2 ? g2 = d2 : k2.next = h2;
    He(d2, b2.memoizedState) || (dh = true);
    b2.memoizedState = d2;
    b2.baseState = g2;
    b2.baseQueue = k2;
    c2.lastRenderedState = d2;
  }
  a2 = c2.interleaved;
  if (null !== a2) {
    e2 = a2;
    do
      f2 = e2.lane, M$1.lanes |= f2, rh |= f2, e2 = e2.next;
    while (e2 !== a2);
  } else null === e2 && (c2.lanes = 0);
  return [b2.memoizedState, c2.dispatch];
}
function Xh(a2) {
  var b2 = Uh(), c2 = b2.queue;
  if (null === c2) throw Error(p$3(311));
  c2.lastRenderedReducer = a2;
  var d2 = c2.dispatch, e2 = c2.pending, f2 = b2.memoizedState;
  if (null !== e2) {
    c2.pending = null;
    var g2 = e2 = e2.next;
    do
      f2 = a2(f2, g2.action), g2 = g2.next;
    while (g2 !== e2);
    He(f2, b2.memoizedState) || (dh = true);
    b2.memoizedState = f2;
    null === b2.baseQueue && (b2.baseState = f2);
    c2.lastRenderedState = f2;
  }
  return [f2, d2];
}
function Yh() {
}
function Zh(a2, b2) {
  var c2 = M$1, d2 = Uh(), e2 = b2(), f2 = !He(d2.memoizedState, e2);
  f2 && (d2.memoizedState = e2, dh = true);
  d2 = d2.queue;
  $h(ai.bind(null, c2, d2, a2), [a2]);
  if (d2.getSnapshot !== b2 || f2 || null !== O$1 && O$1.memoizedState.tag & 1) {
    c2.flags |= 2048;
    bi(9, ci.bind(null, c2, d2, e2, b2), void 0, null);
    if (null === Q) throw Error(p$3(349));
    0 !== (Hh & 30) || di(c2, b2, e2);
  }
  return e2;
}
function di(a2, b2, c2) {
  a2.flags |= 16384;
  a2 = { getSnapshot: b2, value: c2 };
  b2 = M$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$1.updateQueue = b2, b2.stores = [a2]) : (c2 = b2.stores, null === c2 ? b2.stores = [a2] : c2.push(a2));
}
function ci(a2, b2, c2, d2) {
  b2.value = c2;
  b2.getSnapshot = d2;
  ei(b2) && fi(a2);
}
function ai(a2, b2, c2) {
  return c2(function() {
    ei(b2) && fi(a2);
  });
}
function ei(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var c2 = b2();
    return !He(a2, c2);
  } catch (d2) {
    return true;
  }
}
function fi(a2) {
  var b2 = ih(a2, 1);
  null !== b2 && gi(b2, a2, 1, -1);
}
function hi(a2) {
  var b2 = Th();
  "function" === typeof a2 && (a2 = a2());
  b2.memoizedState = b2.baseState = a2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: Vh, lastRenderedState: a2 };
  b2.queue = a2;
  a2 = a2.dispatch = ii.bind(null, M$1, a2);
  return [b2.memoizedState, a2];
}
function bi(a2, b2, c2, d2) {
  a2 = { tag: a2, create: b2, destroy: c2, deps: d2, next: null };
  b2 = M$1.updateQueue;
  null === b2 ? (b2 = { lastEffect: null, stores: null }, M$1.updateQueue = b2, b2.lastEffect = a2.next = a2) : (c2 = b2.lastEffect, null === c2 ? b2.lastEffect = a2.next = a2 : (d2 = c2.next, c2.next = a2, a2.next = d2, b2.lastEffect = a2));
  return a2;
}
function ji() {
  return Uh().memoizedState;
}
function ki(a2, b2, c2, d2) {
  var e2 = Th();
  M$1.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, void 0, void 0 === d2 ? null : d2);
}
function li(a2, b2, c2, d2) {
  var e2 = Uh();
  d2 = void 0 === d2 ? null : d2;
  var f2 = void 0;
  if (null !== N) {
    var g2 = N.memoizedState;
    f2 = g2.destroy;
    if (null !== d2 && Mh(d2, g2.deps)) {
      e2.memoizedState = bi(b2, c2, f2, d2);
      return;
    }
  }
  M$1.flags |= a2;
  e2.memoizedState = bi(1 | b2, c2, f2, d2);
}
function mi(a2, b2) {
  return ki(8390656, 8, a2, b2);
}
function $h(a2, b2) {
  return li(2048, 8, a2, b2);
}
function ni(a2, b2) {
  return li(4, 2, a2, b2);
}
function oi(a2, b2) {
  return li(4, 4, a2, b2);
}
function pi(a2, b2) {
  if ("function" === typeof b2) return a2 = a2(), b2(a2), function() {
    b2(null);
  };
  if (null !== b2 && void 0 !== b2) return a2 = a2(), b2.current = a2, function() {
    b2.current = null;
  };
}
function qi(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return li(4, 4, pi.bind(null, b2, a2), c2);
}
function ri() {
}
function si(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  c2.memoizedState = [a2, b2];
  return a2;
}
function ti(a2, b2) {
  var c2 = Uh();
  b2 = void 0 === b2 ? null : b2;
  var d2 = c2.memoizedState;
  if (null !== d2 && null !== b2 && Mh(b2, d2[1])) return d2[0];
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}
function ui(a2, b2, c2) {
  if (0 === (Hh & 21)) return a2.baseState && (a2.baseState = false, dh = true), a2.memoizedState = c2;
  He(c2, b2) || (c2 = yc(), M$1.lanes |= c2, rh |= c2, a2.baseState = true);
  return b2;
}
function vi(a2, b2) {
  var c2 = C$1;
  C$1 = 0 !== c2 && 4 > c2 ? c2 : 4;
  a2(true);
  var d2 = Gh.transition;
  Gh.transition = {};
  try {
    a2(false), b2();
  } finally {
    C$1 = c2, Gh.transition = d2;
  }
}
function wi() {
  return Uh().memoizedState;
}
function xi(a2, b2, c2) {
  var d2 = yi(a2);
  c2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2)) Ai(b2, c2);
  else if (c2 = hh(a2, b2, c2, d2), null !== c2) {
    var e2 = R$1();
    gi(c2, a2, d2, e2);
    Bi(c2, b2, d2);
  }
}
function ii(a2, b2, c2) {
  var d2 = yi(a2), e2 = { lane: d2, action: c2, hasEagerState: false, eagerState: null, next: null };
  if (zi(a2)) Ai(b2, e2);
  else {
    var f2 = a2.alternate;
    if (0 === a2.lanes && (null === f2 || 0 === f2.lanes) && (f2 = b2.lastRenderedReducer, null !== f2)) try {
      var g2 = b2.lastRenderedState, h2 = f2(g2, c2);
      e2.hasEagerState = true;
      e2.eagerState = h2;
      if (He(h2, g2)) {
        var k2 = b2.interleaved;
        null === k2 ? (e2.next = e2, gh(b2)) : (e2.next = k2.next, k2.next = e2);
        b2.interleaved = e2;
        return;
      }
    } catch (l2) {
    } finally {
    }
    c2 = hh(a2, b2, e2, d2);
    null !== c2 && (e2 = R$1(), gi(c2, a2, d2, e2), Bi(c2, b2, d2));
  }
}
function zi(a2) {
  var b2 = a2.alternate;
  return a2 === M$1 || null !== b2 && b2 === M$1;
}
function Ai(a2, b2) {
  Jh = Ih = true;
  var c2 = a2.pending;
  null === c2 ? b2.next = b2 : (b2.next = c2.next, c2.next = b2);
  a2.pending = b2;
}
function Bi(a2, b2, c2) {
  if (0 !== (c2 & 4194240)) {
    var d2 = b2.lanes;
    d2 &= a2.pendingLanes;
    c2 |= d2;
    b2.lanes = c2;
    Cc(a2, c2);
  }
}
var Rh = { readContext: eh, useCallback: P$1, useContext: P$1, useEffect: P$1, useImperativeHandle: P$1, useInsertionEffect: P$1, useLayoutEffect: P$1, useMemo: P$1, useReducer: P$1, useRef: P$1, useState: P$1, useDebugValue: P$1, useDeferredValue: P$1, useTransition: P$1, useMutableSource: P$1, useSyncExternalStore: P$1, useId: P$1, unstable_isNewReconciler: false }, Oh = { readContext: eh, useCallback: function(a2, b2) {
  Th().memoizedState = [a2, void 0 === b2 ? null : b2];
  return a2;
}, useContext: eh, useEffect: mi, useImperativeHandle: function(a2, b2, c2) {
  c2 = null !== c2 && void 0 !== c2 ? c2.concat([a2]) : null;
  return ki(
    4194308,
    4,
    pi.bind(null, b2, a2),
    c2
  );
}, useLayoutEffect: function(a2, b2) {
  return ki(4194308, 4, a2, b2);
}, useInsertionEffect: function(a2, b2) {
  return ki(4, 2, a2, b2);
}, useMemo: function(a2, b2) {
  var c2 = Th();
  b2 = void 0 === b2 ? null : b2;
  a2 = a2();
  c2.memoizedState = [a2, b2];
  return a2;
}, useReducer: function(a2, b2, c2) {
  var d2 = Th();
  b2 = void 0 !== c2 ? c2(b2) : b2;
  d2.memoizedState = d2.baseState = b2;
  a2 = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: a2, lastRenderedState: b2 };
  d2.queue = a2;
  a2 = a2.dispatch = xi.bind(null, M$1, a2);
  return [d2.memoizedState, a2];
}, useRef: function(a2) {
  var b2 = Th();
  a2 = { current: a2 };
  return b2.memoizedState = a2;
}, useState: hi, useDebugValue: ri, useDeferredValue: function(a2) {
  return Th().memoizedState = a2;
}, useTransition: function() {
  var a2 = hi(false), b2 = a2[0];
  a2 = vi.bind(null, a2[1]);
  Th().memoizedState = a2;
  return [b2, a2];
}, useMutableSource: function() {
}, useSyncExternalStore: function(a2, b2, c2) {
  var d2 = M$1, e2 = Th();
  if (I$1) {
    if (void 0 === c2) throw Error(p$3(407));
    c2 = c2();
  } else {
    c2 = b2();
    if (null === Q) throw Error(p$3(349));
    0 !== (Hh & 30) || di(d2, b2, c2);
  }
  e2.memoizedState = c2;
  var f2 = { value: c2, getSnapshot: b2 };
  e2.queue = f2;
  mi(ai.bind(
    null,
    d2,
    f2,
    a2
  ), [a2]);
  d2.flags |= 2048;
  bi(9, ci.bind(null, d2, f2, c2, b2), void 0, null);
  return c2;
}, useId: function() {
  var a2 = Th(), b2 = Q.identifierPrefix;
  if (I$1) {
    var c2 = sg;
    var d2 = rg;
    c2 = (d2 & ~(1 << 32 - oc(d2) - 1)).toString(32) + c2;
    b2 = ":" + b2 + "R" + c2;
    c2 = Kh++;
    0 < c2 && (b2 += "H" + c2.toString(32));
    b2 += ":";
  } else c2 = Lh++, b2 = ":" + b2 + "r" + c2.toString(32) + ":";
  return a2.memoizedState = b2;
}, unstable_isNewReconciler: false }, Ph = {
  readContext: eh,
  useCallback: si,
  useContext: eh,
  useEffect: $h,
  useImperativeHandle: qi,
  useInsertionEffect: ni,
  useLayoutEffect: oi,
  useMemo: ti,
  useReducer: Wh,
  useRef: ji,
  useState: function() {
    return Wh(Vh);
  },
  useDebugValue: ri,
  useDeferredValue: function(a2) {
    var b2 = Uh();
    return ui(b2, N.memoizedState, a2);
  },
  useTransition: function() {
    var a2 = Wh(Vh)[0], b2 = Uh().memoizedState;
    return [a2, b2];
  },
  useMutableSource: Yh,
  useSyncExternalStore: Zh,
  useId: wi,
  unstable_isNewReconciler: false
}, Qh = { readContext: eh, useCallback: si, useContext: eh, useEffect: $h, useImperativeHandle: qi, useInsertionEffect: ni, useLayoutEffect: oi, useMemo: ti, useReducer: Xh, useRef: ji, useState: function() {
  return Xh(Vh);
}, useDebugValue: ri, useDeferredValue: function(a2) {
  var b2 = Uh();
  return null === N ? b2.memoizedState = a2 : ui(b2, N.memoizedState, a2);
}, useTransition: function() {
  var a2 = Xh(Vh)[0], b2 = Uh().memoizedState;
  return [a2, b2];
}, useMutableSource: Yh, useSyncExternalStore: Zh, useId: wi, unstable_isNewReconciler: false };
function Ci(a2, b2) {
  if (a2 && a2.defaultProps) {
    b2 = A$1({}, b2);
    a2 = a2.defaultProps;
    for (var c2 in a2) void 0 === b2[c2] && (b2[c2] = a2[c2]);
    return b2;
  }
  return b2;
}
function Di(a2, b2, c2, d2) {
  b2 = a2.memoizedState;
  c2 = c2(d2, b2);
  c2 = null === c2 || void 0 === c2 ? b2 : A$1({}, b2, c2);
  a2.memoizedState = c2;
  0 === a2.lanes && (a2.updateQueue.baseState = c2);
}
var Ei = { isMounted: function(a2) {
  return (a2 = a2._reactInternals) ? Vb(a2) === a2 : false;
}, enqueueSetState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R$1(), e2 = yi(a2), f2 = mh(d2, e2);
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueReplaceState: function(a2, b2, c2) {
  a2 = a2._reactInternals;
  var d2 = R$1(), e2 = yi(a2), f2 = mh(d2, e2);
  f2.tag = 1;
  f2.payload = b2;
  void 0 !== c2 && null !== c2 && (f2.callback = c2);
  b2 = nh(a2, f2, e2);
  null !== b2 && (gi(b2, a2, e2, d2), oh(b2, a2, e2));
}, enqueueForceUpdate: function(a2, b2) {
  a2 = a2._reactInternals;
  var c2 = R$1(), d2 = yi(a2), e2 = mh(c2, d2);
  e2.tag = 2;
  void 0 !== b2 && null !== b2 && (e2.callback = b2);
  b2 = nh(a2, e2, d2);
  null !== b2 && (gi(b2, a2, d2, c2), oh(b2, a2, d2));
} };
function Fi(a2, b2, c2, d2, e2, f2, g2) {
  a2 = a2.stateNode;
  return "function" === typeof a2.shouldComponentUpdate ? a2.shouldComponentUpdate(d2, f2, g2) : b2.prototype && b2.prototype.isPureReactComponent ? !Ie(c2, d2) || !Ie(e2, f2) : true;
}
function Gi(a2, b2, c2) {
  var d2 = false, e2 = Vf;
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? f2 = eh(f2) : (e2 = Zf(b2) ? Xf : H.current, d2 = b2.contextTypes, f2 = (d2 = null !== d2 && void 0 !== d2) ? Yf(a2, e2) : Vf);
  b2 = new b2(c2, f2);
  a2.memoizedState = null !== b2.state && void 0 !== b2.state ? b2.state : null;
  b2.updater = Ei;
  a2.stateNode = b2;
  b2._reactInternals = a2;
  d2 && (a2 = a2.stateNode, a2.__reactInternalMemoizedUnmaskedChildContext = e2, a2.__reactInternalMemoizedMaskedChildContext = f2);
  return b2;
}
function Hi(a2, b2, c2, d2) {
  a2 = b2.state;
  "function" === typeof b2.componentWillReceiveProps && b2.componentWillReceiveProps(c2, d2);
  "function" === typeof b2.UNSAFE_componentWillReceiveProps && b2.UNSAFE_componentWillReceiveProps(c2, d2);
  b2.state !== a2 && Ei.enqueueReplaceState(b2, b2.state, null);
}
function Ii(a2, b2, c2, d2) {
  var e2 = a2.stateNode;
  e2.props = c2;
  e2.state = a2.memoizedState;
  e2.refs = {};
  kh(a2);
  var f2 = b2.contextType;
  "object" === typeof f2 && null !== f2 ? e2.context = eh(f2) : (f2 = Zf(b2) ? Xf : H.current, e2.context = Yf(a2, f2));
  e2.state = a2.memoizedState;
  f2 = b2.getDerivedStateFromProps;
  "function" === typeof f2 && (Di(a2, b2, f2, c2), e2.state = a2.memoizedState);
  "function" === typeof b2.getDerivedStateFromProps || "function" === typeof e2.getSnapshotBeforeUpdate || "function" !== typeof e2.UNSAFE_componentWillMount && "function" !== typeof e2.componentWillMount || (b2 = e2.state, "function" === typeof e2.componentWillMount && e2.componentWillMount(), "function" === typeof e2.UNSAFE_componentWillMount && e2.UNSAFE_componentWillMount(), b2 !== e2.state && Ei.enqueueReplaceState(e2, e2.state, null), qh(a2, c2, e2, d2), e2.state = a2.memoizedState);
  "function" === typeof e2.componentDidMount && (a2.flags |= 4194308);
}
function Ji(a2, b2) {
  try {
    var c2 = "", d2 = b2;
    do
      c2 += Pa(d2), d2 = d2.return;
    while (d2);
    var e2 = c2;
  } catch (f2) {
    e2 = "\nError generating stack: " + f2.message + "\n" + f2.stack;
  }
  return { value: a2, source: b2, stack: e2, digest: null };
}
function Ki(a2, b2, c2) {
  return { value: a2, source: null, stack: null != c2 ? c2 : null, digest: null != b2 ? b2 : null };
}
function Li(a2, b2) {
  try {
    console.error(b2.value);
  } catch (c2) {
    setTimeout(function() {
      throw c2;
    });
  }
}
var Mi = "function" === typeof WeakMap ? WeakMap : Map;
function Ni(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  c2.payload = { element: null };
  var d2 = b2.value;
  c2.callback = function() {
    Oi || (Oi = true, Pi = d2);
    Li(a2, b2);
  };
  return c2;
}
function Qi(a2, b2, c2) {
  c2 = mh(-1, c2);
  c2.tag = 3;
  var d2 = a2.type.getDerivedStateFromError;
  if ("function" === typeof d2) {
    var e2 = b2.value;
    c2.payload = function() {
      return d2(e2);
    };
    c2.callback = function() {
      Li(a2, b2);
    };
  }
  var f2 = a2.stateNode;
  null !== f2 && "function" === typeof f2.componentDidCatch && (c2.callback = function() {
    Li(a2, b2);
    "function" !== typeof d2 && (null === Ri ? Ri = /* @__PURE__ */ new Set([this]) : Ri.add(this));
    var c3 = b2.stack;
    this.componentDidCatch(b2.value, { componentStack: null !== c3 ? c3 : "" });
  });
  return c2;
}
function Si(a2, b2, c2) {
  var d2 = a2.pingCache;
  if (null === d2) {
    d2 = a2.pingCache = new Mi();
    var e2 = /* @__PURE__ */ new Set();
    d2.set(b2, e2);
  } else e2 = d2.get(b2), void 0 === e2 && (e2 = /* @__PURE__ */ new Set(), d2.set(b2, e2));
  e2.has(c2) || (e2.add(c2), a2 = Ti.bind(null, a2, b2, c2), b2.then(a2, a2));
}
function Ui(a2) {
  do {
    var b2;
    if (b2 = 13 === a2.tag) b2 = a2.memoizedState, b2 = null !== b2 ? null !== b2.dehydrated ? true : false : true;
    if (b2) return a2;
    a2 = a2.return;
  } while (null !== a2);
  return null;
}
function Vi(a2, b2, c2, d2, e2) {
  if (0 === (a2.mode & 1)) return a2 === b2 ? a2.flags |= 65536 : (a2.flags |= 128, c2.flags |= 131072, c2.flags &= -52805, 1 === c2.tag && (null === c2.alternate ? c2.tag = 17 : (b2 = mh(-1, 1), b2.tag = 2, nh(c2, b2, 1))), c2.lanes |= 1), a2;
  a2.flags |= 65536;
  a2.lanes = e2;
  return a2;
}
var Wi = ua.ReactCurrentOwner, dh = false;
function Xi(a2, b2, c2, d2) {
  b2.child = null === a2 ? Vg(b2, null, c2, d2) : Ug(b2, a2.child, c2, d2);
}
function Yi(a2, b2, c2, d2, e2) {
  c2 = c2.render;
  var f2 = b2.ref;
  ch(b2, e2);
  d2 = Nh(a2, b2, c2, d2, f2, e2);
  c2 = Sh();
  if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I$1 && c2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, d2, e2);
  return b2.child;
}
function $i(a2, b2, c2, d2, e2) {
  if (null === a2) {
    var f2 = c2.type;
    if ("function" === typeof f2 && !aj(f2) && void 0 === f2.defaultProps && null === c2.compare && void 0 === c2.defaultProps) return b2.tag = 15, b2.type = f2, bj(a2, b2, f2, d2, e2);
    a2 = Rg(c2.type, null, d2, b2, b2.mode, e2);
    a2.ref = b2.ref;
    a2.return = b2;
    return b2.child = a2;
  }
  f2 = a2.child;
  if (0 === (a2.lanes & e2)) {
    var g2 = f2.memoizedProps;
    c2 = c2.compare;
    c2 = null !== c2 ? c2 : Ie;
    if (c2(g2, d2) && a2.ref === b2.ref) return Zi(a2, b2, e2);
  }
  b2.flags |= 1;
  a2 = Pg(f2, d2);
  a2.ref = b2.ref;
  a2.return = b2;
  return b2.child = a2;
}
function bj(a2, b2, c2, d2, e2) {
  if (null !== a2) {
    var f2 = a2.memoizedProps;
    if (Ie(f2, d2) && a2.ref === b2.ref) if (dh = false, b2.pendingProps = d2 = f2, 0 !== (a2.lanes & e2)) 0 !== (a2.flags & 131072) && (dh = true);
    else return b2.lanes = a2.lanes, Zi(a2, b2, e2);
  }
  return cj(a2, b2, c2, d2, e2);
}
function dj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.children, f2 = null !== a2 ? a2.memoizedState : null;
  if ("hidden" === d2.mode) if (0 === (b2.mode & 1)) b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, G(ej, fj), fj |= c2;
  else {
    if (0 === (c2 & 1073741824)) return a2 = null !== f2 ? f2.baseLanes | c2 : c2, b2.lanes = b2.childLanes = 1073741824, b2.memoizedState = { baseLanes: a2, cachePool: null, transitions: null }, b2.updateQueue = null, G(ej, fj), fj |= a2, null;
    b2.memoizedState = { baseLanes: 0, cachePool: null, transitions: null };
    d2 = null !== f2 ? f2.baseLanes : c2;
    G(ej, fj);
    fj |= d2;
  }
  else null !== f2 ? (d2 = f2.baseLanes | c2, b2.memoizedState = null) : d2 = c2, G(ej, fj), fj |= d2;
  Xi(a2, b2, e2, c2);
  return b2.child;
}
function gj(a2, b2) {
  var c2 = b2.ref;
  if (null === a2 && null !== c2 || null !== a2 && a2.ref !== c2) b2.flags |= 512, b2.flags |= 2097152;
}
function cj(a2, b2, c2, d2, e2) {
  var f2 = Zf(c2) ? Xf : H.current;
  f2 = Yf(b2, f2);
  ch(b2, e2);
  c2 = Nh(a2, b2, c2, d2, f2, e2);
  d2 = Sh();
  if (null !== a2 && !dh) return b2.updateQueue = a2.updateQueue, b2.flags &= -2053, a2.lanes &= ~e2, Zi(a2, b2, e2);
  I$1 && d2 && vg(b2);
  b2.flags |= 1;
  Xi(a2, b2, c2, e2);
  return b2.child;
}
function hj(a2, b2, c2, d2, e2) {
  if (Zf(c2)) {
    var f2 = true;
    cg(b2);
  } else f2 = false;
  ch(b2, e2);
  if (null === b2.stateNode) ij(a2, b2), Gi(b2, c2, d2), Ii(b2, c2, d2, e2), d2 = true;
  else if (null === a2) {
    var g2 = b2.stateNode, h2 = b2.memoizedProps;
    g2.props = h2;
    var k2 = g2.context, l2 = c2.contextType;
    "object" === typeof l2 && null !== l2 ? l2 = eh(l2) : (l2 = Zf(c2) ? Xf : H.current, l2 = Yf(b2, l2));
    var m2 = c2.getDerivedStateFromProps, q2 = "function" === typeof m2 || "function" === typeof g2.getSnapshotBeforeUpdate;
    q2 || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== d2 || k2 !== l2) && Hi(b2, g2, d2, l2);
    jh = false;
    var r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    k2 = b2.memoizedState;
    h2 !== d2 || r2 !== k2 || Wf.current || jh ? ("function" === typeof m2 && (Di(b2, c2, m2, d2), k2 = b2.memoizedState), (h2 = jh || Fi(b2, c2, h2, d2, r2, k2, l2)) ? (q2 || "function" !== typeof g2.UNSAFE_componentWillMount && "function" !== typeof g2.componentWillMount || ("function" === typeof g2.componentWillMount && g2.componentWillMount(), "function" === typeof g2.UNSAFE_componentWillMount && g2.UNSAFE_componentWillMount()), "function" === typeof g2.componentDidMount && (b2.flags |= 4194308)) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), b2.memoizedProps = d2, b2.memoizedState = k2), g2.props = d2, g2.state = k2, g2.context = l2, d2 = h2) : ("function" === typeof g2.componentDidMount && (b2.flags |= 4194308), d2 = false);
  } else {
    g2 = b2.stateNode;
    lh(a2, b2);
    h2 = b2.memoizedProps;
    l2 = b2.type === b2.elementType ? h2 : Ci(b2.type, h2);
    g2.props = l2;
    q2 = b2.pendingProps;
    r2 = g2.context;
    k2 = c2.contextType;
    "object" === typeof k2 && null !== k2 ? k2 = eh(k2) : (k2 = Zf(c2) ? Xf : H.current, k2 = Yf(b2, k2));
    var y2 = c2.getDerivedStateFromProps;
    (m2 = "function" === typeof y2 || "function" === typeof g2.getSnapshotBeforeUpdate) || "function" !== typeof g2.UNSAFE_componentWillReceiveProps && "function" !== typeof g2.componentWillReceiveProps || (h2 !== q2 || r2 !== k2) && Hi(b2, g2, d2, k2);
    jh = false;
    r2 = b2.memoizedState;
    g2.state = r2;
    qh(b2, d2, g2, e2);
    var n2 = b2.memoizedState;
    h2 !== q2 || r2 !== n2 || Wf.current || jh ? ("function" === typeof y2 && (Di(b2, c2, y2, d2), n2 = b2.memoizedState), (l2 = jh || Fi(b2, c2, l2, d2, r2, n2, k2) || false) ? (m2 || "function" !== typeof g2.UNSAFE_componentWillUpdate && "function" !== typeof g2.componentWillUpdate || ("function" === typeof g2.componentWillUpdate && g2.componentWillUpdate(d2, n2, k2), "function" === typeof g2.UNSAFE_componentWillUpdate && g2.UNSAFE_componentWillUpdate(d2, n2, k2)), "function" === typeof g2.componentDidUpdate && (b2.flags |= 4), "function" === typeof g2.getSnapshotBeforeUpdate && (b2.flags |= 1024)) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), b2.memoizedProps = d2, b2.memoizedState = n2), g2.props = d2, g2.state = n2, g2.context = k2, d2 = l2) : ("function" !== typeof g2.componentDidUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 4), "function" !== typeof g2.getSnapshotBeforeUpdate || h2 === a2.memoizedProps && r2 === a2.memoizedState || (b2.flags |= 1024), d2 = false);
  }
  return jj(a2, b2, c2, d2, f2, e2);
}
function jj(a2, b2, c2, d2, e2, f2) {
  gj(a2, b2);
  var g2 = 0 !== (b2.flags & 128);
  if (!d2 && !g2) return e2 && dg(b2, c2, false), Zi(a2, b2, f2);
  d2 = b2.stateNode;
  Wi.current = b2;
  var h2 = g2 && "function" !== typeof c2.getDerivedStateFromError ? null : d2.render();
  b2.flags |= 1;
  null !== a2 && g2 ? (b2.child = Ug(b2, a2.child, null, f2), b2.child = Ug(b2, null, h2, f2)) : Xi(a2, b2, h2, f2);
  b2.memoizedState = d2.state;
  e2 && dg(b2, c2, true);
  return b2.child;
}
function kj(a2) {
  var b2 = a2.stateNode;
  b2.pendingContext ? ag(a2, b2.pendingContext, b2.pendingContext !== b2.context) : b2.context && ag(a2, b2.context, false);
  yh(a2, b2.containerInfo);
}
function lj(a2, b2, c2, d2, e2) {
  Ig();
  Jg(e2);
  b2.flags |= 256;
  Xi(a2, b2, c2, d2);
  return b2.child;
}
var mj = { dehydrated: null, treeContext: null, retryLane: 0 };
function nj(a2) {
  return { baseLanes: a2, cachePool: null, transitions: null };
}
function oj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = L$1.current, f2 = false, g2 = 0 !== (b2.flags & 128), h2;
  (h2 = g2) || (h2 = null !== a2 && null === a2.memoizedState ? false : 0 !== (e2 & 2));
  if (h2) f2 = true, b2.flags &= -129;
  else if (null === a2 || null !== a2.memoizedState) e2 |= 1;
  G(L$1, e2 & 1);
  if (null === a2) {
    Eg(b2);
    a2 = b2.memoizedState;
    if (null !== a2 && (a2 = a2.dehydrated, null !== a2)) return 0 === (b2.mode & 1) ? b2.lanes = 1 : "$!" === a2.data ? b2.lanes = 8 : b2.lanes = 1073741824, null;
    g2 = d2.children;
    a2 = d2.fallback;
    return f2 ? (d2 = b2.mode, f2 = b2.child, g2 = { mode: "hidden", children: g2 }, 0 === (d2 & 1) && null !== f2 ? (f2.childLanes = 0, f2.pendingProps = g2) : f2 = pj(g2, d2, 0, null), a2 = Tg(a2, d2, c2, null), f2.return = b2, a2.return = b2, f2.sibling = a2, b2.child = f2, b2.child.memoizedState = nj(c2), b2.memoizedState = mj, a2) : qj(b2, g2);
  }
  e2 = a2.memoizedState;
  if (null !== e2 && (h2 = e2.dehydrated, null !== h2)) return rj(a2, b2, g2, d2, h2, e2, c2);
  if (f2) {
    f2 = d2.fallback;
    g2 = b2.mode;
    e2 = a2.child;
    h2 = e2.sibling;
    var k2 = { mode: "hidden", children: d2.children };
    0 === (g2 & 1) && b2.child !== e2 ? (d2 = b2.child, d2.childLanes = 0, d2.pendingProps = k2, b2.deletions = null) : (d2 = Pg(e2, k2), d2.subtreeFlags = e2.subtreeFlags & 14680064);
    null !== h2 ? f2 = Pg(h2, f2) : (f2 = Tg(f2, g2, c2, null), f2.flags |= 2);
    f2.return = b2;
    d2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    d2 = f2;
    f2 = b2.child;
    g2 = a2.child.memoizedState;
    g2 = null === g2 ? nj(c2) : { baseLanes: g2.baseLanes | c2, cachePool: null, transitions: g2.transitions };
    f2.memoizedState = g2;
    f2.childLanes = a2.childLanes & ~c2;
    b2.memoizedState = mj;
    return d2;
  }
  f2 = a2.child;
  a2 = f2.sibling;
  d2 = Pg(f2, { mode: "visible", children: d2.children });
  0 === (b2.mode & 1) && (d2.lanes = c2);
  d2.return = b2;
  d2.sibling = null;
  null !== a2 && (c2 = b2.deletions, null === c2 ? (b2.deletions = [a2], b2.flags |= 16) : c2.push(a2));
  b2.child = d2;
  b2.memoizedState = null;
  return d2;
}
function qj(a2, b2) {
  b2 = pj({ mode: "visible", children: b2 }, a2.mode, 0, null);
  b2.return = a2;
  return a2.child = b2;
}
function sj(a2, b2, c2, d2) {
  null !== d2 && Jg(d2);
  Ug(b2, a2.child, null, c2);
  a2 = qj(b2, b2.pendingProps.children);
  a2.flags |= 2;
  b2.memoizedState = null;
  return a2;
}
function rj(a2, b2, c2, d2, e2, f2, g2) {
  if (c2) {
    if (b2.flags & 256) return b2.flags &= -257, d2 = Ki(Error(p$3(422))), sj(a2, b2, g2, d2);
    if (null !== b2.memoizedState) return b2.child = a2.child, b2.flags |= 128, null;
    f2 = d2.fallback;
    e2 = b2.mode;
    d2 = pj({ mode: "visible", children: d2.children }, e2, 0, null);
    f2 = Tg(f2, e2, g2, null);
    f2.flags |= 2;
    d2.return = b2;
    f2.return = b2;
    d2.sibling = f2;
    b2.child = d2;
    0 !== (b2.mode & 1) && Ug(b2, a2.child, null, g2);
    b2.child.memoizedState = nj(g2);
    b2.memoizedState = mj;
    return f2;
  }
  if (0 === (b2.mode & 1)) return sj(a2, b2, g2, null);
  if ("$!" === e2.data) {
    d2 = e2.nextSibling && e2.nextSibling.dataset;
    if (d2) var h2 = d2.dgst;
    d2 = h2;
    f2 = Error(p$3(419));
    d2 = Ki(f2, d2, void 0);
    return sj(a2, b2, g2, d2);
  }
  h2 = 0 !== (g2 & a2.childLanes);
  if (dh || h2) {
    d2 = Q;
    if (null !== d2) {
      switch (g2 & -g2) {
        case 4:
          e2 = 2;
          break;
        case 16:
          e2 = 8;
          break;
        case 64:
        case 128:
        case 256:
        case 512:
        case 1024:
        case 2048:
        case 4096:
        case 8192:
        case 16384:
        case 32768:
        case 65536:
        case 131072:
        case 262144:
        case 524288:
        case 1048576:
        case 2097152:
        case 4194304:
        case 8388608:
        case 16777216:
        case 33554432:
        case 67108864:
          e2 = 32;
          break;
        case 536870912:
          e2 = 268435456;
          break;
        default:
          e2 = 0;
      }
      e2 = 0 !== (e2 & (d2.suspendedLanes | g2)) ? 0 : e2;
      0 !== e2 && e2 !== f2.retryLane && (f2.retryLane = e2, ih(a2, e2), gi(d2, a2, e2, -1));
    }
    tj();
    d2 = Ki(Error(p$3(421)));
    return sj(a2, b2, g2, d2);
  }
  if ("$?" === e2.data) return b2.flags |= 128, b2.child = a2.child, b2 = uj.bind(null, a2), e2._reactRetry = b2, null;
  a2 = f2.treeContext;
  yg = Lf(e2.nextSibling);
  xg = b2;
  I$1 = true;
  zg = null;
  null !== a2 && (og[pg++] = rg, og[pg++] = sg, og[pg++] = qg, rg = a2.id, sg = a2.overflow, qg = b2);
  b2 = qj(b2, d2.children);
  b2.flags |= 4096;
  return b2;
}
function vj(a2, b2, c2) {
  a2.lanes |= b2;
  var d2 = a2.alternate;
  null !== d2 && (d2.lanes |= b2);
  bh(a2.return, b2, c2);
}
function wj(a2, b2, c2, d2, e2) {
  var f2 = a2.memoizedState;
  null === f2 ? a2.memoizedState = { isBackwards: b2, rendering: null, renderingStartTime: 0, last: d2, tail: c2, tailMode: e2 } : (f2.isBackwards = b2, f2.rendering = null, f2.renderingStartTime = 0, f2.last = d2, f2.tail = c2, f2.tailMode = e2);
}
function xj(a2, b2, c2) {
  var d2 = b2.pendingProps, e2 = d2.revealOrder, f2 = d2.tail;
  Xi(a2, b2, d2.children, c2);
  d2 = L$1.current;
  if (0 !== (d2 & 2)) d2 = d2 & 1 | 2, b2.flags |= 128;
  else {
    if (null !== a2 && 0 !== (a2.flags & 128)) a: for (a2 = b2.child; null !== a2; ) {
      if (13 === a2.tag) null !== a2.memoizedState && vj(a2, c2, b2);
      else if (19 === a2.tag) vj(a2, c2, b2);
      else if (null !== a2.child) {
        a2.child.return = a2;
        a2 = a2.child;
        continue;
      }
      if (a2 === b2) break a;
      for (; null === a2.sibling; ) {
        if (null === a2.return || a2.return === b2) break a;
        a2 = a2.return;
      }
      a2.sibling.return = a2.return;
      a2 = a2.sibling;
    }
    d2 &= 1;
  }
  G(L$1, d2);
  if (0 === (b2.mode & 1)) b2.memoizedState = null;
  else switch (e2) {
    case "forwards":
      c2 = b2.child;
      for (e2 = null; null !== c2; ) a2 = c2.alternate, null !== a2 && null === Ch(a2) && (e2 = c2), c2 = c2.sibling;
      c2 = e2;
      null === c2 ? (e2 = b2.child, b2.child = null) : (e2 = c2.sibling, c2.sibling = null);
      wj(b2, false, e2, c2, f2);
      break;
    case "backwards":
      c2 = null;
      e2 = b2.child;
      for (b2.child = null; null !== e2; ) {
        a2 = e2.alternate;
        if (null !== a2 && null === Ch(a2)) {
          b2.child = e2;
          break;
        }
        a2 = e2.sibling;
        e2.sibling = c2;
        c2 = e2;
        e2 = a2;
      }
      wj(b2, true, c2, null, f2);
      break;
    case "together":
      wj(b2, false, null, null, void 0);
      break;
    default:
      b2.memoizedState = null;
  }
  return b2.child;
}
function ij(a2, b2) {
  0 === (b2.mode & 1) && null !== a2 && (a2.alternate = null, b2.alternate = null, b2.flags |= 2);
}
function Zi(a2, b2, c2) {
  null !== a2 && (b2.dependencies = a2.dependencies);
  rh |= b2.lanes;
  if (0 === (c2 & b2.childLanes)) return null;
  if (null !== a2 && b2.child !== a2.child) throw Error(p$3(153));
  if (null !== b2.child) {
    a2 = b2.child;
    c2 = Pg(a2, a2.pendingProps);
    b2.child = c2;
    for (c2.return = b2; null !== a2.sibling; ) a2 = a2.sibling, c2 = c2.sibling = Pg(a2, a2.pendingProps), c2.return = b2;
    c2.sibling = null;
  }
  return b2.child;
}
function yj(a2, b2, c2) {
  switch (b2.tag) {
    case 3:
      kj(b2);
      Ig();
      break;
    case 5:
      Ah(b2);
      break;
    case 1:
      Zf(b2.type) && cg(b2);
      break;
    case 4:
      yh(b2, b2.stateNode.containerInfo);
      break;
    case 10:
      var d2 = b2.type._context, e2 = b2.memoizedProps.value;
      G(Wg, d2._currentValue);
      d2._currentValue = e2;
      break;
    case 13:
      d2 = b2.memoizedState;
      if (null !== d2) {
        if (null !== d2.dehydrated) return G(L$1, L$1.current & 1), b2.flags |= 128, null;
        if (0 !== (c2 & b2.child.childLanes)) return oj(a2, b2, c2);
        G(L$1, L$1.current & 1);
        a2 = Zi(a2, b2, c2);
        return null !== a2 ? a2.sibling : null;
      }
      G(L$1, L$1.current & 1);
      break;
    case 19:
      d2 = 0 !== (c2 & b2.childLanes);
      if (0 !== (a2.flags & 128)) {
        if (d2) return xj(a2, b2, c2);
        b2.flags |= 128;
      }
      e2 = b2.memoizedState;
      null !== e2 && (e2.rendering = null, e2.tail = null, e2.lastEffect = null);
      G(L$1, L$1.current);
      if (d2) break;
      else return null;
    case 22:
    case 23:
      return b2.lanes = 0, dj(a2, b2, c2);
  }
  return Zi(a2, b2, c2);
}
var zj, Aj, Bj, Cj;
zj = function(a2, b2) {
  for (var c2 = b2.child; null !== c2; ) {
    if (5 === c2.tag || 6 === c2.tag) a2.appendChild(c2.stateNode);
    else if (4 !== c2.tag && null !== c2.child) {
      c2.child.return = c2;
      c2 = c2.child;
      continue;
    }
    if (c2 === b2) break;
    for (; null === c2.sibling; ) {
      if (null === c2.return || c2.return === b2) return;
      c2 = c2.return;
    }
    c2.sibling.return = c2.return;
    c2 = c2.sibling;
  }
};
Aj = function() {
};
Bj = function(a2, b2, c2, d2) {
  var e2 = a2.memoizedProps;
  if (e2 !== d2) {
    a2 = b2.stateNode;
    xh(uh.current);
    var f2 = null;
    switch (c2) {
      case "input":
        e2 = Ya(a2, e2);
        d2 = Ya(a2, d2);
        f2 = [];
        break;
      case "select":
        e2 = A$1({}, e2, { value: void 0 });
        d2 = A$1({}, d2, { value: void 0 });
        f2 = [];
        break;
      case "textarea":
        e2 = gb(a2, e2);
        d2 = gb(a2, d2);
        f2 = [];
        break;
      default:
        "function" !== typeof e2.onClick && "function" === typeof d2.onClick && (a2.onclick = Bf);
    }
    ub(c2, d2);
    var g2;
    c2 = null;
    for (l2 in e2) if (!d2.hasOwnProperty(l2) && e2.hasOwnProperty(l2) && null != e2[l2]) if ("style" === l2) {
      var h2 = e2[l2];
      for (g2 in h2) h2.hasOwnProperty(g2) && (c2 || (c2 = {}), c2[g2] = "");
    } else "dangerouslySetInnerHTML" !== l2 && "children" !== l2 && "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && "autoFocus" !== l2 && (ea.hasOwnProperty(l2) ? f2 || (f2 = []) : (f2 = f2 || []).push(l2, null));
    for (l2 in d2) {
      var k2 = d2[l2];
      h2 = null != e2 ? e2[l2] : void 0;
      if (d2.hasOwnProperty(l2) && k2 !== h2 && (null != k2 || null != h2)) if ("style" === l2) if (h2) {
        for (g2 in h2) !h2.hasOwnProperty(g2) || k2 && k2.hasOwnProperty(g2) || (c2 || (c2 = {}), c2[g2] = "");
        for (g2 in k2) k2.hasOwnProperty(g2) && h2[g2] !== k2[g2] && (c2 || (c2 = {}), c2[g2] = k2[g2]);
      } else c2 || (f2 || (f2 = []), f2.push(
        l2,
        c2
      )), c2 = k2;
      else "dangerouslySetInnerHTML" === l2 ? (k2 = k2 ? k2.__html : void 0, h2 = h2 ? h2.__html : void 0, null != k2 && h2 !== k2 && (f2 = f2 || []).push(l2, k2)) : "children" === l2 ? "string" !== typeof k2 && "number" !== typeof k2 || (f2 = f2 || []).push(l2, "" + k2) : "suppressContentEditableWarning" !== l2 && "suppressHydrationWarning" !== l2 && (ea.hasOwnProperty(l2) ? (null != k2 && "onScroll" === l2 && D$1("scroll", a2), f2 || h2 === k2 || (f2 = [])) : (f2 = f2 || []).push(l2, k2));
    }
    c2 && (f2 = f2 || []).push("style", c2);
    var l2 = f2;
    if (b2.updateQueue = l2) b2.flags |= 4;
  }
};
Cj = function(a2, b2, c2, d2) {
  c2 !== d2 && (b2.flags |= 4);
};
function Dj(a2, b2) {
  if (!I$1) switch (a2.tailMode) {
    case "hidden":
      b2 = a2.tail;
      for (var c2 = null; null !== b2; ) null !== b2.alternate && (c2 = b2), b2 = b2.sibling;
      null === c2 ? a2.tail = null : c2.sibling = null;
      break;
    case "collapsed":
      c2 = a2.tail;
      for (var d2 = null; null !== c2; ) null !== c2.alternate && (d2 = c2), c2 = c2.sibling;
      null === d2 ? b2 || null === a2.tail ? a2.tail = null : a2.tail.sibling = null : d2.sibling = null;
  }
}
function S$1(a2) {
  var b2 = null !== a2.alternate && a2.alternate.child === a2.child, c2 = 0, d2 = 0;
  if (b2) for (var e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags & 14680064, d2 |= e2.flags & 14680064, e2.return = a2, e2 = e2.sibling;
  else for (e2 = a2.child; null !== e2; ) c2 |= e2.lanes | e2.childLanes, d2 |= e2.subtreeFlags, d2 |= e2.flags, e2.return = a2, e2 = e2.sibling;
  a2.subtreeFlags |= d2;
  a2.childLanes = c2;
  return b2;
}
function Ej(a2, b2, c2) {
  var d2 = b2.pendingProps;
  wg(b2);
  switch (b2.tag) {
    case 2:
    case 16:
    case 15:
    case 0:
    case 11:
    case 7:
    case 8:
    case 12:
    case 9:
    case 14:
      return S$1(b2), null;
    case 1:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 3:
      d2 = b2.stateNode;
      zh();
      E$1(Wf);
      E$1(H);
      Eh();
      d2.pendingContext && (d2.context = d2.pendingContext, d2.pendingContext = null);
      if (null === a2 || null === a2.child) Gg(b2) ? b2.flags |= 4 : null === a2 || a2.memoizedState.isDehydrated && 0 === (b2.flags & 256) || (b2.flags |= 1024, null !== zg && (Fj(zg), zg = null));
      Aj(a2, b2);
      S$1(b2);
      return null;
    case 5:
      Bh(b2);
      var e2 = xh(wh.current);
      c2 = b2.type;
      if (null !== a2 && null != b2.stateNode) Bj(a2, b2, c2, d2, e2), a2.ref !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      else {
        if (!d2) {
          if (null === b2.stateNode) throw Error(p$3(166));
          S$1(b2);
          return null;
        }
        a2 = xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.type;
          var f2 = b2.memoizedProps;
          d2[Of] = b2;
          d2[Pf] = f2;
          a2 = 0 !== (b2.mode & 1);
          switch (c2) {
            case "dialog":
              D$1("cancel", d2);
              D$1("close", d2);
              break;
            case "iframe":
            case "object":
            case "embed":
              D$1("load", d2);
              break;
            case "video":
            case "audio":
              for (e2 = 0; e2 < lf.length; e2++) D$1(lf[e2], d2);
              break;
            case "source":
              D$1("error", d2);
              break;
            case "img":
            case "image":
            case "link":
              D$1(
                "error",
                d2
              );
              D$1("load", d2);
              break;
            case "details":
              D$1("toggle", d2);
              break;
            case "input":
              Za(d2, f2);
              D$1("invalid", d2);
              break;
            case "select":
              d2._wrapperState = { wasMultiple: !!f2.multiple };
              D$1("invalid", d2);
              break;
            case "textarea":
              hb(d2, f2), D$1("invalid", d2);
          }
          ub(c2, f2);
          e2 = null;
          for (var g2 in f2) if (f2.hasOwnProperty(g2)) {
            var h2 = f2[g2];
            "children" === g2 ? "string" === typeof h2 ? d2.textContent !== h2 && (true !== f2.suppressHydrationWarning && Af(d2.textContent, h2, a2), e2 = ["children", h2]) : "number" === typeof h2 && d2.textContent !== "" + h2 && (true !== f2.suppressHydrationWarning && Af(
              d2.textContent,
              h2,
              a2
            ), e2 = ["children", "" + h2]) : ea.hasOwnProperty(g2) && null != h2 && "onScroll" === g2 && D$1("scroll", d2);
          }
          switch (c2) {
            case "input":
              Va(d2);
              db(d2, f2, true);
              break;
            case "textarea":
              Va(d2);
              jb(d2);
              break;
            case "select":
            case "option":
              break;
            default:
              "function" === typeof f2.onClick && (d2.onclick = Bf);
          }
          d2 = e2;
          b2.updateQueue = d2;
          null !== d2 && (b2.flags |= 4);
        } else {
          g2 = 9 === e2.nodeType ? e2 : e2.ownerDocument;
          "http://www.w3.org/1999/xhtml" === a2 && (a2 = kb(c2));
          "http://www.w3.org/1999/xhtml" === a2 ? "script" === c2 ? (a2 = g2.createElement("div"), a2.innerHTML = "<script><\/script>", a2 = a2.removeChild(a2.firstChild)) : "string" === typeof d2.is ? a2 = g2.createElement(c2, { is: d2.is }) : (a2 = g2.createElement(c2), "select" === c2 && (g2 = a2, d2.multiple ? g2.multiple = true : d2.size && (g2.size = d2.size))) : a2 = g2.createElementNS(a2, c2);
          a2[Of] = b2;
          a2[Pf] = d2;
          zj(a2, b2, false, false);
          b2.stateNode = a2;
          a: {
            g2 = vb(c2, d2);
            switch (c2) {
              case "dialog":
                D$1("cancel", a2);
                D$1("close", a2);
                e2 = d2;
                break;
              case "iframe":
              case "object":
              case "embed":
                D$1("load", a2);
                e2 = d2;
                break;
              case "video":
              case "audio":
                for (e2 = 0; e2 < lf.length; e2++) D$1(lf[e2], a2);
                e2 = d2;
                break;
              case "source":
                D$1("error", a2);
                e2 = d2;
                break;
              case "img":
              case "image":
              case "link":
                D$1(
                  "error",
                  a2
                );
                D$1("load", a2);
                e2 = d2;
                break;
              case "details":
                D$1("toggle", a2);
                e2 = d2;
                break;
              case "input":
                Za(a2, d2);
                e2 = Ya(a2, d2);
                D$1("invalid", a2);
                break;
              case "option":
                e2 = d2;
                break;
              case "select":
                a2._wrapperState = { wasMultiple: !!d2.multiple };
                e2 = A$1({}, d2, { value: void 0 });
                D$1("invalid", a2);
                break;
              case "textarea":
                hb(a2, d2);
                e2 = gb(a2, d2);
                D$1("invalid", a2);
                break;
              default:
                e2 = d2;
            }
            ub(c2, e2);
            h2 = e2;
            for (f2 in h2) if (h2.hasOwnProperty(f2)) {
              var k2 = h2[f2];
              "style" === f2 ? sb(a2, k2) : "dangerouslySetInnerHTML" === f2 ? (k2 = k2 ? k2.__html : void 0, null != k2 && nb(a2, k2)) : "children" === f2 ? "string" === typeof k2 ? ("textarea" !== c2 || "" !== k2) && ob(a2, k2) : "number" === typeof k2 && ob(a2, "" + k2) : "suppressContentEditableWarning" !== f2 && "suppressHydrationWarning" !== f2 && "autoFocus" !== f2 && (ea.hasOwnProperty(f2) ? null != k2 && "onScroll" === f2 && D$1("scroll", a2) : null != k2 && ta(a2, f2, k2, g2));
            }
            switch (c2) {
              case "input":
                Va(a2);
                db(a2, d2, false);
                break;
              case "textarea":
                Va(a2);
                jb(a2);
                break;
              case "option":
                null != d2.value && a2.setAttribute("value", "" + Sa(d2.value));
                break;
              case "select":
                a2.multiple = !!d2.multiple;
                f2 = d2.value;
                null != f2 ? fb(a2, !!d2.multiple, f2, false) : null != d2.defaultValue && fb(
                  a2,
                  !!d2.multiple,
                  d2.defaultValue,
                  true
                );
                break;
              default:
                "function" === typeof e2.onClick && (a2.onclick = Bf);
            }
            switch (c2) {
              case "button":
              case "input":
              case "select":
              case "textarea":
                d2 = !!d2.autoFocus;
                break a;
              case "img":
                d2 = true;
                break a;
              default:
                d2 = false;
            }
          }
          d2 && (b2.flags |= 4);
        }
        null !== b2.ref && (b2.flags |= 512, b2.flags |= 2097152);
      }
      S$1(b2);
      return null;
    case 6:
      if (a2 && null != b2.stateNode) Cj(a2, b2, a2.memoizedProps, d2);
      else {
        if ("string" !== typeof d2 && null === b2.stateNode) throw Error(p$3(166));
        c2 = xh(wh.current);
        xh(uh.current);
        if (Gg(b2)) {
          d2 = b2.stateNode;
          c2 = b2.memoizedProps;
          d2[Of] = b2;
          if (f2 = d2.nodeValue !== c2) {
            if (a2 = xg, null !== a2) switch (a2.tag) {
              case 3:
                Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
                break;
              case 5:
                true !== a2.memoizedProps.suppressHydrationWarning && Af(d2.nodeValue, c2, 0 !== (a2.mode & 1));
            }
          }
          f2 && (b2.flags |= 4);
        } else d2 = (9 === c2.nodeType ? c2 : c2.ownerDocument).createTextNode(d2), d2[Of] = b2, b2.stateNode = d2;
      }
      S$1(b2);
      return null;
    case 13:
      E$1(L$1);
      d2 = b2.memoizedState;
      if (null === a2 || null !== a2.memoizedState && null !== a2.memoizedState.dehydrated) {
        if (I$1 && null !== yg && 0 !== (b2.mode & 1) && 0 === (b2.flags & 128)) Hg(), Ig(), b2.flags |= 98560, f2 = false;
        else if (f2 = Gg(b2), null !== d2 && null !== d2.dehydrated) {
          if (null === a2) {
            if (!f2) throw Error(p$3(318));
            f2 = b2.memoizedState;
            f2 = null !== f2 ? f2.dehydrated : null;
            if (!f2) throw Error(p$3(317));
            f2[Of] = b2;
          } else Ig(), 0 === (b2.flags & 128) && (b2.memoizedState = null), b2.flags |= 4;
          S$1(b2);
          f2 = false;
        } else null !== zg && (Fj(zg), zg = null), f2 = true;
        if (!f2) return b2.flags & 65536 ? b2 : null;
      }
      if (0 !== (b2.flags & 128)) return b2.lanes = c2, b2;
      d2 = null !== d2;
      d2 !== (null !== a2 && null !== a2.memoizedState) && d2 && (b2.child.flags |= 8192, 0 !== (b2.mode & 1) && (null === a2 || 0 !== (L$1.current & 1) ? 0 === T$1 && (T$1 = 3) : tj()));
      null !== b2.updateQueue && (b2.flags |= 4);
      S$1(b2);
      return null;
    case 4:
      return zh(), Aj(a2, b2), null === a2 && sf(b2.stateNode.containerInfo), S$1(b2), null;
    case 10:
      return ah(b2.type._context), S$1(b2), null;
    case 17:
      return Zf(b2.type) && $f(), S$1(b2), null;
    case 19:
      E$1(L$1);
      f2 = b2.memoizedState;
      if (null === f2) return S$1(b2), null;
      d2 = 0 !== (b2.flags & 128);
      g2 = f2.rendering;
      if (null === g2) if (d2) Dj(f2, false);
      else {
        if (0 !== T$1 || null !== a2 && 0 !== (a2.flags & 128)) for (a2 = b2.child; null !== a2; ) {
          g2 = Ch(a2);
          if (null !== g2) {
            b2.flags |= 128;
            Dj(f2, false);
            d2 = g2.updateQueue;
            null !== d2 && (b2.updateQueue = d2, b2.flags |= 4);
            b2.subtreeFlags = 0;
            d2 = c2;
            for (c2 = b2.child; null !== c2; ) f2 = c2, a2 = d2, f2.flags &= 14680066, g2 = f2.alternate, null === g2 ? (f2.childLanes = 0, f2.lanes = a2, f2.child = null, f2.subtreeFlags = 0, f2.memoizedProps = null, f2.memoizedState = null, f2.updateQueue = null, f2.dependencies = null, f2.stateNode = null) : (f2.childLanes = g2.childLanes, f2.lanes = g2.lanes, f2.child = g2.child, f2.subtreeFlags = 0, f2.deletions = null, f2.memoizedProps = g2.memoizedProps, f2.memoizedState = g2.memoizedState, f2.updateQueue = g2.updateQueue, f2.type = g2.type, a2 = g2.dependencies, f2.dependencies = null === a2 ? null : { lanes: a2.lanes, firstContext: a2.firstContext }), c2 = c2.sibling;
            G(L$1, L$1.current & 1 | 2);
            return b2.child;
          }
          a2 = a2.sibling;
        }
        null !== f2.tail && B() > Gj && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
      }
      else {
        if (!d2) if (a2 = Ch(g2), null !== a2) {
          if (b2.flags |= 128, d2 = true, c2 = a2.updateQueue, null !== c2 && (b2.updateQueue = c2, b2.flags |= 4), Dj(f2, true), null === f2.tail && "hidden" === f2.tailMode && !g2.alternate && !I$1) return S$1(b2), null;
        } else 2 * B() - f2.renderingStartTime > Gj && 1073741824 !== c2 && (b2.flags |= 128, d2 = true, Dj(f2, false), b2.lanes = 4194304);
        f2.isBackwards ? (g2.sibling = b2.child, b2.child = g2) : (c2 = f2.last, null !== c2 ? c2.sibling = g2 : b2.child = g2, f2.last = g2);
      }
      if (null !== f2.tail) return b2 = f2.tail, f2.rendering = b2, f2.tail = b2.sibling, f2.renderingStartTime = B(), b2.sibling = null, c2 = L$1.current, G(L$1, d2 ? c2 & 1 | 2 : c2 & 1), b2;
      S$1(b2);
      return null;
    case 22:
    case 23:
      return Hj(), d2 = null !== b2.memoizedState, null !== a2 && null !== a2.memoizedState !== d2 && (b2.flags |= 8192), d2 && 0 !== (b2.mode & 1) ? 0 !== (fj & 1073741824) && (S$1(b2), b2.subtreeFlags & 6 && (b2.flags |= 8192)) : S$1(b2), null;
    case 24:
      return null;
    case 25:
      return null;
  }
  throw Error(p$3(156, b2.tag));
}
function Ij(a2, b2) {
  wg(b2);
  switch (b2.tag) {
    case 1:
      return Zf(b2.type) && $f(), a2 = b2.flags, a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 3:
      return zh(), E$1(Wf), E$1(H), Eh(), a2 = b2.flags, 0 !== (a2 & 65536) && 0 === (a2 & 128) ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 5:
      return Bh(b2), null;
    case 13:
      E$1(L$1);
      a2 = b2.memoizedState;
      if (null !== a2 && null !== a2.dehydrated) {
        if (null === b2.alternate) throw Error(p$3(340));
        Ig();
      }
      a2 = b2.flags;
      return a2 & 65536 ? (b2.flags = a2 & -65537 | 128, b2) : null;
    case 19:
      return E$1(L$1), null;
    case 4:
      return zh(), null;
    case 10:
      return ah(b2.type._context), null;
    case 22:
    case 23:
      return Hj(), null;
    case 24:
      return null;
    default:
      return null;
  }
}
var Jj = false, U$1 = false, Kj = "function" === typeof WeakSet ? WeakSet : Set, V$1 = null;
function Lj(a2, b2) {
  var c2 = a2.ref;
  if (null !== c2) if ("function" === typeof c2) try {
    c2(null);
  } catch (d2) {
    W(a2, b2, d2);
  }
  else c2.current = null;
}
function Mj(a2, b2, c2) {
  try {
    c2();
  } catch (d2) {
    W(a2, b2, d2);
  }
}
var Nj = false;
function Oj(a2, b2) {
  Cf = dd;
  a2 = Me();
  if (Ne(a2)) {
    if ("selectionStart" in a2) var c2 = { start: a2.selectionStart, end: a2.selectionEnd };
    else a: {
      c2 = (c2 = a2.ownerDocument) && c2.defaultView || window;
      var d2 = c2.getSelection && c2.getSelection();
      if (d2 && 0 !== d2.rangeCount) {
        c2 = d2.anchorNode;
        var e2 = d2.anchorOffset, f2 = d2.focusNode;
        d2 = d2.focusOffset;
        try {
          c2.nodeType, f2.nodeType;
        } catch (F2) {
          c2 = null;
          break a;
        }
        var g2 = 0, h2 = -1, k2 = -1, l2 = 0, m2 = 0, q2 = a2, r2 = null;
        b: for (; ; ) {
          for (var y2; ; ) {
            q2 !== c2 || 0 !== e2 && 3 !== q2.nodeType || (h2 = g2 + e2);
            q2 !== f2 || 0 !== d2 && 3 !== q2.nodeType || (k2 = g2 + d2);
            3 === q2.nodeType && (g2 += q2.nodeValue.length);
            if (null === (y2 = q2.firstChild)) break;
            r2 = q2;
            q2 = y2;
          }
          for (; ; ) {
            if (q2 === a2) break b;
            r2 === c2 && ++l2 === e2 && (h2 = g2);
            r2 === f2 && ++m2 === d2 && (k2 = g2);
            if (null !== (y2 = q2.nextSibling)) break;
            q2 = r2;
            r2 = q2.parentNode;
          }
          q2 = y2;
        }
        c2 = -1 === h2 || -1 === k2 ? null : { start: h2, end: k2 };
      } else c2 = null;
    }
    c2 = c2 || { start: 0, end: 0 };
  } else c2 = null;
  Df = { focusedElem: a2, selectionRange: c2 };
  dd = false;
  for (V$1 = b2; null !== V$1; ) if (b2 = V$1, a2 = b2.child, 0 !== (b2.subtreeFlags & 1028) && null !== a2) a2.return = b2, V$1 = a2;
  else for (; null !== V$1; ) {
    b2 = V$1;
    try {
      var n2 = b2.alternate;
      if (0 !== (b2.flags & 1024)) switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          break;
        case 1:
          if (null !== n2) {
            var t2 = n2.memoizedProps, J2 = n2.memoizedState, x2 = b2.stateNode, w2 = x2.getSnapshotBeforeUpdate(b2.elementType === b2.type ? t2 : Ci(b2.type, t2), J2);
            x2.__reactInternalSnapshotBeforeUpdate = w2;
          }
          break;
        case 3:
          var u2 = b2.stateNode.containerInfo;
          1 === u2.nodeType ? u2.textContent = "" : 9 === u2.nodeType && u2.documentElement && u2.removeChild(u2.documentElement);
          break;
        case 5:
        case 6:
        case 4:
        case 17:
          break;
        default:
          throw Error(p$3(163));
      }
    } catch (F2) {
      W(b2, b2.return, F2);
    }
    a2 = b2.sibling;
    if (null !== a2) {
      a2.return = b2.return;
      V$1 = a2;
      break;
    }
    V$1 = b2.return;
  }
  n2 = Nj;
  Nj = false;
  return n2;
}
function Pj(a2, b2, c2) {
  var d2 = b2.updateQueue;
  d2 = null !== d2 ? d2.lastEffect : null;
  if (null !== d2) {
    var e2 = d2 = d2.next;
    do {
      if ((e2.tag & a2) === a2) {
        var f2 = e2.destroy;
        e2.destroy = void 0;
        void 0 !== f2 && Mj(b2, c2, f2);
      }
      e2 = e2.next;
    } while (e2 !== d2);
  }
}
function Qj(a2, b2) {
  b2 = b2.updateQueue;
  b2 = null !== b2 ? b2.lastEffect : null;
  if (null !== b2) {
    var c2 = b2 = b2.next;
    do {
      if ((c2.tag & a2) === a2) {
        var d2 = c2.create;
        c2.destroy = d2();
      }
      c2 = c2.next;
    } while (c2 !== b2);
  }
}
function Rj(a2) {
  var b2 = a2.ref;
  if (null !== b2) {
    var c2 = a2.stateNode;
    switch (a2.tag) {
      case 5:
        a2 = c2;
        break;
      default:
        a2 = c2;
    }
    "function" === typeof b2 ? b2(a2) : b2.current = a2;
  }
}
function Sj(a2) {
  var b2 = a2.alternate;
  null !== b2 && (a2.alternate = null, Sj(b2));
  a2.child = null;
  a2.deletions = null;
  a2.sibling = null;
  5 === a2.tag && (b2 = a2.stateNode, null !== b2 && (delete b2[Of], delete b2[Pf], delete b2[of], delete b2[Qf], delete b2[Rf]));
  a2.stateNode = null;
  a2.return = null;
  a2.dependencies = null;
  a2.memoizedProps = null;
  a2.memoizedState = null;
  a2.pendingProps = null;
  a2.stateNode = null;
  a2.updateQueue = null;
}
function Tj(a2) {
  return 5 === a2.tag || 3 === a2.tag || 4 === a2.tag;
}
function Uj(a2) {
  a: for (; ; ) {
    for (; null === a2.sibling; ) {
      if (null === a2.return || Tj(a2.return)) return null;
      a2 = a2.return;
    }
    a2.sibling.return = a2.return;
    for (a2 = a2.sibling; 5 !== a2.tag && 6 !== a2.tag && 18 !== a2.tag; ) {
      if (a2.flags & 2) continue a;
      if (null === a2.child || 4 === a2.tag) continue a;
      else a2.child.return = a2, a2 = a2.child;
    }
    if (!(a2.flags & 2)) return a2.stateNode;
  }
}
function Vj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? 8 === c2.nodeType ? c2.parentNode.insertBefore(a2, b2) : c2.insertBefore(a2, b2) : (8 === c2.nodeType ? (b2 = c2.parentNode, b2.insertBefore(a2, c2)) : (b2 = c2, b2.appendChild(a2)), c2 = c2._reactRootContainer, null !== c2 && void 0 !== c2 || null !== b2.onclick || (b2.onclick = Bf));
  else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Vj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Vj(a2, b2, c2), a2 = a2.sibling;
}
function Wj(a2, b2, c2) {
  var d2 = a2.tag;
  if (5 === d2 || 6 === d2) a2 = a2.stateNode, b2 ? c2.insertBefore(a2, b2) : c2.appendChild(a2);
  else if (4 !== d2 && (a2 = a2.child, null !== a2)) for (Wj(a2, b2, c2), a2 = a2.sibling; null !== a2; ) Wj(a2, b2, c2), a2 = a2.sibling;
}
var X$1 = null, Xj = false;
function Yj(a2, b2, c2) {
  for (c2 = c2.child; null !== c2; ) Zj(a2, b2, c2), c2 = c2.sibling;
}
function Zj(a2, b2, c2) {
  if (lc && "function" === typeof lc.onCommitFiberUnmount) try {
    lc.onCommitFiberUnmount(kc, c2);
  } catch (h2) {
  }
  switch (c2.tag) {
    case 5:
      U$1 || Lj(c2, b2);
    case 6:
      var d2 = X$1, e2 = Xj;
      X$1 = null;
      Yj(a2, b2, c2);
      X$1 = d2;
      Xj = e2;
      null !== X$1 && (Xj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? a2.parentNode.removeChild(c2) : a2.removeChild(c2)) : X$1.removeChild(c2.stateNode));
      break;
    case 18:
      null !== X$1 && (Xj ? (a2 = X$1, c2 = c2.stateNode, 8 === a2.nodeType ? Kf(a2.parentNode, c2) : 1 === a2.nodeType && Kf(a2, c2), bd(a2)) : Kf(X$1, c2.stateNode));
      break;
    case 4:
      d2 = X$1;
      e2 = Xj;
      X$1 = c2.stateNode.containerInfo;
      Xj = true;
      Yj(a2, b2, c2);
      X$1 = d2;
      Xj = e2;
      break;
    case 0:
    case 11:
    case 14:
    case 15:
      if (!U$1 && (d2 = c2.updateQueue, null !== d2 && (d2 = d2.lastEffect, null !== d2))) {
        e2 = d2 = d2.next;
        do {
          var f2 = e2, g2 = f2.destroy;
          f2 = f2.tag;
          void 0 !== g2 && (0 !== (f2 & 2) ? Mj(c2, b2, g2) : 0 !== (f2 & 4) && Mj(c2, b2, g2));
          e2 = e2.next;
        } while (e2 !== d2);
      }
      Yj(a2, b2, c2);
      break;
    case 1:
      if (!U$1 && (Lj(c2, b2), d2 = c2.stateNode, "function" === typeof d2.componentWillUnmount)) try {
        d2.props = c2.memoizedProps, d2.state = c2.memoizedState, d2.componentWillUnmount();
      } catch (h2) {
        W(c2, b2, h2);
      }
      Yj(a2, b2, c2);
      break;
    case 21:
      Yj(a2, b2, c2);
      break;
    case 22:
      c2.mode & 1 ? (U$1 = (d2 = U$1) || null !== c2.memoizedState, Yj(a2, b2, c2), U$1 = d2) : Yj(a2, b2, c2);
      break;
    default:
      Yj(a2, b2, c2);
  }
}
function ak(a2) {
  var b2 = a2.updateQueue;
  if (null !== b2) {
    a2.updateQueue = null;
    var c2 = a2.stateNode;
    null === c2 && (c2 = a2.stateNode = new Kj());
    b2.forEach(function(b3) {
      var d2 = bk.bind(null, a2, b3);
      c2.has(b3) || (c2.add(b3), b3.then(d2, d2));
    });
  }
}
function ck(a2, b2) {
  var c2 = b2.deletions;
  if (null !== c2) for (var d2 = 0; d2 < c2.length; d2++) {
    var e2 = c2[d2];
    try {
      var f2 = a2, g2 = b2, h2 = g2;
      a: for (; null !== h2; ) {
        switch (h2.tag) {
          case 5:
            X$1 = h2.stateNode;
            Xj = false;
            break a;
          case 3:
            X$1 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
          case 4:
            X$1 = h2.stateNode.containerInfo;
            Xj = true;
            break a;
        }
        h2 = h2.return;
      }
      if (null === X$1) throw Error(p$3(160));
      Zj(f2, g2, e2);
      X$1 = null;
      Xj = false;
      var k2 = e2.alternate;
      null !== k2 && (k2.return = null);
      e2.return = null;
    } catch (l2) {
      W(e2, b2, l2);
    }
  }
  if (b2.subtreeFlags & 12854) for (b2 = b2.child; null !== b2; ) dk(b2, a2), b2 = b2.sibling;
}
function dk(a2, b2) {
  var c2 = a2.alternate, d2 = a2.flags;
  switch (a2.tag) {
    case 0:
    case 11:
    case 14:
    case 15:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        try {
          Pj(3, a2, a2.return), Qj(3, a2);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
        try {
          Pj(5, a2, a2.return);
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 1:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      break;
    case 5:
      ck(b2, a2);
      ek(a2);
      d2 & 512 && null !== c2 && Lj(c2, c2.return);
      if (a2.flags & 32) {
        var e2 = a2.stateNode;
        try {
          ob(e2, "");
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      if (d2 & 4 && (e2 = a2.stateNode, null != e2)) {
        var f2 = a2.memoizedProps, g2 = null !== c2 ? c2.memoizedProps : f2, h2 = a2.type, k2 = a2.updateQueue;
        a2.updateQueue = null;
        if (null !== k2) try {
          "input" === h2 && "radio" === f2.type && null != f2.name && ab(e2, f2);
          vb(h2, g2);
          var l2 = vb(h2, f2);
          for (g2 = 0; g2 < k2.length; g2 += 2) {
            var m2 = k2[g2], q2 = k2[g2 + 1];
            "style" === m2 ? sb(e2, q2) : "dangerouslySetInnerHTML" === m2 ? nb(e2, q2) : "children" === m2 ? ob(e2, q2) : ta(e2, m2, q2, l2);
          }
          switch (h2) {
            case "input":
              bb(e2, f2);
              break;
            case "textarea":
              ib(e2, f2);
              break;
            case "select":
              var r2 = e2._wrapperState.wasMultiple;
              e2._wrapperState.wasMultiple = !!f2.multiple;
              var y2 = f2.value;
              null != y2 ? fb(e2, !!f2.multiple, y2, false) : r2 !== !!f2.multiple && (null != f2.defaultValue ? fb(
                e2,
                !!f2.multiple,
                f2.defaultValue,
                true
              ) : fb(e2, !!f2.multiple, f2.multiple ? [] : "", false));
          }
          e2[Pf] = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 6:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4) {
        if (null === a2.stateNode) throw Error(p$3(162));
        e2 = a2.stateNode;
        f2 = a2.memoizedProps;
        try {
          e2.nodeValue = f2;
        } catch (t2) {
          W(a2, a2.return, t2);
        }
      }
      break;
    case 3:
      ck(b2, a2);
      ek(a2);
      if (d2 & 4 && null !== c2 && c2.memoizedState.isDehydrated) try {
        bd(b2.containerInfo);
      } catch (t2) {
        W(a2, a2.return, t2);
      }
      break;
    case 4:
      ck(b2, a2);
      ek(a2);
      break;
    case 13:
      ck(b2, a2);
      ek(a2);
      e2 = a2.child;
      e2.flags & 8192 && (f2 = null !== e2.memoizedState, e2.stateNode.isHidden = f2, !f2 || null !== e2.alternate && null !== e2.alternate.memoizedState || (fk = B()));
      d2 & 4 && ak(a2);
      break;
    case 22:
      m2 = null !== c2 && null !== c2.memoizedState;
      a2.mode & 1 ? (U$1 = (l2 = U$1) || m2, ck(b2, a2), U$1 = l2) : ck(b2, a2);
      ek(a2);
      if (d2 & 8192) {
        l2 = null !== a2.memoizedState;
        if ((a2.stateNode.isHidden = l2) && !m2 && 0 !== (a2.mode & 1)) for (V$1 = a2, m2 = a2.child; null !== m2; ) {
          for (q2 = V$1 = m2; null !== V$1; ) {
            r2 = V$1;
            y2 = r2.child;
            switch (r2.tag) {
              case 0:
              case 11:
              case 14:
              case 15:
                Pj(4, r2, r2.return);
                break;
              case 1:
                Lj(r2, r2.return);
                var n2 = r2.stateNode;
                if ("function" === typeof n2.componentWillUnmount) {
                  d2 = r2;
                  c2 = r2.return;
                  try {
                    b2 = d2, n2.props = b2.memoizedProps, n2.state = b2.memoizedState, n2.componentWillUnmount();
                  } catch (t2) {
                    W(d2, c2, t2);
                  }
                }
                break;
              case 5:
                Lj(r2, r2.return);
                break;
              case 22:
                if (null !== r2.memoizedState) {
                  gk(q2);
                  continue;
                }
            }
            null !== y2 ? (y2.return = r2, V$1 = y2) : gk(q2);
          }
          m2 = m2.sibling;
        }
        a: for (m2 = null, q2 = a2; ; ) {
          if (5 === q2.tag) {
            if (null === m2) {
              m2 = q2;
              try {
                e2 = q2.stateNode, l2 ? (f2 = e2.style, "function" === typeof f2.setProperty ? f2.setProperty("display", "none", "important") : f2.display = "none") : (h2 = q2.stateNode, k2 = q2.memoizedProps.style, g2 = void 0 !== k2 && null !== k2 && k2.hasOwnProperty("display") ? k2.display : null, h2.style.display = rb("display", g2));
              } catch (t2) {
                W(a2, a2.return, t2);
              }
            }
          } else if (6 === q2.tag) {
            if (null === m2) try {
              q2.stateNode.nodeValue = l2 ? "" : q2.memoizedProps;
            } catch (t2) {
              W(a2, a2.return, t2);
            }
          } else if ((22 !== q2.tag && 23 !== q2.tag || null === q2.memoizedState || q2 === a2) && null !== q2.child) {
            q2.child.return = q2;
            q2 = q2.child;
            continue;
          }
          if (q2 === a2) break a;
          for (; null === q2.sibling; ) {
            if (null === q2.return || q2.return === a2) break a;
            m2 === q2 && (m2 = null);
            q2 = q2.return;
          }
          m2 === q2 && (m2 = null);
          q2.sibling.return = q2.return;
          q2 = q2.sibling;
        }
      }
      break;
    case 19:
      ck(b2, a2);
      ek(a2);
      d2 & 4 && ak(a2);
      break;
    case 21:
      break;
    default:
      ck(
        b2,
        a2
      ), ek(a2);
  }
}
function ek(a2) {
  var b2 = a2.flags;
  if (b2 & 2) {
    try {
      a: {
        for (var c2 = a2.return; null !== c2; ) {
          if (Tj(c2)) {
            var d2 = c2;
            break a;
          }
          c2 = c2.return;
        }
        throw Error(p$3(160));
      }
      switch (d2.tag) {
        case 5:
          var e2 = d2.stateNode;
          d2.flags & 32 && (ob(e2, ""), d2.flags &= -33);
          var f2 = Uj(a2);
          Wj(a2, f2, e2);
          break;
        case 3:
        case 4:
          var g2 = d2.stateNode.containerInfo, h2 = Uj(a2);
          Vj(a2, h2, g2);
          break;
        default:
          throw Error(p$3(161));
      }
    } catch (k2) {
      W(a2, a2.return, k2);
    }
    a2.flags &= -3;
  }
  b2 & 4096 && (a2.flags &= -4097);
}
function hk(a2, b2, c2) {
  V$1 = a2;
  ik(a2);
}
function ik(a2, b2, c2) {
  for (var d2 = 0 !== (a2.mode & 1); null !== V$1; ) {
    var e2 = V$1, f2 = e2.child;
    if (22 === e2.tag && d2) {
      var g2 = null !== e2.memoizedState || Jj;
      if (!g2) {
        var h2 = e2.alternate, k2 = null !== h2 && null !== h2.memoizedState || U$1;
        h2 = Jj;
        var l2 = U$1;
        Jj = g2;
        if ((U$1 = k2) && !l2) for (V$1 = e2; null !== V$1; ) g2 = V$1, k2 = g2.child, 22 === g2.tag && null !== g2.memoizedState ? jk(e2) : null !== k2 ? (k2.return = g2, V$1 = k2) : jk(e2);
        for (; null !== f2; ) V$1 = f2, ik(f2), f2 = f2.sibling;
        V$1 = e2;
        Jj = h2;
        U$1 = l2;
      }
      kk(a2);
    } else 0 !== (e2.subtreeFlags & 8772) && null !== f2 ? (f2.return = e2, V$1 = f2) : kk(a2);
  }
}
function kk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (0 !== (b2.flags & 8772)) {
      var c2 = b2.alternate;
      try {
        if (0 !== (b2.flags & 8772)) switch (b2.tag) {
          case 0:
          case 11:
          case 15:
            U$1 || Qj(5, b2);
            break;
          case 1:
            var d2 = b2.stateNode;
            if (b2.flags & 4 && !U$1) if (null === c2) d2.componentDidMount();
            else {
              var e2 = b2.elementType === b2.type ? c2.memoizedProps : Ci(b2.type, c2.memoizedProps);
              d2.componentDidUpdate(e2, c2.memoizedState, d2.__reactInternalSnapshotBeforeUpdate);
            }
            var f2 = b2.updateQueue;
            null !== f2 && sh(b2, f2, d2);
            break;
          case 3:
            var g2 = b2.updateQueue;
            if (null !== g2) {
              c2 = null;
              if (null !== b2.child) switch (b2.child.tag) {
                case 5:
                  c2 = b2.child.stateNode;
                  break;
                case 1:
                  c2 = b2.child.stateNode;
              }
              sh(b2, g2, c2);
            }
            break;
          case 5:
            var h2 = b2.stateNode;
            if (null === c2 && b2.flags & 4) {
              c2 = h2;
              var k2 = b2.memoizedProps;
              switch (b2.type) {
                case "button":
                case "input":
                case "select":
                case "textarea":
                  k2.autoFocus && c2.focus();
                  break;
                case "img":
                  k2.src && (c2.src = k2.src);
              }
            }
            break;
          case 6:
            break;
          case 4:
            break;
          case 12:
            break;
          case 13:
            if (null === b2.memoizedState) {
              var l2 = b2.alternate;
              if (null !== l2) {
                var m2 = l2.memoizedState;
                if (null !== m2) {
                  var q2 = m2.dehydrated;
                  null !== q2 && bd(q2);
                }
              }
            }
            break;
          case 19:
          case 17:
          case 21:
          case 22:
          case 23:
          case 25:
            break;
          default:
            throw Error(p$3(163));
        }
        U$1 || b2.flags & 512 && Rj(b2);
      } catch (r2) {
        W(b2, b2.return, r2);
      }
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function gk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var c2 = b2.sibling;
    if (null !== c2) {
      c2.return = b2.return;
      V$1 = c2;
      break;
    }
    V$1 = b2.return;
  }
}
function jk(a2) {
  for (; null !== V$1; ) {
    var b2 = V$1;
    try {
      switch (b2.tag) {
        case 0:
        case 11:
        case 15:
          var c2 = b2.return;
          try {
            Qj(4, b2);
          } catch (k2) {
            W(b2, c2, k2);
          }
          break;
        case 1:
          var d2 = b2.stateNode;
          if ("function" === typeof d2.componentDidMount) {
            var e2 = b2.return;
            try {
              d2.componentDidMount();
            } catch (k2) {
              W(b2, e2, k2);
            }
          }
          var f2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, f2, k2);
          }
          break;
        case 5:
          var g2 = b2.return;
          try {
            Rj(b2);
          } catch (k2) {
            W(b2, g2, k2);
          }
      }
    } catch (k2) {
      W(b2, b2.return, k2);
    }
    if (b2 === a2) {
      V$1 = null;
      break;
    }
    var h2 = b2.sibling;
    if (null !== h2) {
      h2.return = b2.return;
      V$1 = h2;
      break;
    }
    V$1 = b2.return;
  }
}
var lk = Math.ceil, mk = ua.ReactCurrentDispatcher, nk = ua.ReactCurrentOwner, ok = ua.ReactCurrentBatchConfig, K = 0, Q = null, Y = null, Z = 0, fj = 0, ej = Uf(0), T$1 = 0, pk = null, rh = 0, qk = 0, rk = 0, sk = null, tk = null, fk = 0, Gj = Infinity, uk = null, Oi = false, Pi = null, Ri = null, vk = false, wk = null, xk = 0, yk = 0, zk = null, Ak = -1, Bk = 0;
function R$1() {
  return 0 !== (K & 6) ? B() : -1 !== Ak ? Ak : Ak = B();
}
function yi(a2) {
  if (0 === (a2.mode & 1)) return 1;
  if (0 !== (K & 2) && 0 !== Z) return Z & -Z;
  if (null !== Kg.transition) return 0 === Bk && (Bk = yc()), Bk;
  a2 = C$1;
  if (0 !== a2) return a2;
  a2 = window.event;
  a2 = void 0 === a2 ? 16 : jd(a2.type);
  return a2;
}
function gi(a2, b2, c2, d2) {
  if (50 < yk) throw yk = 0, zk = null, Error(p$3(185));
  Ac(a2, c2, d2);
  if (0 === (K & 2) || a2 !== Q) a2 === Q && (0 === (K & 2) && (qk |= c2), 4 === T$1 && Ck(a2, Z)), Dk(a2, d2), 1 === c2 && 0 === K && 0 === (b2.mode & 1) && (Gj = B() + 500, fg && jg());
}
function Dk(a2, b2) {
  var c2 = a2.callbackNode;
  wc(a2, b2);
  var d2 = uc(a2, a2 === Q ? Z : 0);
  if (0 === d2) null !== c2 && bc(c2), a2.callbackNode = null, a2.callbackPriority = 0;
  else if (b2 = d2 & -d2, a2.callbackPriority !== b2) {
    null != c2 && bc(c2);
    if (1 === b2) 0 === a2.tag ? ig(Ek.bind(null, a2)) : hg(Ek.bind(null, a2)), Jf(function() {
      0 === (K & 6) && jg();
    }), c2 = null;
    else {
      switch (Dc(d2)) {
        case 1:
          c2 = fc;
          break;
        case 4:
          c2 = gc;
          break;
        case 16:
          c2 = hc;
          break;
        case 536870912:
          c2 = jc;
          break;
        default:
          c2 = hc;
      }
      c2 = Fk(c2, Gk.bind(null, a2));
    }
    a2.callbackPriority = b2;
    a2.callbackNode = c2;
  }
}
function Gk(a2, b2) {
  Ak = -1;
  Bk = 0;
  if (0 !== (K & 6)) throw Error(p$3(327));
  var c2 = a2.callbackNode;
  if (Hk() && a2.callbackNode !== c2) return null;
  var d2 = uc(a2, a2 === Q ? Z : 0);
  if (0 === d2) return null;
  if (0 !== (d2 & 30) || 0 !== (d2 & a2.expiredLanes) || b2) b2 = Ik(a2, d2);
  else {
    b2 = d2;
    var e2 = K;
    K |= 2;
    var f2 = Jk();
    if (Q !== a2 || Z !== b2) uk = null, Gj = B() + 500, Kk(a2, b2);
    do
      try {
        Lk();
        break;
      } catch (h2) {
        Mk(a2, h2);
      }
    while (1);
    $g();
    mk.current = f2;
    K = e2;
    null !== Y ? b2 = 0 : (Q = null, Z = 0, b2 = T$1);
  }
  if (0 !== b2) {
    2 === b2 && (e2 = xc(a2), 0 !== e2 && (d2 = e2, b2 = Nk(a2, e2)));
    if (1 === b2) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
    if (6 === b2) Ck(a2, d2);
    else {
      e2 = a2.current.alternate;
      if (0 === (d2 & 30) && !Ok(e2) && (b2 = Ik(a2, d2), 2 === b2 && (f2 = xc(a2), 0 !== f2 && (d2 = f2, b2 = Nk(a2, f2))), 1 === b2)) throw c2 = pk, Kk(a2, 0), Ck(a2, d2), Dk(a2, B()), c2;
      a2.finishedWork = e2;
      a2.finishedLanes = d2;
      switch (b2) {
        case 0:
        case 1:
          throw Error(p$3(345));
        case 2:
          Pk(a2, tk, uk);
          break;
        case 3:
          Ck(a2, d2);
          if ((d2 & 130023424) === d2 && (b2 = fk + 500 - B(), 10 < b2)) {
            if (0 !== uc(a2, 0)) break;
            e2 = a2.suspendedLanes;
            if ((e2 & d2) !== d2) {
              R$1();
              a2.pingedLanes |= a2.suspendedLanes & e2;
              break;
            }
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), b2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 4:
          Ck(a2, d2);
          if ((d2 & 4194240) === d2) break;
          b2 = a2.eventTimes;
          for (e2 = -1; 0 < d2; ) {
            var g2 = 31 - oc(d2);
            f2 = 1 << g2;
            g2 = b2[g2];
            g2 > e2 && (e2 = g2);
            d2 &= ~f2;
          }
          d2 = e2;
          d2 = B() - d2;
          d2 = (120 > d2 ? 120 : 480 > d2 ? 480 : 1080 > d2 ? 1080 : 1920 > d2 ? 1920 : 3e3 > d2 ? 3e3 : 4320 > d2 ? 4320 : 1960 * lk(d2 / 1960)) - d2;
          if (10 < d2) {
            a2.timeoutHandle = Ff(Pk.bind(null, a2, tk, uk), d2);
            break;
          }
          Pk(a2, tk, uk);
          break;
        case 5:
          Pk(a2, tk, uk);
          break;
        default:
          throw Error(p$3(329));
      }
    }
  }
  Dk(a2, B());
  return a2.callbackNode === c2 ? Gk.bind(null, a2) : null;
}
function Nk(a2, b2) {
  var c2 = sk;
  a2.current.memoizedState.isDehydrated && (Kk(a2, b2).flags |= 256);
  a2 = Ik(a2, b2);
  2 !== a2 && (b2 = tk, tk = c2, null !== b2 && Fj(b2));
  return a2;
}
function Fj(a2) {
  null === tk ? tk = a2 : tk.push.apply(tk, a2);
}
function Ok(a2) {
  for (var b2 = a2; ; ) {
    if (b2.flags & 16384) {
      var c2 = b2.updateQueue;
      if (null !== c2 && (c2 = c2.stores, null !== c2)) for (var d2 = 0; d2 < c2.length; d2++) {
        var e2 = c2[d2], f2 = e2.getSnapshot;
        e2 = e2.value;
        try {
          if (!He(f2(), e2)) return false;
        } catch (g2) {
          return false;
        }
      }
    }
    c2 = b2.child;
    if (b2.subtreeFlags & 16384 && null !== c2) c2.return = b2, b2 = c2;
    else {
      if (b2 === a2) break;
      for (; null === b2.sibling; ) {
        if (null === b2.return || b2.return === a2) return true;
        b2 = b2.return;
      }
      b2.sibling.return = b2.return;
      b2 = b2.sibling;
    }
  }
  return true;
}
function Ck(a2, b2) {
  b2 &= ~rk;
  b2 &= ~qk;
  a2.suspendedLanes |= b2;
  a2.pingedLanes &= ~b2;
  for (a2 = a2.expirationTimes; 0 < b2; ) {
    var c2 = 31 - oc(b2), d2 = 1 << c2;
    a2[c2] = -1;
    b2 &= ~d2;
  }
}
function Ek(a2) {
  if (0 !== (K & 6)) throw Error(p$3(327));
  Hk();
  var b2 = uc(a2, 0);
  if (0 === (b2 & 1)) return Dk(a2, B()), null;
  var c2 = Ik(a2, b2);
  if (0 !== a2.tag && 2 === c2) {
    var d2 = xc(a2);
    0 !== d2 && (b2 = d2, c2 = Nk(a2, d2));
  }
  if (1 === c2) throw c2 = pk, Kk(a2, 0), Ck(a2, b2), Dk(a2, B()), c2;
  if (6 === c2) throw Error(p$3(345));
  a2.finishedWork = a2.current.alternate;
  a2.finishedLanes = b2;
  Pk(a2, tk, uk);
  Dk(a2, B());
  return null;
}
function Qk(a2, b2) {
  var c2 = K;
  K |= 1;
  try {
    return a2(b2);
  } finally {
    K = c2, 0 === K && (Gj = B() + 500, fg && jg());
  }
}
function Rk(a2) {
  null !== wk && 0 === wk.tag && 0 === (K & 6) && Hk();
  var b2 = K;
  K |= 1;
  var c2 = ok.transition, d2 = C$1;
  try {
    if (ok.transition = null, C$1 = 1, a2) return a2();
  } finally {
    C$1 = d2, ok.transition = c2, K = b2, 0 === (K & 6) && jg();
  }
}
function Hj() {
  fj = ej.current;
  E$1(ej);
}
function Kk(a2, b2) {
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  var c2 = a2.timeoutHandle;
  -1 !== c2 && (a2.timeoutHandle = -1, Gf(c2));
  if (null !== Y) for (c2 = Y.return; null !== c2; ) {
    var d2 = c2;
    wg(d2);
    switch (d2.tag) {
      case 1:
        d2 = d2.type.childContextTypes;
        null !== d2 && void 0 !== d2 && $f();
        break;
      case 3:
        zh();
        E$1(Wf);
        E$1(H);
        Eh();
        break;
      case 5:
        Bh(d2);
        break;
      case 4:
        zh();
        break;
      case 13:
        E$1(L$1);
        break;
      case 19:
        E$1(L$1);
        break;
      case 10:
        ah(d2.type._context);
        break;
      case 22:
      case 23:
        Hj();
    }
    c2 = c2.return;
  }
  Q = a2;
  Y = a2 = Pg(a2.current, null);
  Z = fj = b2;
  T$1 = 0;
  pk = null;
  rk = qk = rh = 0;
  tk = sk = null;
  if (null !== fh) {
    for (b2 = 0; b2 < fh.length; b2++) if (c2 = fh[b2], d2 = c2.interleaved, null !== d2) {
      c2.interleaved = null;
      var e2 = d2.next, f2 = c2.pending;
      if (null !== f2) {
        var g2 = f2.next;
        f2.next = e2;
        d2.next = g2;
      }
      c2.pending = d2;
    }
    fh = null;
  }
  return a2;
}
function Mk(a2, b2) {
  do {
    var c2 = Y;
    try {
      $g();
      Fh.current = Rh;
      if (Ih) {
        for (var d2 = M$1.memoizedState; null !== d2; ) {
          var e2 = d2.queue;
          null !== e2 && (e2.pending = null);
          d2 = d2.next;
        }
        Ih = false;
      }
      Hh = 0;
      O$1 = N = M$1 = null;
      Jh = false;
      Kh = 0;
      nk.current = null;
      if (null === c2 || null === c2.return) {
        T$1 = 1;
        pk = b2;
        Y = null;
        break;
      }
      a: {
        var f2 = a2, g2 = c2.return, h2 = c2, k2 = b2;
        b2 = Z;
        h2.flags |= 32768;
        if (null !== k2 && "object" === typeof k2 && "function" === typeof k2.then) {
          var l2 = k2, m2 = h2, q2 = m2.tag;
          if (0 === (m2.mode & 1) && (0 === q2 || 11 === q2 || 15 === q2)) {
            var r2 = m2.alternate;
            r2 ? (m2.updateQueue = r2.updateQueue, m2.memoizedState = r2.memoizedState, m2.lanes = r2.lanes) : (m2.updateQueue = null, m2.memoizedState = null);
          }
          var y2 = Ui(g2);
          if (null !== y2) {
            y2.flags &= -257;
            Vi(y2, g2, h2, f2, b2);
            y2.mode & 1 && Si(f2, l2, b2);
            b2 = y2;
            k2 = l2;
            var n2 = b2.updateQueue;
            if (null === n2) {
              var t2 = /* @__PURE__ */ new Set();
              t2.add(k2);
              b2.updateQueue = t2;
            } else n2.add(k2);
            break a;
          } else {
            if (0 === (b2 & 1)) {
              Si(f2, l2, b2);
              tj();
              break a;
            }
            k2 = Error(p$3(426));
          }
        } else if (I$1 && h2.mode & 1) {
          var J2 = Ui(g2);
          if (null !== J2) {
            0 === (J2.flags & 65536) && (J2.flags |= 256);
            Vi(J2, g2, h2, f2, b2);
            Jg(Ji(k2, h2));
            break a;
          }
        }
        f2 = k2 = Ji(k2, h2);
        4 !== T$1 && (T$1 = 2);
        null === sk ? sk = [f2] : sk.push(f2);
        f2 = g2;
        do {
          switch (f2.tag) {
            case 3:
              f2.flags |= 65536;
              b2 &= -b2;
              f2.lanes |= b2;
              var x2 = Ni(f2, k2, b2);
              ph(f2, x2);
              break a;
            case 1:
              h2 = k2;
              var w2 = f2.type, u2 = f2.stateNode;
              if (0 === (f2.flags & 128) && ("function" === typeof w2.getDerivedStateFromError || null !== u2 && "function" === typeof u2.componentDidCatch && (null === Ri || !Ri.has(u2)))) {
                f2.flags |= 65536;
                b2 &= -b2;
                f2.lanes |= b2;
                var F2 = Qi(f2, h2, b2);
                ph(f2, F2);
                break a;
              }
          }
          f2 = f2.return;
        } while (null !== f2);
      }
      Sk(c2);
    } catch (na) {
      b2 = na;
      Y === c2 && null !== c2 && (Y = c2 = c2.return);
      continue;
    }
    break;
  } while (1);
}
function Jk() {
  var a2 = mk.current;
  mk.current = Rh;
  return null === a2 ? Rh : a2;
}
function tj() {
  if (0 === T$1 || 3 === T$1 || 2 === T$1) T$1 = 4;
  null === Q || 0 === (rh & 268435455) && 0 === (qk & 268435455) || Ck(Q, Z);
}
function Ik(a2, b2) {
  var c2 = K;
  K |= 2;
  var d2 = Jk();
  if (Q !== a2 || Z !== b2) uk = null, Kk(a2, b2);
  do
    try {
      Tk();
      break;
    } catch (e2) {
      Mk(a2, e2);
    }
  while (1);
  $g();
  K = c2;
  mk.current = d2;
  if (null !== Y) throw Error(p$3(261));
  Q = null;
  Z = 0;
  return T$1;
}
function Tk() {
  for (; null !== Y; ) Uk(Y);
}
function Lk() {
  for (; null !== Y && !cc(); ) Uk(Y);
}
function Uk(a2) {
  var b2 = Vk(a2.alternate, a2, fj);
  a2.memoizedProps = a2.pendingProps;
  null === b2 ? Sk(a2) : Y = b2;
  nk.current = null;
}
function Sk(a2) {
  var b2 = a2;
  do {
    var c2 = b2.alternate;
    a2 = b2.return;
    if (0 === (b2.flags & 32768)) {
      if (c2 = Ej(c2, b2, fj), null !== c2) {
        Y = c2;
        return;
      }
    } else {
      c2 = Ij(c2, b2);
      if (null !== c2) {
        c2.flags &= 32767;
        Y = c2;
        return;
      }
      if (null !== a2) a2.flags |= 32768, a2.subtreeFlags = 0, a2.deletions = null;
      else {
        T$1 = 6;
        Y = null;
        return;
      }
    }
    b2 = b2.sibling;
    if (null !== b2) {
      Y = b2;
      return;
    }
    Y = b2 = a2;
  } while (null !== b2);
  0 === T$1 && (T$1 = 5);
}
function Pk(a2, b2, c2) {
  var d2 = C$1, e2 = ok.transition;
  try {
    ok.transition = null, C$1 = 1, Wk(a2, b2, c2, d2);
  } finally {
    ok.transition = e2, C$1 = d2;
  }
  return null;
}
function Wk(a2, b2, c2, d2) {
  do
    Hk();
  while (null !== wk);
  if (0 !== (K & 6)) throw Error(p$3(327));
  c2 = a2.finishedWork;
  var e2 = a2.finishedLanes;
  if (null === c2) return null;
  a2.finishedWork = null;
  a2.finishedLanes = 0;
  if (c2 === a2.current) throw Error(p$3(177));
  a2.callbackNode = null;
  a2.callbackPriority = 0;
  var f2 = c2.lanes | c2.childLanes;
  Bc(a2, f2);
  a2 === Q && (Y = Q = null, Z = 0);
  0 === (c2.subtreeFlags & 2064) && 0 === (c2.flags & 2064) || vk || (vk = true, Fk(hc, function() {
    Hk();
    return null;
  }));
  f2 = 0 !== (c2.flags & 15990);
  if (0 !== (c2.subtreeFlags & 15990) || f2) {
    f2 = ok.transition;
    ok.transition = null;
    var g2 = C$1;
    C$1 = 1;
    var h2 = K;
    K |= 4;
    nk.current = null;
    Oj(a2, c2);
    dk(c2, a2);
    Oe(Df);
    dd = !!Cf;
    Df = Cf = null;
    a2.current = c2;
    hk(c2);
    dc();
    K = h2;
    C$1 = g2;
    ok.transition = f2;
  } else a2.current = c2;
  vk && (vk = false, wk = a2, xk = e2);
  f2 = a2.pendingLanes;
  0 === f2 && (Ri = null);
  mc(c2.stateNode);
  Dk(a2, B());
  if (null !== b2) for (d2 = a2.onRecoverableError, c2 = 0; c2 < b2.length; c2++) e2 = b2[c2], d2(e2.value, { componentStack: e2.stack, digest: e2.digest });
  if (Oi) throw Oi = false, a2 = Pi, Pi = null, a2;
  0 !== (xk & 1) && 0 !== a2.tag && Hk();
  f2 = a2.pendingLanes;
  0 !== (f2 & 1) ? a2 === zk ? yk++ : (yk = 0, zk = a2) : yk = 0;
  jg();
  return null;
}
function Hk() {
  if (null !== wk) {
    var a2 = Dc(xk), b2 = ok.transition, c2 = C$1;
    try {
      ok.transition = null;
      C$1 = 16 > a2 ? 16 : a2;
      if (null === wk) var d2 = false;
      else {
        a2 = wk;
        wk = null;
        xk = 0;
        if (0 !== (K & 6)) throw Error(p$3(331));
        var e2 = K;
        K |= 4;
        for (V$1 = a2.current; null !== V$1; ) {
          var f2 = V$1, g2 = f2.child;
          if (0 !== (V$1.flags & 16)) {
            var h2 = f2.deletions;
            if (null !== h2) {
              for (var k2 = 0; k2 < h2.length; k2++) {
                var l2 = h2[k2];
                for (V$1 = l2; null !== V$1; ) {
                  var m2 = V$1;
                  switch (m2.tag) {
                    case 0:
                    case 11:
                    case 15:
                      Pj(8, m2, f2);
                  }
                  var q2 = m2.child;
                  if (null !== q2) q2.return = m2, V$1 = q2;
                  else for (; null !== V$1; ) {
                    m2 = V$1;
                    var r2 = m2.sibling, y2 = m2.return;
                    Sj(m2);
                    if (m2 === l2) {
                      V$1 = null;
                      break;
                    }
                    if (null !== r2) {
                      r2.return = y2;
                      V$1 = r2;
                      break;
                    }
                    V$1 = y2;
                  }
                }
              }
              var n2 = f2.alternate;
              if (null !== n2) {
                var t2 = n2.child;
                if (null !== t2) {
                  n2.child = null;
                  do {
                    var J2 = t2.sibling;
                    t2.sibling = null;
                    t2 = J2;
                  } while (null !== t2);
                }
              }
              V$1 = f2;
            }
          }
          if (0 !== (f2.subtreeFlags & 2064) && null !== g2) g2.return = f2, V$1 = g2;
          else b: for (; null !== V$1; ) {
            f2 = V$1;
            if (0 !== (f2.flags & 2048)) switch (f2.tag) {
              case 0:
              case 11:
              case 15:
                Pj(9, f2, f2.return);
            }
            var x2 = f2.sibling;
            if (null !== x2) {
              x2.return = f2.return;
              V$1 = x2;
              break b;
            }
            V$1 = f2.return;
          }
        }
        var w2 = a2.current;
        for (V$1 = w2; null !== V$1; ) {
          g2 = V$1;
          var u2 = g2.child;
          if (0 !== (g2.subtreeFlags & 2064) && null !== u2) u2.return = g2, V$1 = u2;
          else b: for (g2 = w2; null !== V$1; ) {
            h2 = V$1;
            if (0 !== (h2.flags & 2048)) try {
              switch (h2.tag) {
                case 0:
                case 11:
                case 15:
                  Qj(9, h2);
              }
            } catch (na) {
              W(h2, h2.return, na);
            }
            if (h2 === g2) {
              V$1 = null;
              break b;
            }
            var F2 = h2.sibling;
            if (null !== F2) {
              F2.return = h2.return;
              V$1 = F2;
              break b;
            }
            V$1 = h2.return;
          }
        }
        K = e2;
        jg();
        if (lc && "function" === typeof lc.onPostCommitFiberRoot) try {
          lc.onPostCommitFiberRoot(kc, a2);
        } catch (na) {
        }
        d2 = true;
      }
      return d2;
    } finally {
      C$1 = c2, ok.transition = b2;
    }
  }
  return false;
}
function Xk(a2, b2, c2) {
  b2 = Ji(c2, b2);
  b2 = Ni(a2, b2, 1);
  a2 = nh(a2, b2, 1);
  b2 = R$1();
  null !== a2 && (Ac(a2, 1, b2), Dk(a2, b2));
}
function W(a2, b2, c2) {
  if (3 === a2.tag) Xk(a2, a2, c2);
  else for (; null !== b2; ) {
    if (3 === b2.tag) {
      Xk(b2, a2, c2);
      break;
    } else if (1 === b2.tag) {
      var d2 = b2.stateNode;
      if ("function" === typeof b2.type.getDerivedStateFromError || "function" === typeof d2.componentDidCatch && (null === Ri || !Ri.has(d2))) {
        a2 = Ji(c2, a2);
        a2 = Qi(b2, a2, 1);
        b2 = nh(b2, a2, 1);
        a2 = R$1();
        null !== b2 && (Ac(b2, 1, a2), Dk(b2, a2));
        break;
      }
    }
    b2 = b2.return;
  }
}
function Ti(a2, b2, c2) {
  var d2 = a2.pingCache;
  null !== d2 && d2.delete(b2);
  b2 = R$1();
  a2.pingedLanes |= a2.suspendedLanes & c2;
  Q === a2 && (Z & c2) === c2 && (4 === T$1 || 3 === T$1 && (Z & 130023424) === Z && 500 > B() - fk ? Kk(a2, 0) : rk |= c2);
  Dk(a2, b2);
}
function Yk(a2, b2) {
  0 === b2 && (0 === (a2.mode & 1) ? b2 = 1 : (b2 = sc, sc <<= 1, 0 === (sc & 130023424) && (sc = 4194304)));
  var c2 = R$1();
  a2 = ih(a2, b2);
  null !== a2 && (Ac(a2, b2, c2), Dk(a2, c2));
}
function uj(a2) {
  var b2 = a2.memoizedState, c2 = 0;
  null !== b2 && (c2 = b2.retryLane);
  Yk(a2, c2);
}
function bk(a2, b2) {
  var c2 = 0;
  switch (a2.tag) {
    case 13:
      var d2 = a2.stateNode;
      var e2 = a2.memoizedState;
      null !== e2 && (c2 = e2.retryLane);
      break;
    case 19:
      d2 = a2.stateNode;
      break;
    default:
      throw Error(p$3(314));
  }
  null !== d2 && d2.delete(b2);
  Yk(a2, c2);
}
var Vk;
Vk = function(a2, b2, c2) {
  if (null !== a2) if (a2.memoizedProps !== b2.pendingProps || Wf.current) dh = true;
  else {
    if (0 === (a2.lanes & c2) && 0 === (b2.flags & 128)) return dh = false, yj(a2, b2, c2);
    dh = 0 !== (a2.flags & 131072) ? true : false;
  }
  else dh = false, I$1 && 0 !== (b2.flags & 1048576) && ug(b2, ng, b2.index);
  b2.lanes = 0;
  switch (b2.tag) {
    case 2:
      var d2 = b2.type;
      ij(a2, b2);
      a2 = b2.pendingProps;
      var e2 = Yf(b2, H.current);
      ch(b2, c2);
      e2 = Nh(null, b2, d2, a2, e2, c2);
      var f2 = Sh();
      b2.flags |= 1;
      "object" === typeof e2 && null !== e2 && "function" === typeof e2.render && void 0 === e2.$$typeof ? (b2.tag = 1, b2.memoizedState = null, b2.updateQueue = null, Zf(d2) ? (f2 = true, cg(b2)) : f2 = false, b2.memoizedState = null !== e2.state && void 0 !== e2.state ? e2.state : null, kh(b2), e2.updater = Ei, b2.stateNode = e2, e2._reactInternals = b2, Ii(b2, d2, a2, c2), b2 = jj(null, b2, d2, true, f2, c2)) : (b2.tag = 0, I$1 && f2 && vg(b2), Xi(null, b2, e2, c2), b2 = b2.child);
      return b2;
    case 16:
      d2 = b2.elementType;
      a: {
        ij(a2, b2);
        a2 = b2.pendingProps;
        e2 = d2._init;
        d2 = e2(d2._payload);
        b2.type = d2;
        e2 = b2.tag = Zk(d2);
        a2 = Ci(d2, a2);
        switch (e2) {
          case 0:
            b2 = cj(null, b2, d2, a2, c2);
            break a;
          case 1:
            b2 = hj(null, b2, d2, a2, c2);
            break a;
          case 11:
            b2 = Yi(null, b2, d2, a2, c2);
            break a;
          case 14:
            b2 = $i(null, b2, d2, Ci(d2.type, a2), c2);
            break a;
        }
        throw Error(p$3(
          306,
          d2,
          ""
        ));
      }
      return b2;
    case 0:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), cj(a2, b2, d2, e2, c2);
    case 1:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), hj(a2, b2, d2, e2, c2);
    case 3:
      a: {
        kj(b2);
        if (null === a2) throw Error(p$3(387));
        d2 = b2.pendingProps;
        f2 = b2.memoizedState;
        e2 = f2.element;
        lh(a2, b2);
        qh(b2, d2, null, c2);
        var g2 = b2.memoizedState;
        d2 = g2.element;
        if (f2.isDehydrated) if (f2 = { element: d2, isDehydrated: false, cache: g2.cache, pendingSuspenseBoundaries: g2.pendingSuspenseBoundaries, transitions: g2.transitions }, b2.updateQueue.baseState = f2, b2.memoizedState = f2, b2.flags & 256) {
          e2 = Ji(Error(p$3(423)), b2);
          b2 = lj(a2, b2, d2, c2, e2);
          break a;
        } else if (d2 !== e2) {
          e2 = Ji(Error(p$3(424)), b2);
          b2 = lj(a2, b2, d2, c2, e2);
          break a;
        } else for (yg = Lf(b2.stateNode.containerInfo.firstChild), xg = b2, I$1 = true, zg = null, c2 = Vg(b2, null, d2, c2), b2.child = c2; c2; ) c2.flags = c2.flags & -3 | 4096, c2 = c2.sibling;
        else {
          Ig();
          if (d2 === e2) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
          Xi(a2, b2, d2, c2);
        }
        b2 = b2.child;
      }
      return b2;
    case 5:
      return Ah(b2), null === a2 && Eg(b2), d2 = b2.type, e2 = b2.pendingProps, f2 = null !== a2 ? a2.memoizedProps : null, g2 = e2.children, Ef(d2, e2) ? g2 = null : null !== f2 && Ef(d2, f2) && (b2.flags |= 32), gj(a2, b2), Xi(a2, b2, g2, c2), b2.child;
    case 6:
      return null === a2 && Eg(b2), null;
    case 13:
      return oj(a2, b2, c2);
    case 4:
      return yh(b2, b2.stateNode.containerInfo), d2 = b2.pendingProps, null === a2 ? b2.child = Ug(b2, null, d2, c2) : Xi(a2, b2, d2, c2), b2.child;
    case 11:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), Yi(a2, b2, d2, e2, c2);
    case 7:
      return Xi(a2, b2, b2.pendingProps, c2), b2.child;
    case 8:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 12:
      return Xi(a2, b2, b2.pendingProps.children, c2), b2.child;
    case 10:
      a: {
        d2 = b2.type._context;
        e2 = b2.pendingProps;
        f2 = b2.memoizedProps;
        g2 = e2.value;
        G(Wg, d2._currentValue);
        d2._currentValue = g2;
        if (null !== f2) if (He(f2.value, g2)) {
          if (f2.children === e2.children && !Wf.current) {
            b2 = Zi(a2, b2, c2);
            break a;
          }
        } else for (f2 = b2.child, null !== f2 && (f2.return = b2); null !== f2; ) {
          var h2 = f2.dependencies;
          if (null !== h2) {
            g2 = f2.child;
            for (var k2 = h2.firstContext; null !== k2; ) {
              if (k2.context === d2) {
                if (1 === f2.tag) {
                  k2 = mh(-1, c2 & -c2);
                  k2.tag = 2;
                  var l2 = f2.updateQueue;
                  if (null !== l2) {
                    l2 = l2.shared;
                    var m2 = l2.pending;
                    null === m2 ? k2.next = k2 : (k2.next = m2.next, m2.next = k2);
                    l2.pending = k2;
                  }
                }
                f2.lanes |= c2;
                k2 = f2.alternate;
                null !== k2 && (k2.lanes |= c2);
                bh(
                  f2.return,
                  c2,
                  b2
                );
                h2.lanes |= c2;
                break;
              }
              k2 = k2.next;
            }
          } else if (10 === f2.tag) g2 = f2.type === b2.type ? null : f2.child;
          else if (18 === f2.tag) {
            g2 = f2.return;
            if (null === g2) throw Error(p$3(341));
            g2.lanes |= c2;
            h2 = g2.alternate;
            null !== h2 && (h2.lanes |= c2);
            bh(g2, c2, b2);
            g2 = f2.sibling;
          } else g2 = f2.child;
          if (null !== g2) g2.return = f2;
          else for (g2 = f2; null !== g2; ) {
            if (g2 === b2) {
              g2 = null;
              break;
            }
            f2 = g2.sibling;
            if (null !== f2) {
              f2.return = g2.return;
              g2 = f2;
              break;
            }
            g2 = g2.return;
          }
          f2 = g2;
        }
        Xi(a2, b2, e2.children, c2);
        b2 = b2.child;
      }
      return b2;
    case 9:
      return e2 = b2.type, d2 = b2.pendingProps.children, ch(b2, c2), e2 = eh(e2), d2 = d2(e2), b2.flags |= 1, Xi(a2, b2, d2, c2), b2.child;
    case 14:
      return d2 = b2.type, e2 = Ci(d2, b2.pendingProps), e2 = Ci(d2.type, e2), $i(a2, b2, d2, e2, c2);
    case 15:
      return bj(a2, b2, b2.type, b2.pendingProps, c2);
    case 17:
      return d2 = b2.type, e2 = b2.pendingProps, e2 = b2.elementType === d2 ? e2 : Ci(d2, e2), ij(a2, b2), b2.tag = 1, Zf(d2) ? (a2 = true, cg(b2)) : a2 = false, ch(b2, c2), Gi(b2, d2, e2), Ii(b2, d2, e2, c2), jj(null, b2, d2, true, a2, c2);
    case 19:
      return xj(a2, b2, c2);
    case 22:
      return dj(a2, b2, c2);
  }
  throw Error(p$3(156, b2.tag));
};
function Fk(a2, b2) {
  return ac(a2, b2);
}
function $k(a2, b2, c2, d2) {
  this.tag = a2;
  this.key = c2;
  this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null;
  this.index = 0;
  this.ref = null;
  this.pendingProps = b2;
  this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null;
  this.mode = d2;
  this.subtreeFlags = this.flags = 0;
  this.deletions = null;
  this.childLanes = this.lanes = 0;
  this.alternate = null;
}
function Bg(a2, b2, c2, d2) {
  return new $k(a2, b2, c2, d2);
}
function aj(a2) {
  a2 = a2.prototype;
  return !(!a2 || !a2.isReactComponent);
}
function Zk(a2) {
  if ("function" === typeof a2) return aj(a2) ? 1 : 0;
  if (void 0 !== a2 && null !== a2) {
    a2 = a2.$$typeof;
    if (a2 === Da) return 11;
    if (a2 === Ga) return 14;
  }
  return 2;
}
function Pg(a2, b2) {
  var c2 = a2.alternate;
  null === c2 ? (c2 = Bg(a2.tag, b2, a2.key, a2.mode), c2.elementType = a2.elementType, c2.type = a2.type, c2.stateNode = a2.stateNode, c2.alternate = a2, a2.alternate = c2) : (c2.pendingProps = b2, c2.type = a2.type, c2.flags = 0, c2.subtreeFlags = 0, c2.deletions = null);
  c2.flags = a2.flags & 14680064;
  c2.childLanes = a2.childLanes;
  c2.lanes = a2.lanes;
  c2.child = a2.child;
  c2.memoizedProps = a2.memoizedProps;
  c2.memoizedState = a2.memoizedState;
  c2.updateQueue = a2.updateQueue;
  b2 = a2.dependencies;
  c2.dependencies = null === b2 ? null : { lanes: b2.lanes, firstContext: b2.firstContext };
  c2.sibling = a2.sibling;
  c2.index = a2.index;
  c2.ref = a2.ref;
  return c2;
}
function Rg(a2, b2, c2, d2, e2, f2) {
  var g2 = 2;
  d2 = a2;
  if ("function" === typeof a2) aj(a2) && (g2 = 1);
  else if ("string" === typeof a2) g2 = 5;
  else a: switch (a2) {
    case ya:
      return Tg(c2.children, e2, f2, b2);
    case za:
      g2 = 8;
      e2 |= 8;
      break;
    case Aa:
      return a2 = Bg(12, c2, b2, e2 | 2), a2.elementType = Aa, a2.lanes = f2, a2;
    case Ea:
      return a2 = Bg(13, c2, b2, e2), a2.elementType = Ea, a2.lanes = f2, a2;
    case Fa:
      return a2 = Bg(19, c2, b2, e2), a2.elementType = Fa, a2.lanes = f2, a2;
    case Ia:
      return pj(c2, e2, f2, b2);
    default:
      if ("object" === typeof a2 && null !== a2) switch (a2.$$typeof) {
        case Ba:
          g2 = 10;
          break a;
        case Ca:
          g2 = 9;
          break a;
        case Da:
          g2 = 11;
          break a;
        case Ga:
          g2 = 14;
          break a;
        case Ha:
          g2 = 16;
          d2 = null;
          break a;
      }
      throw Error(p$3(130, null == a2 ? a2 : typeof a2, ""));
  }
  b2 = Bg(g2, c2, b2, e2);
  b2.elementType = a2;
  b2.type = d2;
  b2.lanes = f2;
  return b2;
}
function Tg(a2, b2, c2, d2) {
  a2 = Bg(7, a2, d2, b2);
  a2.lanes = c2;
  return a2;
}
function pj(a2, b2, c2, d2) {
  a2 = Bg(22, a2, d2, b2);
  a2.elementType = Ia;
  a2.lanes = c2;
  a2.stateNode = { isHidden: false };
  return a2;
}
function Qg(a2, b2, c2) {
  a2 = Bg(6, a2, null, b2);
  a2.lanes = c2;
  return a2;
}
function Sg(a2, b2, c2) {
  b2 = Bg(4, null !== a2.children ? a2.children : [], a2.key, b2);
  b2.lanes = c2;
  b2.stateNode = { containerInfo: a2.containerInfo, pendingChildren: null, implementation: a2.implementation };
  return b2;
}
function al(a2, b2, c2, d2, e2) {
  this.tag = b2;
  this.containerInfo = a2;
  this.finishedWork = this.pingCache = this.current = this.pendingChildren = null;
  this.timeoutHandle = -1;
  this.callbackNode = this.pendingContext = this.context = null;
  this.callbackPriority = 0;
  this.eventTimes = zc(0);
  this.expirationTimes = zc(-1);
  this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0;
  this.entanglements = zc(0);
  this.identifierPrefix = d2;
  this.onRecoverableError = e2;
  this.mutableSourceEagerHydrationData = null;
}
function bl(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = new al(a2, b2, c2, h2, k2);
  1 === b2 ? (b2 = 1, true === f2 && (b2 |= 8)) : b2 = 0;
  f2 = Bg(3, null, null, b2);
  a2.current = f2;
  f2.stateNode = a2;
  f2.memoizedState = { element: d2, isDehydrated: c2, cache: null, transitions: null, pendingSuspenseBoundaries: null };
  kh(f2);
  return a2;
}
function cl(a2, b2, c2) {
  var d2 = 3 < arguments.length && void 0 !== arguments[3] ? arguments[3] : null;
  return { $$typeof: wa, key: null == d2 ? null : "" + d2, children: a2, containerInfo: b2, implementation: c2 };
}
function dl(a2) {
  if (!a2) return Vf;
  a2 = a2._reactInternals;
  a: {
    if (Vb(a2) !== a2 || 1 !== a2.tag) throw Error(p$3(170));
    var b2 = a2;
    do {
      switch (b2.tag) {
        case 3:
          b2 = b2.stateNode.context;
          break a;
        case 1:
          if (Zf(b2.type)) {
            b2 = b2.stateNode.__reactInternalMemoizedMergedChildContext;
            break a;
          }
      }
      b2 = b2.return;
    } while (null !== b2);
    throw Error(p$3(171));
  }
  if (1 === a2.tag) {
    var c2 = a2.type;
    if (Zf(c2)) return bg(a2, c2, b2);
  }
  return b2;
}
function el(a2, b2, c2, d2, e2, f2, g2, h2, k2) {
  a2 = bl(c2, d2, true, a2, e2, f2, g2, h2, k2);
  a2.context = dl(null);
  c2 = a2.current;
  d2 = R$1();
  e2 = yi(c2);
  f2 = mh(d2, e2);
  f2.callback = void 0 !== b2 && null !== b2 ? b2 : null;
  nh(c2, f2, e2);
  a2.current.lanes = e2;
  Ac(a2, e2, d2);
  Dk(a2, d2);
  return a2;
}
function fl(a2, b2, c2, d2) {
  var e2 = b2.current, f2 = R$1(), g2 = yi(e2);
  c2 = dl(c2);
  null === b2.context ? b2.context = c2 : b2.pendingContext = c2;
  b2 = mh(f2, g2);
  b2.payload = { element: a2 };
  d2 = void 0 === d2 ? null : d2;
  null !== d2 && (b2.callback = d2);
  a2 = nh(e2, b2, g2);
  null !== a2 && (gi(a2, e2, g2, f2), oh(a2, e2, g2));
  return g2;
}
function gl(a2) {
  a2 = a2.current;
  if (!a2.child) return null;
  switch (a2.child.tag) {
    case 5:
      return a2.child.stateNode;
    default:
      return a2.child.stateNode;
  }
}
function hl(a2, b2) {
  a2 = a2.memoizedState;
  if (null !== a2 && null !== a2.dehydrated) {
    var c2 = a2.retryLane;
    a2.retryLane = 0 !== c2 && c2 < b2 ? c2 : b2;
  }
}
function il(a2, b2) {
  hl(a2, b2);
  (a2 = a2.alternate) && hl(a2, b2);
}
function jl() {
  return null;
}
var kl = "function" === typeof reportError ? reportError : function(a2) {
  console.error(a2);
};
function ll(a2) {
  this._internalRoot = a2;
}
ml.prototype.render = ll.prototype.render = function(a2) {
  var b2 = this._internalRoot;
  if (null === b2) throw Error(p$3(409));
  fl(a2, b2, null, null);
};
ml.prototype.unmount = ll.prototype.unmount = function() {
  var a2 = this._internalRoot;
  if (null !== a2) {
    this._internalRoot = null;
    var b2 = a2.containerInfo;
    Rk(function() {
      fl(null, a2, null, null);
    });
    b2[uf] = null;
  }
};
function ml(a2) {
  this._internalRoot = a2;
}
ml.prototype.unstable_scheduleHydration = function(a2) {
  if (a2) {
    var b2 = Hc();
    a2 = { blockedOn: null, target: a2, priority: b2 };
    for (var c2 = 0; c2 < Qc.length && 0 !== b2 && b2 < Qc[c2].priority; c2++) ;
    Qc.splice(c2, 0, a2);
    0 === c2 && Vc(a2);
  }
};
function nl(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType);
}
function ol(a2) {
  return !(!a2 || 1 !== a2.nodeType && 9 !== a2.nodeType && 11 !== a2.nodeType && (8 !== a2.nodeType || " react-mount-point-unstable " !== a2.nodeValue));
}
function pl() {
}
function ql(a2, b2, c2, d2, e2) {
  if (e2) {
    if ("function" === typeof d2) {
      var f2 = d2;
      d2 = function() {
        var a3 = gl(g2);
        f2.call(a3);
      };
    }
    var g2 = el(b2, d2, a2, 0, null, false, false, "", pl);
    a2._reactRootContainer = g2;
    a2[uf] = g2.current;
    sf(8 === a2.nodeType ? a2.parentNode : a2);
    Rk();
    return g2;
  }
  for (; e2 = a2.lastChild; ) a2.removeChild(e2);
  if ("function" === typeof d2) {
    var h2 = d2;
    d2 = function() {
      var a3 = gl(k2);
      h2.call(a3);
    };
  }
  var k2 = bl(a2, 0, false, null, null, false, false, "", pl);
  a2._reactRootContainer = k2;
  a2[uf] = k2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  Rk(function() {
    fl(b2, k2, c2, d2);
  });
  return k2;
}
function rl(a2, b2, c2, d2, e2) {
  var f2 = c2._reactRootContainer;
  if (f2) {
    var g2 = f2;
    if ("function" === typeof e2) {
      var h2 = e2;
      e2 = function() {
        var a3 = gl(g2);
        h2.call(a3);
      };
    }
    fl(b2, g2, a2, e2);
  } else g2 = ql(c2, b2, a2, e2, d2);
  return gl(g2);
}
Ec = function(a2) {
  switch (a2.tag) {
    case 3:
      var b2 = a2.stateNode;
      if (b2.current.memoizedState.isDehydrated) {
        var c2 = tc(b2.pendingLanes);
        0 !== c2 && (Cc(b2, c2 | 1), Dk(b2, B()), 0 === (K & 6) && (Gj = B() + 500, jg()));
      }
      break;
    case 13:
      Rk(function() {
        var b3 = ih(a2, 1);
        if (null !== b3) {
          var c3 = R$1();
          gi(b3, a2, 1, c3);
        }
      }), il(a2, 1);
  }
};
Fc = function(a2) {
  if (13 === a2.tag) {
    var b2 = ih(a2, 134217728);
    if (null !== b2) {
      var c2 = R$1();
      gi(b2, a2, 134217728, c2);
    }
    il(a2, 134217728);
  }
};
Gc = function(a2) {
  if (13 === a2.tag) {
    var b2 = yi(a2), c2 = ih(a2, b2);
    if (null !== c2) {
      var d2 = R$1();
      gi(c2, a2, b2, d2);
    }
    il(a2, b2);
  }
};
Hc = function() {
  return C$1;
};
Ic = function(a2, b2) {
  var c2 = C$1;
  try {
    return C$1 = a2, b2();
  } finally {
    C$1 = c2;
  }
};
yb = function(a2, b2, c2) {
  switch (b2) {
    case "input":
      bb(a2, c2);
      b2 = c2.name;
      if ("radio" === c2.type && null != b2) {
        for (c2 = a2; c2.parentNode; ) c2 = c2.parentNode;
        c2 = c2.querySelectorAll("input[name=" + JSON.stringify("" + b2) + '][type="radio"]');
        for (b2 = 0; b2 < c2.length; b2++) {
          var d2 = c2[b2];
          if (d2 !== a2 && d2.form === a2.form) {
            var e2 = Db(d2);
            if (!e2) throw Error(p$3(90));
            Wa(d2);
            bb(d2, e2);
          }
        }
      }
      break;
    case "textarea":
      ib(a2, c2);
      break;
    case "select":
      b2 = c2.value, null != b2 && fb(a2, !!c2.multiple, b2, false);
  }
};
Gb = Qk;
Hb = Rk;
var sl = { usingClientEntryPoint: false, Events: [Cb, ue, Db, Eb, Fb, Qk] }, tl = { findFiberByHostInstance: Wc, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" };
var ul = { bundleType: tl.bundleType, version: tl.version, rendererPackageName: tl.rendererPackageName, rendererConfig: tl.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: ua.ReactCurrentDispatcher, findHostInstanceByFiber: function(a2) {
  a2 = Zb(a2);
  return null === a2 ? null : a2.stateNode;
}, findFiberByHostInstance: tl.findFiberByHostInstance || jl, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" };
if ("undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__) {
  var vl = __REACT_DEVTOOLS_GLOBAL_HOOK__;
  if (!vl.isDisabled && vl.supportsFiber) try {
    kc = vl.inject(ul), lc = vl;
  } catch (a2) {
  }
}
reactDom_production_min.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = sl;
reactDom_production_min.createPortal = function(a2, b2) {
  var c2 = 2 < arguments.length && void 0 !== arguments[2] ? arguments[2] : null;
  if (!nl(b2)) throw Error(p$3(200));
  return cl(a2, b2, null, c2);
};
reactDom_production_min.createRoot = function(a2, b2) {
  if (!nl(a2)) throw Error(p$3(299));
  var c2 = false, d2 = "", e2 = kl;
  null !== b2 && void 0 !== b2 && (true === b2.unstable_strictMode && (c2 = true), void 0 !== b2.identifierPrefix && (d2 = b2.identifierPrefix), void 0 !== b2.onRecoverableError && (e2 = b2.onRecoverableError));
  b2 = bl(a2, 1, false, null, null, c2, false, d2, e2);
  a2[uf] = b2.current;
  sf(8 === a2.nodeType ? a2.parentNode : a2);
  return new ll(b2);
};
reactDom_production_min.findDOMNode = function(a2) {
  if (null == a2) return null;
  if (1 === a2.nodeType) return a2;
  var b2 = a2._reactInternals;
  if (void 0 === b2) {
    if ("function" === typeof a2.render) throw Error(p$3(188));
    a2 = Object.keys(a2).join(",");
    throw Error(p$3(268, a2));
  }
  a2 = Zb(b2);
  a2 = null === a2 ? null : a2.stateNode;
  return a2;
};
reactDom_production_min.flushSync = function(a2) {
  return Rk(a2);
};
reactDom_production_min.hydrate = function(a2, b2, c2) {
  if (!ol(b2)) throw Error(p$3(200));
  return rl(null, a2, b2, true, c2);
};
reactDom_production_min.hydrateRoot = function(a2, b2, c2) {
  if (!nl(a2)) throw Error(p$3(405));
  var d2 = null != c2 && c2.hydratedSources || null, e2 = false, f2 = "", g2 = kl;
  null !== c2 && void 0 !== c2 && (true === c2.unstable_strictMode && (e2 = true), void 0 !== c2.identifierPrefix && (f2 = c2.identifierPrefix), void 0 !== c2.onRecoverableError && (g2 = c2.onRecoverableError));
  b2 = el(b2, null, a2, 1, null != c2 ? c2 : null, e2, false, f2, g2);
  a2[uf] = b2.current;
  sf(a2);
  if (d2) for (a2 = 0; a2 < d2.length; a2++) c2 = d2[a2], e2 = c2._getVersion, e2 = e2(c2._source), null == b2.mutableSourceEagerHydrationData ? b2.mutableSourceEagerHydrationData = [c2, e2] : b2.mutableSourceEagerHydrationData.push(
    c2,
    e2
  );
  return new ml(b2);
};
reactDom_production_min.render = function(a2, b2, c2) {
  if (!ol(b2)) throw Error(p$3(200));
  return rl(null, a2, b2, false, c2);
};
reactDom_production_min.unmountComponentAtNode = function(a2) {
  if (!ol(a2)) throw Error(p$3(40));
  return a2._reactRootContainer ? (Rk(function() {
    rl(null, null, a2, false, function() {
      a2._reactRootContainer = null;
      a2[uf] = null;
    });
  }), true) : false;
};
reactDom_production_min.unstable_batchedUpdates = Qk;
reactDom_production_min.unstable_renderSubtreeIntoContainer = function(a2, b2, c2, d2) {
  if (!ol(c2)) throw Error(p$3(200));
  if (null == a2 || void 0 === a2._reactInternals) throw Error(p$3(38));
  return rl(a2, b2, c2, false, d2);
};
reactDom_production_min.version = "18.3.1-next-f1338f8080-20240426";
function checkDCE() {
  if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE !== "function") {
    return;
  }
  try {
    __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(checkDCE);
  } catch (err) {
    console.error(err);
  }
}
{
  checkDCE();
  reactDom.exports = reactDom_production_min;
}
var reactDomExports = reactDom.exports;
const ReactDOM = /* @__PURE__ */ getDefaultExportFromCjs(reactDomExports);
var m$3 = reactDomExports;
{
  client.createRoot = m$3.createRoot;
  client.hydrateRoot = m$3.hydrateRoot;
}
const pushStateEvent = "pushstate";
const popStateEvent = "popstate";
const beforeUnloadEvent = "beforeunload";
const beforeUnloadListener = (event) => {
  event.preventDefault();
  return event.returnValue = "";
};
const stopBlocking = () => {
  removeEventListener(beforeUnloadEvent, beforeUnloadListener, {
    capture: true
  });
};
function createHistory(opts) {
  let location = opts.getLocation();
  const subscribers = /* @__PURE__ */ new Set();
  let blockers = [];
  const notify = () => {
    location = opts.getLocation();
    subscribers.forEach((subscriber) => subscriber());
  };
  const tryNavigation = async (task, navigateOpts) => {
    var _a;
    const ignoreBlocker = (navigateOpts == null ? void 0 : navigateOpts.ignoreBlocker) ?? false;
    if (!ignoreBlocker && typeof document !== "undefined" && blockers.length) {
      for (const blocker of blockers) {
        const allowed = await blocker();
        if (!allowed) {
          (_a = opts.onBlocked) == null ? void 0 : _a.call(opts, notify);
          return;
        }
      }
    }
    task();
  };
  return {
    get location() {
      return location;
    },
    subscribers,
    subscribe: (cb2) => {
      subscribers.add(cb2);
      return () => {
        subscribers.delete(cb2);
      };
    },
    push: (path2, state, navigateOpts) => {
      state = assignKey(state);
      tryNavigation(() => {
        opts.pushState(path2, state);
        notify();
      }, navigateOpts);
    },
    replace: (path2, state, navigateOpts) => {
      state = assignKey(state);
      tryNavigation(() => {
        opts.replaceState(path2, state);
        notify();
      }, navigateOpts);
    },
    go: (index2, navigateOpts) => {
      tryNavigation(() => {
        opts.go(index2);
        notify();
      }, navigateOpts);
    },
    back: (navigateOpts) => {
      tryNavigation(() => {
        opts.back();
        notify();
      }, navigateOpts);
    },
    forward: (navigateOpts) => {
      tryNavigation(() => {
        opts.forward();
        notify();
      }, navigateOpts);
    },
    createHref: (str) => opts.createHref(str),
    block: (blocker) => {
      blockers.push(blocker);
      if (blockers.length === 1) {
        addEventListener(beforeUnloadEvent, beforeUnloadListener, {
          capture: true
        });
      }
      return () => {
        blockers = blockers.filter((b2) => b2 !== blocker);
        if (!blockers.length) {
          stopBlocking();
        }
      };
    },
    flush: () => {
      var _a;
      return (_a = opts.flush) == null ? void 0 : _a.call(opts);
    },
    destroy: () => {
      var _a;
      return (_a = opts.destroy) == null ? void 0 : _a.call(opts);
    },
    notify
  };
}
function assignKey(state) {
  if (!state) {
    state = {};
  }
  return {
    ...state,
    key: createRandomKey()
  };
}
function createBrowserHistory(opts) {
  const win = typeof document !== "undefined" ? window : void 0;
  const originalPushState = win.history.pushState;
  const originalReplaceState = win.history.replaceState;
  const createHref = (path2) => path2;
  const parseLocation = () => parseHref(
    `${win.location.pathname}${win.location.search}${win.location.hash}`,
    win.history.state
  );
  let currentLocation = parseLocation();
  let rollbackLocation;
  const getLocation = () => currentLocation;
  let next;
  let scheduled;
  const flush = () => {
    if (!next) {
      return;
    }
    history._ignoreSubscribers = true;
    (next.isPush ? win.history.pushState : win.history.replaceState)(
      next.state,
      "",
      next.href
    );
    history._ignoreSubscribers = false;
    next = void 0;
    scheduled = void 0;
    rollbackLocation = void 0;
  };
  const queueHistoryAction = (type, destHref, state) => {
    const href = createHref(destHref);
    if (!scheduled) {
      rollbackLocation = currentLocation;
    }
    currentLocation = parseHref(destHref, state);
    next = {
      href,
      state,
      isPush: (next == null ? void 0 : next.isPush) || type === "push"
    };
    if (!scheduled) {
      scheduled = Promise.resolve().then(() => flush());
    }
  };
  const onPushPop = () => {
    currentLocation = parseLocation();
    history.notify();
  };
  const history = createHistory({
    getLocation,
    pushState: (href, state) => queueHistoryAction("push", href, state),
    replaceState: (href, state) => queueHistoryAction("replace", href, state),
    back: () => win.history.back(),
    forward: () => win.history.forward(),
    go: (n2) => win.history.go(n2),
    createHref: (href) => createHref(href),
    flush,
    destroy: () => {
      win.history.pushState = originalPushState;
      win.history.replaceState = originalReplaceState;
      win.removeEventListener(pushStateEvent, onPushPop);
      win.removeEventListener(popStateEvent, onPushPop);
    },
    onBlocked: (onUpdate) => {
      if (rollbackLocation && currentLocation !== rollbackLocation) {
        currentLocation = rollbackLocation;
        onUpdate();
      }
    }
  });
  win.addEventListener(pushStateEvent, onPushPop);
  win.addEventListener(popStateEvent, onPushPop);
  win.history.pushState = function(...args) {
    const res = originalPushState.apply(win.history, args);
    if (!history._ignoreSubscribers) onPushPop();
    return res;
  };
  win.history.replaceState = function(...args) {
    const res = originalReplaceState.apply(win.history, args);
    if (!history._ignoreSubscribers) onPushPop();
    return res;
  };
  return history;
}
function createMemoryHistory(opts = {
  initialEntries: ["/"]
}) {
  const entries = opts.initialEntries;
  let index2 = opts.initialIndex ?? entries.length - 1;
  let currentState = {
    key: createRandomKey()
  };
  const getLocation = () => parseHref(entries[index2], currentState);
  return createHistory({
    getLocation,
    pushState: (path2, state) => {
      currentState = state;
      if (index2 < entries.length - 1) {
        entries.splice(index2 + 1);
      }
      entries.push(path2);
      index2 = Math.max(entries.length - 1, 0);
    },
    replaceState: (path2, state) => {
      currentState = state;
      entries[index2] = path2;
    },
    back: () => {
      currentState = assignKey(currentState);
      index2 = Math.max(index2 - 1, 0);
    },
    forward: () => {
      currentState = assignKey(currentState);
      index2 = Math.min(index2 + 1, entries.length - 1);
    },
    go: (n2) => {
      currentState = assignKey(currentState);
      index2 = Math.min(Math.max(index2 + n2, 0), entries.length - 1);
    },
    createHref: (path2) => path2
  });
}
function parseHref(href, state) {
  const hashIndex = href.indexOf("#");
  const searchIndex = href.indexOf("?");
  return {
    href,
    pathname: href.substring(
      0,
      hashIndex > 0 ? searchIndex > 0 ? Math.min(hashIndex, searchIndex) : hashIndex : searchIndex > 0 ? searchIndex : href.length
    ),
    hash: hashIndex > -1 ? href.substring(hashIndex) : "",
    search: searchIndex > -1 ? href.slice(searchIndex, hashIndex === -1 ? void 0 : hashIndex) : "",
    state: state || {}
  };
}
function createRandomKey() {
  return (Math.random() + 1).toString(36).substring(7);
}
var prefix = "Invariant failed";
function invariant$1(condition, message) {
  if (condition) {
    return;
  }
  {
    throw new Error(prefix);
  }
}
function warning(condition, message) {
}
const routerContext = reactExports.createContext(null);
function getRouterContext() {
  if (typeof document === "undefined") {
    return routerContext;
  }
  if (window.__TSR_ROUTER_CONTEXT__) {
    return window.__TSR_ROUTER_CONTEXT__;
  }
  window.__TSR_ROUTER_CONTEXT__ = routerContext;
  return routerContext;
}
function useRouter(opts) {
  const value = reactExports.useContext(getRouterContext());
  warning(
    !(((opts == null ? void 0 : opts.warn) ?? true) && !value)
  );
  return value;
}
var withSelector = { exports: {} };
var withSelector_production_min = {};
var shim = { exports: {} };
var useSyncExternalStoreShim_production_min = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var e$1 = reactExports;
function h$3(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var k = "function" === typeof Object.is ? Object.is : h$3, l$1 = e$1.useState, m$2 = e$1.useEffect, n$3 = e$1.useLayoutEffect, p$2 = e$1.useDebugValue;
function q$2(a2, b2) {
  var d2 = b2(), f2 = l$1({ inst: { value: d2, getSnapshot: b2 } }), c2 = f2[0].inst, g2 = f2[1];
  n$3(function() {
    c2.value = d2;
    c2.getSnapshot = b2;
    r$5(c2) && g2({ inst: c2 });
  }, [a2, d2, b2]);
  m$2(function() {
    r$5(c2) && g2({ inst: c2 });
    return a2(function() {
      r$5(c2) && g2({ inst: c2 });
    });
  }, [a2]);
  p$2(d2);
  return d2;
}
function r$5(a2) {
  var b2 = a2.getSnapshot;
  a2 = a2.value;
  try {
    var d2 = b2();
    return !k(a2, d2);
  } catch (f2) {
    return true;
  }
}
function t$2(a2, b2) {
  return b2();
}
var u$3 = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? t$2 : q$2;
useSyncExternalStoreShim_production_min.useSyncExternalStore = void 0 !== e$1.useSyncExternalStore ? e$1.useSyncExternalStore : u$3;
{
  shim.exports = useSyncExternalStoreShim_production_min;
}
var shimExports = shim.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var h$2 = reactExports, n$2 = shimExports;
function p$1(a2, b2) {
  return a2 === b2 && (0 !== a2 || 1 / a2 === 1 / b2) || a2 !== a2 && b2 !== b2;
}
var q$1 = "function" === typeof Object.is ? Object.is : p$1, r$4 = n$2.useSyncExternalStore, t$1 = h$2.useRef, u$2 = h$2.useEffect, v$2 = h$2.useMemo, w$1 = h$2.useDebugValue;
withSelector_production_min.useSyncExternalStoreWithSelector = function(a2, b2, e2, l2, g2) {
  var c2 = t$1(null);
  if (null === c2.current) {
    var f2 = { hasValue: false, value: null };
    c2.current = f2;
  } else f2 = c2.current;
  c2 = v$2(function() {
    function a3(a4) {
      if (!c3) {
        c3 = true;
        d3 = a4;
        a4 = l2(a4);
        if (void 0 !== g2 && f2.hasValue) {
          var b3 = f2.value;
          if (g2(b3, a4)) return k2 = b3;
        }
        return k2 = a4;
      }
      b3 = k2;
      if (q$1(d3, a4)) return b3;
      var e3 = l2(a4);
      if (void 0 !== g2 && g2(b3, e3)) return b3;
      d3 = a4;
      return k2 = e3;
    }
    var c3 = false, d3, k2, m2 = void 0 === e2 ? null : e2;
    return [function() {
      return a3(b2());
    }, null === m2 ? void 0 : function() {
      return a3(m2());
    }];
  }, [b2, e2, l2, g2]);
  var d2 = r$4(a2, c2[0], c2[1]);
  u$2(function() {
    f2.hasValue = true;
    f2.value = d2;
  }, [d2]);
  w$1(d2);
  return d2;
};
{
  withSelector.exports = withSelector_production_min;
}
var withSelectorExports = withSelector.exports;
class Store {
  constructor(initialState2, options) {
    this.listeners = /* @__PURE__ */ new Set();
    this._batching = false;
    this._flushing = 0;
    this.subscribe = (listener) => {
      var _a, _b;
      this.listeners.add(listener);
      const unsub = (_b = (_a = this.options) == null ? void 0 : _a.onSubscribe) == null ? void 0 : _b.call(_a, listener, this);
      return () => {
        this.listeners.delete(listener);
        unsub == null ? void 0 : unsub();
      };
    };
    this.setState = (updater) => {
      var _a, _b, _c;
      const previous = this.state;
      this.state = ((_a = this.options) == null ? void 0 : _a.updateFn) ? this.options.updateFn(previous)(updater) : updater(previous);
      (_c = (_b = this.options) == null ? void 0 : _b.onUpdate) == null ? void 0 : _c.call(_b);
      this._flush();
    };
    this._flush = () => {
      if (this._batching) return;
      const flushId = ++this._flushing;
      this.listeners.forEach((listener) => {
        if (this._flushing !== flushId) return;
        listener();
      });
    };
    this.batch = (cb2) => {
      if (this._batching) return cb2();
      this._batching = true;
      cb2();
      this._batching = false;
      this._flush();
    };
    this.state = initialState2;
    this.options = options;
  }
}
function useStore(store, selector = (d2) => d2) {
  const slice2 = withSelectorExports.useSyncExternalStoreWithSelector(
    store.subscribe,
    () => store.state,
    () => store.state,
    selector,
    shallow
  );
  return slice2;
}
function shallow(objA, objB) {
  if (Object.is(objA, objB)) {
    return true;
  }
  if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
    return false;
  }
  const keysA = Object.keys(objA);
  if (keysA.length !== Object.keys(objB).length) {
    return false;
  }
  for (let i2 = 0; i2 < keysA.length; i2++) {
    if (!Object.prototype.hasOwnProperty.call(objB, keysA[i2]) || !Object.is(objA[keysA[i2]], objB[keysA[i2]])) {
      return false;
    }
  }
  return true;
}
const rootRouteId = "__root__";
function encode(obj, pfx) {
  let k2, i2, tmp, str = "";
  for (k2 in obj) {
    if ((tmp = obj[k2]) !== void 0) {
      if (Array.isArray(tmp)) {
        for (i2 = 0; i2 < tmp.length; i2++) {
          str && (str += "&");
          str += encodeURIComponent(k2) + "=" + encodeURIComponent(tmp[i2]);
        }
      } else {
        str && (str += "&");
        str += encodeURIComponent(k2) + "=" + encodeURIComponent(tmp);
      }
    }
  }
  return "" + str;
}
function toValue$1(mix) {
  if (!mix) return "";
  const str = decodeURIComponent(mix);
  if (str === "false") return false;
  if (str === "true") return true;
  return +str * 0 === 0 && +str + "" === str ? +str : str;
}
function decode(str, pfx) {
  let tmp, k2;
  const out = {}, arr = str.split("&");
  while (tmp = arr.shift()) {
    const equalIndex = tmp.indexOf("=");
    if (equalIndex !== -1) {
      k2 = tmp.slice(0, equalIndex);
      k2 = decodeURIComponent(k2);
      const value = tmp.slice(equalIndex + 1);
      if (out[k2] !== void 0) {
        out[k2] = [].concat(out[k2], toValue$1(value));
      } else {
        out[k2] = toValue$1(value);
      }
    } else {
      k2 = tmp;
      k2 = decodeURIComponent(k2);
      out[k2] = "";
    }
  }
  return out;
}
const defaultParseSearch = parseSearchWith(JSON.parse);
const defaultStringifySearch = stringifySearchWith(
  JSON.stringify,
  JSON.parse
);
function parseSearchWith(parser) {
  return (searchStr) => {
    if (searchStr.substring(0, 1) === "?") {
      searchStr = searchStr.substring(1);
    }
    const query = decode(searchStr);
    for (const key in query) {
      const value = query[key];
      if (typeof value === "string") {
        try {
          query[key] = parser(value);
        } catch (err) {
        }
      }
    }
    return query;
  };
}
function stringifySearchWith(stringify, parser) {
  function stringifyValue(val) {
    if (typeof val === "object" && val !== null) {
      try {
        return stringify(val);
      } catch (err) {
      }
    } else if (typeof val === "string" && typeof parser === "function") {
      try {
        parser(val);
        return stringify(val);
      } catch (err) {
      }
    }
    return val;
  }
  return (search) => {
    search = { ...search };
    Object.keys(search).forEach((key) => {
      const val = search[key];
      if (typeof val === "undefined" || val === void 0) {
        delete search[key];
      } else {
        search[key] = stringifyValue(val);
      }
    });
    const searchStr = encode(search).toString();
    return searchStr ? `?${searchStr}` : "";
  };
}
function last(arr) {
  return arr[arr.length - 1];
}
function isFunction$1(d2) {
  return typeof d2 === "function";
}
function functionalUpdate(updater, previous) {
  if (isFunction$1(updater)) {
    return updater(previous);
  }
  return updater;
}
function pick(parent, keys) {
  return keys.reduce((obj, key) => {
    obj[key] = parent[key];
    return obj;
  }, {});
}
function replaceEqualDeep(prev, _next) {
  if (prev === _next) {
    return prev;
  }
  const next = _next;
  const array = isPlainArray(prev) && isPlainArray(next);
  if (array || isPlainObject$2(prev) && isPlainObject$2(next)) {
    const prevItems = array ? prev : Object.keys(prev);
    const prevSize = prevItems.length;
    const nextItems = array ? next : Object.keys(next);
    const nextSize = nextItems.length;
    const copy2 = array ? [] : {};
    let equalItems = 0;
    for (let i2 = 0; i2 < nextSize; i2++) {
      const key = array ? i2 : nextItems[i2];
      if ((!array && prevItems.includes(key) || array) && prev[key] === void 0 && next[key] === void 0) {
        copy2[key] = void 0;
        equalItems++;
      } else {
        copy2[key] = replaceEqualDeep(prev[key], next[key]);
        if (copy2[key] === prev[key] && prev[key] !== void 0) {
          equalItems++;
        }
      }
    }
    return prevSize === nextSize && equalItems === prevSize ? prev : copy2;
  }
  return next;
}
function isPlainObject$2(o2) {
  if (!hasObjectPrototype(o2)) {
    return false;
  }
  const ctor = o2.constructor;
  if (typeof ctor === "undefined") {
    return true;
  }
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot)) {
    return false;
  }
  if (!prot.hasOwnProperty("isPrototypeOf")) {
    return false;
  }
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function isPlainArray(value) {
  return Array.isArray(value) && value.length === Object.keys(value).length;
}
function deepEqual$2(a2, b2, partial = false) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (isPlainObject$2(a2) && isPlainObject$2(b2)) {
    const aKeys = Object.keys(a2).filter((key) => a2[key] !== void 0);
    const bKeys = Object.keys(b2).filter((key) => b2[key] !== void 0);
    if (!partial && aKeys.length !== bKeys.length) {
      return false;
    }
    return !bKeys.some(
      (key) => !(key in a2) || !deepEqual$2(a2[key], b2[key], partial)
    );
  }
  if (Array.isArray(a2) && Array.isArray(b2)) {
    if (a2.length !== b2.length) {
      return false;
    }
    return !a2.some((item, index2) => !deepEqual$2(item, b2[index2], partial));
  }
  return false;
}
const useLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function createControlledPromise(onResolve) {
  let resolveLoadPromise;
  let rejectLoadPromise;
  const controlledPromise = new Promise((resolve, reject) => {
    resolveLoadPromise = resolve;
    rejectLoadPromise = reject;
  });
  controlledPromise.status = "pending";
  controlledPromise.resolve = (value) => {
    controlledPromise.status = "resolved";
    controlledPromise.value = value;
    resolveLoadPromise(value);
    onResolve == null ? void 0 : onResolve(value);
  };
  controlledPromise.reject = (e2) => {
    controlledPromise.status = "rejected";
    rejectLoadPromise(e2);
  };
  return controlledPromise;
}
function usePrevious$2(value) {
  const ref = reactExports.useRef({
    value,
    prev: null
  });
  const current = ref.current.value;
  if (value !== current) {
    ref.current = {
      value,
      prev: current
    };
  }
  return ref.current.prev;
}
function joinPaths(paths) {
  return cleanPath(
    paths.filter((val) => {
      return val !== void 0;
    }).join("/")
  );
}
function cleanPath(path2) {
  return path2.replace(/\/{2,}/g, "/");
}
function trimPathLeft(path2) {
  return path2 === "/" ? path2 : path2.replace(/^\/{1,}/, "");
}
function trimPathRight(path2) {
  return path2 === "/" ? path2 : path2.replace(/\/{1,}$/, "");
}
function trimPath(path2) {
  return trimPathRight(trimPathLeft(path2));
}
function resolvePath({
  basepath,
  base,
  to,
  trailingSlash = "never"
}) {
  var _a, _b;
  base = removeBasepath(basepath, base);
  to = removeBasepath(basepath, to);
  let baseSegments = parsePathname(base);
  const toSegments = parsePathname(to);
  if (baseSegments.length > 1 && ((_a = last(baseSegments)) == null ? void 0 : _a.value) === "/") {
    baseSegments.pop();
  }
  toSegments.forEach((toSegment, index2) => {
    if (toSegment.value === "/") {
      if (!index2) {
        baseSegments = [toSegment];
      } else if (index2 === toSegments.length - 1) {
        baseSegments.push(toSegment);
      } else ;
    } else if (toSegment.value === "..") {
      baseSegments.pop();
    } else if (toSegment.value === ".") ;
    else {
      baseSegments.push(toSegment);
    }
  });
  if (baseSegments.length > 1) {
    if (((_b = last(baseSegments)) == null ? void 0 : _b.value) === "/") {
      if (trailingSlash === "never") {
        baseSegments.pop();
      }
    } else if (trailingSlash === "always") {
      baseSegments.push({ type: "pathname", value: "/" });
    }
  }
  const joined = joinPaths([basepath, ...baseSegments.map((d2) => d2.value)]);
  return cleanPath(joined);
}
function parsePathname(pathname) {
  if (!pathname) {
    return [];
  }
  pathname = cleanPath(pathname);
  const segments = [];
  if (pathname.slice(0, 1) === "/") {
    pathname = pathname.substring(1);
    segments.push({
      type: "pathname",
      value: "/"
    });
  }
  if (!pathname) {
    return segments;
  }
  const split = pathname.split("/").filter(Boolean);
  segments.push(
    ...split.map((part) => {
      if (part === "$" || part === "*") {
        return {
          type: "wildcard",
          value: part
        };
      }
      if (part.charAt(0) === "$") {
        return {
          type: "param",
          value: part
        };
      }
      return {
        type: "pathname",
        value: decodeURI(part)
      };
    })
  );
  if (pathname.slice(-1) === "/") {
    pathname = pathname.substring(1);
    segments.push({
      type: "pathname",
      value: "/"
    });
  }
  return segments;
}
function interpolatePath({
  path: path2,
  params,
  leaveWildcards,
  leaveParams
}) {
  const interpolatedPathSegments = parsePathname(path2);
  const encodedParams = {};
  for (const [key, value] of Object.entries(params)) {
    const isValueString = typeof value === "string";
    if (["*", "_splat"].includes(key)) {
      encodedParams[key] = isValueString ? encodeURI(value) : value;
    } else {
      encodedParams[key] = isValueString ? encodeURIComponent(value) : value;
    }
  }
  return joinPaths(
    interpolatedPathSegments.map((segment) => {
      if (segment.type === "wildcard") {
        const value = encodedParams._splat;
        if (leaveWildcards) return `${segment.value}${value ?? ""}`;
        return value;
      }
      if (segment.type === "param") {
        if (leaveParams) {
          const value = encodedParams[segment.value];
          return `${segment.value}${value ?? ""}`;
        }
        return encodedParams[segment.value.substring(1)] ?? "undefined";
      }
      return segment.value;
    })
  );
}
function matchPathname(basepath, currentPathname, matchLocation) {
  const pathParams = matchByPath(basepath, currentPathname, matchLocation);
  if (matchLocation.to && !pathParams) {
    return;
  }
  return pathParams ?? {};
}
function removeBasepath(basepath, pathname) {
  switch (true) {
    case basepath === "/":
      return pathname;
    case pathname === basepath:
      return "";
    case pathname.length < basepath.length:
      return pathname;
    case pathname[basepath.length] !== "/":
      return pathname;
    case pathname.startsWith(basepath):
      return pathname.slice(basepath.length);
    default:
      return pathname;
  }
}
function matchByPath(basepath, from, matchLocation) {
  from = removeBasepath(basepath, from);
  const to = removeBasepath(basepath, `${matchLocation.to ?? "$"}`);
  const baseSegments = parsePathname(from);
  const routeSegments = parsePathname(to);
  if (!from.startsWith("/")) {
    baseSegments.unshift({
      type: "pathname",
      value: "/"
    });
  }
  if (!to.startsWith("/")) {
    routeSegments.unshift({
      type: "pathname",
      value: "/"
    });
  }
  const params = {};
  const isMatch = (() => {
    for (let i2 = 0; i2 < Math.max(baseSegments.length, routeSegments.length); i2++) {
      const baseSegment = baseSegments[i2];
      const routeSegment = routeSegments[i2];
      const isLastBaseSegment = i2 >= baseSegments.length - 1;
      const isLastRouteSegment = i2 >= routeSegments.length - 1;
      if (routeSegment) {
        if (routeSegment.type === "wildcard") {
          const _splat = decodeURI(
            joinPaths(baseSegments.slice(i2).map((d2) => d2.value))
          );
          params["*"] = _splat;
          params["_splat"] = _splat;
          return true;
        }
        if (routeSegment.type === "pathname") {
          if (routeSegment.value === "/" && !(baseSegment == null ? void 0 : baseSegment.value)) {
            return true;
          }
          if (baseSegment) {
            if (matchLocation.caseSensitive) {
              if (routeSegment.value !== baseSegment.value) {
                return false;
              }
            } else if (routeSegment.value.toLowerCase() !== baseSegment.value.toLowerCase()) {
              return false;
            }
          }
        }
        if (!baseSegment) {
          return false;
        }
        if (routeSegment.type === "param") {
          if (baseSegment.value === "/") {
            return false;
          }
          if (baseSegment.value.charAt(0) !== "$") {
            params[routeSegment.value.substring(1)] = decodeURIComponent(
              baseSegment.value
            );
          }
        }
      }
      if (!isLastBaseSegment && isLastRouteSegment) {
        params["**"] = joinPaths(baseSegments.slice(i2 + 1).map((d2) => d2.value));
        return !!matchLocation.fuzzy && (routeSegment == null ? void 0 : routeSegment.value) !== "/";
      }
    }
    return true;
  })();
  return isMatch ? params : void 0;
}
function isRedirect(obj) {
  return !!(obj == null ? void 0 : obj.isRedirect);
}
function isResolvedRedirect(obj) {
  return !!(obj == null ? void 0 : obj.isRedirect) && obj.href;
}
function CatchBoundary(props) {
  const errorComponent = props.errorComponent ?? ErrorComponent;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    CatchBoundaryImpl,
    {
      getResetKey: props.getResetKey,
      onCatch: props.onCatch,
      children: ({ error, reset }) => {
        if (error) {
          return reactExports.createElement(errorComponent, {
            error,
            reset
          });
        }
        return props.children;
      }
    }
  );
}
class CatchBoundaryImpl extends reactExports.Component {
  constructor() {
    super(...arguments);
    this.state = { error: null };
  }
  static getDerivedStateFromProps(props) {
    return { resetKey: props.getResetKey() };
  }
  static getDerivedStateFromError(error) {
    return { error };
  }
  reset() {
    this.setState({ error: null });
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevState.error && prevState.resetKey !== this.state.resetKey) {
      this.reset();
    }
  }
  componentDidCatch(error, errorInfo) {
    if (this.props.onCatch) {
      this.props.onCatch(error, errorInfo);
    }
  }
  render() {
    return this.props.children({
      error: this.state.resetKey !== this.props.getResetKey() ? null : this.state.error,
      reset: () => {
        this.reset();
      }
    });
  }
}
function ErrorComponent({ error }) {
  const [show, setShow] = reactExports.useState(false);
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { padding: ".5rem", maxWidth: "100%" }, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { style: { display: "flex", alignItems: "center", gap: ".5rem" }, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("strong", { style: { fontSize: "1rem" }, children: "Something went wrong!" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          style: {
            appearance: "none",
            fontSize: ".6em",
            border: "1px solid currentColor",
            padding: ".1rem .2rem",
            fontWeight: "bold",
            borderRadius: ".25rem"
          },
          onClick: () => setShow((d2) => !d2),
          children: show ? "Hide Error" : "Show Error"
        }
      )
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { height: ".25rem" } }),
    show ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      "pre",
      {
        style: {
          fontSize: ".7em",
          border: "1px solid red",
          borderRadius: ".25rem",
          padding: ".3rem",
          color: "red",
          overflow: "auto"
        },
        children: error.message ? /* @__PURE__ */ jsxRuntimeExports.jsx("code", { children: error.message }) : null
      }
    ) }) : null
  ] });
}
function useRouterState(opts) {
  const contextRouter = useRouter({
    warn: (opts == null ? void 0 : opts.router) === void 0
  });
  return useStore(((opts == null ? void 0 : opts.router) || contextRouter).__store, opts == null ? void 0 : opts.select);
}
function isNotFound(obj) {
  return !!(obj == null ? void 0 : obj.isNotFound);
}
function CatchNotFound(props) {
  const resetKey = useRouterState({
    select: (s2) => `not-found-${s2.location.pathname}-${s2.status}`
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    CatchBoundary,
    {
      getResetKey: () => resetKey,
      onCatch: (error, errorInfo) => {
        var _a;
        if (isNotFound(error)) {
          (_a = props.onCatch) == null ? void 0 : _a.call(props, error, errorInfo);
        } else {
          throw error;
        }
      },
      errorComponent: ({ error }) => {
        var _a;
        return (_a = props.fallback) == null ? void 0 : _a.call(props, error);
      },
      children: props.children
    }
  );
}
function DefaultGlobalNotFound() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: "Not Found" });
}
const defaultTransformer = {
  stringify: (value) => JSON.stringify(value, function replacer(key, value2) {
    const keyVal = this[key];
    const transformer = transformers.find((t2) => t2.stringifyCondition(keyVal));
    if (transformer) {
      return transformer.stringify(keyVal);
    }
    return value2;
  }),
  parse: (value) => JSON.parse(value, function parser(key, value2) {
    const keyVal = this[key];
    const transformer = transformers.find((t2) => t2.parseCondition(keyVal));
    if (transformer) {
      return transformer.parse(keyVal);
    }
    return value2;
  })
};
const transformers = [
  {
    // Dates
    stringifyCondition: (value) => value instanceof Date,
    stringify: (value) => ({ $date: value.toISOString() }),
    parseCondition: (value) => isPlainObject$2(value) && value.$date,
    parse: (value) => new Date(value.$date)
  },
  {
    // undefined
    stringifyCondition: (value) => value === void 0,
    stringify: () => ({ $undefined: "" }),
    parseCondition: (value) => isPlainObject$2(value) && value.$undefined === "",
    parse: () => void 0
  }
];
const componentTypes = [
  "component",
  "errorComponent",
  "pendingComponent",
  "notFoundComponent"
];
function routeNeedsPreload(route) {
  var _a;
  for (const componentType of componentTypes) {
    if ((_a = route.options[componentType]) == null ? void 0 : _a.preload) {
      return true;
    }
  }
  return false;
}
function createRouter(options) {
  return new Router(options);
}
class Router {
  /**
   * @deprecated Use the `createRouter` function instead
   */
  constructor(options) {
    this.tempLocationKey = `${Math.round(
      Math.random() * 1e7
    )}`;
    this.resetNextScroll = true;
    this.shouldViewTransition = void 0;
    this.subscribers = /* @__PURE__ */ new Set();
    this.startReactTransition = (fn) => fn();
    this.update = (newOptions) => {
      if (newOptions.notFoundRoute) {
        console.warn(
          "The notFoundRoute API is deprecated and will be removed in the next major version. See https://tanstack.com/router/v1/docs/guide/not-found-errors#migrating-from-notfoundroute for more info."
        );
      }
      const previousOptions = this.options;
      this.options = {
        ...this.options,
        ...newOptions
      };
      this.isServer = this.options.isServer ?? typeof document === "undefined";
      if (!this.basepath || newOptions.basepath && newOptions.basepath !== previousOptions.basepath) {
        if (newOptions.basepath === void 0 || newOptions.basepath === "" || newOptions.basepath === "/") {
          this.basepath = "/";
        } else {
          this.basepath = `/${trimPath(newOptions.basepath)}`;
        }
      }
      if (
        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
        !this.history || this.options.history && this.options.history !== this.history
      ) {
        this.history = this.options.history ?? (this.isServer ? createMemoryHistory({
          initialEntries: [this.basepath || "/"]
        }) : createBrowserHistory());
        this.latestLocation = this.parseLocation();
      }
      if (this.options.routeTree !== this.routeTree) {
        this.routeTree = this.options.routeTree;
        this.buildRouteTree();
      }
      if (!this.__store) {
        this.__store = new Store(getInitialRouterState(this.latestLocation), {
          onUpdate: () => {
            this.__store.state = {
              ...this.state,
              cachedMatches: this.state.cachedMatches.filter(
                (d2) => !["redirected"].includes(d2.status)
              )
            };
          }
        });
      }
    };
    this.buildRouteTree = () => {
      this.routesById = {};
      this.routesByPath = {};
      const notFoundRoute = this.options.notFoundRoute;
      if (notFoundRoute) {
        notFoundRoute.init({ originalIndex: 99999999999 });
        this.routesById[notFoundRoute.id] = notFoundRoute;
      }
      const recurseRoutes = (childRoutes) => {
        childRoutes.forEach((childRoute, i2) => {
          childRoute.init({ originalIndex: i2 });
          const existingRoute = this.routesById[childRoute.id];
          invariant$1(
            !existingRoute,
            `Duplicate routes found with id: ${String(childRoute.id)}`
          );
          this.routesById[childRoute.id] = childRoute;
          if (!childRoute.isRoot && childRoute.path) {
            const trimmedFullPath = trimPathRight(childRoute.fullPath);
            if (!this.routesByPath[trimmedFullPath] || childRoute.fullPath.endsWith("/")) {
              this.routesByPath[trimmedFullPath] = childRoute;
            }
          }
          const children = childRoute.children;
          if (children == null ? void 0 : children.length) {
            recurseRoutes(children);
          }
        });
      };
      recurseRoutes([this.routeTree]);
      const scoredRoutes = [];
      const routes = Object.values(this.routesById);
      routes.forEach((d2, i2) => {
        var _a;
        if (d2.isRoot || !d2.path) {
          return;
        }
        const trimmed = trimPathLeft(d2.fullPath);
        const parsed = parsePathname(trimmed);
        while (parsed.length > 1 && ((_a = parsed[0]) == null ? void 0 : _a.value) === "/") {
          parsed.shift();
        }
        const scores = parsed.map((segment) => {
          if (segment.value === "/") {
            return 0.75;
          }
          if (segment.type === "param") {
            return 0.5;
          }
          if (segment.type === "wildcard") {
            return 0.25;
          }
          return 1;
        });
        scoredRoutes.push({ child: d2, trimmed, parsed, index: i2, scores });
      });
      this.flatRoutes = scoredRoutes.sort((a2, b2) => {
        const minLength = Math.min(a2.scores.length, b2.scores.length);
        for (let i2 = 0; i2 < minLength; i2++) {
          if (a2.scores[i2] !== b2.scores[i2]) {
            return b2.scores[i2] - a2.scores[i2];
          }
        }
        if (a2.scores.length !== b2.scores.length) {
          return b2.scores.length - a2.scores.length;
        }
        for (let i2 = 0; i2 < minLength; i2++) {
          if (a2.parsed[i2].value !== b2.parsed[i2].value) {
            return a2.parsed[i2].value > b2.parsed[i2].value ? 1 : -1;
          }
        }
        return a2.index - b2.index;
      }).map((d2, i2) => {
        d2.child.rank = i2;
        return d2.child;
      });
    };
    this.subscribe = (eventType, fn) => {
      const listener = {
        eventType,
        fn
      };
      this.subscribers.add(listener);
      return () => {
        this.subscribers.delete(listener);
      };
    };
    this.emit = (routerEvent) => {
      this.subscribers.forEach((listener) => {
        if (listener.eventType === routerEvent.type) {
          listener.fn(routerEvent);
        }
      });
    };
    this.parseLocation = (previousLocation) => {
      const parse2 = ({
        pathname,
        search,
        hash,
        state
      }) => {
        const parsedSearch = this.options.parseSearch(search);
        const searchStr = this.options.stringifySearch(parsedSearch);
        return {
          pathname,
          searchStr,
          search: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.search, parsedSearch),
          hash: hash.split("#").reverse()[0] ?? "",
          href: `${pathname}${searchStr}${hash}`,
          state: replaceEqualDeep(previousLocation == null ? void 0 : previousLocation.state, state)
        };
      };
      const location = parse2(this.history.location);
      const { __tempLocation, __tempKey } = location.state;
      if (__tempLocation && (!__tempKey || __tempKey === this.tempLocationKey)) {
        const parsedTempLocation = parse2(__tempLocation);
        parsedTempLocation.state.key = location.state.key;
        delete parsedTempLocation.state.__tempLocation;
        return {
          ...parsedTempLocation,
          maskedLocation: location
        };
      }
      return location;
    };
    this.resolvePathWithBase = (from, path2) => {
      const resolvedPath = resolvePath({
        basepath: this.basepath,
        base: from,
        to: cleanPath(path2),
        trailingSlash: this.options.trailingSlash
      });
      return resolvedPath;
    };
    this.cancelMatch = (id2) => {
      const match = this.getMatch(id2);
      if (!match) return;
      match.abortController.abort();
      clearTimeout(match.pendingTimeout);
    };
    this.cancelMatches = () => {
      var _a;
      (_a = this.state.pendingMatches) == null ? void 0 : _a.forEach((match) => {
        this.cancelMatch(match.id);
      });
    };
    this.buildLocation = (opts) => {
      const build = (dest = {}, matches) => {
        var _a, _b, _c, _d, _e;
        const fromMatches = dest._fromLocation ? this.matchRoutes(dest._fromLocation) : this.state.matches;
        const fromMatch = dest.from != null ? fromMatches.find(
          (d2) => matchPathname(this.basepath, trimPathRight(d2.pathname), {
            to: dest.from,
            caseSensitive: false,
            fuzzy: false
          })
        ) : void 0;
        const fromPath = (fromMatch == null ? void 0 : fromMatch.pathname) || this.latestLocation.pathname;
        invariant$1(
          dest.from == null || fromMatch != null,
          "Could not find match for from: " + dest.from
        );
        const fromSearch = ((_a = this.state.pendingMatches) == null ? void 0 : _a.length) ? (_b = last(this.state.pendingMatches)) == null ? void 0 : _b.search : ((_c = last(fromMatches)) == null ? void 0 : _c.search) || this.latestLocation.search;
        const stayingMatches = matches == null ? void 0 : matches.filter(
          (d2) => fromMatches.find((e2) => e2.routeId === d2.routeId)
        );
        const fromRouteByFromPathRouteId = this.routesById[(_d = stayingMatches == null ? void 0 : stayingMatches.find((d2) => d2.pathname === fromPath)) == null ? void 0 : _d.routeId];
        let pathname = dest.to ? this.resolvePathWithBase(fromPath, `${dest.to}`) : this.resolvePathWithBase(
          fromPath,
          (fromRouteByFromPathRouteId == null ? void 0 : fromRouteByFromPathRouteId.to) ?? fromPath
        );
        const prevParams = { ...(_e = last(fromMatches)) == null ? void 0 : _e.params };
        let nextParams = (dest.params ?? true) === true ? prevParams : { ...prevParams, ...functionalUpdate(dest.params, prevParams) };
        if (Object.keys(nextParams).length > 0) {
          matches == null ? void 0 : matches.map((d2) => {
            var _a2;
            const route = this.looseRoutesById[d2.routeId];
            return ((_a2 = route == null ? void 0 : route.options.params) == null ? void 0 : _a2.stringify) ?? route.options.stringifyParams;
          }).filter(Boolean).forEach((fn) => {
            nextParams = { ...nextParams, ...fn(nextParams) };
          });
        }
        pathname = interpolatePath({
          path: pathname,
          params: nextParams ?? {},
          leaveWildcards: false,
          leaveParams: opts.leaveParams
        });
        const preSearchFilters = (stayingMatches == null ? void 0 : stayingMatches.map(
          (match) => this.looseRoutesById[match.routeId].options.preSearchFilters ?? []
        ).flat().filter(Boolean)) ?? [];
        const postSearchFilters = (stayingMatches == null ? void 0 : stayingMatches.map(
          (match) => this.looseRoutesById[match.routeId].options.postSearchFilters ?? []
        ).flat().filter(Boolean)) ?? [];
        const preFilteredSearch = preSearchFilters.length ? preSearchFilters.reduce((prev, next) => next(prev), fromSearch) : fromSearch;
        const destSearch = dest.search === true ? preFilteredSearch : dest.search ? functionalUpdate(dest.search, preFilteredSearch) : preSearchFilters.length ? preFilteredSearch : {};
        const postFilteredSearch = postSearchFilters.length ? postSearchFilters.reduce((prev, next) => next(prev), destSearch) : destSearch;
        const search = replaceEqualDeep(fromSearch, postFilteredSearch);
        const searchStr = this.options.stringifySearch(search);
        const hash = dest.hash === true ? this.latestLocation.hash : dest.hash ? functionalUpdate(dest.hash, this.latestLocation.hash) : void 0;
        const hashStr = hash ? `#${hash}` : "";
        let nextState = dest.state === true ? this.latestLocation.state : dest.state ? functionalUpdate(dest.state, this.latestLocation.state) : {};
        nextState = replaceEqualDeep(this.latestLocation.state, nextState);
        return {
          pathname,
          search,
          searchStr,
          state: nextState,
          hash: hash ?? "",
          href: `${pathname}${searchStr}${hashStr}`,
          unmaskOnReload: dest.unmaskOnReload
        };
      };
      const buildWithMatches = (dest = {}, maskedDest) => {
        var _a;
        const next = build(dest);
        let maskedNext = maskedDest ? build(maskedDest) : void 0;
        if (!maskedNext) {
          let params = {};
          const foundMask = (_a = this.options.routeMasks) == null ? void 0 : _a.find((d2) => {
            const match = matchPathname(this.basepath, next.pathname, {
              to: d2.from,
              caseSensitive: false,
              fuzzy: false
            });
            if (match) {
              params = match;
              return true;
            }
            return false;
          });
          if (foundMask) {
            const { from, ...maskProps } = foundMask;
            maskedDest = {
              ...pick(opts, ["from"]),
              ...maskProps,
              params
            };
            maskedNext = build(maskedDest);
          }
        }
        const nextMatches = this.matchRoutes(next);
        const maskedMatches = maskedNext ? this.matchRoutes(maskedNext) : void 0;
        const maskedFinal = maskedNext ? build(maskedDest, maskedMatches) : void 0;
        const final = build(dest, nextMatches);
        if (maskedFinal) {
          final.maskedLocation = maskedFinal;
        }
        return final;
      };
      if (opts.mask) {
        return buildWithMatches(opts, {
          ...pick(opts, ["from"]),
          ...opts.mask
        });
      }
      return buildWithMatches(opts);
    };
    this.commitLocation = ({
      viewTransition,
      ignoreBlocker,
      ...next
    }) => {
      const isSameState = () => {
        next.state.key = this.latestLocation.state.key;
        const isEqual = deepEqual$2(next.state, this.latestLocation.state);
        delete next.state.key;
        return isEqual;
      };
      const isSameUrl = this.latestLocation.href === next.href;
      const previousCommitPromise = this.commitLocationPromise;
      this.commitLocationPromise = createControlledPromise(() => {
        previousCommitPromise == null ? void 0 : previousCommitPromise.resolve();
      });
      if (isSameUrl && isSameState()) {
        this.load();
      } else {
        let { maskedLocation, ...nextHistory } = next;
        if (maskedLocation) {
          nextHistory = {
            ...maskedLocation,
            state: {
              ...maskedLocation.state,
              __tempKey: void 0,
              __tempLocation: {
                ...nextHistory,
                search: nextHistory.searchStr,
                state: {
                  ...nextHistory.state,
                  __tempKey: void 0,
                  __tempLocation: void 0,
                  key: void 0
                }
              }
            }
          };
          if (nextHistory.unmaskOnReload ?? this.options.unmaskOnReload ?? false) {
            nextHistory.state.__tempKey = this.tempLocationKey;
          }
        }
        this.shouldViewTransition = viewTransition;
        this.history[next.replace ? "replace" : "push"](
          nextHistory.href,
          nextHistory.state,
          { ignoreBlocker }
        );
      }
      this.resetNextScroll = next.resetScroll ?? true;
      if (!this.history.subscribers.size) {
        this.load();
      }
      return this.commitLocationPromise;
    };
    this.buildAndCommitLocation = ({
      replace,
      resetScroll,
      viewTransition,
      ignoreBlocker,
      ...rest
    } = {}) => {
      const href = rest.href;
      if (href) {
        const parsed = parseHref(href, {});
        rest.to = parsed.pathname;
        rest.search = this.options.parseSearch(parsed.search);
        rest.hash = parsed.hash;
      }
      const location = this.buildLocation(rest);
      return this.commitLocation({
        ...location,
        viewTransition,
        replace,
        resetScroll,
        ignoreBlocker
      });
    };
    this.navigate = ({ to, ...rest }) => {
      const toString = String(to);
      let isExternal;
      try {
        new URL(`${toString}`);
        isExternal = true;
      } catch (e2) {
      }
      invariant$1(
        !isExternal
      );
      return this.buildAndCommitLocation({
        ...rest,
        to
        // to: toString,
      });
    };
    this.load = async () => {
      this.latestLocation = this.parseLocation(this.latestLocation);
      let redirect;
      let notFound;
      let loadPromise;
      loadPromise = new Promise((resolve) => {
        this.startReactTransition(async () => {
          var _a;
          try {
            const next = this.latestLocation;
            const prevLocation = this.state.resolvedLocation;
            const pathDidChange = prevLocation.href !== next.href;
            this.cancelMatches();
            let pendingMatches;
            this.__store.batch(() => {
              pendingMatches = this.matchRoutes(next);
              this.__store.setState((s2) => ({
                ...s2,
                status: "pending",
                isLoading: true,
                location: next,
                pendingMatches,
                // If a cached moved to pendingMatches, remove it from cachedMatches
                cachedMatches: s2.cachedMatches.filter((d2) => {
                  return !pendingMatches.find((e2) => e2.id === d2.id);
                })
              }));
            });
            if (!this.state.redirect) {
              this.emit({
                type: "onBeforeNavigate",
                fromLocation: prevLocation,
                toLocation: next,
                pathChanged: pathDidChange
              });
            }
            this.emit({
              type: "onBeforeLoad",
              fromLocation: prevLocation,
              toLocation: next,
              pathChanged: pathDidChange
            });
            await this.loadMatches({
              matches: pendingMatches,
              location: next,
              // eslint-disable-next-line @typescript-eslint/require-await
              onReady: async () => {
                this.startViewTransition(async () => {
                  let exitingMatches;
                  let enteringMatches;
                  let stayingMatches;
                  this.__store.batch(() => {
                    this.__store.setState((s2) => {
                      const previousMatches = s2.matches;
                      const newMatches = s2.pendingMatches || s2.matches;
                      exitingMatches = previousMatches.filter(
                        (match) => !newMatches.find((d2) => d2.id === match.id)
                      );
                      enteringMatches = newMatches.filter(
                        (match) => !previousMatches.find((d2) => d2.id === match.id)
                      );
                      stayingMatches = previousMatches.filter(
                        (match) => newMatches.find((d2) => d2.id === match.id)
                      );
                      return {
                        ...s2,
                        isLoading: false,
                        loadedAt: Date.now(),
                        matches: newMatches,
                        pendingMatches: void 0,
                        cachedMatches: [
                          ...s2.cachedMatches,
                          ...exitingMatches.filter((d2) => d2.status !== "error")
                        ]
                      };
                    });
                    this.cleanCache();
                  });
                  [
                    [exitingMatches, "onLeave"],
                    [enteringMatches, "onEnter"],
                    [stayingMatches, "onStay"]
                  ].forEach(([matches, hook]) => {
                    matches.forEach((match) => {
                      var _a2, _b;
                      (_b = (_a2 = this.looseRoutesById[match.routeId].options)[hook]) == null ? void 0 : _b.call(_a2, match);
                    });
                  });
                });
              }
            });
          } catch (err) {
            if (isResolvedRedirect(err)) {
              redirect = err;
              if (!this.isServer) {
                this.navigate({
                  ...err,
                  replace: true,
                  ignoreBlocker: true
                });
              }
            } else if (isNotFound(err)) {
              notFound = err;
            }
            this.__store.setState((s2) => ({
              ...s2,
              statusCode: redirect ? redirect.statusCode : notFound ? 404 : s2.matches.some((d2) => d2.status === "error") ? 500 : 200,
              redirect
            }));
          }
          if (this.latestLoadPromise === loadPromise) {
            (_a = this.commitLocationPromise) == null ? void 0 : _a.resolve();
            this.latestLoadPromise = void 0;
            this.commitLocationPromise = void 0;
          }
          resolve();
        });
      });
      this.latestLoadPromise = loadPromise;
      await loadPromise;
      while (this.latestLoadPromise && loadPromise !== this.latestLoadPromise) {
        await this.latestLoadPromise;
      }
    };
    this.startViewTransition = (fn) => {
      const shouldViewTransition = this.shouldViewTransition ?? this.options.defaultViewTransition;
      delete this.shouldViewTransition;
      if (shouldViewTransition && typeof document !== "undefined" && "startViewTransition" in document && typeof document.startViewTransition === "function") {
        document.startViewTransition(fn);
      } else {
        fn();
      }
    };
    this.updateMatch = (id2, updater) => {
      var _a;
      let updated;
      const isPending = (_a = this.state.pendingMatches) == null ? void 0 : _a.find((d2) => d2.id === id2);
      const isMatched = this.state.matches.find((d2) => d2.id === id2);
      const matchesKey = isPending ? "pendingMatches" : isMatched ? "matches" : "cachedMatches";
      this.__store.setState((s2) => {
        var _a2;
        return {
          ...s2,
          [matchesKey]: (_a2 = s2[matchesKey]) == null ? void 0 : _a2.map(
            (d2) => d2.id === id2 ? updated = updater(d2) : d2
          )
        };
      });
      return updated;
    };
    this.getMatch = (matchId) => {
      return [
        ...this.state.cachedMatches,
        ...this.state.pendingMatches ?? [],
        ...this.state.matches
      ].find((d2) => d2.id === matchId);
    };
    this.loadMatches = async ({
      location,
      matches,
      preload: preload2,
      onReady,
      updateMatch = this.updateMatch
    }) => {
      let firstBadMatchIndex;
      let rendered = false;
      const triggerOnReady = async () => {
        if (!rendered) {
          rendered = true;
          await (onReady == null ? void 0 : onReady());
        }
      };
      if (!this.isServer && !this.state.matches.length) {
        triggerOnReady();
      }
      const handleRedirectAndNotFound = (match, err) => {
        var _a, _b, _c;
        if (isResolvedRedirect(err)) throw err;
        if (isRedirect(err) || isNotFound(err)) {
          updateMatch(match.id, (prev) => ({
            ...prev,
            status: isRedirect(err) ? "redirected" : isNotFound(err) ? "notFound" : "error",
            isFetching: false,
            error: err,
            beforeLoadPromise: void 0,
            loaderPromise: void 0
          }));
          if (!err.routeId) {
            err.routeId = match.routeId;
          }
          (_a = match.beforeLoadPromise) == null ? void 0 : _a.resolve();
          (_b = match.loaderPromise) == null ? void 0 : _b.resolve();
          (_c = match.loadPromise) == null ? void 0 : _c.resolve();
          if (isRedirect(err)) {
            rendered = true;
            err = this.resolveRedirect({ ...err, _fromLocation: location });
            throw err;
          } else if (isNotFound(err)) {
            this._handleNotFound(matches, err, {
              updateMatch
            });
            throw err;
          }
        }
      };
      try {
        await new Promise((resolveAll, rejectAll) => {
          ;
          (async () => {
            var _a, _b, _c;
            try {
              const handleSerialError = (index2, err, routerCode) => {
                var _a2, _b2;
                const { id: matchId, routeId } = matches[index2];
                const route = this.looseRoutesById[routeId];
                if (err instanceof Promise) {
                  throw err;
                }
                err.routerCode = routerCode;
                firstBadMatchIndex = firstBadMatchIndex ?? index2;
                handleRedirectAndNotFound(this.getMatch(matchId), err);
                try {
                  (_b2 = (_a2 = route.options).onError) == null ? void 0 : _b2.call(_a2, err);
                } catch (errorHandlerErr) {
                  err = errorHandlerErr;
                  handleRedirectAndNotFound(this.getMatch(matchId), err);
                }
                updateMatch(matchId, (prev) => {
                  var _a3;
                  (_a3 = prev.beforeLoadPromise) == null ? void 0 : _a3.resolve();
                  return {
                    ...prev,
                    error: err,
                    status: "error",
                    isFetching: false,
                    updatedAt: Date.now(),
                    abortController: new AbortController(),
                    beforeLoadPromise: void 0
                  };
                });
              };
              for (const [index2, { id: matchId, routeId }] of matches.entries()) {
                const existingMatch = this.getMatch(matchId);
                const parentMatchId = (_a = matches[index2 - 1]) == null ? void 0 : _a.id;
                const route = this.looseRoutesById[routeId];
                const pendingMs = route.options.pendingMs ?? this.options.defaultPendingMs;
                const shouldPending = !!(onReady && !this.isServer && !preload2 && (route.options.loader || route.options.beforeLoad) && typeof pendingMs === "number" && pendingMs !== Infinity && (route.options.pendingComponent ?? this.options.defaultPendingComponent));
                if (
                  // If we are in the middle of a load, either of these will be present
                  // (not to be confused with `loadPromise`, which is always defined)
                  existingMatch.beforeLoadPromise || existingMatch.loaderPromise
                ) {
                  if (shouldPending) {
                    setTimeout(() => {
                      try {
                        triggerOnReady();
                      } catch {
                      }
                    }, pendingMs);
                  }
                  await existingMatch.beforeLoadPromise;
                } else {
                  try {
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      loadPromise: createControlledPromise(() => {
                        var _a2;
                        (_a2 = prev.loadPromise) == null ? void 0 : _a2.resolve();
                      }),
                      beforeLoadPromise: createControlledPromise()
                    }));
                    const abortController = new AbortController();
                    let pendingTimeout;
                    if (shouldPending) {
                      pendingTimeout = setTimeout(() => {
                        try {
                          triggerOnReady();
                        } catch {
                        }
                      }, pendingMs);
                    }
                    const { paramsError, searchError } = this.getMatch(matchId);
                    if (paramsError) {
                      handleSerialError(index2, paramsError, "PARSE_PARAMS");
                    }
                    if (searchError) {
                      handleSerialError(index2, searchError, "VALIDATE_SEARCH");
                    }
                    const getParentMatchContext = () => parentMatchId ? this.getMatch(parentMatchId).context : this.options.context ?? {};
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      isFetching: "beforeLoad",
                      fetchCount: prev.fetchCount + 1,
                      abortController,
                      pendingTimeout,
                      context: {
                        ...getParentMatchContext(),
                        ...prev.__routeContext,
                        ...prev.__beforeLoadContext
                      }
                    }));
                    const { search, params, context, cause } = this.getMatch(matchId);
                    const beforeLoadFnContext = {
                      search,
                      abortController,
                      params,
                      preload: !!preload2,
                      context,
                      location,
                      navigate: (opts) => this.navigate({ ...opts, _fromLocation: location }),
                      buildLocation: this.buildLocation,
                      cause: preload2 ? "preload" : cause,
                      matches
                    };
                    let beforeLoadContext = await ((_c = (_b = route.options).beforeLoad) == null ? void 0 : _c.call(_b, beforeLoadFnContext)) ?? {};
                    if (this.serializeLoaderData) {
                      beforeLoadContext = this.serializeLoaderData(
                        "__beforeLoadContext",
                        beforeLoadContext,
                        {
                          router: this,
                          match: this.getMatch(matchId)
                        }
                      );
                    }
                    if (isRedirect(beforeLoadContext) || isNotFound(beforeLoadContext)) {
                      handleSerialError(index2, beforeLoadContext, "BEFORE_LOAD");
                    }
                    updateMatch(matchId, (prev) => {
                      return {
                        ...prev,
                        __beforeLoadContext: beforeLoadContext,
                        context: {
                          ...getParentMatchContext(),
                          ...prev.__routeContext,
                          ...beforeLoadContext
                        },
                        abortController
                      };
                    });
                  } catch (err) {
                    handleSerialError(index2, err, "BEFORE_LOAD");
                  }
                  updateMatch(matchId, (prev) => {
                    var _a2;
                    (_a2 = prev.beforeLoadPromise) == null ? void 0 : _a2.resolve();
                    return {
                      ...prev,
                      beforeLoadPromise: void 0,
                      isFetching: false
                    };
                  });
                }
              }
              const validResolvedMatches = matches.slice(0, firstBadMatchIndex);
              const matchPromises = [];
              validResolvedMatches.forEach(({ id: matchId, routeId }, index2) => {
                matchPromises.push(
                  (async () => {
                    const { loaderPromise: prevLoaderPromise } = this.getMatch(matchId);
                    let loaderRunningAsync = false;
                    if (prevLoaderPromise) {
                      await prevLoaderPromise;
                    } else {
                      const parentMatchPromise = matchPromises[index2 - 1];
                      const route = this.looseRoutesById[routeId];
                      const getLoaderContext = () => {
                        const {
                          params,
                          loaderDeps,
                          abortController,
                          context,
                          cause
                        } = this.getMatch(matchId);
                        return {
                          params,
                          deps: loaderDeps,
                          preload: !!preload2,
                          parentMatchPromise,
                          abortController,
                          context,
                          location,
                          navigate: (opts) => this.navigate({ ...opts, _fromLocation: location }),
                          cause: preload2 ? "preload" : cause,
                          route
                        };
                      };
                      const age = Date.now() - this.getMatch(matchId).updatedAt;
                      const staleAge = preload2 ? route.options.preloadStaleTime ?? this.options.defaultPreloadStaleTime ?? 3e4 : route.options.staleTime ?? this.options.defaultStaleTime ?? 0;
                      const shouldReloadOption = route.options.shouldReload;
                      const shouldReload = typeof shouldReloadOption === "function" ? shouldReloadOption(getLoaderContext()) : shouldReloadOption;
                      updateMatch(matchId, (prev) => ({
                        ...prev,
                        loaderPromise: createControlledPromise(),
                        preload: !!preload2 && !this.state.matches.find((d2) => d2.id === matchId)
                      }));
                      const runLoader = async () => {
                        var _a2, _b2, _c2, _d, _e, _f, _g, _h;
                        try {
                          const potentialPendingMinPromise = async () => {
                            const latestMatch = this.getMatch(matchId);
                            if (latestMatch.minPendingPromise) {
                              await latestMatch.minPendingPromise;
                            }
                          };
                          try {
                            route._lazyPromise = route._lazyPromise || (route.lazyFn ? route.lazyFn().then((lazyRoute) => {
                              Object.assign(
                                route.options,
                                lazyRoute.options
                              );
                            }) : Promise.resolve());
                            const componentsPromise = this.getMatch(matchId).componentsPromise || route._lazyPromise.then(
                              () => Promise.all(
                                componentTypes.map(async (type) => {
                                  const component = route.options[type];
                                  if (component == null ? void 0 : component.preload) {
                                    await component.preload();
                                  }
                                })
                              )
                            );
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              isFetching: "loader",
                              componentsPromise
                            }));
                            let loaderData = await ((_b2 = (_a2 = route.options).loader) == null ? void 0 : _b2.call(_a2, getLoaderContext()));
                            if (this.serializeLoaderData) {
                              loaderData = this.serializeLoaderData(
                                "loaderData",
                                loaderData,
                                {
                                  router: this,
                                  match: this.getMatch(matchId)
                                }
                              );
                            }
                            handleRedirectAndNotFound(
                              this.getMatch(matchId),
                              loaderData
                            );
                            await route._lazyPromise;
                            await potentialPendingMinPromise();
                            const meta = (_d = (_c2 = route.options).meta) == null ? void 0 : _d.call(_c2, {
                              matches,
                              match: this.getMatch(matchId),
                              params: this.getMatch(matchId).params,
                              loaderData
                            });
                            const headers = (_f = (_e = route.options).headers) == null ? void 0 : _f.call(_e, {
                              loaderData
                            });
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              error: void 0,
                              status: "success",
                              isFetching: false,
                              updatedAt: Date.now(),
                              loaderData,
                              meta,
                              headers
                            }));
                          } catch (e2) {
                            let error = e2;
                            await potentialPendingMinPromise();
                            handleRedirectAndNotFound(this.getMatch(matchId), e2);
                            try {
                              (_h = (_g = route.options).onError) == null ? void 0 : _h.call(_g, e2);
                            } catch (onErrorError) {
                              error = onErrorError;
                              handleRedirectAndNotFound(
                                this.getMatch(matchId),
                                onErrorError
                              );
                            }
                            updateMatch(matchId, (prev) => ({
                              ...prev,
                              error,
                              status: "error",
                              isFetching: false
                            }));
                          }
                          await this.getMatch(matchId).componentsPromise;
                        } catch (err) {
                          handleRedirectAndNotFound(this.getMatch(matchId), err);
                        }
                      };
                      const { status, invalid } = this.getMatch(matchId);
                      loaderRunningAsync = status === "success" && (invalid || (shouldReload ?? age > staleAge));
                      if (preload2 && route.options.preload === false) {
                      } else if (loaderRunningAsync) {
                        ;
                        (async () => {
                          try {
                            await runLoader();
                          } catch (err) {
                          }
                        })();
                      } else if (status !== "success") {
                        await runLoader();
                      }
                      const { loaderPromise, loadPromise } = this.getMatch(matchId);
                      loaderPromise == null ? void 0 : loaderPromise.resolve();
                      loadPromise == null ? void 0 : loadPromise.resolve();
                    }
                    updateMatch(matchId, (prev) => ({
                      ...prev,
                      isFetching: loaderRunningAsync ? prev.isFetching : false,
                      loaderPromise: void 0
                    }));
                  })()
                );
              });
              await Promise.all(matchPromises);
              resolveAll();
            } catch (err) {
              rejectAll(err);
            }
          })();
        });
        await triggerOnReady();
      } catch (err) {
        if (isRedirect(err) || isNotFound(err)) {
          if (isNotFound(err) && !preload2) {
            await triggerOnReady();
          }
          throw err;
        }
      }
      return matches;
    };
    this.invalidate = () => {
      const invalidate = (d2) => ({
        ...d2,
        invalid: true,
        ...d2.status === "error" ? { status: "pending", error: void 0 } : {}
      });
      this.__store.setState((s2) => {
        var _a;
        return {
          ...s2,
          matches: s2.matches.map(invalidate),
          cachedMatches: s2.cachedMatches.map(invalidate),
          pendingMatches: (_a = s2.pendingMatches) == null ? void 0 : _a.map(invalidate)
        };
      });
      return this.load();
    };
    this.resolveRedirect = (err) => {
      const redirect = err;
      if (!redirect.href) {
        redirect.href = this.buildLocation(redirect).href;
      }
      return redirect;
    };
    this.cleanCache = () => {
      this.__store.setState((s2) => {
        return {
          ...s2,
          cachedMatches: s2.cachedMatches.filter((d2) => {
            const route = this.looseRoutesById[d2.routeId];
            if (!route.options.loader) {
              return false;
            }
            const gcTime = (d2.preload ? route.options.preloadGcTime ?? this.options.defaultPreloadGcTime : route.options.gcTime ?? this.options.defaultGcTime) ?? 5 * 60 * 1e3;
            return d2.status !== "error" && Date.now() - d2.updatedAt < gcTime;
          })
        };
      });
    };
    this.preloadRoute = async (opts) => {
      const next = this.buildLocation(opts);
      let matches = this.matchRoutes(next, {
        throwOnError: true,
        preload: true
      });
      const loadedMatchIds = Object.fromEntries(
        [
          ...this.state.matches,
          ...this.state.pendingMatches ?? [],
          ...this.state.cachedMatches
        ].map((d2) => [d2.id, true])
      );
      this.__store.batch(() => {
        matches.forEach((match) => {
          if (!loadedMatchIds[match.id]) {
            this.__store.setState((s2) => ({
              ...s2,
              cachedMatches: [...s2.cachedMatches, match]
            }));
          }
        });
      });
      const activeMatchIds = new Set(
        [...this.state.matches, ...this.state.pendingMatches ?? []].map(
          (d2) => d2.id
        )
      );
      try {
        matches = await this.loadMatches({
          matches,
          location: next,
          preload: true,
          updateMatch: (id2, updater) => {
            if (activeMatchIds.has(id2)) {
              matches = matches.map((d2) => d2.id === id2 ? updater(d2) : d2);
            } else {
              this.updateMatch(id2, updater);
            }
          }
        });
        return matches;
      } catch (err) {
        if (isRedirect(err)) {
          return await this.preloadRoute({
            ...err,
            _fromLocation: next
          });
        }
        console.error(err);
        return void 0;
      }
    };
    this.matchRoute = (location, opts) => {
      const matchLocation = {
        ...location,
        to: location.to ? this.resolvePathWithBase(
          location.from || "",
          location.to
        ) : void 0,
        params: location.params || {},
        leaveParams: true
      };
      const next = this.buildLocation(matchLocation);
      if ((opts == null ? void 0 : opts.pending) && this.state.status !== "pending") {
        return false;
      }
      const pending = (opts == null ? void 0 : opts.pending) === void 0 ? !this.state.isLoading : opts.pending;
      const baseLocation = pending ? this.latestLocation : this.state.resolvedLocation;
      const match = matchPathname(this.basepath, baseLocation.pathname, {
        ...opts,
        to: next.pathname
      });
      if (!match) {
        return false;
      }
      if (location.params) {
        if (!deepEqual$2(match, location.params, true)) {
          return false;
        }
      }
      if (match && ((opts == null ? void 0 : opts.includeSearch) ?? true)) {
        return deepEqual$2(baseLocation.search, next.search, true) ? match : false;
      }
      return match;
    };
    this.dehydrate = () => {
      var _a;
      const pickError = ((_a = this.options.errorSerializer) == null ? void 0 : _a.serialize) ?? defaultSerializeError;
      return {
        state: {
          dehydratedMatches: this.state.matches.map((d2) => {
            return {
              ...pick(d2, ["id", "status", "updatedAt"]),
              // If an error occurs server-side during SSRing,
              // send a small subset of the error to the client
              error: d2.error ? {
                data: pickError(d2.error),
                __isServerError: true
              } : void 0
              // NOTE: We don't send the loader data here, because
              // there is a potential that it needs to be streamed.
              // Instead, we render it next to the route match in the HTML
              // which gives us the potential to stream it via suspense.
            };
          })
        },
        manifest: this.manifest
      };
    };
    this.hydrate = () => {
      var _a, _b, _c;
      let ctx;
      if (typeof document !== "undefined") {
        ctx = this.options.transformer.parse((_a = window.__TSR__) == null ? void 0 : _a.dehydrated);
      }
      invariant$1(
        ctx
      );
      this.dehydratedData = ctx.payload;
      (_c = (_b = this.options).hydrate) == null ? void 0 : _c.call(_b, ctx.payload);
      const dehydratedState = ctx.router.state;
      const matches = this.matchRoutes(this.state.location).map((match) => {
        const dehydratedMatch = dehydratedState.dehydratedMatches.find(
          (d2) => d2.id === match.id
        );
        invariant$1(
          dehydratedMatch,
          `Could not find a client-side match for dehydrated match with id: ${match.id}!`
        );
        return {
          ...match,
          ...dehydratedMatch
        };
      });
      this.__store.setState((s2) => {
        return {
          ...s2,
          matches
        };
      });
      this.manifest = ctx.router.manifest;
    };
    this.injectedHtml = [];
    this.injectHtml = (html) => {
      const cb2 = () => {
        this.injectedHtml = this.injectedHtml.filter((d2) => d2 !== cb2);
        return html;
      };
      this.injectedHtml.push(cb2);
    };
    this.streamedKeys = /* @__PURE__ */ new Set();
    this.getStreamedValue = (key) => {
      var _a;
      if (this.isServer) {
        return void 0;
      }
      const streamedValue = (_a = window.__TSR__) == null ? void 0 : _a.streamedValues[key];
      if (!streamedValue) {
        return;
      }
      if (!streamedValue.parsed) {
        streamedValue.parsed = this.options.transformer.parse(streamedValue.value);
      }
      return streamedValue.parsed;
    };
    this.streamValue = (key, value) => {
      var _a;
      warning(
        !this.streamedKeys.has(key)
      );
      this.streamedKeys.add(key);
      const children = `__TSR__.streamedValues['${key}'] = { value: ${(_a = this.serializer) == null ? void 0 : _a.call(this, this.options.transformer.stringify(value))}}`;
      this.injectHtml(
        `<script class='tsr-once'>${children}${""}; __TSR__.cleanScripts()<\/script>`
      );
    };
    this._handleNotFound = (matches, err, {
      updateMatch = this.updateMatch
    } = {}) => {
      const matchesByRouteId = Object.fromEntries(
        matches.map((match2) => [match2.routeId, match2])
      );
      let routeCursor = (err.global ? this.looseRoutesById[rootRouteId] : this.looseRoutesById[err.routeId]) || this.looseRoutesById[rootRouteId];
      while (!routeCursor.options.notFoundComponent && !this.options.defaultNotFoundComponent && routeCursor.id !== rootRouteId) {
        routeCursor = routeCursor.parentRoute;
        invariant$1(
          routeCursor
        );
      }
      const match = matchesByRouteId[routeCursor.id];
      invariant$1(match, "Could not find match for route: " + routeCursor.id);
      updateMatch(match.id, (prev) => ({
        ...prev,
        status: "notFound",
        error: err,
        isFetching: false
      }));
      if (err.routerCode === "BEFORE_LOAD" && routeCursor.parentRoute) {
        err.routeId = routeCursor.parentRoute.id;
        this._handleNotFound(matches, err, {
          updateMatch
        });
      }
    };
    this.hasNotFoundMatch = () => {
      return this.__store.state.matches.some(
        (d2) => d2.status === "notFound" || d2.globalNotFound
      );
    };
    this.update({
      defaultPreloadDelay: 50,
      defaultPendingMs: 1e3,
      defaultPendingMinMs: 500,
      context: void 0,
      ...options,
      notFoundMode: options.notFoundMode ?? "fuzzy",
      stringifySearch: options.stringifySearch ?? defaultStringifySearch,
      parseSearch: options.parseSearch ?? defaultParseSearch,
      transformer: options.transformer ?? defaultTransformer
    });
    if (typeof document !== "undefined") {
      window.__TSR__ROUTER__ = this;
    }
  }
  get state() {
    return this.__store.state;
  }
  get looseRoutesById() {
    return this.routesById;
  }
  matchRoutes(pathnameOrNext, locationSearchOrOpts, opts) {
    if (typeof pathnameOrNext === "string") {
      return this.matchRoutesInternal(
        {
          pathname: pathnameOrNext,
          search: locationSearchOrOpts
        },
        opts
      );
    } else {
      return this.matchRoutesInternal(pathnameOrNext, locationSearchOrOpts);
    }
  }
  matchRoutesInternal(next, opts) {
    let routeParams = {};
    const foundRoute = this.flatRoutes.find((route) => {
      const matchedParams = matchPathname(
        this.basepath,
        trimPathRight(next.pathname),
        {
          to: route.fullPath,
          caseSensitive: route.options.caseSensitive ?? this.options.caseSensitive,
          fuzzy: true
        }
      );
      if (matchedParams) {
        routeParams = matchedParams;
        return true;
      }
      return false;
    });
    let routeCursor = foundRoute || this.routesById[rootRouteId];
    const matchedRoutes = [routeCursor];
    let isGlobalNotFound = false;
    if (
      // If we found a route, and it's not an index route and we have left over path
      foundRoute ? foundRoute.path !== "/" && routeParams["**"] : (
        // Or if we didn't find a route and we have left over path
        trimPathRight(next.pathname)
      )
    ) {
      if (this.options.notFoundRoute) {
        matchedRoutes.push(this.options.notFoundRoute);
      } else {
        isGlobalNotFound = true;
      }
    }
    while (routeCursor.parentRoute) {
      routeCursor = routeCursor.parentRoute;
      matchedRoutes.unshift(routeCursor);
    }
    const globalNotFoundRouteId = (() => {
      if (!isGlobalNotFound) {
        return void 0;
      }
      if (this.options.notFoundMode !== "root") {
        for (let i2 = matchedRoutes.length - 1; i2 >= 0; i2--) {
          const route = matchedRoutes[i2];
          if (route.children) {
            return route.id;
          }
        }
      }
      return rootRouteId;
    })();
    const parseErrors = matchedRoutes.map((route) => {
      var _a;
      let parsedParamsError;
      const parseParams = ((_a = route.options.params) == null ? void 0 : _a.parse) ?? route.options.parseParams;
      if (parseParams) {
        try {
          const parsedParams = parseParams(routeParams);
          Object.assign(routeParams, parsedParams);
        } catch (err) {
          parsedParamsError = new PathParamError(err.message, {
            cause: err
          });
          if (opts == null ? void 0 : opts.throwOnError) {
            throw parsedParamsError;
          }
          return parsedParamsError;
        }
      }
      return;
    });
    const matches = [];
    matchedRoutes.forEach((route, index2) => {
      var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
      const parentMatch = matches[index2 - 1];
      const [preMatchSearch, searchError] = (() => {
        const parentSearch = (parentMatch == null ? void 0 : parentMatch.search) ?? next.search;
        try {
          const validator = typeof route.options.validateSearch === "object" ? route.options.validateSearch.parse : route.options.validateSearch;
          const search = (validator == null ? void 0 : validator(parentSearch)) ?? {};
          return [
            {
              ...parentSearch,
              ...search
            },
            void 0
          ];
        } catch (err) {
          const searchParamError = new SearchParamError(err.message, {
            cause: err
          });
          if (opts == null ? void 0 : opts.throwOnError) {
            throw searchParamError;
          }
          return [parentSearch, searchParamError];
        }
      })();
      const loaderDeps = ((_b = (_a = route.options).loaderDeps) == null ? void 0 : _b.call(_a, {
        search: preMatchSearch
      })) ?? "";
      const loaderDepsHash = loaderDeps ? JSON.stringify(loaderDeps) : "";
      const interpolatedPath = interpolatePath({
        path: route.fullPath,
        params: routeParams
      });
      const matchId = interpolatePath({
        path: route.id,
        params: routeParams,
        leaveWildcards: true
      }) + loaderDepsHash;
      const existingMatch = this.getMatch(matchId);
      const cause = this.state.matches.find((d2) => d2.id === matchId) ? "stay" : "enter";
      let match;
      if (existingMatch) {
        match = {
          ...existingMatch,
          cause,
          params: routeParams
        };
      } else {
        const status = route.options.loader || route.options.beforeLoad || route.lazyFn || routeNeedsPreload(route) ? "pending" : "success";
        match = {
          id: matchId,
          index: index2,
          routeId: route.id,
          params: routeParams,
          pathname: joinPaths([this.basepath, interpolatedPath]),
          updatedAt: Date.now(),
          search: {},
          searchError: void 0,
          status,
          isFetching: false,
          error: void 0,
          paramsError: parseErrors[index2],
          __routeContext: {},
          __beforeLoadContext: {},
          context: {},
          abortController: new AbortController(),
          fetchCount: 0,
          cause,
          loaderDeps,
          invalid: false,
          preload: false,
          links: (_d = (_c = route.options).links) == null ? void 0 : _d.call(_c),
          scripts: (_f = (_e = route.options).scripts) == null ? void 0 : _f.call(_e),
          staticData: route.options.staticData || {},
          loadPromise: createControlledPromise(),
          fullPath: route.fullPath
        };
      }
      if (match.status === "success") {
        match.meta = (_h = (_g = route.options).meta) == null ? void 0 : _h.call(_g, {
          matches,
          match,
          params: match.params,
          loaderData: match.loaderData
        });
        match.headers = (_j = (_i = route.options).headers) == null ? void 0 : _j.call(_i, {
          loaderData: match.loaderData
        });
      }
      if (!(opts == null ? void 0 : opts.preload)) {
        match.globalNotFound = globalNotFoundRouteId === route.id;
      }
      match.search = replaceEqualDeep(match.search, preMatchSearch);
      match.searchError = searchError;
      const parentMatchId = parentMatch == null ? void 0 : parentMatch.id;
      const parentContext = !parentMatchId ? this.options.context ?? {} : parentMatch.context ?? this.options.context ?? {};
      match.context = {
        ...parentContext,
        ...match.__routeContext,
        ...match.__beforeLoadContext
      };
      const contextFnContext = {
        search: match.search,
        params: match.params,
        context: match.context,
        location: next,
        navigate: (opts2) => this.navigate({ ...opts2, _fromLocation: next }),
        buildLocation: this.buildLocation,
        cause: match.cause,
        abortController: match.abortController,
        preload: !!match.preload,
        matches
      };
      match.__routeContext = ((_l = (_k = route.options).context) == null ? void 0 : _l.call(_k, contextFnContext)) ?? {};
      match.context = {
        ...parentContext,
        ...match.__routeContext,
        ...match.__beforeLoadContext
      };
      matches.push(match);
    });
    return matches;
  }
}
class SearchParamError extends Error {
}
class PathParamError extends Error {
}
function getInitialRouterState(location) {
  return {
    loadedAt: 0,
    isLoading: false,
    isTransitioning: false,
    status: "idle",
    resolvedLocation: { ...location },
    location,
    matches: [],
    pendingMatches: [],
    cachedMatches: [],
    statusCode: 200
  };
}
function defaultSerializeError(err) {
  if (err instanceof Error) {
    const obj = {
      name: err.name,
      message: err.message
    };
    return obj;
  }
  return {
    data: err
  };
}
function isServerSideError(error) {
  if (!(typeof error === "object" && error && "data" in error)) return false;
  if (!("__isServerError" in error && error.__isServerError)) return false;
  if (!(typeof error.data === "object" && error.data)) return false;
  return error.__isServerError === true;
}
function defaultDeserializeError(serializedData) {
  if ("name" in serializedData && "message" in serializedData) {
    const error = new Error(serializedData.message);
    error.name = serializedData.name;
    return error;
  }
  return serializedData.data;
}
const matchContext = reactExports.createContext(void 0);
function useMatch(opts) {
  const nearestMatchId = reactExports.useContext(matchContext);
  const matchSelection = useRouterState({
    select: (state) => {
      const match = state.matches.find(
        (d2) => opts.from ? opts.from === d2.routeId : d2.id === nearestMatchId
      );
      invariant$1(
        !((opts.shouldThrow ?? true) && !match),
        `Could not find ${opts.from ? `an active match from "${opts.from}"` : "a nearest match!"}`
      );
      if (match === void 0) {
        return void 0;
      }
      return opts.select ? opts.select(match) : match;
    }
  });
  return matchSelection;
}
function useLoaderDeps(opts) {
  return useMatch({
    ...opts,
    select: (s2) => {
      return typeof opts.select === "function" ? opts.select(s2.loaderDeps) : s2.loaderDeps;
    }
  });
}
function useLoaderData(opts) {
  return useMatch({
    ...opts,
    select: (s2) => {
      return typeof opts.select === "function" ? opts.select(s2.loaderData) : s2.loaderData;
    }
  });
}
function useParams(opts) {
  return useMatch({
    ...opts,
    select: (match) => {
      return opts.select ? opts.select(match.params) : match.params;
    }
  });
}
function useSearch(opts) {
  return useMatch({
    ...opts,
    select: (match) => {
      return opts.select ? opts.select(match.search) : match.search;
    }
  });
}
function useNavigate(_defaultOpts) {
  const { navigate } = useRouter();
  return reactExports.useCallback(
    (options) => {
      return navigate({
        ...options
      });
    },
    [navigate]
  );
}
let Route$1 = class Route {
  /**
   * @deprecated Use the `createRoute` function instead.
   */
  constructor(options) {
    this.init = (opts) => {
      var _a, _b;
      this.originalIndex = opts.originalIndex;
      const options2 = this.options;
      const isRoot = !(options2 == null ? void 0 : options2.path) && !(options2 == null ? void 0 : options2.id);
      this.parentRoute = (_b = (_a = this.options).getParentRoute) == null ? void 0 : _b.call(_a);
      if (isRoot) {
        this._path = rootRouteId;
      } else {
        invariant$1(
          this.parentRoute
        );
      }
      let path2 = isRoot ? rootRouteId : options2.path;
      if (path2 && path2 !== "/") {
        path2 = trimPathLeft(path2);
      }
      const customId = (options2 == null ? void 0 : options2.id) || path2;
      let id2 = isRoot ? rootRouteId : joinPaths([
        this.parentRoute.id === rootRouteId ? "" : this.parentRoute.id,
        customId
      ]);
      if (path2 === rootRouteId) {
        path2 = "/";
      }
      if (id2 !== rootRouteId) {
        id2 = joinPaths(["/", id2]);
      }
      const fullPath = id2 === rootRouteId ? "/" : joinPaths([this.parentRoute.fullPath, path2]);
      this._path = path2;
      this._id = id2;
      this._fullPath = fullPath;
      this._to = fullPath;
    };
    this.updateLoader = (options2) => {
      Object.assign(this.options, options2);
      return this;
    };
    this.update = (options2) => {
      Object.assign(this.options, options2);
      return this;
    };
    this.lazy = (lazyFn) => {
      this.lazyFn = lazyFn;
      return this;
    };
    this.useMatch = (opts) => {
      return useMatch({ ...opts, from: this.id });
    };
    this.useRouteContext = (opts) => {
      return useMatch({
        ...opts,
        from: this.id,
        select: (d2) => (opts == null ? void 0 : opts.select) ? opts.select(d2.context) : d2.context
      });
    };
    this.useSearch = (opts) => {
      return useSearch({ ...opts, from: this.id });
    };
    this.useParams = (opts) => {
      return useParams({ ...opts, from: this.id });
    };
    this.useLoaderDeps = (opts) => {
      return useLoaderDeps({ ...opts, from: this.id });
    };
    this.useLoaderData = (opts) => {
      return useLoaderData({ ...opts, from: this.id });
    };
    this.useNavigate = () => {
      return useNavigate({ from: this.id });
    };
    this.options = options || {};
    this.isRoot = !(options == null ? void 0 : options.getParentRoute);
    invariant$1(
      !((options == null ? void 0 : options.id) && (options == null ? void 0 : options.path))
    );
    this.$$typeof = Symbol.for("react.memo");
  }
  get to() {
    return this._to;
  }
  get id() {
    return this._id;
  }
  get path() {
    return this._path;
  }
  get fullPath() {
    return this._fullPath;
  }
  addChildren(children) {
    return this._addFileChildren(children);
  }
  _addFileChildren(children) {
    if (Array.isArray(children)) {
      this.children = children;
    }
    if (typeof children === "object" && children !== null) {
      this.children = Object.values(children);
    }
    return this;
  }
};
function createRoute(options) {
  return new Route$1(options);
}
class RootRoute extends Route$1 {
  /**
   * @deprecated `RootRoute` is now an internal implementation detail. Use `createRootRoute()` instead.
   */
  constructor(options) {
    super(options);
  }
  addChildren(children) {
    super.addChildren(children);
    return this;
  }
  _addFileChildren(children) {
    super._addFileChildren(children);
    return this;
  }
  _addFileTypes() {
    return this;
  }
}
function createRootRoute(options) {
  return new RootRoute(options);
}
function createFileRoute(path2) {
  return new FileRoute(path2, {
    silent: true
  }).createRoute;
}
class FileRoute {
  constructor(path2, _opts) {
    this.path = path2;
    this.createRoute = (options) => {
      warning(
        this.silent
      );
      const route = createRoute(options);
      route.isRoot = false;
      return route;
    };
    this.silent = _opts == null ? void 0 : _opts.silent;
  }
}
class LazyRoute {
  constructor(opts) {
    this.useMatch = (opts2) => {
      return useMatch({ select: opts2 == null ? void 0 : opts2.select, from: this.options.id });
    };
    this.useRouteContext = (opts2) => {
      return useMatch({
        from: this.options.id,
        select: (d2) => (opts2 == null ? void 0 : opts2.select) ? opts2.select(d2.context) : d2.context
      });
    };
    this.useSearch = (opts2) => {
      return useSearch({ ...opts2, from: this.options.id });
    };
    this.useParams = (opts2) => {
      return useParams({ ...opts2, from: this.options.id });
    };
    this.useLoaderDeps = (opts2) => {
      return useLoaderDeps({ ...opts2, from: this.options.id });
    };
    this.useLoaderData = (opts2) => {
      return useLoaderData({ ...opts2, from: this.options.id });
    };
    this.useNavigate = () => {
      return useNavigate({ from: this.options.id });
    };
    this.options = opts;
    this.$$typeof = Symbol.for("react.memo");
  }
}
const routeGroupPatternRegex = /\(.+\)/g;
function removeGroups(s2) {
  return s2.replaceAll(routeGroupPatternRegex, "").replaceAll("//", "/");
}
function createLazyFileRoute(id2) {
  return (opts) => new LazyRoute({ id: removeGroups(id2), ...opts });
}
function SafeFragment(props) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: props.children });
}
function renderRouteNotFound(router2, route, data) {
  if (!route.options.notFoundComponent) {
    if (router2.options.defaultNotFoundComponent) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.defaultNotFoundComponent, { data });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(DefaultGlobalNotFound, {});
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(route.options.notFoundComponent, { data });
}
const Match = reactExports.memo(function MatchImpl({
  matchId
}) {
  var _a, _b;
  const router2 = useRouter();
  const routeId = useRouterState({
    select: (s2) => {
      var _a2;
      return (_a2 = s2.matches.find((d2) => d2.id === matchId)) == null ? void 0 : _a2.routeId;
    }
  });
  invariant$1(
    routeId
  );
  const route = router2.routesById[routeId];
  const PendingComponent = route.options.pendingComponent ?? router2.options.defaultPendingComponent;
  const pendingElement = PendingComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(PendingComponent, {}) : null;
  const routeErrorComponent = route.options.errorComponent ?? router2.options.defaultErrorComponent;
  const routeOnCatch = route.options.onCatch ?? router2.options.defaultOnCatch;
  const routeNotFoundComponent = route.isRoot ? (
    // If it's the root route, use the globalNotFound option, with fallback to the notFoundRoute's component
    route.options.notFoundComponent ?? ((_a = router2.options.notFoundRoute) == null ? void 0 : _a.options.component)
  ) : route.options.notFoundComponent;
  const ResolvedSuspenseBoundary = (
    // If we're on the root route, allow forcefully wrapping in suspense
    (!route.isRoot || route.options.wrapInSuspense) && (route.options.wrapInSuspense ?? PendingComponent ?? ((_b = route.options.errorComponent) == null ? void 0 : _b.preload)) ? reactExports.Suspense : SafeFragment
  );
  const ResolvedCatchBoundary = routeErrorComponent ? CatchBoundary : SafeFragment;
  const ResolvedNotFoundBoundary = routeNotFoundComponent ? CatchNotFound : SafeFragment;
  const resetKey = useRouterState({
    select: (s2) => s2.loadedAt
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ResolvedSuspenseBoundary, { fallback: pendingElement, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ResolvedCatchBoundary,
    {
      getResetKey: () => resetKey,
      errorComponent: routeErrorComponent || ErrorComponent,
      onCatch: (error, errorInfo) => {
        if (isNotFound(error)) throw error;
        routeOnCatch == null ? void 0 : routeOnCatch(error, errorInfo);
      },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        ResolvedNotFoundBoundary,
        {
          fallback: (error) => {
            if (!routeNotFoundComponent || error.routeId && error.routeId !== routeId || !error.routeId && !route.isRoot)
              throw error;
            return reactExports.createElement(routeNotFoundComponent, error);
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(MatchInner, { matchId })
        }
      )
    }
  ) }) });
});
const MatchInner = reactExports.memo(function MatchInnerImpl({
  matchId
}) {
  var _a, _b, _c;
  const router2 = useRouter();
  const { match, matchIndex, routeId } = useRouterState({
    select: (s2) => {
      const matchIndex2 = s2.matches.findIndex((d2) => d2.id === matchId);
      const match2 = s2.matches[matchIndex2];
      const routeId2 = match2.routeId;
      return {
        routeId: routeId2,
        matchIndex: matchIndex2,
        match: pick(match2, ["id", "status", "error", "loadPromise"])
      };
    }
  });
  const route = router2.routesById[routeId];
  const out = reactExports.useMemo(() => {
    const Comp = route.options.component ?? router2.options.defaultComponent;
    return Comp ? /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, {}) : /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {});
  }, [route.options.component, router2.options.defaultComponent]);
  const RouteErrorComponent = (route.options.errorComponent ?? router2.options.defaultErrorComponent) || ErrorComponent;
  if (match.status === "notFound") {
    let error;
    if (isServerSideError(match.error)) {
      const deserializeError = ((_a = router2.options.errorSerializer) == null ? void 0 : _a.deserialize) ?? defaultDeserializeError;
      error = deserializeError(match.error.data);
    } else {
      error = match.error;
    }
    invariant$1(isNotFound(error));
    return renderRouteNotFound(router2, route, error);
  }
  if (match.status === "redirected") {
    invariant$1(isRedirect(match.error));
    throw match.loadPromise;
  }
  if (match.status === "error") {
    if (router2.isServer) {
      return /* @__PURE__ */ jsxRuntimeExports.jsx(
        RouteErrorComponent,
        {
          error: match.error,
          info: {
            componentStack: ""
          }
        }
      );
    }
    if (isServerSideError(match.error)) {
      const deserializeError = ((_b = router2.options.errorSerializer) == null ? void 0 : _b.deserialize) ?? defaultDeserializeError;
      throw deserializeError(match.error.data);
    } else {
      throw match.error;
    }
  }
  if (match.status === "pending") {
    const pendingMinMs = route.options.pendingMinMs ?? router2.options.defaultPendingMinMs;
    if (pendingMinMs && !((_c = router2.getMatch(match.id)) == null ? void 0 : _c.minPendingPromise)) {
      if (!router2.isServer) {
        const minPendingPromise = createControlledPromise();
        Promise.resolve().then(() => {
          router2.updateMatch(match.id, (prev) => ({
            ...prev,
            minPendingPromise
          }));
        });
        setTimeout(() => {
          minPendingPromise.resolve();
          router2.updateMatch(match.id, (prev) => ({
            ...prev,
            minPendingPromise: void 0
          }));
        }, pendingMinMs);
      }
    }
    throw match.loadPromise;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    out,
    router2.AfterEachMatch ? /* @__PURE__ */ jsxRuntimeExports.jsx(router2.AfterEachMatch, { match, matchIndex }) : null
  ] });
});
const Outlet = reactExports.memo(function OutletImpl() {
  const router2 = useRouter();
  const matchId = reactExports.useContext(matchContext);
  const routeId = useRouterState({
    select: (s2) => {
      var _a;
      return (_a = s2.matches.find((d2) => d2.id === matchId)) == null ? void 0 : _a.routeId;
    }
  });
  const route = router2.routesById[routeId];
  const { parentGlobalNotFound } = useRouterState({
    select: (s2) => {
      const matches = s2.matches;
      const parentMatch = matches.find((d2) => d2.id === matchId);
      invariant$1(
        parentMatch
      );
      return {
        parentGlobalNotFound: parentMatch.globalNotFound
      };
    }
  });
  const childMatchId = useRouterState({
    select: (s2) => {
      var _a;
      const matches = s2.matches;
      const index2 = matches.findIndex((d2) => d2.id === matchId);
      return (_a = matches[index2 + 1]) == null ? void 0 : _a.id;
    }
  });
  if (parentGlobalNotFound) {
    return renderRouteNotFound(router2, route, void 0);
  }
  if (!childMatchId) {
    return null;
  }
  const nextMatch = /* @__PURE__ */ jsxRuntimeExports.jsx(Match, { matchId: childMatchId });
  const pendingElement = router2.options.defaultPendingComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.defaultPendingComponent, {}) : null;
  if (matchId === rootRouteId) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { fallback: pendingElement, children: nextMatch });
  }
  return nextMatch;
});
function Transitioner() {
  const router2 = useRouter();
  const mountLoadForRouter = reactExports.useRef({ router: router2, mounted: false });
  const routerState = useRouterState({
    select: (s2) => pick(s2, ["isLoading", "location", "resolvedLocation", "isTransitioning"])
  });
  const [isTransitioning, startReactTransition_] = reactExports.useTransition();
  const hasPendingMatches = useRouterState({
    select: (s2) => s2.matches.some((d2) => d2.status === "pending")
  });
  const previousIsLoading = usePrevious$2(routerState.isLoading);
  const isAnyPending = routerState.isLoading || isTransitioning || hasPendingMatches;
  const previousIsAnyPending = usePrevious$2(isAnyPending);
  if (!router2.isServer) {
    router2.startReactTransition = startReactTransition_;
  }
  reactExports.useEffect(() => {
    const unsub = router2.history.subscribe(router2.load);
    const nextLocation = router2.buildLocation({
      to: router2.latestLocation.pathname,
      search: true,
      params: true,
      hash: true,
      state: true
    });
    if (trimPathRight(router2.latestLocation.href) !== trimPathRight(nextLocation.href)) {
      router2.commitLocation({ ...nextLocation, replace: true });
    }
    return () => {
      unsub();
    };
  }, [router2, router2.history]);
  useLayoutEffect(() => {
    var _a;
    if (typeof window !== "undefined" && ((_a = window.__TSR__) == null ? void 0 : _a.dehydrated) || mountLoadForRouter.current.router === router2 && mountLoadForRouter.current.mounted) {
      return;
    }
    mountLoadForRouter.current = { router: router2, mounted: true };
    const tryLoad = async () => {
      try {
        await router2.load();
      } catch (err) {
        console.error(err);
      }
    };
    tryLoad();
  }, [router2]);
  useLayoutEffect(() => {
    if (previousIsLoading && !routerState.isLoading) {
      const toLocation = router2.state.location;
      const fromLocation = router2.state.resolvedLocation;
      const pathChanged = fromLocation.href !== toLocation.href;
      router2.emit({
        type: "onLoad",
        // When the new URL has committed, when the new matches have been loaded into state.matches
        fromLocation,
        toLocation,
        pathChanged
      });
    }
  }, [previousIsLoading, router2, routerState.isLoading]);
  useLayoutEffect(() => {
    if (previousIsAnyPending && !isAnyPending) {
      const toLocation = router2.state.location;
      const fromLocation = router2.state.resolvedLocation;
      const pathChanged = fromLocation.href !== toLocation.href;
      router2.emit({
        type: "onResolved",
        fromLocation,
        toLocation,
        pathChanged
      });
      router2.__store.setState((s2) => ({
        ...s2,
        status: "idle",
        resolvedLocation: s2.location
      }));
      if (typeof document !== "undefined" && document.querySelector) {
        if (router2.state.location.hash !== "") {
          const el2 = document.getElementById(router2.state.location.hash);
          if (el2) {
            el2.scrollIntoView();
          }
        }
      }
    }
  }, [isAnyPending, previousIsAnyPending, router2]);
  return null;
}
function Matches() {
  const router2 = useRouter();
  const pendingElement = router2.options.defaultPendingComponent ? /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.defaultPendingComponent, {}) : null;
  const ResolvedSuspense = router2.isServer || typeof document !== "undefined" && window.__TSR__ ? SafeFragment : reactExports.Suspense;
  const inner = /* @__PURE__ */ jsxRuntimeExports.jsxs(ResolvedSuspense, { fallback: pendingElement, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(Transitioner, {}),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MatchesInner, {})
  ] });
  return router2.options.InnerWrap ? /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.InnerWrap, { children: inner }) : inner;
}
function MatchesInner() {
  const matchId = useRouterState({
    select: (s2) => {
      var _a;
      return (_a = s2.matches[0]) == null ? void 0 : _a.id;
    }
  });
  const resetKey = useRouterState({
    select: (s2) => s2.loadedAt
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(matchContext.Provider, { value: matchId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    CatchBoundary,
    {
      getResetKey: () => resetKey,
      errorComponent: ErrorComponent,
      onCatch: (error) => {
        warning(false, error.message || error.toString());
      },
      children: matchId ? /* @__PURE__ */ jsxRuntimeExports.jsx(Match, { matchId }) : null
    }
  ) });
}
function RouterContextProvider({
  router: router2,
  children,
  ...rest
}) {
  router2.update({
    ...router2.options,
    ...rest,
    context: {
      ...router2.options.context,
      ...rest.context
    }
  });
  const routerContext2 = getRouterContext();
  const provider = /* @__PURE__ */ jsxRuntimeExports.jsx(routerContext2.Provider, { value: router2, children });
  if (router2.options.Wrap) {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(router2.options.Wrap, { children: provider });
  }
  return provider;
}
function RouterProvider({ router: router2, ...rest }) {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(RouterContextProvider, { router: router2, ...rest, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Matches, {}) });
}
const scriptRel = function detectScriptRel() {
  const relList = typeof document !== "undefined" && document.createElement("link").relList;
  return relList && relList.supports && relList.supports("modulepreload") ? "modulepreload" : "preload";
}();
const assetsURL = function(dep, importerUrl) {
  return new URL(dep, importerUrl).href;
};
const seen = {};
const __vitePreload = function preload(baseModule, deps, importerUrl) {
  let promise = Promise.resolve();
  if (deps && deps.length > 0) {
    const links = document.getElementsByTagName("link");
    const cspNonceMeta = document.querySelector(
      "meta[property=csp-nonce]"
    );
    const cspNonce = cspNonceMeta?.nonce || cspNonceMeta?.getAttribute("nonce");
    promise = Promise.allSettled(
      deps.map((dep) => {
        dep = assetsURL(dep, importerUrl);
        if (dep in seen) return;
        seen[dep] = true;
        const isCss = dep.endsWith(".css");
        const cssSelector = isCss ? '[rel="stylesheet"]' : "";
        const isBaseRelative = !!importerUrl;
        if (isBaseRelative) {
          for (let i2 = links.length - 1; i2 >= 0; i2--) {
            const link2 = links[i2];
            if (link2.href === dep && (!isCss || link2.rel === "stylesheet")) {
              return;
            }
          }
        } else if (document.querySelector(`link[href="${dep}"]${cssSelector}`)) {
          return;
        }
        const link = document.createElement("link");
        link.rel = isCss ? "stylesheet" : scriptRel;
        if (!isCss) {
          link.as = "script";
        }
        link.crossOrigin = "";
        link.href = dep;
        if (cspNonce) {
          link.setAttribute("nonce", cspNonce);
        }
        document.head.appendChild(link);
        if (isCss) {
          return new Promise((res, rej) => {
            link.addEventListener("load", res);
            link.addEventListener(
              "error",
              () => rej(new Error(`Unable to preload CSS for ${dep}`))
            );
          });
        }
      })
    );
  }
  function handlePreloadError(err) {
    const e2 = new Event("vite:preloadError", {
      cancelable: true
    });
    e2.payload = err;
    window.dispatchEvent(e2);
    if (!e2.defaultPrevented) {
      throw err;
    }
  }
  return promise.then((res) => {
    for (const item of res || []) {
      if (item.status !== "rejected") continue;
      handlePreloadError(item.reason);
    }
    return baseModule().catch(handlePreloadError);
  });
};
const __variableDynamicImportRuntimeHelper = (glob, path2, segs) => {
  const v2 = glob[path2];
  if (v2) {
    return typeof v2 === "function" ? v2() : Promise.resolve(v2);
  }
  return new Promise((_2, reject) => {
    (typeof queueMicrotask === "function" ? queueMicrotask : setTimeout)(
      reject.bind(
        null,
        new Error(
          "Unknown variable dynamic import: " + path2 + (path2.split("/").length !== segs ? ". Note that variables only represent file names one level deep." : "")
        )
      )
    );
  });
};
const warn = (...args) => {
  if (console?.warn) {
    if (isString$2(args[0])) args[0] = `react-i18next:: ${args[0]}`;
    console.warn(...args);
  }
};
const alreadyWarned = {};
const warnOnce = (...args) => {
  if (isString$2(args[0]) && alreadyWarned[args[0]]) return;
  if (isString$2(args[0])) alreadyWarned[args[0]] = /* @__PURE__ */ new Date();
  warn(...args);
};
const loadedClb = (i18n, cb2) => () => {
  if (i18n.isInitialized) {
    cb2();
  } else {
    const initialized = () => {
      setTimeout(() => {
        i18n.off("initialized", initialized);
      }, 0);
      cb2();
    };
    i18n.on("initialized", initialized);
  }
};
const loadNamespaces = (i18n, ns, cb2) => {
  i18n.loadNamespaces(ns, loadedClb(i18n, cb2));
};
const loadLanguages = (i18n, lng, ns, cb2) => {
  if (isString$2(ns)) ns = [ns];
  if (i18n.options.preload && i18n.options.preload.indexOf(lng) > -1) return loadNamespaces(i18n, ns, cb2);
  ns.forEach((n2) => {
    if (i18n.options.ns.indexOf(n2) < 0) i18n.options.ns.push(n2);
  });
  i18n.loadLanguages(lng, loadedClb(i18n, cb2));
};
const hasLoadedNamespace = (ns, i18n, options = {}) => {
  if (!i18n.languages || !i18n.languages.length) {
    warnOnce("i18n.languages were undefined or empty", i18n.languages);
    return true;
  }
  return i18n.hasLoadedNamespace(ns, {
    lng: options.lng,
    precheck: (i18nInstance2, loadNotPending) => {
      if (options.bindI18n?.indexOf("languageChanging") > -1 && i18nInstance2.services.backendConnector.backend && i18nInstance2.isLanguageChangingTo && !loadNotPending(i18nInstance2.isLanguageChangingTo, ns)) return false;
    }
  });
};
const isString$2 = (obj) => typeof obj === "string";
const isObject$2 = (obj) => typeof obj === "object" && obj !== null;
const matchHtmlEntity = /&(?:amp|#38|lt|#60|gt|#62|apos|#39|quot|#34|nbsp|#160|copy|#169|reg|#174|hellip|#8230|#x2F|#47);/g;
const htmlEntities = {
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"',
  "&nbsp;": " ",
  "&#160;": " ",
  "&copy;": "©",
  "&#169;": "©",
  "&reg;": "®",
  "&#174;": "®",
  "&hellip;": "…",
  "&#8230;": "…",
  "&#x2F;": "/",
  "&#47;": "/"
};
const unescapeHtmlEntity = (m2) => htmlEntities[m2];
const unescape = (text) => text.replace(matchHtmlEntity, unescapeHtmlEntity);
let defaultOptions$1 = {
  bindI18n: "languageChanged",
  bindI18nStore: "",
  transEmptyNodeValue: "",
  transSupportBasicHtmlNodes: true,
  transWrapTextNodes: "",
  transKeepBasicHtmlNodesFor: ["br", "strong", "i", "p"],
  useSuspense: true,
  unescape
};
const setDefaults = (options = {}) => {
  defaultOptions$1 = {
    ...defaultOptions$1,
    ...options
  };
};
const getDefaults$1 = () => defaultOptions$1;
let i18nInstance;
const setI18n = (instance2) => {
  i18nInstance = instance2;
};
const getI18n = () => i18nInstance;
const initReactI18next = {
  type: "3rdParty",
  init(instance2) {
    setDefaults(instance2.options.react);
    setI18n(instance2);
  }
};
const I18nContext = reactExports.createContext();
class ReportNamespaces {
  constructor() {
    this.usedNamespaces = {};
  }
  addUsedNamespaces(namespaces) {
    namespaces.forEach((ns) => {
      if (!this.usedNamespaces[ns]) this.usedNamespaces[ns] = true;
    });
  }
  getUsedNamespaces() {
    return Object.keys(this.usedNamespaces);
  }
}
const usePrevious$1 = (value, ignore) => {
  const ref = reactExports.useRef();
  reactExports.useEffect(() => {
    ref.current = value;
  }, [value, ignore]);
  return ref.current;
};
const alwaysNewT = (i18n, language, namespace, keyPrefix) => i18n.getFixedT(language, namespace, keyPrefix);
const useMemoizedT = (i18n, language, namespace, keyPrefix) => reactExports.useCallback(alwaysNewT(i18n, language, namespace, keyPrefix), [i18n, language, namespace, keyPrefix]);
const useTranslation = (ns, props = {}) => {
  const {
    i18n: i18nFromProps
  } = props;
  const {
    i18n: i18nFromContext,
    defaultNS: defaultNSFromContext
  } = reactExports.useContext(I18nContext) || {};
  const i18n = i18nFromProps || i18nFromContext || getI18n();
  if (i18n && !i18n.reportNamespaces) i18n.reportNamespaces = new ReportNamespaces();
  if (!i18n) {
    warnOnce("You will need to pass in an i18next instance by using initReactI18next");
    const notReadyT = (k2, optsOrDefaultValue) => {
      if (isString$2(optsOrDefaultValue)) return optsOrDefaultValue;
      if (isObject$2(optsOrDefaultValue) && isString$2(optsOrDefaultValue.defaultValue)) return optsOrDefaultValue.defaultValue;
      return Array.isArray(k2) ? k2[k2.length - 1] : k2;
    };
    const retNotReady = [notReadyT, {}, false];
    retNotReady.t = notReadyT;
    retNotReady.i18n = {};
    retNotReady.ready = false;
    return retNotReady;
  }
  if (i18n.options.react?.wait) warnOnce("It seems you are still using the old wait option, you may migrate to the new useSuspense behaviour.");
  const i18nOptions = {
    ...getDefaults$1(),
    ...i18n.options.react,
    ...props
  };
  const {
    useSuspense,
    keyPrefix
  } = i18nOptions;
  let namespaces = ns || defaultNSFromContext || i18n.options?.defaultNS;
  namespaces = isString$2(namespaces) ? [namespaces] : namespaces || ["translation"];
  i18n.reportNamespaces.addUsedNamespaces?.(namespaces);
  const ready = (i18n.isInitialized || i18n.initializedStoreOnce) && namespaces.every((n2) => hasLoadedNamespace(n2, i18n, i18nOptions));
  const memoGetT = useMemoizedT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  const getT = () => memoGetT;
  const getNewT = () => alwaysNewT(i18n, props.lng || null, i18nOptions.nsMode === "fallback" ? namespaces : namespaces[0], keyPrefix);
  const [t2, setT] = reactExports.useState(getT);
  let joinedNS = namespaces.join();
  if (props.lng) joinedNS = `${props.lng}${joinedNS}`;
  const previousJoinedNS = usePrevious$1(joinedNS);
  const isMounted = reactExports.useRef(true);
  reactExports.useEffect(() => {
    const {
      bindI18n,
      bindI18nStore
    } = i18nOptions;
    isMounted.current = true;
    if (!ready && !useSuspense) {
      if (props.lng) {
        loadLanguages(i18n, props.lng, namespaces, () => {
          if (isMounted.current) setT(getNewT);
        });
      } else {
        loadNamespaces(i18n, namespaces, () => {
          if (isMounted.current) setT(getNewT);
        });
      }
    }
    if (ready && previousJoinedNS && previousJoinedNS !== joinedNS && isMounted.current) {
      setT(getNewT);
    }
    const boundReset = () => {
      if (isMounted.current) setT(getNewT);
    };
    if (bindI18n) i18n?.on(bindI18n, boundReset);
    if (bindI18nStore) i18n?.store.on(bindI18nStore, boundReset);
    return () => {
      isMounted.current = false;
      if (i18n) bindI18n?.split(" ").forEach((e2) => i18n.off(e2, boundReset));
      if (bindI18nStore && i18n) bindI18nStore.split(" ").forEach((e2) => i18n.store.off(e2, boundReset));
    };
  }, [i18n, joinedNS]);
  reactExports.useEffect(() => {
    if (isMounted.current && ready) {
      setT(getT);
    }
  }, [i18n, keyPrefix, ready]);
  const ret = [t2, i18n, ready];
  ret.t = t2;
  ret.i18n = i18n;
  ret.ready = ready;
  if (ready) return ret;
  if (!ready && !useSuspense) return ret;
  throw new Promise((resolve) => {
    if (props.lng) {
      loadLanguages(i18n, props.lng, namespaces, () => resolve());
    } else {
      loadNamespaces(i18n, namespaces, () => resolve());
    }
  });
};
const isString$1 = (obj) => typeof obj === "string";
const defer = () => {
  let res;
  let rej;
  const promise = new Promise((resolve, reject) => {
    res = resolve;
    rej = reject;
  });
  promise.resolve = res;
  promise.reject = rej;
  return promise;
};
const makeString = (object) => {
  if (object == null) return "";
  return "" + object;
};
const copy = (a2, s2, t2) => {
  a2.forEach((m2) => {
    if (s2[m2]) t2[m2] = s2[m2];
  });
};
const lastOfPathSeparatorRegExp = /###/g;
const cleanKey = (key) => key && key.indexOf("###") > -1 ? key.replace(lastOfPathSeparatorRegExp, ".") : key;
const canNotTraverseDeeper = (object) => !object || isString$1(object);
const getLastOfPath = (object, path2, Empty) => {
  const stack = !isString$1(path2) ? path2 : path2.split(".");
  let stackIndex = 0;
  while (stackIndex < stack.length - 1) {
    if (canNotTraverseDeeper(object)) return {};
    const key = cleanKey(stack[stackIndex]);
    if (!object[key] && Empty) object[key] = new Empty();
    if (Object.prototype.hasOwnProperty.call(object, key)) {
      object = object[key];
    } else {
      object = {};
    }
    ++stackIndex;
  }
  if (canNotTraverseDeeper(object)) return {};
  return {
    obj: object,
    k: cleanKey(stack[stackIndex])
  };
};
const setPath = (object, path2, newValue) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2, Object);
  if (obj !== void 0 || path2.length === 1) {
    obj[k2] = newValue;
    return;
  }
  let e2 = path2[path2.length - 1];
  let p2 = path2.slice(0, path2.length - 1);
  let last2 = getLastOfPath(object, p2, Object);
  while (last2.obj === void 0 && p2.length) {
    e2 = `${p2[p2.length - 1]}.${e2}`;
    p2 = p2.slice(0, p2.length - 1);
    last2 = getLastOfPath(object, p2, Object);
    if (last2?.obj && typeof last2.obj[`${last2.k}.${e2}`] !== "undefined") {
      last2.obj = void 0;
    }
  }
  last2.obj[`${last2.k}.${e2}`] = newValue;
};
const pushPath = (object, path2, newValue, concat) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2, Object);
  obj[k2] = obj[k2] || [];
  obj[k2].push(newValue);
};
const getPath = (object, path2) => {
  const {
    obj,
    k: k2
  } = getLastOfPath(object, path2);
  if (!obj) return void 0;
  return obj[k2];
};
const getPathWithDefaults = (data, defaultData, key) => {
  const value = getPath(data, key);
  if (value !== void 0) {
    return value;
  }
  return getPath(defaultData, key);
};
const deepExtend = (target, source, overwrite) => {
  for (const prop in source) {
    if (prop !== "__proto__" && prop !== "constructor") {
      if (prop in target) {
        if (isString$1(target[prop]) || target[prop] instanceof String || isString$1(source[prop]) || source[prop] instanceof String) {
          if (overwrite) target[prop] = source[prop];
        } else {
          deepExtend(target[prop], source[prop], overwrite);
        }
      } else {
        target[prop] = source[prop];
      }
    }
  }
  return target;
};
const regexEscape = (str) => str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
var _entityMap = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;",
  "/": "&#x2F;"
};
const escape = (data) => {
  if (isString$1(data)) {
    return data.replace(/[&<>"'\/]/g, (s2) => _entityMap[s2]);
  }
  return data;
};
class RegExpCache {
  constructor(capacity) {
    this.capacity = capacity;
    this.regExpMap = /* @__PURE__ */ new Map();
    this.regExpQueue = [];
  }
  getRegExp(pattern) {
    const regExpFromCache = this.regExpMap.get(pattern);
    if (regExpFromCache !== void 0) {
      return regExpFromCache;
    }
    const regExpNew = new RegExp(pattern);
    if (this.regExpQueue.length === this.capacity) {
      this.regExpMap.delete(this.regExpQueue.shift());
    }
    this.regExpMap.set(pattern, regExpNew);
    this.regExpQueue.push(pattern);
    return regExpNew;
  }
}
const chars = [" ", ",", "?", "!", ";"];
const looksLikeObjectPathRegExpCache = new RegExpCache(20);
const looksLikeObjectPath = (key, nsSeparator, keySeparator) => {
  nsSeparator = nsSeparator || "";
  keySeparator = keySeparator || "";
  const possibleChars = chars.filter((c2) => nsSeparator.indexOf(c2) < 0 && keySeparator.indexOf(c2) < 0);
  if (possibleChars.length === 0) return true;
  const r2 = looksLikeObjectPathRegExpCache.getRegExp(`(${possibleChars.map((c2) => c2 === "?" ? "\\?" : c2).join("|")})`);
  let matched = !r2.test(key);
  if (!matched) {
    const ki2 = key.indexOf(keySeparator);
    if (ki2 > 0 && !r2.test(key.substring(0, ki2))) {
      matched = true;
    }
  }
  return matched;
};
const deepFind = function(obj, path2) {
  let keySeparator = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : ".";
  if (!obj) return void 0;
  if (obj[path2]) return obj[path2];
  const tokens = path2.split(keySeparator);
  let current = obj;
  for (let i2 = 0; i2 < tokens.length; ) {
    if (!current || typeof current !== "object") {
      return void 0;
    }
    let next;
    let nextPath = "";
    for (let j = i2; j < tokens.length; ++j) {
      if (j !== i2) {
        nextPath += keySeparator;
      }
      nextPath += tokens[j];
      next = current[nextPath];
      if (next !== void 0) {
        if (["string", "number", "boolean"].indexOf(typeof next) > -1 && j < tokens.length - 1) {
          continue;
        }
        i2 += j - i2 + 1;
        break;
      }
    }
    current = next;
  }
  return current;
};
const getCleanedCode = (code) => code?.replace("_", "-");
const consoleLogger = {
  type: "logger",
  log(args) {
    this.output("log", args);
  },
  warn(args) {
    this.output("warn", args);
  },
  error(args) {
    this.output("error", args);
  },
  output(type, args) {
    console?.[type]?.apply?.(console, args);
  }
};
class Logger {
  constructor(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.init(concreteLogger, options);
  }
  init(concreteLogger) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.prefix = options.prefix || "i18next:";
    this.logger = concreteLogger || consoleLogger;
    this.options = options;
    this.debug = options.debug;
  }
  log() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    return this.forward(args, "log", "", true);
  }
  warn() {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }
    return this.forward(args, "warn", "", true);
  }
  error() {
    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
      args[_key3] = arguments[_key3];
    }
    return this.forward(args, "error", "");
  }
  deprecate() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.forward(args, "warn", "WARNING DEPRECATED: ", true);
  }
  forward(args, lvl, prefix2, debugOnly) {
    if (debugOnly && !this.debug) return null;
    if (isString$1(args[0])) args[0] = `${prefix2}${this.prefix} ${args[0]}`;
    return this.logger[lvl](args);
  }
  create(moduleName) {
    return new Logger(this.logger, {
      ...{
        prefix: `${this.prefix}:${moduleName}:`
      },
      ...this.options
    });
  }
  clone(options) {
    options = options || this.options;
    options.prefix = options.prefix || this.prefix;
    return new Logger(this.logger, options);
  }
}
var baseLogger = new Logger();
class EventEmitter {
  constructor() {
    this.observers = {};
  }
  on(events, listener) {
    events.split(" ").forEach((event) => {
      if (!this.observers[event]) this.observers[event] = /* @__PURE__ */ new Map();
      const numListeners = this.observers[event].get(listener) || 0;
      this.observers[event].set(listener, numListeners + 1);
    });
    return this;
  }
  off(event, listener) {
    if (!this.observers[event]) return;
    if (!listener) {
      delete this.observers[event];
      return;
    }
    this.observers[event].delete(listener);
  }
  emit(event) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
    if (this.observers[event]) {
      const cloned = Array.from(this.observers[event].entries());
      cloned.forEach((_ref) => {
        let [observer, numTimesAdded] = _ref;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer(...args);
        }
      });
    }
    if (this.observers["*"]) {
      const cloned = Array.from(this.observers["*"].entries());
      cloned.forEach((_ref2) => {
        let [observer, numTimesAdded] = _ref2;
        for (let i2 = 0; i2 < numTimesAdded; i2++) {
          observer.apply(observer, [event, ...args]);
        }
      });
    }
  }
}
class ResourceStore extends EventEmitter {
  constructor(data) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      ns: ["translation"],
      defaultNS: "translation"
    };
    super();
    this.data = data || {};
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    if (this.options.ignoreJSONStructure === void 0) {
      this.options.ignoreJSONStructure = true;
    }
  }
  addNamespaces(ns) {
    if (this.options.ns.indexOf(ns) < 0) {
      this.options.ns.push(ns);
    }
  }
  removeNamespaces(ns) {
    const index2 = this.options.ns.indexOf(ns);
    if (index2 > -1) {
      this.options.ns.splice(index2, 1);
    }
  }
  getResource(lng, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const ignoreJSONStructure = options.ignoreJSONStructure !== void 0 ? options.ignoreJSONStructure : this.options.ignoreJSONStructure;
    let path2;
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
    } else {
      path2 = [lng, ns];
      if (key) {
        if (Array.isArray(key)) {
          path2.push(...key);
        } else if (isString$1(key) && keySeparator) {
          path2.push(...key.split(keySeparator));
        } else {
          path2.push(key);
        }
      }
    }
    const result = getPath(this.data, path2);
    if (!result && !ns && !key && lng.indexOf(".") > -1) {
      lng = path2[0];
      ns = path2[1];
      key = path2.slice(2).join(".");
    }
    if (result || !ignoreJSONStructure || !isString$1(key)) return result;
    return deepFind(this.data?.[lng]?.[ns], key, keySeparator);
  }
  addResource(lng, ns, key, value) {
    let options = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      silent: false
    };
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let path2 = [lng, ns];
    if (key) path2 = path2.concat(keySeparator ? key.split(keySeparator) : key);
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      value = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    setPath(this.data, path2, value);
    if (!options.silent) this.emit("added", lng, ns, key, value);
  }
  addResources(lng, ns, resources) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {
      silent: false
    };
    for (const m2 in resources) {
      if (isString$1(resources[m2]) || Array.isArray(resources[m2])) this.addResource(lng, ns, m2, resources[m2], {
        silent: true
      });
    }
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  addResourceBundle(lng, ns, resources, deep, overwrite) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {
      silent: false,
      skipCopy: false
    };
    let path2 = [lng, ns];
    if (lng.indexOf(".") > -1) {
      path2 = lng.split(".");
      deep = resources;
      resources = ns;
      ns = path2[1];
    }
    this.addNamespaces(ns);
    let pack = getPath(this.data, path2) || {};
    if (!options.skipCopy) resources = JSON.parse(JSON.stringify(resources));
    if (deep) {
      deepExtend(pack, resources, overwrite);
    } else {
      pack = {
        ...pack,
        ...resources
      };
    }
    setPath(this.data, path2, pack);
    if (!options.silent) this.emit("added", lng, ns, resources);
  }
  removeResourceBundle(lng, ns) {
    if (this.hasResourceBundle(lng, ns)) {
      delete this.data[lng][ns];
    }
    this.removeNamespaces(ns);
    this.emit("removed", lng, ns);
  }
  hasResourceBundle(lng, ns) {
    return this.getResource(lng, ns) !== void 0;
  }
  getResourceBundle(lng, ns) {
    if (!ns) ns = this.options.defaultNS;
    return this.getResource(lng, ns);
  }
  getDataByLanguage(lng) {
    return this.data[lng];
  }
  hasLanguageSomeTranslations(lng) {
    const data = this.getDataByLanguage(lng);
    const n2 = data && Object.keys(data) || [];
    return !!n2.find((v2) => data[v2] && Object.keys(data[v2]).length > 0);
  }
  toJSON() {
    return this.data;
  }
}
var postProcessor = {
  processors: {},
  addPostProcessor(module) {
    this.processors[module.name] = module;
  },
  handle(processors, value, key, options, translator) {
    processors.forEach((processor) => {
      value = this.processors[processor]?.process(value, key, options, translator) ?? value;
    });
    return value;
  }
};
const checkedLoadedFor = {};
class Translator extends EventEmitter {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    super();
    copy(["resourceStore", "languageUtils", "pluralResolver", "interpolator", "backendConnector", "i18nFormat", "utils"], services, this);
    this.options = options;
    if (this.options.keySeparator === void 0) {
      this.options.keySeparator = ".";
    }
    this.logger = baseLogger.create("translator");
  }
  changeLanguage(lng) {
    if (lng) this.language = lng;
  }
  exists(key) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    if (key === void 0 || key === null) {
      return false;
    }
    const resolved = this.resolve(key, options);
    return resolved?.res !== void 0;
  }
  extractFromKey(key, options) {
    let nsSeparator = options.nsSeparator !== void 0 ? options.nsSeparator : this.options.nsSeparator;
    if (nsSeparator === void 0) nsSeparator = ":";
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    let namespaces = options.ns || this.options.defaultNS || [];
    const wouldCheckForNsInKey = nsSeparator && key.indexOf(nsSeparator) > -1;
    const seemsNaturalLanguage = !this.options.userDefinedKeySeparator && !options.keySeparator && !this.options.userDefinedNsSeparator && !options.nsSeparator && !looksLikeObjectPath(key, nsSeparator, keySeparator);
    if (wouldCheckForNsInKey && !seemsNaturalLanguage) {
      const m2 = key.match(this.interpolator.nestingRegexp);
      if (m2 && m2.length > 0) {
        return {
          key,
          namespaces: isString$1(namespaces) ? [namespaces] : namespaces
        };
      }
      const parts = key.split(nsSeparator);
      if (nsSeparator !== keySeparator || nsSeparator === keySeparator && this.options.ns.indexOf(parts[0]) > -1) namespaces = parts.shift();
      key = parts.join(keySeparator);
    }
    return {
      key,
      namespaces: isString$1(namespaces) ? [namespaces] : namespaces
    };
  }
  translate(keys, options, lastKey) {
    if (typeof options !== "object" && this.options.overloadTranslationOptionHandler) {
      options = this.options.overloadTranslationOptionHandler(arguments);
    }
    if (typeof options === "object") options = {
      ...options
    };
    if (!options) options = {};
    if (keys === void 0 || keys === null) return "";
    if (!Array.isArray(keys)) keys = [String(keys)];
    const returnDetails = options.returnDetails !== void 0 ? options.returnDetails : this.options.returnDetails;
    const keySeparator = options.keySeparator !== void 0 ? options.keySeparator : this.options.keySeparator;
    const {
      key,
      namespaces
    } = this.extractFromKey(keys[keys.length - 1], options);
    const namespace = namespaces[namespaces.length - 1];
    const lng = options.lng || this.language;
    const appendNamespaceToCIMode = options.appendNamespaceToCIMode || this.options.appendNamespaceToCIMode;
    if (lng?.toLowerCase() === "cimode") {
      if (appendNamespaceToCIMode) {
        const nsSeparator = options.nsSeparator || this.options.nsSeparator;
        if (returnDetails) {
          return {
            res: `${namespace}${nsSeparator}${key}`,
            usedKey: key,
            exactUsedKey: key,
            usedLng: lng,
            usedNS: namespace,
            usedParams: this.getUsedParamsDetails(options)
          };
        }
        return `${namespace}${nsSeparator}${key}`;
      }
      if (returnDetails) {
        return {
          res: key,
          usedKey: key,
          exactUsedKey: key,
          usedLng: lng,
          usedNS: namespace,
          usedParams: this.getUsedParamsDetails(options)
        };
      }
      return key;
    }
    const resolved = this.resolve(keys, options);
    let res = resolved?.res;
    const resUsedKey = resolved?.usedKey || key;
    const resExactUsedKey = resolved?.exactUsedKey || key;
    const resType = Object.prototype.toString.apply(res);
    const noObject = ["[object Number]", "[object Function]", "[object RegExp]"];
    const joinArrays = options.joinArrays !== void 0 ? options.joinArrays : this.options.joinArrays;
    const handleAsObjectInI18nFormat = !this.i18nFormat || this.i18nFormat.handleAsObject;
    const handleAsObject = !isString$1(res) && typeof res !== "boolean" && typeof res !== "number";
    if (handleAsObjectInI18nFormat && res && handleAsObject && noObject.indexOf(resType) < 0 && !(isString$1(joinArrays) && Array.isArray(res))) {
      if (!options.returnObjects && !this.options.returnObjects) {
        if (!this.options.returnedObjectHandler) {
          this.logger.warn("accessing an object - but returnObjects options is not enabled!");
        }
        const r2 = this.options.returnedObjectHandler ? this.options.returnedObjectHandler(resUsedKey, res, {
          ...options,
          ns: namespaces
        }) : `key '${key} (${this.language})' returned an object instead of string.`;
        if (returnDetails) {
          resolved.res = r2;
          resolved.usedParams = this.getUsedParamsDetails(options);
          return resolved;
        }
        return r2;
      }
      if (keySeparator) {
        const resTypeIsArray = Array.isArray(res);
        const copy2 = resTypeIsArray ? [] : {};
        const newKeyToUse = resTypeIsArray ? resExactUsedKey : resUsedKey;
        for (const m2 in res) {
          if (Object.prototype.hasOwnProperty.call(res, m2)) {
            const deepKey = `${newKeyToUse}${keySeparator}${m2}`;
            copy2[m2] = this.translate(deepKey, {
              ...options,
              ...{
                joinArrays: false,
                ns: namespaces
              }
            });
            if (copy2[m2] === deepKey) copy2[m2] = res[m2];
          }
        }
        res = copy2;
      }
    } else if (handleAsObjectInI18nFormat && isString$1(joinArrays) && Array.isArray(res)) {
      res = res.join(joinArrays);
      if (res) res = this.extendTranslation(res, keys, options, lastKey);
    } else {
      let usedDefault = false;
      let usedKey = false;
      const needsPluralHandling = options.count !== void 0 && !isString$1(options.count);
      const hasDefaultValue = Translator.hasDefaultValue(options);
      const defaultValueSuffix = needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, options) : "";
      const defaultValueSuffixOrdinalFallback = options.ordinal && needsPluralHandling ? this.pluralResolver.getSuffix(lng, options.count, {
        ordinal: false
      }) : "";
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;
      const defaultValue = needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] || options[`defaultValue${defaultValueSuffix}`] || options[`defaultValue${defaultValueSuffixOrdinalFallback}`] || options.defaultValue;
      if (!this.isValidLookup(res) && hasDefaultValue) {
        usedDefault = true;
        res = defaultValue;
      }
      if (!this.isValidLookup(res)) {
        usedKey = true;
        res = key;
      }
      const missingKeyNoValueFallbackToKey = options.missingKeyNoValueFallbackToKey || this.options.missingKeyNoValueFallbackToKey;
      const resForMissing = missingKeyNoValueFallbackToKey && usedKey ? void 0 : res;
      const updateMissing = hasDefaultValue && defaultValue !== res && this.options.updateMissing;
      if (usedKey || usedDefault || updateMissing) {
        this.logger.log(updateMissing ? "updateKey" : "missingKey", lng, namespace, key, updateMissing ? defaultValue : res);
        if (keySeparator) {
          const fk2 = this.resolve(key, {
            ...options,
            keySeparator: false
          });
          if (fk2 && fk2.res) this.logger.warn("Seems the loaded translations were in flat JSON format instead of nested. Either set keySeparator: false on init or make sure your translations are published in nested format.");
        }
        let lngs = [];
        const fallbackLngs = this.languageUtils.getFallbackCodes(this.options.fallbackLng, options.lng || this.language);
        if (this.options.saveMissingTo === "fallback" && fallbackLngs && fallbackLngs[0]) {
          for (let i2 = 0; i2 < fallbackLngs.length; i2++) {
            lngs.push(fallbackLngs[i2]);
          }
        } else if (this.options.saveMissingTo === "all") {
          lngs = this.languageUtils.toResolveHierarchy(options.lng || this.language);
        } else {
          lngs.push(options.lng || this.language);
        }
        const send = (l2, k2, specificDefaultValue) => {
          const defaultForMissing = hasDefaultValue && specificDefaultValue !== res ? specificDefaultValue : resForMissing;
          if (this.options.missingKeyHandler) {
            this.options.missingKeyHandler(l2, namespace, k2, defaultForMissing, updateMissing, options);
          } else if (this.backendConnector?.saveMissing) {
            this.backendConnector.saveMissing(l2, namespace, k2, defaultForMissing, updateMissing, options);
          }
          this.emit("missingKey", l2, namespace, k2, res);
        };
        if (this.options.saveMissing) {
          if (this.options.saveMissingPlurals && needsPluralHandling) {
            lngs.forEach((language) => {
              const suffixes = this.pluralResolver.getSuffixes(language, options);
              if (needsZeroSuffixLookup && options[`defaultValue${this.options.pluralSeparator}zero`] && suffixes.indexOf(`${this.options.pluralSeparator}zero`) < 0) {
                suffixes.push(`${this.options.pluralSeparator}zero`);
              }
              suffixes.forEach((suffix) => {
                send([language], key + suffix, options[`defaultValue${suffix}`] || defaultValue);
              });
            });
          } else {
            send(lngs, key, defaultValue);
          }
        }
      }
      res = this.extendTranslation(res, keys, options, resolved, lastKey);
      if (usedKey && res === key && this.options.appendNamespaceToMissingKey) res = `${namespace}:${key}`;
      if ((usedKey || usedDefault) && this.options.parseMissingKeyHandler) {
        res = this.options.parseMissingKeyHandler(this.options.appendNamespaceToMissingKey ? `${namespace}:${key}` : key, usedDefault ? res : void 0);
      }
    }
    if (returnDetails) {
      resolved.res = res;
      resolved.usedParams = this.getUsedParamsDetails(options);
      return resolved;
    }
    return res;
  }
  extendTranslation(res, key, options, resolved, lastKey) {
    var _this = this;
    if (this.i18nFormat?.parse) {
      res = this.i18nFormat.parse(res, {
        ...this.options.interpolation.defaultVariables,
        ...options
      }, options.lng || this.language || resolved.usedLng, resolved.usedNS, resolved.usedKey, {
        resolved
      });
    } else if (!options.skipInterpolation) {
      if (options.interpolation) this.interpolator.init({
        ...options,
        ...{
          interpolation: {
            ...this.options.interpolation,
            ...options.interpolation
          }
        }
      });
      const skipOnVariables = isString$1(res) && (options?.interpolation?.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables);
      let nestBef;
      if (skipOnVariables) {
        const nb2 = res.match(this.interpolator.nestingRegexp);
        nestBef = nb2 && nb2.length;
      }
      let data = options.replace && !isString$1(options.replace) ? options.replace : options;
      if (this.options.interpolation.defaultVariables) data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
      res = this.interpolator.interpolate(res, data, options.lng || this.language || resolved.usedLng, options);
      if (skipOnVariables) {
        const na = res.match(this.interpolator.nestingRegexp);
        const nestAft = na && na.length;
        if (nestBef < nestAft) options.nest = false;
      }
      if (!options.lng && resolved && resolved.res) options.lng = this.language || resolved.usedLng;
      if (options.nest !== false) res = this.interpolator.nest(res, function() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        if (lastKey?.[0] === args[0] && !options.context) {
          _this.logger.warn(`It seems you are nesting recursively key: ${args[0]} in key: ${key[0]}`);
          return null;
        }
        return _this.translate(...args, key);
      }, options);
      if (options.interpolation) this.interpolator.reset();
    }
    const postProcess = options.postProcess || this.options.postProcess;
    const postProcessorNames = isString$1(postProcess) ? [postProcess] : postProcess;
    if (res !== void 0 && res !== null && postProcessorNames?.length && options.applyPostProcessor !== false) {
      res = postProcessor.handle(postProcessorNames, res, key, this.options && this.options.postProcessPassResolved ? {
        i18nResolved: {
          ...resolved,
          usedParams: this.getUsedParamsDetails(options)
        },
        ...options
      } : options, this);
    }
    return res;
  }
  resolve(keys) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let found;
    let usedKey;
    let exactUsedKey;
    let usedLng;
    let usedNS;
    if (isString$1(keys)) keys = [keys];
    keys.forEach((k2) => {
      if (this.isValidLookup(found)) return;
      const extracted = this.extractFromKey(k2, options);
      const key = extracted.key;
      usedKey = key;
      let namespaces = extracted.namespaces;
      if (this.options.fallbackNS) namespaces = namespaces.concat(this.options.fallbackNS);
      const needsPluralHandling = options.count !== void 0 && !isString$1(options.count);
      const needsZeroSuffixLookup = needsPluralHandling && !options.ordinal && options.count === 0;
      const needsContextHandling = options.context !== void 0 && (isString$1(options.context) || typeof options.context === "number") && options.context !== "";
      const codes = options.lngs ? options.lngs : this.languageUtils.toResolveHierarchy(options.lng || this.language, options.fallbackLng);
      namespaces.forEach((ns) => {
        if (this.isValidLookup(found)) return;
        usedNS = ns;
        if (!checkedLoadedFor[`${codes[0]}-${ns}`] && this.utils?.hasLoadedNamespace && !this.utils?.hasLoadedNamespace(usedNS)) {
          checkedLoadedFor[`${codes[0]}-${ns}`] = true;
          this.logger.warn(`key "${usedKey}" for languages "${codes.join(", ")}" won't get resolved as namespace "${usedNS}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
        }
        codes.forEach((code) => {
          if (this.isValidLookup(found)) return;
          usedLng = code;
          const finalKeys = [key];
          if (this.i18nFormat?.addLookupKeys) {
            this.i18nFormat.addLookupKeys(finalKeys, key, code, ns, options);
          } else {
            let pluralSuffix;
            if (needsPluralHandling) pluralSuffix = this.pluralResolver.getSuffix(code, options.count, options);
            const zeroSuffix = `${this.options.pluralSeparator}zero`;
            const ordinalPrefix = `${this.options.pluralSeparator}ordinal${this.options.pluralSeparator}`;
            if (needsPluralHandling) {
              finalKeys.push(key + pluralSuffix);
              if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                finalKeys.push(key + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
              }
              if (needsZeroSuffixLookup) {
                finalKeys.push(key + zeroSuffix);
              }
            }
            if (needsContextHandling) {
              const contextKey = `${key}${this.options.contextSeparator}${options.context}`;
              finalKeys.push(contextKey);
              if (needsPluralHandling) {
                finalKeys.push(contextKey + pluralSuffix);
                if (options.ordinal && pluralSuffix.indexOf(ordinalPrefix) === 0) {
                  finalKeys.push(contextKey + pluralSuffix.replace(ordinalPrefix, this.options.pluralSeparator));
                }
                if (needsZeroSuffixLookup) {
                  finalKeys.push(contextKey + zeroSuffix);
                }
              }
            }
          }
          let possibleKey;
          while (possibleKey = finalKeys.pop()) {
            if (!this.isValidLookup(found)) {
              exactUsedKey = possibleKey;
              found = this.getResource(code, ns, possibleKey, options);
            }
          }
        });
      });
    });
    return {
      res: found,
      usedKey,
      exactUsedKey,
      usedLng,
      usedNS
    };
  }
  isValidLookup(res) {
    return res !== void 0 && !(!this.options.returnNull && res === null) && !(!this.options.returnEmptyString && res === "");
  }
  getResource(code, ns, key) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    if (this.i18nFormat?.getResource) return this.i18nFormat.getResource(code, ns, key, options);
    return this.resourceStore.getResource(code, ns, key, options);
  }
  getUsedParamsDetails() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    const optionsKeys = ["defaultValue", "ordinal", "context", "replace", "lng", "lngs", "fallbackLng", "ns", "keySeparator", "nsSeparator", "returnObjects", "returnDetails", "joinArrays", "postProcess", "interpolation"];
    const useOptionsReplaceForData = options.replace && !isString$1(options.replace);
    let data = useOptionsReplaceForData ? options.replace : options;
    if (useOptionsReplaceForData && typeof options.count !== "undefined") {
      data.count = options.count;
    }
    if (this.options.interpolation.defaultVariables) {
      data = {
        ...this.options.interpolation.defaultVariables,
        ...data
      };
    }
    if (!useOptionsReplaceForData) {
      data = {
        ...data
      };
      for (const key of optionsKeys) {
        delete data[key];
      }
    }
    return data;
  }
  static hasDefaultValue(options) {
    const prefix2 = "defaultValue";
    for (const option in options) {
      if (Object.prototype.hasOwnProperty.call(options, option) && prefix2 === option.substring(0, prefix2.length) && void 0 !== options[option]) {
        return true;
      }
    }
    return false;
  }
}
class LanguageUtil {
  constructor(options) {
    this.options = options;
    this.supportedLngs = this.options.supportedLngs || false;
    this.logger = baseLogger.create("languageUtils");
  }
  getScriptPartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return null;
    const p2 = code.split("-");
    if (p2.length === 2) return null;
    p2.pop();
    if (p2[p2.length - 1].toLowerCase() === "x") return null;
    return this.formatLanguageCode(p2.join("-"));
  }
  getLanguagePartFromCode(code) {
    code = getCleanedCode(code);
    if (!code || code.indexOf("-") < 0) return code;
    const p2 = code.split("-");
    return this.formatLanguageCode(p2[0]);
  }
  formatLanguageCode(code) {
    if (isString$1(code) && code.indexOf("-") > -1) {
      let formattedCode = Intl.getCanonicalLocales(code)[0];
      if (formattedCode && this.options.lowerCaseLng) {
        formattedCode = formattedCode.toLowerCase();
      }
      if (formattedCode) return formattedCode;
      if (this.options.lowerCaseLng) {
        return code.toLowerCase();
      }
      return code;
    }
    return this.options.cleanCode || this.options.lowerCaseLng ? code.toLowerCase() : code;
  }
  isSupportedCode(code) {
    if (this.options.load === "languageOnly" || this.options.nonExplicitSupportedLngs) {
      code = this.getLanguagePartFromCode(code);
    }
    return !this.supportedLngs || !this.supportedLngs.length || this.supportedLngs.indexOf(code) > -1;
  }
  getBestMatchFromCodes(codes) {
    if (!codes) return null;
    let found;
    codes.forEach((code) => {
      if (found) return;
      const cleanedLng = this.formatLanguageCode(code);
      if (!this.options.supportedLngs || this.isSupportedCode(cleanedLng)) found = cleanedLng;
    });
    if (!found && this.options.supportedLngs) {
      codes.forEach((code) => {
        if (found) return;
        const lngOnly = this.getLanguagePartFromCode(code);
        if (this.isSupportedCode(lngOnly)) return found = lngOnly;
        found = this.options.supportedLngs.find((supportedLng) => {
          if (supportedLng === lngOnly) return supportedLng;
          if (supportedLng.indexOf("-") < 0 && lngOnly.indexOf("-") < 0) return;
          if (supportedLng.indexOf("-") > 0 && lngOnly.indexOf("-") < 0 && supportedLng.substring(0, supportedLng.indexOf("-")) === lngOnly) return supportedLng;
          if (supportedLng.indexOf(lngOnly) === 0 && lngOnly.length > 1) return supportedLng;
        });
      });
    }
    if (!found) found = this.getFallbackCodes(this.options.fallbackLng)[0];
    return found;
  }
  getFallbackCodes(fallbacks, code) {
    if (!fallbacks) return [];
    if (typeof fallbacks === "function") fallbacks = fallbacks(code);
    if (isString$1(fallbacks)) fallbacks = [fallbacks];
    if (Array.isArray(fallbacks)) return fallbacks;
    if (!code) return fallbacks.default || [];
    let found = fallbacks[code];
    if (!found) found = fallbacks[this.getScriptPartFromCode(code)];
    if (!found) found = fallbacks[this.formatLanguageCode(code)];
    if (!found) found = fallbacks[this.getLanguagePartFromCode(code)];
    if (!found) found = fallbacks.default;
    return found || [];
  }
  toResolveHierarchy(code, fallbackCode) {
    const fallbackCodes = this.getFallbackCodes(fallbackCode || this.options.fallbackLng || [], code);
    const codes = [];
    const addCode = (c2) => {
      if (!c2) return;
      if (this.isSupportedCode(c2)) {
        codes.push(c2);
      } else {
        this.logger.warn(`rejecting language code not found in supportedLngs: ${c2}`);
      }
    };
    if (isString$1(code) && (code.indexOf("-") > -1 || code.indexOf("_") > -1)) {
      if (this.options.load !== "languageOnly") addCode(this.formatLanguageCode(code));
      if (this.options.load !== "languageOnly" && this.options.load !== "currentOnly") addCode(this.getScriptPartFromCode(code));
      if (this.options.load !== "currentOnly") addCode(this.getLanguagePartFromCode(code));
    } else if (isString$1(code)) {
      addCode(this.formatLanguageCode(code));
    }
    fallbackCodes.forEach((fc2) => {
      if (codes.indexOf(fc2) < 0) addCode(this.formatLanguageCode(fc2));
    });
    return codes;
  }
}
const suffixesOrder = {
  zero: 0,
  one: 1,
  two: 2,
  few: 3,
  many: 4,
  other: 5
};
const dummyRule = {
  select: (count2) => count2 === 1 ? "one" : "other",
  resolvedOptions: () => ({
    pluralCategories: ["one", "other"]
  })
};
class PluralResolver {
  constructor(languageUtils) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.languageUtils = languageUtils;
    this.options = options;
    this.logger = baseLogger.create("pluralResolver");
    this.pluralRulesCache = {};
  }
  addRule(lng, obj) {
    this.rules[lng] = obj;
  }
  clearCache() {
    this.pluralRulesCache = {};
  }
  getRule(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    const cleanedCode = getCleanedCode(code === "dev" ? "en" : code);
    const type = options.ordinal ? "ordinal" : "cardinal";
    const cacheKey = JSON.stringify({
      cleanedCode,
      type
    });
    if (cacheKey in this.pluralRulesCache) {
      return this.pluralRulesCache[cacheKey];
    }
    let rule;
    try {
      rule = new Intl.PluralRules(cleanedCode, {
        type
      });
    } catch (err) {
      if (!Intl) {
        this.logger.error("No Intl support, please use an Intl polyfill!");
        return dummyRule;
      }
      if (!code.match(/-|_/)) return dummyRule;
      const lngPart = this.languageUtils.getLanguagePartFromCode(code);
      rule = this.getRule(lngPart, options);
    }
    this.pluralRulesCache[cacheKey] = rule;
    return rule;
  }
  needsPlural(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    return rule?.resolvedOptions().pluralCategories.length > 1;
  }
  getPluralFormsOfKey(code, key) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return this.getSuffixes(code, options).map((suffix) => `${key}${suffix}`);
  }
  getSuffixes(code) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let rule = this.getRule(code, options);
    if (!rule) rule = this.getRule("dev", options);
    if (!rule) return [];
    return rule.resolvedOptions().pluralCategories.sort((pluralCategory1, pluralCategory2) => suffixesOrder[pluralCategory1] - suffixesOrder[pluralCategory2]).map((pluralCategory) => `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${pluralCategory}`);
  }
  getSuffix(code, count2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    const rule = this.getRule(code, options);
    if (rule) {
      return `${this.options.prepend}${options.ordinal ? `ordinal${this.options.prepend}` : ""}${rule.select(count2)}`;
    }
    this.logger.warn(`no plural rule found for: ${code}`);
    return this.getSuffix("dev", count2, options);
  }
}
const deepFindWithDefaults = function(data, defaultData, key) {
  let keySeparator = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : ".";
  let ignoreJSONStructure = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
  let path2 = getPathWithDefaults(data, defaultData, key);
  if (!path2 && ignoreJSONStructure && isString$1(key)) {
    path2 = deepFind(data, key, keySeparator);
    if (path2 === void 0) path2 = deepFind(defaultData, key, keySeparator);
  }
  return path2;
};
const regexSafe = (val) => val.replace(/\$/g, "$$$$");
class Interpolator {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("interpolator");
    this.options = options;
    this.format = options?.interpolation?.format || ((value) => value);
    this.init(options);
  }
  init() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    if (!options.interpolation) options.interpolation = {
      escapeValue: true
    };
    const {
      escape: escape$12,
      escapeValue,
      useRawValueToEscape,
      prefix: prefix2,
      prefixEscaped,
      suffix,
      suffixEscaped,
      formatSeparator,
      unescapeSuffix,
      unescapePrefix,
      nestingPrefix,
      nestingPrefixEscaped,
      nestingSuffix,
      nestingSuffixEscaped,
      nestingOptionsSeparator,
      maxReplaces,
      alwaysFormat
    } = options.interpolation;
    this.escape = escape$12 !== void 0 ? escape$12 : escape;
    this.escapeValue = escapeValue !== void 0 ? escapeValue : true;
    this.useRawValueToEscape = useRawValueToEscape !== void 0 ? useRawValueToEscape : false;
    this.prefix = prefix2 ? regexEscape(prefix2) : prefixEscaped || "{{";
    this.suffix = suffix ? regexEscape(suffix) : suffixEscaped || "}}";
    this.formatSeparator = formatSeparator || ",";
    this.unescapePrefix = unescapeSuffix ? "" : unescapePrefix || "-";
    this.unescapeSuffix = this.unescapePrefix ? "" : unescapeSuffix || "";
    this.nestingPrefix = nestingPrefix ? regexEscape(nestingPrefix) : nestingPrefixEscaped || regexEscape("$t(");
    this.nestingSuffix = nestingSuffix ? regexEscape(nestingSuffix) : nestingSuffixEscaped || regexEscape(")");
    this.nestingOptionsSeparator = nestingOptionsSeparator || ",";
    this.maxReplaces = maxReplaces || 1e3;
    this.alwaysFormat = alwaysFormat !== void 0 ? alwaysFormat : false;
    this.resetRegExp();
  }
  reset() {
    if (this.options) this.init(this.options);
  }
  resetRegExp() {
    const getOrResetRegExp = (existingRegExp, pattern) => {
      if (existingRegExp?.source === pattern) {
        existingRegExp.lastIndex = 0;
        return existingRegExp;
      }
      return new RegExp(pattern, "g");
    };
    this.regexp = getOrResetRegExp(this.regexp, `${this.prefix}(.+?)${this.suffix}`);
    this.regexpUnescape = getOrResetRegExp(this.regexpUnescape, `${this.prefix}${this.unescapePrefix}(.+?)${this.unescapeSuffix}${this.suffix}`);
    this.nestingRegexp = getOrResetRegExp(this.nestingRegexp, `${this.nestingPrefix}(.+?)${this.nestingSuffix}`);
  }
  interpolate(str, data, lng, options) {
    let match;
    let value;
    let replaces;
    const defaultData = this.options && this.options.interpolation && this.options.interpolation.defaultVariables || {};
    const handleFormat = (key) => {
      if (key.indexOf(this.formatSeparator) < 0) {
        const path2 = deepFindWithDefaults(data, defaultData, key, this.options.keySeparator, this.options.ignoreJSONStructure);
        return this.alwaysFormat ? this.format(path2, void 0, lng, {
          ...options,
          ...data,
          interpolationkey: key
        }) : path2;
      }
      const p2 = key.split(this.formatSeparator);
      const k2 = p2.shift().trim();
      const f2 = p2.join(this.formatSeparator).trim();
      return this.format(deepFindWithDefaults(data, defaultData, k2, this.options.keySeparator, this.options.ignoreJSONStructure), f2, lng, {
        ...options,
        ...data,
        interpolationkey: k2
      });
    };
    this.resetRegExp();
    const missingInterpolationHandler = options?.missingInterpolationHandler || this.options.missingInterpolationHandler;
    const skipOnVariables = options?.interpolation?.skipOnVariables !== void 0 ? options.interpolation.skipOnVariables : this.options.interpolation.skipOnVariables;
    const todos = [{
      regex: this.regexpUnescape,
      safeValue: (val) => regexSafe(val)
    }, {
      regex: this.regexp,
      safeValue: (val) => this.escapeValue ? regexSafe(this.escape(val)) : regexSafe(val)
    }];
    todos.forEach((todo) => {
      replaces = 0;
      while (match = todo.regex.exec(str)) {
        const matchedVar = match[1].trim();
        value = handleFormat(matchedVar);
        if (value === void 0) {
          if (typeof missingInterpolationHandler === "function") {
            const temp = missingInterpolationHandler(str, match, options);
            value = isString$1(temp) ? temp : "";
          } else if (options && Object.prototype.hasOwnProperty.call(options, matchedVar)) {
            value = "";
          } else if (skipOnVariables) {
            value = match[0];
            continue;
          } else {
            this.logger.warn(`missed to pass in variable ${matchedVar} for interpolating ${str}`);
            value = "";
          }
        } else if (!isString$1(value) && !this.useRawValueToEscape) {
          value = makeString(value);
        }
        const safeValue = todo.safeValue(value);
        str = str.replace(match[0], safeValue);
        if (skipOnVariables) {
          todo.regex.lastIndex += value.length;
          todo.regex.lastIndex -= match[0].length;
        } else {
          todo.regex.lastIndex = 0;
        }
        replaces++;
        if (replaces >= this.maxReplaces) {
          break;
        }
      }
    });
    return str;
  }
  nest(str, fc2) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let match;
    let value;
    let clonedOptions;
    const handleHasOptions = (key, inheritedOptions) => {
      const sep = this.nestingOptionsSeparator;
      if (key.indexOf(sep) < 0) return key;
      const c2 = key.split(new RegExp(`${sep}[ ]*{`));
      let optionsString = `{${c2[1]}`;
      key = c2[0];
      optionsString = this.interpolate(optionsString, clonedOptions);
      const matchedSingleQuotes = optionsString.match(/'/g);
      const matchedDoubleQuotes = optionsString.match(/"/g);
      if ((matchedSingleQuotes?.length ?? 0) % 2 === 0 && !matchedDoubleQuotes || matchedDoubleQuotes.length % 2 !== 0) {
        optionsString = optionsString.replace(/'/g, '"');
      }
      try {
        clonedOptions = JSON.parse(optionsString);
        if (inheritedOptions) clonedOptions = {
          ...inheritedOptions,
          ...clonedOptions
        };
      } catch (e2) {
        this.logger.warn(`failed parsing options string in nesting for key ${key}`, e2);
        return `${key}${sep}${optionsString}`;
      }
      if (clonedOptions.defaultValue && clonedOptions.defaultValue.indexOf(this.prefix) > -1) delete clonedOptions.defaultValue;
      return key;
    };
    while (match = this.nestingRegexp.exec(str)) {
      let formatters = [];
      clonedOptions = {
        ...options
      };
      clonedOptions = clonedOptions.replace && !isString$1(clonedOptions.replace) ? clonedOptions.replace : clonedOptions;
      clonedOptions.applyPostProcessor = false;
      delete clonedOptions.defaultValue;
      let doReduce = false;
      if (match[0].indexOf(this.formatSeparator) !== -1 && !/{.*}/.test(match[1])) {
        const r2 = match[1].split(this.formatSeparator).map((elem) => elem.trim());
        match[1] = r2.shift();
        formatters = r2;
        doReduce = true;
      }
      value = fc2(handleHasOptions.call(this, match[1].trim(), clonedOptions), clonedOptions);
      if (value && match[0] === str && !isString$1(value)) return value;
      if (!isString$1(value)) value = makeString(value);
      if (!value) {
        this.logger.warn(`missed to resolve ${match[1]} for nesting ${str}`);
        value = "";
      }
      if (doReduce) {
        value = formatters.reduce((v2, f2) => this.format(v2, f2, options.lng, {
          ...options,
          interpolationkey: match[1].trim()
        }), value.trim());
      }
      str = str.replace(match[0], value);
      this.regexp.lastIndex = 0;
    }
    return str;
  }
}
const parseFormatStr = (formatStr) => {
  let formatName = formatStr.toLowerCase().trim();
  const formatOptions = {};
  if (formatStr.indexOf("(") > -1) {
    const p2 = formatStr.split("(");
    formatName = p2[0].toLowerCase().trim();
    const optStr = p2[1].substring(0, p2[1].length - 1);
    if (formatName === "currency" && optStr.indexOf(":") < 0) {
      if (!formatOptions.currency) formatOptions.currency = optStr.trim();
    } else if (formatName === "relativetime" && optStr.indexOf(":") < 0) {
      if (!formatOptions.range) formatOptions.range = optStr.trim();
    } else {
      const opts = optStr.split(";");
      opts.forEach((opt) => {
        if (opt) {
          const [key, ...rest] = opt.split(":");
          const val = rest.join(":").trim().replace(/^'+|'+$/g, "");
          const trimmedKey = key.trim();
          if (!formatOptions[trimmedKey]) formatOptions[trimmedKey] = val;
          if (val === "false") formatOptions[trimmedKey] = false;
          if (val === "true") formatOptions[trimmedKey] = true;
          if (!isNaN(val)) formatOptions[trimmedKey] = parseInt(val, 10);
        }
      });
    }
  }
  return {
    formatName,
    formatOptions
  };
};
const createCachedFormatter = (fn) => {
  const cache = {};
  return (val, lng, options) => {
    let optForCache = options;
    if (options && options.interpolationkey && options.formatParams && options.formatParams[options.interpolationkey] && options[options.interpolationkey]) {
      optForCache = {
        ...optForCache,
        [options.interpolationkey]: void 0
      };
    }
    const key = lng + JSON.stringify(optForCache);
    let formatter = cache[key];
    if (!formatter) {
      formatter = fn(getCleanedCode(lng), options);
      cache[key] = formatter;
    }
    return formatter(val);
  };
};
class Formatter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    this.logger = baseLogger.create("formatter");
    this.options = options;
    this.formats = {
      number: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      currency: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.NumberFormat(lng, {
          ...opt,
          style: "currency"
        });
        return (val) => formatter.format(val);
      }),
      datetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.DateTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      }),
      relativetime: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.RelativeTimeFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val, opt.range || "day");
      }),
      list: createCachedFormatter((lng, opt) => {
        const formatter = new Intl.ListFormat(lng, {
          ...opt
        });
        return (val) => formatter.format(val);
      })
    };
    this.init(options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      interpolation: {}
    };
    this.formatSeparator = options.interpolation.formatSeparator || ",";
  }
  add(name, fc2) {
    this.formats[name.toLowerCase().trim()] = fc2;
  }
  addCached(name, fc2) {
    this.formats[name.toLowerCase().trim()] = createCachedFormatter(fc2);
  }
  format(value, format2, lng) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    const formats = format2.split(this.formatSeparator);
    if (formats.length > 1 && formats[0].indexOf("(") > 1 && formats[0].indexOf(")") < 0 && formats.find((f2) => f2.indexOf(")") > -1)) {
      const lastIndex = formats.findIndex((f2) => f2.indexOf(")") > -1);
      formats[0] = [formats[0], ...formats.splice(1, lastIndex)].join(this.formatSeparator);
    }
    const result = formats.reduce((mem, f2) => {
      const {
        formatName,
        formatOptions
      } = parseFormatStr(f2);
      if (this.formats[formatName]) {
        let formatted = mem;
        try {
          const valOptions = options?.formatParams?.[options.interpolationkey] || {};
          const l2 = valOptions.locale || valOptions.lng || options.locale || options.lng || lng;
          formatted = this.formats[formatName](mem, l2, {
            ...formatOptions,
            ...options,
            ...valOptions
          });
        } catch (error) {
          this.logger.warn(error);
        }
        return formatted;
      } else {
        this.logger.warn(`there was no format function for ${formatName}`);
      }
      return mem;
    }, value);
    return result;
  }
}
const removePending = (q2, name) => {
  if (q2.pending[name] !== void 0) {
    delete q2.pending[name];
    q2.pendingCount--;
  }
};
class Connector extends EventEmitter {
  constructor(backend, store, services) {
    let options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    super();
    this.backend = backend;
    this.store = store;
    this.services = services;
    this.languageUtils = services.languageUtils;
    this.options = options;
    this.logger = baseLogger.create("backendConnector");
    this.waitingReads = [];
    this.maxParallelReads = options.maxParallelReads || 10;
    this.readingCalls = 0;
    this.maxRetries = options.maxRetries >= 0 ? options.maxRetries : 5;
    this.retryTimeout = options.retryTimeout >= 1 ? options.retryTimeout : 350;
    this.state = {};
    this.queue = [];
    this.backend?.init?.(services, options.backend, options);
  }
  queueLoad(languages, namespaces, options, callback) {
    const toLoad = {};
    const pending = {};
    const toLoadLanguages = {};
    const toLoadNamespaces = {};
    languages.forEach((lng) => {
      let hasAllNamespaces = true;
      namespaces.forEach((ns) => {
        const name = `${lng}|${ns}`;
        if (!options.reload && this.store.hasResourceBundle(lng, ns)) {
          this.state[name] = 2;
        } else if (this.state[name] < 0) ;
        else if (this.state[name] === 1) {
          if (pending[name] === void 0) pending[name] = true;
        } else {
          this.state[name] = 1;
          hasAllNamespaces = false;
          if (pending[name] === void 0) pending[name] = true;
          if (toLoad[name] === void 0) toLoad[name] = true;
          if (toLoadNamespaces[ns] === void 0) toLoadNamespaces[ns] = true;
        }
      });
      if (!hasAllNamespaces) toLoadLanguages[lng] = true;
    });
    if (Object.keys(toLoad).length || Object.keys(pending).length) {
      this.queue.push({
        pending,
        pendingCount: Object.keys(pending).length,
        loaded: {},
        errors: [],
        callback
      });
    }
    return {
      toLoad: Object.keys(toLoad),
      pending: Object.keys(pending),
      toLoadLanguages: Object.keys(toLoadLanguages),
      toLoadNamespaces: Object.keys(toLoadNamespaces)
    };
  }
  loaded(name, err, data) {
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    if (err) this.emit("failedLoading", lng, ns, err);
    if (!err && data) {
      this.store.addResourceBundle(lng, ns, data, void 0, void 0, {
        skipCopy: true
      });
    }
    this.state[name] = err ? -1 : 2;
    if (err && data) this.state[name] = 0;
    const loaded = {};
    this.queue.forEach((q2) => {
      pushPath(q2.loaded, [lng], ns);
      removePending(q2, name);
      if (err) q2.errors.push(err);
      if (q2.pendingCount === 0 && !q2.done) {
        Object.keys(q2.loaded).forEach((l2) => {
          if (!loaded[l2]) loaded[l2] = {};
          const loadedKeys = q2.loaded[l2];
          if (loadedKeys.length) {
            loadedKeys.forEach((n2) => {
              if (loaded[l2][n2] === void 0) loaded[l2][n2] = true;
            });
          }
        });
        q2.done = true;
        if (q2.errors.length) {
          q2.callback(q2.errors);
        } else {
          q2.callback();
        }
      }
    });
    this.emit("loaded", loaded);
    this.queue = this.queue.filter((q2) => !q2.done);
  }
  read(lng, ns, fcName) {
    let tried = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 0;
    let wait = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : this.retryTimeout;
    let callback = arguments.length > 5 ? arguments[5] : void 0;
    if (!lng.length) return callback(null, {});
    if (this.readingCalls >= this.maxParallelReads) {
      this.waitingReads.push({
        lng,
        ns,
        fcName,
        tried,
        wait,
        callback
      });
      return;
    }
    this.readingCalls++;
    const resolver = (err, data) => {
      this.readingCalls--;
      if (this.waitingReads.length > 0) {
        const next = this.waitingReads.shift();
        this.read(next.lng, next.ns, next.fcName, next.tried, next.wait, next.callback);
      }
      if (err && data && tried < this.maxRetries) {
        setTimeout(() => {
          this.read.call(this, lng, ns, fcName, tried + 1, wait * 2, callback);
        }, wait);
        return;
      }
      callback(err, data);
    };
    const fc2 = this.backend[fcName].bind(this.backend);
    if (fc2.length === 2) {
      try {
        const r2 = fc2(lng, ns);
        if (r2 && typeof r2.then === "function") {
          r2.then((data) => resolver(null, data)).catch(resolver);
        } else {
          resolver(null, r2);
        }
      } catch (err) {
        resolver(err);
      }
      return;
    }
    return fc2(lng, ns, resolver);
  }
  prepareLoading(languages, namespaces) {
    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    let callback = arguments.length > 3 ? arguments[3] : void 0;
    if (!this.backend) {
      this.logger.warn("No backend was added via i18next.use. Will not load resources.");
      return callback && callback();
    }
    if (isString$1(languages)) languages = this.languageUtils.toResolveHierarchy(languages);
    if (isString$1(namespaces)) namespaces = [namespaces];
    const toLoad = this.queueLoad(languages, namespaces, options, callback);
    if (!toLoad.toLoad.length) {
      if (!toLoad.pending.length) callback();
      return null;
    }
    toLoad.toLoad.forEach((name) => {
      this.loadOne(name);
    });
  }
  load(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {}, callback);
  }
  reload(languages, namespaces, callback) {
    this.prepareLoading(languages, namespaces, {
      reload: true
    }, callback);
  }
  loadOne(name) {
    let prefix2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "";
    const s2 = name.split("|");
    const lng = s2[0];
    const ns = s2[1];
    this.read(lng, ns, "read", void 0, void 0, (err, data) => {
      if (err) this.logger.warn(`${prefix2}loading namespace ${ns} for language ${lng} failed`, err);
      if (!err && data) this.logger.log(`${prefix2}loaded namespace ${ns} for language ${lng}`, data);
      this.loaded(name, err, data);
    });
  }
  saveMissing(languages, namespace, key, fallbackValue, isUpdate) {
    let options = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
    let clb = arguments.length > 6 && arguments[6] !== void 0 ? arguments[6] : () => {
    };
    if (this.services?.utils?.hasLoadedNamespace && !this.services?.utils?.hasLoadedNamespace(namespace)) {
      this.logger.warn(`did not save key "${key}" as the namespace "${namespace}" was not yet loaded`, "This means something IS WRONG in your setup. You access the t function before i18next.init / i18next.loadNamespace / i18next.changeLanguage was done. Wait for the callback or Promise to resolve before accessing it!!!");
      return;
    }
    if (key === void 0 || key === null || key === "") return;
    if (this.backend?.create) {
      const opts = {
        ...options,
        isUpdate
      };
      const fc2 = this.backend.create.bind(this.backend);
      if (fc2.length < 6) {
        try {
          let r2;
          if (fc2.length === 5) {
            r2 = fc2(languages, namespace, key, fallbackValue, opts);
          } else {
            r2 = fc2(languages, namespace, key, fallbackValue);
          }
          if (r2 && typeof r2.then === "function") {
            r2.then((data) => clb(null, data)).catch(clb);
          } else {
            clb(null, r2);
          }
        } catch (err) {
          clb(err);
        }
      } else {
        fc2(languages, namespace, key, fallbackValue, clb, opts);
      }
    }
    if (!languages || !languages[0]) return;
    this.store.addResource(languages[0], namespace, key, fallbackValue);
  }
}
const get$2 = () => ({
  debug: false,
  initAsync: true,
  ns: ["translation"],
  defaultNS: ["translation"],
  fallbackLng: ["dev"],
  fallbackNS: false,
  supportedLngs: false,
  nonExplicitSupportedLngs: false,
  load: "all",
  preload: false,
  simplifyPluralSuffix: true,
  keySeparator: ".",
  nsSeparator: ":",
  pluralSeparator: "_",
  contextSeparator: "_",
  partialBundledLanguages: false,
  saveMissing: false,
  updateMissing: false,
  saveMissingTo: "fallback",
  saveMissingPlurals: true,
  missingKeyHandler: false,
  missingInterpolationHandler: false,
  postProcess: false,
  postProcessPassResolved: false,
  returnNull: false,
  returnEmptyString: true,
  returnObjects: false,
  joinArrays: false,
  returnedObjectHandler: false,
  parseMissingKeyHandler: false,
  appendNamespaceToMissingKey: false,
  appendNamespaceToCIMode: false,
  overloadTranslationOptionHandler: (args) => {
    let ret = {};
    if (typeof args[1] === "object") ret = args[1];
    if (isString$1(args[1])) ret.defaultValue = args[1];
    if (isString$1(args[2])) ret.tDescription = args[2];
    if (typeof args[2] === "object" || typeof args[3] === "object") {
      const options = args[3] || args[2];
      Object.keys(options).forEach((key) => {
        ret[key] = options[key];
      });
    }
    return ret;
  },
  interpolation: {
    escapeValue: true,
    format: (value) => value,
    prefix: "{{",
    suffix: "}}",
    formatSeparator: ",",
    unescapePrefix: "-",
    nestingPrefix: "$t(",
    nestingSuffix: ")",
    nestingOptionsSeparator: ",",
    maxReplaces: 1e3,
    skipOnVariables: true
  }
});
const transformOptions = (options) => {
  if (isString$1(options.ns)) options.ns = [options.ns];
  if (isString$1(options.fallbackLng)) options.fallbackLng = [options.fallbackLng];
  if (isString$1(options.fallbackNS)) options.fallbackNS = [options.fallbackNS];
  if (options.supportedLngs?.indexOf?.("cimode") < 0) {
    options.supportedLngs = options.supportedLngs.concat(["cimode"]);
  }
  if (typeof options.initImmediate === "boolean") options.initAsync = options.initImmediate;
  return options;
};
const noop = () => {
};
const bindMemberFunctions = (inst) => {
  const mems = Object.getOwnPropertyNames(Object.getPrototypeOf(inst));
  mems.forEach((mem) => {
    if (typeof inst[mem] === "function") {
      inst[mem] = inst[mem].bind(inst);
    }
  });
};
class I18n extends EventEmitter {
  constructor() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    super();
    this.options = transformOptions(options);
    this.services = {};
    this.logger = baseLogger;
    this.modules = {
      external: []
    };
    bindMemberFunctions(this);
    if (callback && !this.isInitialized && !options.isClone) {
      if (!this.options.initAsync) {
        this.init(options, callback);
        return this;
      }
      setTimeout(() => {
        this.init(options, callback);
      }, 0);
    }
  }
  init() {
    var _this = this;
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    this.isInitializing = true;
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    if (!options.defaultNS && options.defaultNS !== false && options.ns) {
      if (isString$1(options.ns)) {
        options.defaultNS = options.ns;
      } else if (options.ns.indexOf("translation") < 0) {
        options.defaultNS = options.ns[0];
      }
    }
    const defOpts = get$2();
    this.options = {
      ...defOpts,
      ...this.options,
      ...transformOptions(options)
    };
    this.options.interpolation = {
      ...defOpts.interpolation,
      ...this.options.interpolation
    };
    if (options.keySeparator !== void 0) {
      this.options.userDefinedKeySeparator = options.keySeparator;
    }
    if (options.nsSeparator !== void 0) {
      this.options.userDefinedNsSeparator = options.nsSeparator;
    }
    const createClassOnDemand = (ClassOrObject) => {
      if (!ClassOrObject) return null;
      if (typeof ClassOrObject === "function") return new ClassOrObject();
      return ClassOrObject;
    };
    if (!this.options.isClone) {
      if (this.modules.logger) {
        baseLogger.init(createClassOnDemand(this.modules.logger), this.options);
      } else {
        baseLogger.init(null, this.options);
      }
      let formatter;
      if (this.modules.formatter) {
        formatter = this.modules.formatter;
      } else {
        formatter = Formatter;
      }
      const lu = new LanguageUtil(this.options);
      this.store = new ResourceStore(this.options.resources, this.options);
      const s2 = this.services;
      s2.logger = baseLogger;
      s2.resourceStore = this.store;
      s2.languageUtils = lu;
      s2.pluralResolver = new PluralResolver(lu, {
        prepend: this.options.pluralSeparator,
        simplifyPluralSuffix: this.options.simplifyPluralSuffix
      });
      if (formatter && (!this.options.interpolation.format || this.options.interpolation.format === defOpts.interpolation.format)) {
        s2.formatter = createClassOnDemand(formatter);
        s2.formatter.init(s2, this.options);
        this.options.interpolation.format = s2.formatter.format.bind(s2.formatter);
      }
      s2.interpolator = new Interpolator(this.options);
      s2.utils = {
        hasLoadedNamespace: this.hasLoadedNamespace.bind(this)
      };
      s2.backendConnector = new Connector(createClassOnDemand(this.modules.backend), s2.resourceStore, s2, this.options);
      s2.backendConnector.on("*", function(event) {
        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }
        _this.emit(event, ...args);
      });
      if (this.modules.languageDetector) {
        s2.languageDetector = createClassOnDemand(this.modules.languageDetector);
        if (s2.languageDetector.init) s2.languageDetector.init(s2, this.options.detection, this.options);
      }
      if (this.modules.i18nFormat) {
        s2.i18nFormat = createClassOnDemand(this.modules.i18nFormat);
        if (s2.i18nFormat.init) s2.i18nFormat.init(this);
      }
      this.translator = new Translator(this.services, this.options);
      this.translator.on("*", function(event) {
        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }
        _this.emit(event, ...args);
      });
      this.modules.external.forEach((m2) => {
        if (m2.init) m2.init(this);
      });
    }
    this.format = this.options.interpolation.format;
    if (!callback) callback = noop;
    if (this.options.fallbackLng && !this.services.languageDetector && !this.options.lng) {
      const codes = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
      if (codes.length > 0 && codes[0] !== "dev") this.options.lng = codes[0];
    }
    if (!this.services.languageDetector && !this.options.lng) {
      this.logger.warn("init: no languageDetector is used and no lng is defined");
    }
    const storeApi = ["getResource", "hasResourceBundle", "getResourceBundle", "getDataByLanguage"];
    storeApi.forEach((fcName) => {
      this[fcName] = function() {
        return _this.store[fcName](...arguments);
      };
    });
    const storeApiChained = ["addResource", "addResources", "addResourceBundle", "removeResourceBundle"];
    storeApiChained.forEach((fcName) => {
      this[fcName] = function() {
        _this.store[fcName](...arguments);
        return _this;
      };
    });
    const deferred = defer();
    const load = () => {
      const finish = (err, t2) => {
        this.isInitializing = false;
        if (this.isInitialized && !this.initializedStoreOnce) this.logger.warn("init: i18next is already initialized. You should call init just once!");
        this.isInitialized = true;
        if (!this.options.isClone) this.logger.log("initialized", this.options);
        this.emit("initialized", this.options);
        deferred.resolve(t2);
        callback(err, t2);
      };
      if (this.languages && !this.isInitialized) return finish(null, this.t.bind(this));
      this.changeLanguage(this.options.lng, finish);
    };
    if (this.options.resources || !this.options.initAsync) {
      load();
    } else {
      setTimeout(load, 0);
    }
    return deferred;
  }
  loadResources(language) {
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    let usedCallback = callback;
    const usedLng = isString$1(language) ? language : this.language;
    if (typeof language === "function") usedCallback = language;
    if (!this.options.resources || this.options.partialBundledLanguages) {
      if (usedLng?.toLowerCase() === "cimode" && (!this.options.preload || this.options.preload.length === 0)) return usedCallback();
      const toLoad = [];
      const append = (lng) => {
        if (!lng) return;
        if (lng === "cimode") return;
        const lngs = this.services.languageUtils.toResolveHierarchy(lng);
        lngs.forEach((l2) => {
          if (l2 === "cimode") return;
          if (toLoad.indexOf(l2) < 0) toLoad.push(l2);
        });
      };
      if (!usedLng) {
        const fallbacks = this.services.languageUtils.getFallbackCodes(this.options.fallbackLng);
        fallbacks.forEach((l2) => append(l2));
      } else {
        append(usedLng);
      }
      this.options.preload?.forEach?.((l2) => append(l2));
      this.services.backendConnector.load(toLoad, this.options.ns, (e2) => {
        if (!e2 && !this.resolvedLanguage && this.language) this.setResolvedLanguage(this.language);
        usedCallback(e2);
      });
    } else {
      usedCallback(null);
    }
  }
  reloadResources(lngs, ns, callback) {
    const deferred = defer();
    if (typeof lngs === "function") {
      callback = lngs;
      lngs = void 0;
    }
    if (typeof ns === "function") {
      callback = ns;
      ns = void 0;
    }
    if (!lngs) lngs = this.languages;
    if (!ns) ns = this.options.ns;
    if (!callback) callback = noop;
    this.services.backendConnector.reload(lngs, ns, (err) => {
      deferred.resolve();
      callback(err);
    });
    return deferred;
  }
  use(module) {
    if (!module) throw new Error("You are passing an undefined module! Please check the object you are passing to i18next.use()");
    if (!module.type) throw new Error("You are passing a wrong module! Please check the object you are passing to i18next.use()");
    if (module.type === "backend") {
      this.modules.backend = module;
    }
    if (module.type === "logger" || module.log && module.warn && module.error) {
      this.modules.logger = module;
    }
    if (module.type === "languageDetector") {
      this.modules.languageDetector = module;
    }
    if (module.type === "i18nFormat") {
      this.modules.i18nFormat = module;
    }
    if (module.type === "postProcessor") {
      postProcessor.addPostProcessor(module);
    }
    if (module.type === "formatter") {
      this.modules.formatter = module;
    }
    if (module.type === "3rdParty") {
      this.modules.external.push(module);
    }
    return this;
  }
  setResolvedLanguage(l2) {
    if (!l2 || !this.languages) return;
    if (["cimode", "dev"].indexOf(l2) > -1) return;
    for (let li2 = 0; li2 < this.languages.length; li2++) {
      const lngInLngs = this.languages[li2];
      if (["cimode", "dev"].indexOf(lngInLngs) > -1) continue;
      if (this.store.hasLanguageSomeTranslations(lngInLngs)) {
        this.resolvedLanguage = lngInLngs;
        break;
      }
    }
  }
  changeLanguage(lng, callback) {
    var _this2 = this;
    this.isLanguageChangingTo = lng;
    const deferred = defer();
    this.emit("languageChanging", lng);
    const setLngProps = (l2) => {
      this.language = l2;
      this.languages = this.services.languageUtils.toResolveHierarchy(l2);
      this.resolvedLanguage = void 0;
      this.setResolvedLanguage(l2);
    };
    const done = (err, l2) => {
      if (l2) {
        setLngProps(l2);
        this.translator.changeLanguage(l2);
        this.isLanguageChangingTo = void 0;
        this.emit("languageChanged", l2);
        this.logger.log("languageChanged", l2);
      } else {
        this.isLanguageChangingTo = void 0;
      }
      deferred.resolve(function() {
        return _this2.t(...arguments);
      });
      if (callback) callback(err, function() {
        return _this2.t(...arguments);
      });
    };
    const setLng = (lngs) => {
      if (!lng && !lngs && this.services.languageDetector) lngs = [];
      const l2 = isString$1(lngs) ? lngs : this.services.languageUtils.getBestMatchFromCodes(lngs);
      if (l2) {
        if (!this.language) {
          setLngProps(l2);
        }
        if (!this.translator.language) this.translator.changeLanguage(l2);
        this.services.languageDetector?.cacheUserLanguage?.(l2);
      }
      this.loadResources(l2, (err) => {
        done(err, l2);
      });
    };
    if (!lng && this.services.languageDetector && !this.services.languageDetector.async) {
      setLng(this.services.languageDetector.detect());
    } else if (!lng && this.services.languageDetector && this.services.languageDetector.async) {
      if (this.services.languageDetector.detect.length === 0) {
        this.services.languageDetector.detect().then(setLng);
      } else {
        this.services.languageDetector.detect(setLng);
      }
    } else {
      setLng(lng);
    }
    return deferred;
  }
  getFixedT(lng, ns, keyPrefix) {
    var _this3 = this;
    const fixedT = function(key, opts) {
      let options;
      if (typeof opts !== "object") {
        for (var _len3 = arguments.length, rest = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
          rest[_key3 - 2] = arguments[_key3];
        }
        options = _this3.options.overloadTranslationOptionHandler([key, opts].concat(rest));
      } else {
        options = {
          ...opts
        };
      }
      options.lng = options.lng || fixedT.lng;
      options.lngs = options.lngs || fixedT.lngs;
      options.ns = options.ns || fixedT.ns;
      if (options.keyPrefix !== "") options.keyPrefix = options.keyPrefix || keyPrefix || fixedT.keyPrefix;
      const keySeparator = _this3.options.keySeparator || ".";
      let resultKey;
      if (options.keyPrefix && Array.isArray(key)) {
        resultKey = key.map((k2) => `${options.keyPrefix}${keySeparator}${k2}`);
      } else {
        resultKey = options.keyPrefix ? `${options.keyPrefix}${keySeparator}${key}` : key;
      }
      return _this3.t(resultKey, options);
    };
    if (isString$1(lng)) {
      fixedT.lng = lng;
    } else {
      fixedT.lngs = lng;
    }
    fixedT.ns = ns;
    fixedT.keyPrefix = keyPrefix;
    return fixedT;
  }
  t() {
    for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
      args[_key4] = arguments[_key4];
    }
    return this.translator?.translate(...args);
  }
  exists() {
    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
      args[_key5] = arguments[_key5];
    }
    return this.translator?.exists(...args);
  }
  setDefaultNamespace(ns) {
    this.options.defaultNS = ns;
  }
  hasLoadedNamespace(ns) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    if (!this.isInitialized) {
      this.logger.warn("hasLoadedNamespace: i18next was not initialized", this.languages);
      return false;
    }
    if (!this.languages || !this.languages.length) {
      this.logger.warn("hasLoadedNamespace: i18n.languages were undefined or empty", this.languages);
      return false;
    }
    const lng = options.lng || this.resolvedLanguage || this.languages[0];
    const fallbackLng = this.options ? this.options.fallbackLng : false;
    const lastLng = this.languages[this.languages.length - 1];
    if (lng.toLowerCase() === "cimode") return true;
    const loadNotPending = (l2, n2) => {
      const loadState = this.services.backendConnector.state[`${l2}|${n2}`];
      return loadState === -1 || loadState === 0 || loadState === 2;
    };
    if (options.precheck) {
      const preResult = options.precheck(this, loadNotPending);
      if (preResult !== void 0) return preResult;
    }
    if (this.hasResourceBundle(lng, ns)) return true;
    if (!this.services.backendConnector.backend || this.options.resources && !this.options.partialBundledLanguages) return true;
    if (loadNotPending(lng, ns) && (!fallbackLng || loadNotPending(lastLng, ns))) return true;
    return false;
  }
  loadNamespaces(ns, callback) {
    const deferred = defer();
    if (!this.options.ns) {
      if (callback) callback();
      return Promise.resolve();
    }
    if (isString$1(ns)) ns = [ns];
    ns.forEach((n2) => {
      if (this.options.ns.indexOf(n2) < 0) this.options.ns.push(n2);
    });
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  loadLanguages(lngs, callback) {
    const deferred = defer();
    if (isString$1(lngs)) lngs = [lngs];
    const preloaded = this.options.preload || [];
    const newLngs = lngs.filter((lng) => preloaded.indexOf(lng) < 0 && this.services.languageUtils.isSupportedCode(lng));
    if (!newLngs.length) {
      if (callback) callback();
      return Promise.resolve();
    }
    this.options.preload = preloaded.concat(newLngs);
    this.loadResources((err) => {
      deferred.resolve();
      if (callback) callback(err);
    });
    return deferred;
  }
  dir(lng) {
    if (!lng) lng = this.resolvedLanguage || (this.languages?.length > 0 ? this.languages[0] : this.language);
    if (!lng) return "rtl";
    const rtlLngs = ["ar", "shu", "sqr", "ssh", "xaa", "yhd", "yud", "aao", "abh", "abv", "acm", "acq", "acw", "acx", "acy", "adf", "ads", "aeb", "aec", "afb", "ajp", "apc", "apd", "arb", "arq", "ars", "ary", "arz", "auz", "avl", "ayh", "ayl", "ayn", "ayp", "bbz", "pga", "he", "iw", "ps", "pbt", "pbu", "pst", "prp", "prd", "ug", "ur", "ydd", "yds", "yih", "ji", "yi", "hbo", "men", "xmn", "fa", "jpr", "peo", "pes", "prs", "dv", "sam", "ckb"];
    const languageUtils = this.services?.languageUtils || new LanguageUtil(get$2());
    return rtlLngs.indexOf(languageUtils.getLanguagePartFromCode(lng)) > -1 || lng.toLowerCase().indexOf("-arab") > 1 ? "rtl" : "ltr";
  }
  static createInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 ? arguments[1] : void 0;
    return new I18n(options, callback);
  }
  cloneInstance() {
    let options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
    let callback = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : noop;
    const forkResourceStore = options.forkResourceStore;
    if (forkResourceStore) delete options.forkResourceStore;
    const mergedOptions = {
      ...this.options,
      ...options,
      ...{
        isClone: true
      }
    };
    const clone = new I18n(mergedOptions);
    if (options.debug !== void 0 || options.prefix !== void 0) {
      clone.logger = clone.logger.clone(options);
    }
    const membersToCopy = ["store", "services", "language"];
    membersToCopy.forEach((m2) => {
      clone[m2] = this[m2];
    });
    clone.services = {
      ...this.services
    };
    clone.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    if (forkResourceStore) {
      clone.store = new ResourceStore(this.store.data, mergedOptions);
      clone.services.resourceStore = clone.store;
    }
    clone.translator = new Translator(clone.services, mergedOptions);
    clone.translator.on("*", function(event) {
      for (var _len6 = arguments.length, args = new Array(_len6 > 1 ? _len6 - 1 : 0), _key6 = 1; _key6 < _len6; _key6++) {
        args[_key6 - 1] = arguments[_key6];
      }
      clone.emit(event, ...args);
    });
    clone.init(mergedOptions, callback);
    clone.translator.options = mergedOptions;
    clone.translator.backendConnector.services.utils = {
      hasLoadedNamespace: clone.hasLoadedNamespace.bind(clone)
    };
    return clone;
  }
  toJSON() {
    return {
      options: this.options,
      store: this.store,
      language: this.language,
      languages: this.languages,
      resolvedLanguage: this.resolvedLanguage
    };
  }
}
const instance = I18n.createInstance();
instance.createInstance = I18n.createInstance;
instance.createInstance;
instance.dir;
instance.init;
instance.loadResources;
instance.reloadResources;
instance.use;
instance.changeLanguage;
instance.getFixedT;
instance.t;
instance.exists;
instance.setDefaultNamespace;
instance.hasLoadedNamespace;
instance.loadNamespaces;
instance.loadLanguages;
const {
  slice,
  forEach
} = [];
function defaults(obj) {
  forEach.call(slice.call(arguments, 1), (source) => {
    if (source) {
      for (const prop in source) {
        if (obj[prop] === void 0) obj[prop] = source[prop];
      }
    }
  });
  return obj;
}
const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
const serializeCookie = (name, val, options) => {
  const opt = options || {};
  opt.path = opt.path || "/";
  const value = encodeURIComponent(val);
  let str = `${name}=${value}`;
  if (opt.maxAge > 0) {
    const maxAge = opt.maxAge - 0;
    if (Number.isNaN(maxAge)) throw new Error("maxAge should be a Number");
    str += `; Max-Age=${Math.floor(maxAge)}`;
  }
  if (opt.domain) {
    if (!fieldContentRegExp.test(opt.domain)) {
      throw new TypeError("option domain is invalid");
    }
    str += `; Domain=${opt.domain}`;
  }
  if (opt.path) {
    if (!fieldContentRegExp.test(opt.path)) {
      throw new TypeError("option path is invalid");
    }
    str += `; Path=${opt.path}`;
  }
  if (opt.expires) {
    if (typeof opt.expires.toUTCString !== "function") {
      throw new TypeError("option expires is invalid");
    }
    str += `; Expires=${opt.expires.toUTCString()}`;
  }
  if (opt.httpOnly) str += "; HttpOnly";
  if (opt.secure) str += "; Secure";
  if (opt.sameSite) {
    const sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
    switch (sameSite) {
      case true:
        str += "; SameSite=Strict";
        break;
      case "lax":
        str += "; SameSite=Lax";
        break;
      case "strict":
        str += "; SameSite=Strict";
        break;
      case "none":
        str += "; SameSite=None";
        break;
      default:
        throw new TypeError("option sameSite is invalid");
    }
  }
  return str;
};
const cookie = {
  create(name, value, minutes, domain) {
    let cookieOptions = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {
      path: "/",
      sameSite: "strict"
    };
    if (minutes) {
      cookieOptions.expires = /* @__PURE__ */ new Date();
      cookieOptions.expires.setTime(cookieOptions.expires.getTime() + minutes * 60 * 1e3);
    }
    if (domain) cookieOptions.domain = domain;
    document.cookie = serializeCookie(name, encodeURIComponent(value), cookieOptions);
  },
  read(name) {
    const nameEQ = `${name}=`;
    const ca2 = document.cookie.split(";");
    for (let i2 = 0; i2 < ca2.length; i2++) {
      let c2 = ca2[i2];
      while (c2.charAt(0) === " ") c2 = c2.substring(1, c2.length);
      if (c2.indexOf(nameEQ) === 0) return c2.substring(nameEQ.length, c2.length);
    }
    return null;
  },
  remove(name) {
    this.create(name, "", -1);
  }
};
var cookie$1 = {
  name: "cookie",
  // Deconstruct the options object and extract the lookupCookie property
  lookup(_ref) {
    let {
      lookupCookie
    } = _ref;
    if (lookupCookie && typeof document !== "undefined") {
      return cookie.read(lookupCookie) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupCookie, cookieMinutes, cookieDomain, and cookieOptions properties
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupCookie,
      cookieMinutes,
      cookieDomain,
      cookieOptions
    } = _ref2;
    if (lookupCookie && typeof document !== "undefined") {
      cookie.create(lookupCookie, lng, cookieMinutes, cookieDomain, cookieOptions);
    }
  }
};
var querystring = {
  name: "querystring",
  // Deconstruct the options object and extract the lookupQuerystring property
  lookup(_ref) {
    let {
      lookupQuerystring
    } = _ref;
    let found;
    if (typeof window !== "undefined") {
      let {
        search
      } = window.location;
      if (!window.location.search && window.location.hash?.indexOf("?") > -1) {
        search = window.location.hash.substring(window.location.hash.indexOf("?"));
      }
      const query = search.substring(1);
      const params = query.split("&");
      for (let i2 = 0; i2 < params.length; i2++) {
        const pos = params[i2].indexOf("=");
        if (pos > 0) {
          const key = params[i2].substring(0, pos);
          if (key === lookupQuerystring) {
            found = params[i2].substring(pos + 1);
          }
        }
      }
    }
    return found;
  }
};
let hasLocalStorageSupport = null;
const localStorageAvailable = () => {
  if (hasLocalStorageSupport !== null) return hasLocalStorageSupport;
  try {
    hasLocalStorageSupport = window !== "undefined" && window.localStorage !== null;
    const testKey = "i18next.translate.boo";
    window.localStorage.setItem(testKey, "foo");
    window.localStorage.removeItem(testKey);
  } catch (e2) {
    hasLocalStorageSupport = false;
  }
  return hasLocalStorageSupport;
};
var localStorage$1 = {
  name: "localStorage",
  // Deconstruct the options object and extract the lookupLocalStorage property
  lookup(_ref) {
    let {
      lookupLocalStorage
    } = _ref;
    if (lookupLocalStorage && localStorageAvailable()) {
      return window.localStorage.getItem(lookupLocalStorage) || void 0;
    }
    return void 0;
  },
  // Deconstruct the options object and extract the lookupLocalStorage property
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupLocalStorage
    } = _ref2;
    if (lookupLocalStorage && localStorageAvailable()) {
      window.localStorage.setItem(lookupLocalStorage, lng);
    }
  }
};
let hasSessionStorageSupport = null;
const sessionStorageAvailable = () => {
  if (hasSessionStorageSupport !== null) return hasSessionStorageSupport;
  try {
    hasSessionStorageSupport = window !== "undefined" && window.sessionStorage !== null;
    const testKey = "i18next.translate.boo";
    window.sessionStorage.setItem(testKey, "foo");
    window.sessionStorage.removeItem(testKey);
  } catch (e2) {
    hasSessionStorageSupport = false;
  }
  return hasSessionStorageSupport;
};
var sessionStorage = {
  name: "sessionStorage",
  lookup(_ref) {
    let {
      lookupSessionStorage
    } = _ref;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      return window.sessionStorage.getItem(lookupSessionStorage) || void 0;
    }
    return void 0;
  },
  cacheUserLanguage(lng, _ref2) {
    let {
      lookupSessionStorage
    } = _ref2;
    if (lookupSessionStorage && sessionStorageAvailable()) {
      window.sessionStorage.setItem(lookupSessionStorage, lng);
    }
  }
};
var navigator$1 = {
  name: "navigator",
  lookup(options) {
    const found = [];
    if (typeof navigator !== "undefined") {
      const {
        languages,
        userLanguage,
        language
      } = navigator;
      if (languages) {
        for (let i2 = 0; i2 < languages.length; i2++) {
          found.push(languages[i2]);
        }
      }
      if (userLanguage) {
        found.push(userLanguage);
      }
      if (language) {
        found.push(language);
      }
    }
    return found.length > 0 ? found : void 0;
  }
};
var htmlTag = {
  name: "htmlTag",
  // Deconstruct the options object and extract the htmlTag property
  lookup(_ref) {
    let {
      htmlTag: htmlTag2
    } = _ref;
    let found;
    const internalHtmlTag = htmlTag2 || (typeof document !== "undefined" ? document.documentElement : null);
    if (internalHtmlTag && typeof internalHtmlTag.getAttribute === "function") {
      found = internalHtmlTag.getAttribute("lang");
    }
    return found;
  }
};
var path = {
  name: "path",
  // Deconstruct the options object and extract the lookupFromPathIndex property
  lookup(_ref) {
    let {
      lookupFromPathIndex
    } = _ref;
    if (typeof window === "undefined") return void 0;
    const language = window.location.pathname.match(/\/([a-zA-Z-]*)/g);
    if (!Array.isArray(language)) return void 0;
    const index2 = typeof lookupFromPathIndex === "number" ? lookupFromPathIndex : 0;
    return language[index2]?.replace("/", "");
  }
};
var subdomain = {
  name: "subdomain",
  lookup(_ref) {
    let {
      lookupFromSubdomainIndex
    } = _ref;
    const internalLookupFromSubdomainIndex = typeof lookupFromSubdomainIndex === "number" ? lookupFromSubdomainIndex + 1 : 1;
    const language = typeof window !== "undefined" && window.location?.hostname?.match(/^(\w{2,5})\.(([a-z0-9-]{1,63}\.[a-z]{2,6})|localhost)/i);
    if (!language) return void 0;
    return language[internalLookupFromSubdomainIndex];
  }
};
function getDefaults() {
  return {
    order: ["querystring", "cookie", "localStorage", "sessionStorage", "navigator", "htmlTag"],
    lookupQuerystring: "lng",
    lookupCookie: "i18next",
    lookupLocalStorage: "i18nextLng",
    lookupSessionStorage: "i18nextLng",
    // cache user language
    caches: ["localStorage"],
    excludeCacheFor: ["cimode"],
    // cookieMinutes: 10,
    // cookieDomain: 'myDomain'
    convertDetectedLanguage: (l2) => l2
  };
}
class Browser {
  constructor(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    this.type = "languageDetector";
    this.detectors = {};
    this.init(services, options);
  }
  init(services) {
    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    let i18nOptions = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    this.services = services || {
      languageUtils: {}
    };
    this.options = defaults(options, this.options || {}, getDefaults());
    if (typeof this.options.convertDetectedLanguage === "string" && this.options.convertDetectedLanguage.indexOf("15897") > -1) {
      this.options.convertDetectedLanguage = (l2) => l2.replace("-", "_");
    }
    if (this.options.lookupFromUrlIndex) this.options.lookupFromPathIndex = this.options.lookupFromUrlIndex;
    this.i18nOptions = i18nOptions;
    this.addDetector(cookie$1);
    this.addDetector(querystring);
    this.addDetector(localStorage$1);
    this.addDetector(sessionStorage);
    this.addDetector(navigator$1);
    this.addDetector(htmlTag);
    this.addDetector(path);
    this.addDetector(subdomain);
  }
  addDetector(detector) {
    this.detectors[detector.name] = detector;
    return this;
  }
  detect(detectionOrder) {
    if (!detectionOrder) detectionOrder = this.options.order;
    let detected = [];
    detectionOrder.forEach((detectorName) => {
      if (this.detectors[detectorName]) {
        let lookup = this.detectors[detectorName].lookup(this.options);
        if (lookup && typeof lookup === "string") lookup = [lookup];
        if (lookup) detected = detected.concat(lookup);
      }
    });
    detected = detected.map((d2) => this.options.convertDetectedLanguage(d2));
    if (this.services.languageUtils.getBestMatchFromCodes) return detected;
    return detected.length > 0 ? detected[0] : null;
  }
  cacheUserLanguage(lng, caches) {
    if (!caches) caches = this.options.caches;
    if (!caches) return;
    if (this.options.excludeCacheFor && this.options.excludeCacheFor.indexOf(lng) > -1) return;
    caches.forEach((cacheName) => {
      if (this.detectors[cacheName]) this.detectors[cacheName].cacheUserLanguage(lng, this.options);
    });
  }
}
Browser.type = "languageDetector";
var resourcesToBackend = function resourcesToBackend2(res) {
  return {
    type: "backend",
    init: function init(services, backendOptions, i18nextOptions) {
    },
    read: function read(language, namespace, callback) {
      if (typeof res === "function") {
        if (res.length < 3) {
          try {
            var r2 = res(language, namespace);
            if (r2 && typeof r2.then === "function") {
              r2.then(function(data) {
                return callback(null, data && data.default || data);
              }).catch(callback);
            } else {
              callback(null, r2);
            }
          } catch (err) {
            callback(err);
          }
          return;
        }
        res(language, namespace, callback);
        return;
      }
      callback(null, res && res[language] && res[language][namespace]);
    }
  };
};
const supportedLngs = {
  en: "English",
  pl: "Polski"
};
instance.use(
  resourcesToBackend(
    (language, namespace) => __variableDynamicImportRuntimeHelper(/* @__PURE__ */ Object.assign({ "../locales/en/AlgorithmsNames.json": () => __vitePreload(() => import("./AlgorithmsNames-C70z0T7I.js"), true ? [] : void 0, import.meta.url), "../locales/en/AlgorithmsVisibilityButton.json": () => __vitePreload(() => import("./AlgorithmsVisibilityButton-C3bB4VOA.js"), true ? [] : void 0, import.meta.url), "../locales/en/ChartCard.json": () => __vitePreload(() => import("./ChartCard-BVicS4vc.js"), true ? [] : void 0, import.meta.url), "../locales/en/ChartCardFooter.json": () => __vitePreload(() => import("./ChartCardFooter-BvHYLcyH.js"), true ? [] : void 0, import.meta.url), "../locales/en/ChartCardInfo.json": () => __vitePreload(() => import("./ChartCardInfo-DZB-khjS.js"), true ? [] : void 0, import.meta.url), "../locales/en/ChatControls.json": () => __vitePreload(() => import("./ChatControls-Xonox5ZY.js"), true ? [] : void 0, import.meta.url), "../locales/en/CustomDataButton.json": () => __vitePreload(() => import("./CustomDataButton-CvHMS63K.js"), true ? [] : void 0, import.meta.url), "../locales/en/ExampleDataButton.json": () => __vitePreload(() => import("./ExampleDataButton-BbLeYv0h.js"), true ? [] : void 0, import.meta.url), "../locales/en/LocaleToggleButton.json": () => __vitePreload(() => import("./LocaleToggleButton-DQ4aPH-X.js"), true ? [] : void 0, import.meta.url), "../locales/en/ShellSortGapsInfo.json": () => __vitePreload(() => import("./ShellSortGapsInfo-DO_fb-NH.js"), true ? [] : void 0, import.meta.url), "../locales/en/SpeedToggleButton.json": () => __vitePreload(() => import("./SpeedToggleButton-S3E3Gb3E.js"), true ? [] : void 0, import.meta.url), "../locales/en/StartCard.json": () => __vitePreload(() => import("./StartCard-CG8J9BCf.js"), true ? [] : void 0, import.meta.url), "../locales/en/translation.json": () => __vitePreload(() => import("./translation-ClZbUgHW.js"), true ? [] : void 0, import.meta.url), "../locales/en/useCustomDataForm.json": () => __vitePreload(() => import("./useCustomDataForm-DngkthoJ.js"), true ? [] : void 0, import.meta.url), "../locales/pl/AlgorithmsNames.json": () => __vitePreload(() => import("./AlgorithmsNames-CDN4riav.js"), true ? [] : void 0, import.meta.url), "../locales/pl/AlgorithmsVisibilityButton.json": () => __vitePreload(() => import("./AlgorithmsVisibilityButton-DnQEJLug.js"), true ? [] : void 0, import.meta.url), "../locales/pl/ChartCard.json": () => __vitePreload(() => import("./ChartCard-VigpK1Li.js"), true ? [] : void 0, import.meta.url), "../locales/pl/ChartCardFooter.json": () => __vitePreload(() => import("./ChartCardFooter-CVgT2FIA.js"), true ? [] : void 0, import.meta.url), "../locales/pl/ChartCardInfo.json": () => __vitePreload(() => import("./ChartCardInfo-B4zmKzol.js"), true ? [] : void 0, import.meta.url), "../locales/pl/ChatControls.json": () => __vitePreload(() => import("./ChatControls-BoG9G-KF.js"), true ? [] : void 0, import.meta.url), "../locales/pl/CustomDataButton.json": () => __vitePreload(() => import("./CustomDataButton-BTPpfYqA.js"), true ? [] : void 0, import.meta.url), "../locales/pl/ExampleDataButton.json": () => __vitePreload(() => import("./ExampleDataButton-CHZ5xQ61.js"), true ? [] : void 0, import.meta.url), "../locales/pl/LocaleToggleButton.json": () => __vitePreload(() => import("./LocaleToggleButton-JlfoQgHK.js"), true ? [] : void 0, import.meta.url), "../locales/pl/ShellSortGapsInfo.json": () => __vitePreload(() => import("./ShellSortGapsInfo-MUNmSzld.js"), true ? [] : void 0, import.meta.url), "../locales/pl/SpeedToggleButton.json": () => __vitePreload(() => import("./SpeedToggleButton-YiwDB0wk.js"), true ? [] : void 0, import.meta.url), "../locales/pl/StartCard.json": () => __vitePreload(() => import("./StartCard-CSXoFjH9.js"), true ? [] : void 0, import.meta.url), "../locales/pl/translation.json": () => __vitePreload(() => import("./translation-CdnDYdmq.js"), true ? [] : void 0, import.meta.url), "../locales/pl/useCustomDataForm.json": () => __vitePreload(() => import("./useCustomDataForm-C2MI-H3E.js"), true ? [] : void 0, import.meta.url) }), `../locales/${language}/${namespace}.json`, 4)
  )
).use(Browser).use(initReactI18next).init({
  fallbackLng: "en",
  supportedLngs: Object.keys(supportedLngs),
  debug: false,
  interpolation: {
    escapeValue: false
  }
});
instance.loadNamespaces([
  "AlgorithmsNames",
  "ChartCard",
  "ChartCardFooter",
  "ChartCardInfo",
  "ShellSortGapsInfo"
]);
const DndContext = reactExports.createContext({
  dragDropManager: void 0
});
function formatProdErrorMessage(code) {
  return "Minified Redux error #" + code + "; visit https://redux.js.org/Errors?code=" + code + " for the full message or use the non-minified dev environment for full errors. ";
}
var $$observable = function() {
  return typeof Symbol === "function" && Symbol.observable || "@@observable";
}();
var randomString = function randomString2() {
  return Math.random().toString(36).substring(7).split("").join(".");
};
var ActionTypes = {
  INIT: "@@redux/INIT" + randomString(),
  REPLACE: "@@redux/REPLACE" + randomString(),
  PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
    return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
  }
};
function isPlainObject$1(obj) {
  if (typeof obj !== "object" || obj === null) return false;
  var proto = obj;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(obj) === proto;
}
function createStore(reducer, preloadedState, enhancer) {
  var _ref2;
  if (typeof preloadedState === "function" && typeof enhancer === "function" || typeof enhancer === "function" && typeof arguments[3] === "function") {
    throw new Error(formatProdErrorMessage(0));
  }
  if (typeof preloadedState === "function" && typeof enhancer === "undefined") {
    enhancer = preloadedState;
    preloadedState = void 0;
  }
  if (typeof enhancer !== "undefined") {
    if (typeof enhancer !== "function") {
      throw new Error(formatProdErrorMessage(1));
    }
    return enhancer(createStore)(reducer, preloadedState);
  }
  if (typeof reducer !== "function") {
    throw new Error(formatProdErrorMessage(2));
  }
  var currentReducer = reducer;
  var currentState = preloadedState;
  var currentListeners = [];
  var nextListeners = currentListeners;
  var isDispatching = false;
  function ensureCanMutateNextListeners() {
    if (nextListeners === currentListeners) {
      nextListeners = currentListeners.slice();
    }
  }
  function getState2() {
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(3));
    }
    return currentState;
  }
  function subscribe(listener) {
    if (typeof listener !== "function") {
      throw new Error(formatProdErrorMessage(4));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(5));
    }
    var isSubscribed = true;
    ensureCanMutateNextListeners();
    nextListeners.push(listener);
    return function unsubscribe() {
      if (!isSubscribed) {
        return;
      }
      if (isDispatching) {
        throw new Error(formatProdErrorMessage(6));
      }
      isSubscribed = false;
      ensureCanMutateNextListeners();
      var index2 = nextListeners.indexOf(listener);
      nextListeners.splice(index2, 1);
      currentListeners = null;
    };
  }
  function dispatch(action) {
    if (!isPlainObject$1(action)) {
      throw new Error(formatProdErrorMessage(7));
    }
    if (typeof action.type === "undefined") {
      throw new Error(formatProdErrorMessage(8));
    }
    if (isDispatching) {
      throw new Error(formatProdErrorMessage(9));
    }
    try {
      isDispatching = true;
      currentState = currentReducer(currentState, action);
    } finally {
      isDispatching = false;
    }
    var listeners = currentListeners = nextListeners;
    for (var i2 = 0; i2 < listeners.length; i2++) {
      var listener = listeners[i2];
      listener();
    }
    return action;
  }
  function replaceReducer(nextReducer) {
    if (typeof nextReducer !== "function") {
      throw new Error(formatProdErrorMessage(10));
    }
    currentReducer = nextReducer;
    dispatch({
      type: ActionTypes.REPLACE
    });
  }
  function observable() {
    var _ref;
    var outerSubscribe = subscribe;
    return _ref = {
      /**
       * The minimal observable subscription method.
       * @param {Object} observer Any object that can be used as an observer.
       * The observer object should have a `next` method.
       * @returns {subscription} An object with an `unsubscribe` method that can
       * be used to unsubscribe the observable from the store, and prevent further
       * emission of values from the observable.
       */
      subscribe: function subscribe2(observer) {
        if (typeof observer !== "object" || observer === null) {
          throw new Error(formatProdErrorMessage(11));
        }
        function observeState() {
          if (observer.next) {
            observer.next(getState2());
          }
        }
        observeState();
        var unsubscribe = outerSubscribe(observeState);
        return {
          unsubscribe
        };
      }
    }, _ref[$$observable] = function() {
      return this;
    }, _ref;
  }
  dispatch({
    type: ActionTypes.INIT
  });
  return _ref2 = {
    dispatch,
    subscribe,
    getState: getState2,
    replaceReducer
  }, _ref2[$$observable] = observable, _ref2;
}
function invariant(condition, format2, ...args) {
  if (isProduction()) {
    if (format2 === void 0) {
      throw new Error("invariant requires an error message argument");
    }
  }
  if (!condition) {
    let error;
    if (format2 === void 0) {
      error = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
    } else {
      let argIndex = 0;
      error = new Error(format2.replace(/%s/g, function() {
        return args[argIndex++];
      }));
      error.name = "Invariant Violation";
    }
    error.framesToPop = 1;
    throw error;
  }
}
function isProduction() {
  return typeof process !== "undefined" && true;
}
function get$1(obj, path2, defaultValue) {
  return path2.split(".").reduce(
    (a2, c2) => a2 && a2[c2] ? a2[c2] : defaultValue || null,
    obj
  );
}
function without$1(items, item) {
  return items.filter(
    (i2) => i2 !== item
  );
}
function isObject$1(input) {
  return typeof input === "object";
}
function xor(itemsA, itemsB) {
  const map = /* @__PURE__ */ new Map();
  const insertItem = (item) => {
    map.set(item, map.has(item) ? map.get(item) + 1 : 1);
  };
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  const result = [];
  map.forEach((count2, key) => {
    if (count2 === 1) {
      result.push(key);
    }
  });
  return result;
}
function intersection(itemsA, itemsB) {
  return itemsA.filter(
    (t2) => itemsB.indexOf(t2) > -1
  );
}
const INIT_COORDS = "dnd-core/INIT_COORDS";
const BEGIN_DRAG = "dnd-core/BEGIN_DRAG";
const PUBLISH_DRAG_SOURCE = "dnd-core/PUBLISH_DRAG_SOURCE";
const HOVER = "dnd-core/HOVER";
const DROP = "dnd-core/DROP";
const END_DRAG = "dnd-core/END_DRAG";
function setClientOffset(clientOffset, sourceClientOffset) {
  return {
    type: INIT_COORDS,
    payload: {
      sourceClientOffset: sourceClientOffset || null,
      clientOffset: clientOffset || null
    }
  };
}
const ResetCoordinatesAction = {
  type: INIT_COORDS,
  payload: {
    clientOffset: null,
    sourceClientOffset: null
  }
};
function createBeginDrag(manager) {
  return function beginDrag(sourceIds = [], options = {
    publishSource: true
  }) {
    const { publishSource = true, clientOffset, getSourceClientOffset: getSourceClientOffset2 } = options;
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    manager.dispatch(setClientOffset(clientOffset));
    verifyInvariants$1(sourceIds, monitor, registry);
    const sourceId = getDraggableSource(sourceIds, monitor);
    if (sourceId == null) {
      manager.dispatch(ResetCoordinatesAction);
      return;
    }
    let sourceClientOffset = null;
    if (clientOffset) {
      if (!getSourceClientOffset2) {
        throw new Error("getSourceClientOffset must be defined");
      }
      verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2);
      sourceClientOffset = getSourceClientOffset2(sourceId);
    }
    manager.dispatch(setClientOffset(clientOffset, sourceClientOffset));
    const source = registry.getSource(sourceId);
    const item = source.beginDrag(monitor, sourceId);
    if (item == null) {
      return void 0;
    }
    verifyItemIsObject(item);
    registry.pinSource(sourceId);
    const itemType = registry.getSourceType(sourceId);
    return {
      type: BEGIN_DRAG,
      payload: {
        itemType,
        item,
        sourceId,
        clientOffset: clientOffset || null,
        sourceClientOffset: sourceClientOffset || null,
        isSourcePublic: !!publishSource
      }
    };
  };
}
function verifyInvariants$1(sourceIds, monitor, registry) {
  invariant(!monitor.isDragging(), "Cannot call beginDrag while dragging.");
  sourceIds.forEach(function(sourceId) {
    invariant(registry.getSource(sourceId), "Expected sourceIds to be registered.");
  });
}
function verifyGetSourceClientOffsetIsFunction(getSourceClientOffset2) {
  invariant(typeof getSourceClientOffset2 === "function", "When clientOffset is provided, getSourceClientOffset must be a function.");
}
function verifyItemIsObject(item) {
  invariant(isObject$1(item), "Item must be an object.");
}
function getDraggableSource(sourceIds, monitor) {
  let sourceId = null;
  for (let i2 = sourceIds.length - 1; i2 >= 0; i2--) {
    if (monitor.canDragSource(sourceIds[i2])) {
      sourceId = sourceIds[i2];
      break;
    }
  }
  return sourceId;
}
function _defineProperty$4(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$4(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty$4(target, key, source[key]);
    });
  }
  return target;
}
function createDrop(manager) {
  return function drop(options = {}) {
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    verifyInvariants(monitor);
    const targetIds = getDroppableTargets(monitor);
    targetIds.forEach((targetId, index2) => {
      const dropResult = determineDropResult(targetId, index2, registry, monitor);
      const action = {
        type: DROP,
        payload: {
          dropResult: _objectSpread$4({}, options, dropResult)
        }
      };
      manager.dispatch(action);
    });
  };
}
function verifyInvariants(monitor) {
  invariant(monitor.isDragging(), "Cannot call drop while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call drop twice during one drag operation.");
}
function determineDropResult(targetId, index2, registry, monitor) {
  const target = registry.getTarget(targetId);
  let dropResult = target ? target.drop(monitor, targetId) : void 0;
  verifyDropResultType(dropResult);
  if (typeof dropResult === "undefined") {
    dropResult = index2 === 0 ? {} : monitor.getDropResult();
  }
  return dropResult;
}
function verifyDropResultType(dropResult) {
  invariant(typeof dropResult === "undefined" || isObject$1(dropResult), "Drop result must either be an object or undefined.");
}
function getDroppableTargets(monitor) {
  const targetIds = monitor.getTargetIds().filter(monitor.canDropOnTarget, monitor);
  targetIds.reverse();
  return targetIds;
}
function createEndDrag(manager) {
  return function endDrag() {
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    verifyIsDragging(monitor);
    const sourceId = monitor.getSourceId();
    if (sourceId != null) {
      const source = registry.getSource(sourceId, true);
      source.endDrag(monitor, sourceId);
      registry.unpinSource();
    }
    return {
      type: END_DRAG
    };
  };
}
function verifyIsDragging(monitor) {
  invariant(monitor.isDragging(), "Cannot call endDrag while not dragging.");
}
function matchesType(targetType, draggedItemType) {
  if (draggedItemType === null) {
    return targetType === null;
  }
  return Array.isArray(targetType) ? targetType.some(
    (t2) => t2 === draggedItemType
  ) : targetType === draggedItemType;
}
function createHover(manager) {
  return function hover(targetIdsArg, { clientOffset } = {}) {
    verifyTargetIdsIsArray(targetIdsArg);
    const targetIds = targetIdsArg.slice(0);
    const monitor = manager.getMonitor();
    const registry = manager.getRegistry();
    const draggedItemType = monitor.getItemType();
    removeNonMatchingTargetIds(targetIds, registry, draggedItemType);
    checkInvariants(targetIds, monitor, registry);
    hoverAllTargets(targetIds, monitor, registry);
    return {
      type: HOVER,
      payload: {
        targetIds,
        clientOffset: clientOffset || null
      }
    };
  };
}
function verifyTargetIdsIsArray(targetIdsArg) {
  invariant(Array.isArray(targetIdsArg), "Expected targetIds to be an array.");
}
function checkInvariants(targetIds, monitor, registry) {
  invariant(monitor.isDragging(), "Cannot call hover while not dragging.");
  invariant(!monitor.didDrop(), "Cannot call hover after drop.");
  for (let i2 = 0; i2 < targetIds.length; i2++) {
    const targetId = targetIds[i2];
    invariant(targetIds.lastIndexOf(targetId) === i2, "Expected targetIds to be unique in the passed array.");
    const target = registry.getTarget(targetId);
    invariant(target, "Expected targetIds to be registered.");
  }
}
function removeNonMatchingTargetIds(targetIds, registry, draggedItemType) {
  for (let i2 = targetIds.length - 1; i2 >= 0; i2--) {
    const targetId = targetIds[i2];
    const targetType = registry.getTargetType(targetId);
    if (!matchesType(targetType, draggedItemType)) {
      targetIds.splice(i2, 1);
    }
  }
}
function hoverAllTargets(targetIds, monitor, registry) {
  targetIds.forEach(function(targetId) {
    const target = registry.getTarget(targetId);
    target.hover(monitor, targetId);
  });
}
function createPublishDragSource(manager) {
  return function publishDragSource() {
    const monitor = manager.getMonitor();
    if (monitor.isDragging()) {
      return {
        type: PUBLISH_DRAG_SOURCE
      };
    }
    return;
  };
}
function createDragDropActions(manager) {
  return {
    beginDrag: createBeginDrag(manager),
    publishDragSource: createPublishDragSource(manager),
    hover: createHover(manager),
    drop: createDrop(manager),
    endDrag: createEndDrag(manager)
  };
}
class DragDropManagerImpl {
  receiveBackend(backend) {
    this.backend = backend;
  }
  getMonitor() {
    return this.monitor;
  }
  getBackend() {
    return this.backend;
  }
  getRegistry() {
    return this.monitor.registry;
  }
  getActions() {
    const manager = this;
    const { dispatch } = this.store;
    function bindActionCreator(actionCreator) {
      return (...args) => {
        const action = actionCreator.apply(manager, args);
        if (typeof action !== "undefined") {
          dispatch(action);
        }
      };
    }
    const actions = createDragDropActions(this);
    return Object.keys(actions).reduce((boundActions, key) => {
      const action = actions[key];
      boundActions[key] = bindActionCreator(action);
      return boundActions;
    }, {});
  }
  dispatch(action) {
    this.store.dispatch(action);
  }
  constructor(store, monitor) {
    this.isSetUp = false;
    this.handleRefCountChange = () => {
      const shouldSetUp = this.store.getState().refCount > 0;
      if (this.backend) {
        if (shouldSetUp && !this.isSetUp) {
          this.backend.setup();
          this.isSetUp = true;
        } else if (!shouldSetUp && this.isSetUp) {
          this.backend.teardown();
          this.isSetUp = false;
        }
      }
    };
    this.store = store;
    this.monitor = monitor;
    store.subscribe(this.handleRefCountChange);
  }
}
function add(a2, b2) {
  return {
    x: a2.x + b2.x,
    y: a2.y + b2.y
  };
}
function subtract(a2, b2) {
  return {
    x: a2.x - b2.x,
    y: a2.y - b2.y
  };
}
function getSourceClientOffset(state) {
  const { clientOffset, initialClientOffset, initialSourceClientOffset } = state;
  if (!clientOffset || !initialClientOffset || !initialSourceClientOffset) {
    return null;
  }
  return subtract(add(clientOffset, initialSourceClientOffset), initialClientOffset);
}
function getDifferenceFromInitialOffset(state) {
  const { clientOffset, initialClientOffset } = state;
  if (!clientOffset || !initialClientOffset) {
    return null;
  }
  return subtract(clientOffset, initialClientOffset);
}
const NONE = [];
const ALL = [];
NONE.__IS_NONE__ = true;
ALL.__IS_ALL__ = true;
function areDirty(dirtyIds, handlerIds) {
  if (dirtyIds === NONE) {
    return false;
  }
  if (dirtyIds === ALL || typeof handlerIds === "undefined") {
    return true;
  }
  const commonIds = intersection(handlerIds, dirtyIds);
  return commonIds.length > 0;
}
class DragDropMonitorImpl {
  subscribeToStateChange(listener, options = {}) {
    const { handlerIds } = options;
    invariant(typeof listener === "function", "listener must be a function.");
    invariant(typeof handlerIds === "undefined" || Array.isArray(handlerIds), "handlerIds, when specified, must be an array of strings.");
    let prevStateId = this.store.getState().stateId;
    const handleChange = () => {
      const state = this.store.getState();
      const currentStateId = state.stateId;
      try {
        const canSkipListener = currentStateId === prevStateId || currentStateId === prevStateId + 1 && !areDirty(state.dirtyHandlerIds, handlerIds);
        if (!canSkipListener) {
          listener();
        }
      } finally {
        prevStateId = currentStateId;
      }
    };
    return this.store.subscribe(handleChange);
  }
  subscribeToOffsetChange(listener) {
    invariant(typeof listener === "function", "listener must be a function.");
    let previousState = this.store.getState().dragOffset;
    const handleChange = () => {
      const nextState = this.store.getState().dragOffset;
      if (nextState === previousState) {
        return;
      }
      previousState = nextState;
      listener();
    };
    return this.store.subscribe(handleChange);
  }
  canDragSource(sourceId) {
    if (!sourceId) {
      return false;
    }
    const source = this.registry.getSource(sourceId);
    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
    if (this.isDragging()) {
      return false;
    }
    return source.canDrag(this, sourceId);
  }
  canDropOnTarget(targetId) {
    if (!targetId) {
      return false;
    }
    const target = this.registry.getTarget(targetId);
    invariant(target, `Expected to find a valid target. targetId=${targetId}`);
    if (!this.isDragging() || this.didDrop()) {
      return false;
    }
    const targetType = this.registry.getTargetType(targetId);
    const draggedItemType = this.getItemType();
    return matchesType(targetType, draggedItemType) && target.canDrop(this, targetId);
  }
  isDragging() {
    return Boolean(this.getItemType());
  }
  isDraggingSource(sourceId) {
    if (!sourceId) {
      return false;
    }
    const source = this.registry.getSource(sourceId, true);
    invariant(source, `Expected to find a valid source. sourceId=${sourceId}`);
    if (!this.isDragging() || !this.isSourcePublic()) {
      return false;
    }
    const sourceType = this.registry.getSourceType(sourceId);
    const draggedItemType = this.getItemType();
    if (sourceType !== draggedItemType) {
      return false;
    }
    return source.isDragging(this, sourceId);
  }
  isOverTarget(targetId, options = {
    shallow: false
  }) {
    if (!targetId) {
      return false;
    }
    const { shallow: shallow2 } = options;
    if (!this.isDragging()) {
      return false;
    }
    const targetType = this.registry.getTargetType(targetId);
    const draggedItemType = this.getItemType();
    if (draggedItemType && !matchesType(targetType, draggedItemType)) {
      return false;
    }
    const targetIds = this.getTargetIds();
    if (!targetIds.length) {
      return false;
    }
    const index2 = targetIds.indexOf(targetId);
    if (shallow2) {
      return index2 === targetIds.length - 1;
    } else {
      return index2 > -1;
    }
  }
  getItemType() {
    return this.store.getState().dragOperation.itemType;
  }
  getItem() {
    return this.store.getState().dragOperation.item;
  }
  getSourceId() {
    return this.store.getState().dragOperation.sourceId;
  }
  getTargetIds() {
    return this.store.getState().dragOperation.targetIds;
  }
  getDropResult() {
    return this.store.getState().dragOperation.dropResult;
  }
  didDrop() {
    return this.store.getState().dragOperation.didDrop;
  }
  isSourcePublic() {
    return Boolean(this.store.getState().dragOperation.isSourcePublic);
  }
  getInitialClientOffset() {
    return this.store.getState().dragOffset.initialClientOffset;
  }
  getInitialSourceClientOffset() {
    return this.store.getState().dragOffset.initialSourceClientOffset;
  }
  getClientOffset() {
    return this.store.getState().dragOffset.clientOffset;
  }
  getSourceClientOffset() {
    return getSourceClientOffset(this.store.getState().dragOffset);
  }
  getDifferenceFromInitialOffset() {
    return getDifferenceFromInitialOffset(this.store.getState().dragOffset);
  }
  constructor(store, registry) {
    this.store = store;
    this.registry = registry;
  }
}
const scope = typeof global !== "undefined" ? global : self;
const BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;
function makeRequestCallFromTimer(callback) {
  return function requestCall() {
    const timeoutHandle = setTimeout(handleTimer, 0);
    const intervalHandle = setInterval(handleTimer, 50);
    function handleTimer() {
      clearTimeout(timeoutHandle);
      clearInterval(intervalHandle);
      callback();
    }
  };
}
function makeRequestCallFromMutationObserver(callback) {
  let toggle = 1;
  const observer = new BrowserMutationObserver(callback);
  const node = document.createTextNode("");
  observer.observe(node, {
    characterData: true
  });
  return function requestCall() {
    toggle = -toggle;
    node.data = toggle;
  };
}
const makeRequestCall = typeof BrowserMutationObserver === "function" ? (
  // reliably everywhere they are implemented.
  // They are implemented in all modern browsers.
  //
  // - Android 4-4.3
  // - Chrome 26-34
  // - Firefox 14-29
  // - Internet Explorer 11
  // - iPad Safari 6-7.1
  // - iPhone Safari 7-7.1
  // - Safari 6-7
  makeRequestCallFromMutationObserver
) : (
  // task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
  // 11-12, and in web workers in many engines.
  // Although message channels yield to any queued rendering and IO tasks, they
  // would be better than imposing the 4ms delay of timers.
  // However, they do not work reliably in Internet Explorer or Safari.
  // Internet Explorer 10 is the only browser that has setImmediate but does
  // not have MutationObservers.
  // Although setImmediate yields to the browser's renderer, it would be
  // preferrable to falling back to setTimeout since it does not have
  // the minimum 4ms penalty.
  // Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
  // Desktop to a lesser extent) that renders both setImmediate and
  // MessageChannel useless for the purposes of ASAP.
  // https://github.com/kriskowal/q/issues/396
  // Timers are implemented universally.
  // We fall back to timers in workers in most engines, and in foreground
  // contexts in the following browsers.
  // However, note that even this simple case requires nuances to operate in a
  // broad spectrum of browsers.
  //
  // - Firefox 3-13
  // - Internet Explorer 6-9
  // - iPad Safari 4.3
  // - Lynx 2.8.7
  makeRequestCallFromTimer
);
class AsapQueue {
  // Use the fastest means possible to execute a task in its own turn, with
  // priority over other events including IO, animation, reflow, and redraw
  // events in browsers.
  //
  // An exception thrown by a task will permanently interrupt the processing of
  // subsequent tasks. The higher level `asap` function ensures that if an
  // exception is thrown by a task, that the task queue will continue flushing as
  // soon as possible, but if you use `rawAsap` directly, you are responsible to
  // either ensure that no exceptions are thrown from your task, or to manually
  // call `rawAsap.requestFlush` if an exception is thrown.
  enqueueTask(task) {
    const { queue: q2, requestFlush } = this;
    if (!q2.length) {
      requestFlush();
      this.flushing = true;
    }
    q2[q2.length] = task;
  }
  constructor() {
    this.queue = [];
    this.pendingErrors = [];
    this.flushing = false;
    this.index = 0;
    this.capacity = 1024;
    this.flush = () => {
      const { queue: q2 } = this;
      while (this.index < q2.length) {
        const currentIndex = this.index;
        this.index++;
        q2[currentIndex].call();
        if (this.index > this.capacity) {
          for (let scan = 0, newLength = q2.length - this.index; scan < newLength; scan++) {
            q2[scan] = q2[scan + this.index];
          }
          q2.length -= this.index;
          this.index = 0;
        }
      }
      q2.length = 0;
      this.index = 0;
      this.flushing = false;
    };
    this.registerPendingError = (err) => {
      this.pendingErrors.push(err);
      this.requestErrorThrow();
    };
    this.requestFlush = makeRequestCall(this.flush);
    this.requestErrorThrow = makeRequestCallFromTimer(() => {
      if (this.pendingErrors.length) {
        throw this.pendingErrors.shift();
      }
    });
  }
}
class RawTask {
  call() {
    try {
      this.task && this.task();
    } catch (error) {
      this.onError(error);
    } finally {
      this.task = null;
      this.release(this);
    }
  }
  constructor(onError, release) {
    this.onError = onError;
    this.release = release;
    this.task = null;
  }
}
class TaskFactory {
  create(task) {
    const tasks = this.freeTasks;
    const t1 = tasks.length ? tasks.pop() : new RawTask(
      this.onError,
      (t2) => tasks[tasks.length] = t2
    );
    t1.task = task;
    return t1;
  }
  constructor(onError) {
    this.onError = onError;
    this.freeTasks = [];
  }
}
const asapQueue = new AsapQueue();
const taskFactory = new TaskFactory(asapQueue.registerPendingError);
function asap(task) {
  asapQueue.enqueueTask(taskFactory.create(task));
}
const ADD_SOURCE = "dnd-core/ADD_SOURCE";
const ADD_TARGET = "dnd-core/ADD_TARGET";
const REMOVE_SOURCE = "dnd-core/REMOVE_SOURCE";
const REMOVE_TARGET = "dnd-core/REMOVE_TARGET";
function addSource(sourceId) {
  return {
    type: ADD_SOURCE,
    payload: {
      sourceId
    }
  };
}
function addTarget(targetId) {
  return {
    type: ADD_TARGET,
    payload: {
      targetId
    }
  };
}
function removeSource(sourceId) {
  return {
    type: REMOVE_SOURCE,
    payload: {
      sourceId
    }
  };
}
function removeTarget(targetId) {
  return {
    type: REMOVE_TARGET,
    payload: {
      targetId
    }
  };
}
function validateSourceContract(source) {
  invariant(typeof source.canDrag === "function", "Expected canDrag to be a function.");
  invariant(typeof source.beginDrag === "function", "Expected beginDrag to be a function.");
  invariant(typeof source.endDrag === "function", "Expected endDrag to be a function.");
}
function validateTargetContract(target) {
  invariant(typeof target.canDrop === "function", "Expected canDrop to be a function.");
  invariant(typeof target.hover === "function", "Expected hover to be a function.");
  invariant(typeof target.drop === "function", "Expected beginDrag to be a function.");
}
function validateType(type, allowArray) {
  if (allowArray && Array.isArray(type)) {
    type.forEach(
      (t2) => validateType(t2, false)
    );
    return;
  }
  invariant(typeof type === "string" || typeof type === "symbol", allowArray ? "Type can only be a string, a symbol, or an array of either." : "Type can only be a string or a symbol.");
}
var HandlerRole;
(function(HandlerRole2) {
  HandlerRole2["SOURCE"] = "SOURCE";
  HandlerRole2["TARGET"] = "TARGET";
})(HandlerRole || (HandlerRole = {}));
let nextUniqueId = 0;
function getNextUniqueId() {
  return nextUniqueId++;
}
function getNextHandlerId(role) {
  const id2 = getNextUniqueId().toString();
  switch (role) {
    case HandlerRole.SOURCE:
      return `S${id2}`;
    case HandlerRole.TARGET:
      return `T${id2}`;
    default:
      throw new Error(`Unknown Handler Role: ${role}`);
  }
}
function parseRoleFromHandlerId(handlerId) {
  switch (handlerId[0]) {
    case "S":
      return HandlerRole.SOURCE;
    case "T":
      return HandlerRole.TARGET;
    default:
      throw new Error(`Cannot parse handler ID: ${handlerId}`);
  }
}
function mapContainsValue(map, searchValue) {
  const entries = map.entries();
  let isDone = false;
  do {
    const { done, value: [, value] } = entries.next();
    if (value === searchValue) {
      return true;
    }
    isDone = !!done;
  } while (!isDone);
  return false;
}
class HandlerRegistryImpl {
  addSource(type, source) {
    validateType(type);
    validateSourceContract(source);
    const sourceId = this.addHandler(HandlerRole.SOURCE, type, source);
    this.store.dispatch(addSource(sourceId));
    return sourceId;
  }
  addTarget(type, target) {
    validateType(type, true);
    validateTargetContract(target);
    const targetId = this.addHandler(HandlerRole.TARGET, type, target);
    this.store.dispatch(addTarget(targetId));
    return targetId;
  }
  containsHandler(handler) {
    return mapContainsValue(this.dragSources, handler) || mapContainsValue(this.dropTargets, handler);
  }
  getSource(sourceId, includePinned = false) {
    invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
    const isPinned = includePinned && sourceId === this.pinnedSourceId;
    const source = isPinned ? this.pinnedSource : this.dragSources.get(sourceId);
    return source;
  }
  getTarget(targetId) {
    invariant(this.isTargetId(targetId), "Expected a valid target ID.");
    return this.dropTargets.get(targetId);
  }
  getSourceType(sourceId) {
    invariant(this.isSourceId(sourceId), "Expected a valid source ID.");
    return this.types.get(sourceId);
  }
  getTargetType(targetId) {
    invariant(this.isTargetId(targetId), "Expected a valid target ID.");
    return this.types.get(targetId);
  }
  isSourceId(handlerId) {
    const role = parseRoleFromHandlerId(handlerId);
    return role === HandlerRole.SOURCE;
  }
  isTargetId(handlerId) {
    const role = parseRoleFromHandlerId(handlerId);
    return role === HandlerRole.TARGET;
  }
  removeSource(sourceId) {
    invariant(this.getSource(sourceId), "Expected an existing source.");
    this.store.dispatch(removeSource(sourceId));
    asap(() => {
      this.dragSources.delete(sourceId);
      this.types.delete(sourceId);
    });
  }
  removeTarget(targetId) {
    invariant(this.getTarget(targetId), "Expected an existing target.");
    this.store.dispatch(removeTarget(targetId));
    this.dropTargets.delete(targetId);
    this.types.delete(targetId);
  }
  pinSource(sourceId) {
    const source = this.getSource(sourceId);
    invariant(source, "Expected an existing source.");
    this.pinnedSourceId = sourceId;
    this.pinnedSource = source;
  }
  unpinSource() {
    invariant(this.pinnedSource, "No source is pinned at the time.");
    this.pinnedSourceId = null;
    this.pinnedSource = null;
  }
  addHandler(role, type, handler) {
    const id2 = getNextHandlerId(role);
    this.types.set(id2, type);
    if (role === HandlerRole.SOURCE) {
      this.dragSources.set(id2, handler);
    } else if (role === HandlerRole.TARGET) {
      this.dropTargets.set(id2, handler);
    }
    return id2;
  }
  constructor(store) {
    this.types = /* @__PURE__ */ new Map();
    this.dragSources = /* @__PURE__ */ new Map();
    this.dropTargets = /* @__PURE__ */ new Map();
    this.pinnedSourceId = null;
    this.pinnedSource = null;
    this.store = store;
  }
}
const strictEquality = (a2, b2) => a2 === b2;
function areCoordsEqual(offsetA, offsetB) {
  if (!offsetA && !offsetB) {
    return true;
  } else if (!offsetA || !offsetB) {
    return false;
  } else {
    return offsetA.x === offsetB.x && offsetA.y === offsetB.y;
  }
}
function areArraysEqual(a2, b2, isEqual = strictEquality) {
  if (a2.length !== b2.length) {
    return false;
  }
  for (let i2 = 0; i2 < a2.length; ++i2) {
    if (!isEqual(a2[i2], b2[i2])) {
      return false;
    }
  }
  return true;
}
function reduce$5(_state = NONE, action) {
  switch (action.type) {
    case HOVER:
      break;
    case ADD_SOURCE:
    case ADD_TARGET:
    case REMOVE_TARGET:
    case REMOVE_SOURCE:
      return NONE;
    case BEGIN_DRAG:
    case PUBLISH_DRAG_SOURCE:
    case END_DRAG:
    case DROP:
    default:
      return ALL;
  }
  const { targetIds = [], prevTargetIds = [] } = action.payload;
  const result = xor(targetIds, prevTargetIds);
  const didChange = result.length > 0 || !areArraysEqual(targetIds, prevTargetIds);
  if (!didChange) {
    return NONE;
  }
  const prevInnermostTargetId = prevTargetIds[prevTargetIds.length - 1];
  const innermostTargetId = targetIds[targetIds.length - 1];
  if (prevInnermostTargetId !== innermostTargetId) {
    if (prevInnermostTargetId) {
      result.push(prevInnermostTargetId);
    }
    if (innermostTargetId) {
      result.push(innermostTargetId);
    }
  }
  return result;
}
function _defineProperty$3(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$3(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty$3(target, key, source[key]);
    });
  }
  return target;
}
const initialState$2 = {
  initialSourceClientOffset: null,
  initialClientOffset: null,
  clientOffset: null
};
function reduce$4(state = initialState$2, action) {
  const { payload } = action;
  switch (action.type) {
    case INIT_COORDS:
    case BEGIN_DRAG:
      return {
        initialSourceClientOffset: payload.sourceClientOffset,
        initialClientOffset: payload.clientOffset,
        clientOffset: payload.clientOffset
      };
    case HOVER:
      if (areCoordsEqual(state.clientOffset, payload.clientOffset)) {
        return state;
      }
      return _objectSpread$3({}, state, {
        clientOffset: payload.clientOffset
      });
    case END_DRAG:
    case DROP:
      return initialState$2;
    default:
      return state;
  }
}
function _defineProperty$2(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty$2(target, key, source[key]);
    });
  }
  return target;
}
const initialState$1 = {
  itemType: null,
  item: null,
  sourceId: null,
  targetIds: [],
  dropResult: null,
  didDrop: false,
  isSourcePublic: null
};
function reduce$3(state = initialState$1, action) {
  const { payload } = action;
  switch (action.type) {
    case BEGIN_DRAG:
      return _objectSpread$2({}, state, {
        itemType: payload.itemType,
        item: payload.item,
        sourceId: payload.sourceId,
        isSourcePublic: payload.isSourcePublic,
        dropResult: null,
        didDrop: false
      });
    case PUBLISH_DRAG_SOURCE:
      return _objectSpread$2({}, state, {
        isSourcePublic: true
      });
    case HOVER:
      return _objectSpread$2({}, state, {
        targetIds: payload.targetIds
      });
    case REMOVE_TARGET:
      if (state.targetIds.indexOf(payload.targetId) === -1) {
        return state;
      }
      return _objectSpread$2({}, state, {
        targetIds: without$1(state.targetIds, payload.targetId)
      });
    case DROP:
      return _objectSpread$2({}, state, {
        dropResult: payload.dropResult,
        didDrop: true,
        targetIds: []
      });
    case END_DRAG:
      return _objectSpread$2({}, state, {
        itemType: null,
        item: null,
        sourceId: null,
        dropResult: null,
        didDrop: false,
        isSourcePublic: null,
        targetIds: []
      });
    default:
      return state;
  }
}
function reduce$2(state = 0, action) {
  switch (action.type) {
    case ADD_SOURCE:
    case ADD_TARGET:
      return state + 1;
    case REMOVE_SOURCE:
    case REMOVE_TARGET:
      return state - 1;
    default:
      return state;
  }
}
function reduce$1(state = 0) {
  return state + 1;
}
function _defineProperty$1(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread$1(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty$1(target, key, source[key]);
    });
  }
  return target;
}
function reduce(state = {}, action) {
  return {
    dirtyHandlerIds: reduce$5(state.dirtyHandlerIds, {
      type: action.type,
      payload: _objectSpread$1({}, action.payload, {
        prevTargetIds: get$1(state, "dragOperation.targetIds", [])
      })
    }),
    dragOffset: reduce$4(state.dragOffset, action),
    refCount: reduce$2(state.refCount, action),
    dragOperation: reduce$3(state.dragOperation, action),
    stateId: reduce$1(state.stateId)
  };
}
function createDragDropManager(backendFactory, globalContext = void 0, backendOptions = {}, debugMode = false) {
  const store = makeStoreInstance(debugMode);
  const monitor = new DragDropMonitorImpl(store, new HandlerRegistryImpl(store));
  const manager = new DragDropManagerImpl(store, monitor);
  const backend = backendFactory(manager, globalContext, backendOptions);
  manager.receiveBackend(backend);
  return manager;
}
function makeStoreInstance(debugMode) {
  const reduxDevTools = typeof window !== "undefined" && window.__REDUX_DEVTOOLS_EXTENSION__;
  return createStore(reduce, debugMode && reduxDevTools && reduxDevTools({
    name: "dnd-core",
    instanceId: "dnd-core"
  }));
}
function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose$1(source, excluded);
  var key, i2;
  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
    for (i2 = 0; i2 < sourceSymbolKeys.length; i2++) {
      key = sourceSymbolKeys[i2];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }
  return target;
}
function _objectWithoutPropertiesLoose$1(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
let refCount = 0;
const INSTANCE_SYM = Symbol.for("__REACT_DND_CONTEXT_INSTANCE__");
var DndProvider = /* @__PURE__ */ reactExports.memo(function DndProvider2(_param) {
  var { children } = _param, props = _objectWithoutProperties(_param, [
    "children"
  ]);
  const [manager, isGlobalInstance] = getDndContextValue(props);
  reactExports.useEffect(() => {
    if (isGlobalInstance) {
      const context = getGlobalContext();
      ++refCount;
      return () => {
        if (--refCount === 0) {
          context[INSTANCE_SYM] = null;
        }
      };
    }
    return;
  }, []);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(DndContext.Provider, {
    value: manager,
    children
  });
});
function getDndContextValue(props) {
  if ("manager" in props) {
    const manager2 = {
      dragDropManager: props.manager
    };
    return [
      manager2,
      false
    ];
  }
  const manager = createSingletonDndContext(props.backend, props.context, props.options, props.debugMode);
  const isGlobalInstance = !props.context;
  return [
    manager,
    isGlobalInstance
  ];
}
function createSingletonDndContext(backend, context = getGlobalContext(), options, debugMode) {
  const ctx = context;
  if (!ctx[INSTANCE_SYM]) {
    ctx[INSTANCE_SYM] = {
      dragDropManager: createDragDropManager(backend, context, options, debugMode)
    };
  }
  return ctx[INSTANCE_SYM];
}
function getGlobalContext() {
  return typeof global !== "undefined" ? global : window;
}
var fastDeepEqual = function equal(a2, b2) {
  if (a2 === b2) return true;
  if (a2 && b2 && typeof a2 == "object" && typeof b2 == "object") {
    if (a2.constructor !== b2.constructor) return false;
    var length, i2, keys;
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length != b2.length) return false;
      for (i2 = length; i2-- !== 0; )
        if (!equal(a2[i2], b2[i2])) return false;
      return true;
    }
    if (a2.constructor === RegExp) return a2.source === b2.source && a2.flags === b2.flags;
    if (a2.valueOf !== Object.prototype.valueOf) return a2.valueOf() === b2.valueOf();
    if (a2.toString !== Object.prototype.toString) return a2.toString() === b2.toString();
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) return false;
    for (i2 = length; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b2, keys[i2])) return false;
    for (i2 = length; i2-- !== 0; ) {
      var key = keys[i2];
      if (!equal(a2[key], b2[key])) return false;
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
};
const equal2 = /* @__PURE__ */ getDefaultExportFromCjs(fastDeepEqual);
const useIsomorphicLayoutEffect$1 = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function useCollector(monitor, collect, onUpdate) {
  const [collected, setCollected] = reactExports.useState(
    () => collect(monitor)
  );
  const updateCollected = reactExports.useCallback(() => {
    const nextValue = collect(monitor);
    if (!equal2(collected, nextValue)) {
      setCollected(nextValue);
      if (onUpdate) {
        onUpdate();
      }
    }
  }, [
    collected,
    monitor,
    onUpdate
  ]);
  useIsomorphicLayoutEffect$1(updateCollected);
  return [
    collected,
    updateCollected
  ];
}
function useMonitorOutput(monitor, collect, onCollect) {
  const [collected, updateCollected] = useCollector(monitor, collect, onCollect);
  useIsomorphicLayoutEffect$1(function subscribeToMonitorStateChange() {
    const handlerId = monitor.getHandlerId();
    if (handlerId == null) {
      return;
    }
    return monitor.subscribeToStateChange(updateCollected, {
      handlerIds: [
        handlerId
      ]
    });
  }, [
    monitor,
    updateCollected
  ]);
  return collected;
}
function useCollectedProps(collector, monitor, connector) {
  return useMonitorOutput(
    monitor,
    collector || (() => ({})),
    () => connector.reconnect()
  );
}
function useOptionalFactory(arg, deps) {
  const memoDeps = [
    ...[]
  ];
  if (typeof arg !== "function") {
    memoDeps.push(arg);
  }
  return reactExports.useMemo(() => {
    return typeof arg === "function" ? arg() : arg;
  }, memoDeps);
}
function useConnectDragSource(connector) {
  return reactExports.useMemo(
    () => connector.hooks.dragSource(),
    [
      connector
    ]
  );
}
function useConnectDragPreview(connector) {
  return reactExports.useMemo(
    () => connector.hooks.dragPreview(),
    [
      connector
    ]
  );
}
let isCallingCanDrag = false;
let isCallingIsDragging = false;
class DragSourceMonitorImpl {
  receiveHandlerId(sourceId) {
    this.sourceId = sourceId;
  }
  getHandlerId() {
    return this.sourceId;
  }
  canDrag() {
    invariant(!isCallingCanDrag, "You may not call monitor.canDrag() inside your canDrag() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      isCallingCanDrag = true;
      return this.internalMonitor.canDragSource(this.sourceId);
    } finally {
      isCallingCanDrag = false;
    }
  }
  isDragging() {
    if (!this.sourceId) {
      return false;
    }
    invariant(!isCallingIsDragging, "You may not call monitor.isDragging() inside your isDragging() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drag-source-monitor");
    try {
      isCallingIsDragging = true;
      return this.internalMonitor.isDraggingSource(this.sourceId);
    } finally {
      isCallingIsDragging = false;
    }
  }
  subscribeToStateChange(listener, options) {
    return this.internalMonitor.subscribeToStateChange(listener, options);
  }
  isDraggingSource(sourceId) {
    return this.internalMonitor.isDraggingSource(sourceId);
  }
  isOverTarget(targetId, options) {
    return this.internalMonitor.isOverTarget(targetId, options);
  }
  getTargetIds() {
    return this.internalMonitor.getTargetIds();
  }
  isSourcePublic() {
    return this.internalMonitor.isSourcePublic();
  }
  getSourceId() {
    return this.internalMonitor.getSourceId();
  }
  subscribeToOffsetChange(listener) {
    return this.internalMonitor.subscribeToOffsetChange(listener);
  }
  canDragSource(sourceId) {
    return this.internalMonitor.canDragSource(sourceId);
  }
  canDropOnTarget(targetId) {
    return this.internalMonitor.canDropOnTarget(targetId);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(manager) {
    this.sourceId = null;
    this.internalMonitor = manager.getMonitor();
  }
}
let isCallingCanDrop = false;
class DropTargetMonitorImpl {
  receiveHandlerId(targetId) {
    this.targetId = targetId;
  }
  getHandlerId() {
    return this.targetId;
  }
  subscribeToStateChange(listener, options) {
    return this.internalMonitor.subscribeToStateChange(listener, options);
  }
  canDrop() {
    if (!this.targetId) {
      return false;
    }
    invariant(!isCallingCanDrop, "You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");
    try {
      isCallingCanDrop = true;
      return this.internalMonitor.canDropOnTarget(this.targetId);
    } finally {
      isCallingCanDrop = false;
    }
  }
  isOver(options) {
    if (!this.targetId) {
      return false;
    }
    return this.internalMonitor.isOverTarget(this.targetId, options);
  }
  getItemType() {
    return this.internalMonitor.getItemType();
  }
  getItem() {
    return this.internalMonitor.getItem();
  }
  getDropResult() {
    return this.internalMonitor.getDropResult();
  }
  didDrop() {
    return this.internalMonitor.didDrop();
  }
  getInitialClientOffset() {
    return this.internalMonitor.getInitialClientOffset();
  }
  getInitialSourceClientOffset() {
    return this.internalMonitor.getInitialSourceClientOffset();
  }
  getSourceClientOffset() {
    return this.internalMonitor.getSourceClientOffset();
  }
  getClientOffset() {
    return this.internalMonitor.getClientOffset();
  }
  getDifferenceFromInitialOffset() {
    return this.internalMonitor.getDifferenceFromInitialOffset();
  }
  constructor(manager) {
    this.targetId = null;
    this.internalMonitor = manager.getMonitor();
  }
}
function registerTarget(type, target, manager) {
  const registry = manager.getRegistry();
  const targetId = registry.addTarget(type, target);
  return [
    targetId,
    () => registry.removeTarget(targetId)
  ];
}
function registerSource(type, source, manager) {
  const registry = manager.getRegistry();
  const sourceId = registry.addSource(type, source);
  return [
    sourceId,
    () => registry.removeSource(sourceId)
  ];
}
function shallowEqual(objA, objB, compare, compareContext) {
  let compareResult = void 0;
  if (compareResult !== void 0) {
    return !!compareResult;
  }
  if (objA === objB) {
    return true;
  }
  if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
    return false;
  }
  const keysA = Object.keys(objA);
  const keysB = Object.keys(objB);
  if (keysA.length !== keysB.length) {
    return false;
  }
  const bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
  for (let idx = 0; idx < keysA.length; idx++) {
    const key = keysA[idx];
    if (!bHasOwnProperty(key)) {
      return false;
    }
    const valueA = objA[key];
    const valueB = objB[key];
    compareResult = void 0;
    if (compareResult === false || compareResult === void 0 && valueA !== valueB) {
      return false;
    }
  }
  return true;
}
function isRef(obj) {
  return (
    // eslint-disable-next-line no-prototype-builtins
    obj !== null && typeof obj === "object" && Object.prototype.hasOwnProperty.call(obj, "current")
  );
}
function throwIfCompositeComponentElement(element) {
  if (typeof element.type === "string") {
    return;
  }
  const displayName = element.type.displayName || element.type.name || "the component";
  throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${displayName} into a <div>, or turn it into a drag source or a drop target itself.`);
}
function wrapHookToRecognizeElement(hook) {
  return (elementOrNode = null, options = null) => {
    if (!reactExports.isValidElement(elementOrNode)) {
      const node = elementOrNode;
      hook(node, options);
      return node;
    }
    const element = elementOrNode;
    throwIfCompositeComponentElement(element);
    const ref = options ? (node) => hook(node, options) : hook;
    return cloneWithRef(element, ref);
  };
}
function wrapConnectorHooks(hooks) {
  const wrappedHooks = {};
  Object.keys(hooks).forEach((key) => {
    const hook = hooks[key];
    if (key.endsWith("Ref")) {
      wrappedHooks[key] = hooks[key];
    } else {
      const wrappedHook = wrapHookToRecognizeElement(hook);
      wrappedHooks[key] = () => wrappedHook;
    }
  });
  return wrappedHooks;
}
function setRef$1(ref, node) {
  if (typeof ref === "function") {
    ref(node);
  } else {
    ref.current = node;
  }
}
function cloneWithRef(element, newRef) {
  const previousRef = element.ref;
  invariant(typeof previousRef !== "string", "Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs");
  if (!previousRef) {
    return reactExports.cloneElement(element, {
      ref: newRef
    });
  } else {
    return reactExports.cloneElement(element, {
      ref: (node) => {
        setRef$1(previousRef, node);
        setRef$1(newRef, node);
      }
    });
  }
}
class SourceConnector {
  receiveHandlerId(newHandlerId) {
    if (this.handlerId === newHandlerId) {
      return;
    }
    this.handlerId = newHandlerId;
    this.reconnect();
  }
  get connectTarget() {
    return this.dragSource;
  }
  get dragSourceOptions() {
    return this.dragSourceOptionsInternal;
  }
  set dragSourceOptions(options) {
    this.dragSourceOptionsInternal = options;
  }
  get dragPreviewOptions() {
    return this.dragPreviewOptionsInternal;
  }
  set dragPreviewOptions(options) {
    this.dragPreviewOptionsInternal = options;
  }
  reconnect() {
    const didChange = this.reconnectDragSource();
    this.reconnectDragPreview(didChange);
  }
  reconnectDragSource() {
    const dragSource = this.dragSource;
    const didChange = this.didHandlerIdChange() || this.didConnectedDragSourceChange() || this.didDragSourceOptionsChange();
    if (didChange) {
      this.disconnectDragSource();
    }
    if (!this.handlerId) {
      return didChange;
    }
    if (!dragSource) {
      this.lastConnectedDragSource = dragSource;
      return didChange;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDragSource = dragSource;
      this.lastConnectedDragSourceOptions = this.dragSourceOptions;
      this.dragSourceUnsubscribe = this.backend.connectDragSource(this.handlerId, dragSource, this.dragSourceOptions);
    }
    return didChange;
  }
  reconnectDragPreview(forceDidChange = false) {
    const dragPreview = this.dragPreview;
    const didChange = forceDidChange || this.didHandlerIdChange() || this.didConnectedDragPreviewChange() || this.didDragPreviewOptionsChange();
    if (didChange) {
      this.disconnectDragPreview();
    }
    if (!this.handlerId) {
      return;
    }
    if (!dragPreview) {
      this.lastConnectedDragPreview = dragPreview;
      return;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDragPreview = dragPreview;
      this.lastConnectedDragPreviewOptions = this.dragPreviewOptions;
      this.dragPreviewUnsubscribe = this.backend.connectDragPreview(this.handlerId, dragPreview, this.dragPreviewOptions);
    }
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didConnectedDragSourceChange() {
    return this.lastConnectedDragSource !== this.dragSource;
  }
  didConnectedDragPreviewChange() {
    return this.lastConnectedDragPreview !== this.dragPreview;
  }
  didDragSourceOptionsChange() {
    return !shallowEqual(this.lastConnectedDragSourceOptions, this.dragSourceOptions);
  }
  didDragPreviewOptionsChange() {
    return !shallowEqual(this.lastConnectedDragPreviewOptions, this.dragPreviewOptions);
  }
  disconnectDragSource() {
    if (this.dragSourceUnsubscribe) {
      this.dragSourceUnsubscribe();
      this.dragSourceUnsubscribe = void 0;
    }
  }
  disconnectDragPreview() {
    if (this.dragPreviewUnsubscribe) {
      this.dragPreviewUnsubscribe();
      this.dragPreviewUnsubscribe = void 0;
      this.dragPreviewNode = null;
      this.dragPreviewRef = null;
    }
  }
  get dragSource() {
    return this.dragSourceNode || this.dragSourceRef && this.dragSourceRef.current;
  }
  get dragPreview() {
    return this.dragPreviewNode || this.dragPreviewRef && this.dragPreviewRef.current;
  }
  clearDragSource() {
    this.dragSourceNode = null;
    this.dragSourceRef = null;
  }
  clearDragPreview() {
    this.dragPreviewNode = null;
    this.dragPreviewRef = null;
  }
  constructor(backend) {
    this.hooks = wrapConnectorHooks({
      dragSource: (node, options) => {
        this.clearDragSource();
        this.dragSourceOptions = options || null;
        if (isRef(node)) {
          this.dragSourceRef = node;
        } else {
          this.dragSourceNode = node;
        }
        this.reconnectDragSource();
      },
      dragPreview: (node, options) => {
        this.clearDragPreview();
        this.dragPreviewOptions = options || null;
        if (isRef(node)) {
          this.dragPreviewRef = node;
        } else {
          this.dragPreviewNode = node;
        }
        this.reconnectDragPreview();
      }
    });
    this.handlerId = null;
    this.dragSourceRef = null;
    this.dragSourceOptionsInternal = null;
    this.dragPreviewRef = null;
    this.dragPreviewOptionsInternal = null;
    this.lastConnectedHandlerId = null;
    this.lastConnectedDragSource = null;
    this.lastConnectedDragSourceOptions = null;
    this.lastConnectedDragPreview = null;
    this.lastConnectedDragPreviewOptions = null;
    this.backend = backend;
  }
}
class TargetConnector {
  get connectTarget() {
    return this.dropTarget;
  }
  reconnect() {
    const didChange = this.didHandlerIdChange() || this.didDropTargetChange() || this.didOptionsChange();
    if (didChange) {
      this.disconnectDropTarget();
    }
    const dropTarget = this.dropTarget;
    if (!this.handlerId) {
      return;
    }
    if (!dropTarget) {
      this.lastConnectedDropTarget = dropTarget;
      return;
    }
    if (didChange) {
      this.lastConnectedHandlerId = this.handlerId;
      this.lastConnectedDropTarget = dropTarget;
      this.lastConnectedDropTargetOptions = this.dropTargetOptions;
      this.unsubscribeDropTarget = this.backend.connectDropTarget(this.handlerId, dropTarget, this.dropTargetOptions);
    }
  }
  receiveHandlerId(newHandlerId) {
    if (newHandlerId === this.handlerId) {
      return;
    }
    this.handlerId = newHandlerId;
    this.reconnect();
  }
  get dropTargetOptions() {
    return this.dropTargetOptionsInternal;
  }
  set dropTargetOptions(options) {
    this.dropTargetOptionsInternal = options;
  }
  didHandlerIdChange() {
    return this.lastConnectedHandlerId !== this.handlerId;
  }
  didDropTargetChange() {
    return this.lastConnectedDropTarget !== this.dropTarget;
  }
  didOptionsChange() {
    return !shallowEqual(this.lastConnectedDropTargetOptions, this.dropTargetOptions);
  }
  disconnectDropTarget() {
    if (this.unsubscribeDropTarget) {
      this.unsubscribeDropTarget();
      this.unsubscribeDropTarget = void 0;
    }
  }
  get dropTarget() {
    return this.dropTargetNode || this.dropTargetRef && this.dropTargetRef.current;
  }
  clearDropTarget() {
    this.dropTargetRef = null;
    this.dropTargetNode = null;
  }
  constructor(backend) {
    this.hooks = wrapConnectorHooks({
      dropTarget: (node, options) => {
        this.clearDropTarget();
        this.dropTargetOptions = options;
        if (isRef(node)) {
          this.dropTargetRef = node;
        } else {
          this.dropTargetNode = node;
        }
        this.reconnect();
      }
    });
    this.handlerId = null;
    this.dropTargetRef = null;
    this.dropTargetOptionsInternal = null;
    this.lastConnectedHandlerId = null;
    this.lastConnectedDropTarget = null;
    this.lastConnectedDropTargetOptions = null;
    this.backend = backend;
  }
}
function useDragDropManager() {
  const { dragDropManager } = reactExports.useContext(DndContext);
  invariant(dragDropManager != null, "Expected drag drop context");
  return dragDropManager;
}
function useDragSourceConnector(dragSourceOptions, dragPreviewOptions) {
  const manager = useDragDropManager();
  const connector = reactExports.useMemo(
    () => new SourceConnector(manager.getBackend()),
    [
      manager
    ]
  );
  useIsomorphicLayoutEffect$1(() => {
    connector.dragSourceOptions = dragSourceOptions || null;
    connector.reconnect();
    return () => connector.disconnectDragSource();
  }, [
    connector,
    dragSourceOptions
  ]);
  useIsomorphicLayoutEffect$1(() => {
    connector.dragPreviewOptions = dragPreviewOptions || null;
    connector.reconnect();
    return () => connector.disconnectDragPreview();
  }, [
    connector,
    dragPreviewOptions
  ]);
  return connector;
}
function useDragSourceMonitor() {
  const manager = useDragDropManager();
  return reactExports.useMemo(
    () => new DragSourceMonitorImpl(manager),
    [
      manager
    ]
  );
}
class DragSourceImpl {
  beginDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    let result = null;
    if (typeof spec.item === "object") {
      result = spec.item;
    } else if (typeof spec.item === "function") {
      result = spec.item(monitor);
    } else {
      result = {};
    }
    return result !== null && result !== void 0 ? result : null;
  }
  canDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (typeof spec.canDrag === "boolean") {
      return spec.canDrag;
    } else if (typeof spec.canDrag === "function") {
      return spec.canDrag(monitor);
    } else {
      return true;
    }
  }
  isDragging(globalMonitor, target) {
    const spec = this.spec;
    const monitor = this.monitor;
    const { isDragging } = spec;
    return isDragging ? isDragging(monitor) : target === globalMonitor.getSourceId();
  }
  endDrag() {
    const spec = this.spec;
    const monitor = this.monitor;
    const connector = this.connector;
    const { end } = spec;
    if (end) {
      end(monitor.getItem(), monitor);
    }
    connector.reconnect();
  }
  constructor(spec, monitor, connector) {
    this.spec = spec;
    this.monitor = monitor;
    this.connector = connector;
  }
}
function useDragSource(spec, monitor, connector) {
  const handler = reactExports.useMemo(
    () => new DragSourceImpl(spec, monitor, connector),
    [
      monitor,
      connector
    ]
  );
  reactExports.useEffect(() => {
    handler.spec = spec;
  }, [
    spec
  ]);
  return handler;
}
function useDragType(spec) {
  return reactExports.useMemo(() => {
    const result = spec.type;
    invariant(result != null, "spec.type must be defined");
    return result;
  }, [
    spec
  ]);
}
function useRegisteredDragSource(spec, monitor, connector) {
  const manager = useDragDropManager();
  const handler = useDragSource(spec, monitor, connector);
  const itemType = useDragType(spec);
  useIsomorphicLayoutEffect$1(function registerDragSource() {
    if (itemType != null) {
      const [handlerId, unregister] = registerSource(itemType, handler, manager);
      monitor.receiveHandlerId(handlerId);
      connector.receiveHandlerId(handlerId);
      return unregister;
    }
    return;
  }, [
    manager,
    monitor,
    connector,
    handler,
    itemType
  ]);
}
function useDrag(specArg, deps) {
  const spec = useOptionalFactory(specArg);
  invariant(!spec.begin, `useDrag::spec.begin was deprecated in v14. Replace spec.begin() with spec.item(). (see more here - https://react-dnd.github.io/react-dnd/docs/api/use-drag)`);
  const monitor = useDragSourceMonitor();
  const connector = useDragSourceConnector(spec.options, spec.previewOptions);
  useRegisteredDragSource(spec, monitor, connector);
  return [
    useCollectedProps(spec.collect, monitor, connector),
    useConnectDragSource(connector),
    useConnectDragPreview(connector)
  ];
}
function useConnectDropTarget(connector) {
  return reactExports.useMemo(
    () => connector.hooks.dropTarget(),
    [
      connector
    ]
  );
}
function useDropTargetConnector(options) {
  const manager = useDragDropManager();
  const connector = reactExports.useMemo(
    () => new TargetConnector(manager.getBackend()),
    [
      manager
    ]
  );
  useIsomorphicLayoutEffect$1(() => {
    connector.dropTargetOptions = options || null;
    connector.reconnect();
    return () => connector.disconnectDropTarget();
  }, [
    options
  ]);
  return connector;
}
function useDropTargetMonitor() {
  const manager = useDragDropManager();
  return reactExports.useMemo(
    () => new DropTargetMonitorImpl(manager),
    [
      manager
    ]
  );
}
function useAccept(spec) {
  const { accept } = spec;
  return reactExports.useMemo(() => {
    invariant(spec.accept != null, "accept must be defined");
    return Array.isArray(accept) ? accept : [
      accept
    ];
  }, [
    accept
  ]);
}
class DropTargetImpl {
  canDrop() {
    const spec = this.spec;
    const monitor = this.monitor;
    return spec.canDrop ? spec.canDrop(monitor.getItem(), monitor) : true;
  }
  hover() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (spec.hover) {
      spec.hover(monitor.getItem(), monitor);
    }
  }
  drop() {
    const spec = this.spec;
    const monitor = this.monitor;
    if (spec.drop) {
      return spec.drop(monitor.getItem(), monitor);
    }
    return;
  }
  constructor(spec, monitor) {
    this.spec = spec;
    this.monitor = monitor;
  }
}
function useDropTarget(spec, monitor) {
  const dropTarget = reactExports.useMemo(
    () => new DropTargetImpl(spec, monitor),
    [
      monitor
    ]
  );
  reactExports.useEffect(() => {
    dropTarget.spec = spec;
  }, [
    spec
  ]);
  return dropTarget;
}
function useRegisteredDropTarget(spec, monitor, connector) {
  const manager = useDragDropManager();
  const dropTarget = useDropTarget(spec, monitor);
  const accept = useAccept(spec);
  useIsomorphicLayoutEffect$1(function registerDropTarget() {
    const [handlerId, unregister] = registerTarget(accept, dropTarget, manager);
    monitor.receiveHandlerId(handlerId);
    connector.receiveHandlerId(handlerId);
    return unregister;
  }, [
    manager,
    monitor,
    dropTarget,
    connector,
    accept.map(
      (a2) => a2.toString()
    ).join("|")
  ]);
}
function useDrop(specArg, deps) {
  const spec = useOptionalFactory(specArg);
  const monitor = useDropTargetMonitor();
  const connector = useDropTargetConnector(spec.options);
  useRegisteredDropTarget(spec, monitor, connector);
  return [
    useCollectedProps(spec.collect, monitor, connector),
    useConnectDropTarget(connector)
  ];
}
function memoize(fn) {
  let result = null;
  const memoized = () => {
    if (result == null) {
      result = fn();
    }
    return result;
  };
  return memoized;
}
function without(items, item) {
  return items.filter(
    (i2) => i2 !== item
  );
}
function union(itemsA, itemsB) {
  const set2 = /* @__PURE__ */ new Set();
  const insertItem = (item) => set2.add(item);
  itemsA.forEach(insertItem);
  itemsB.forEach(insertItem);
  const result = [];
  set2.forEach(
    (key) => result.push(key)
  );
  return result;
}
class EnterLeaveCounter {
  enter(enteringNode) {
    const previousLength = this.entered.length;
    const isNodeEntered = (node) => this.isNodeInDocument(node) && (!node.contains || node.contains(enteringNode));
    this.entered = union(this.entered.filter(isNodeEntered), [
      enteringNode
    ]);
    return previousLength === 0 && this.entered.length > 0;
  }
  leave(leavingNode) {
    const previousLength = this.entered.length;
    this.entered = without(this.entered.filter(this.isNodeInDocument), leavingNode);
    return previousLength > 0 && this.entered.length === 0;
  }
  reset() {
    this.entered = [];
  }
  constructor(isNodeInDocument) {
    this.entered = [];
    this.isNodeInDocument = isNodeInDocument;
  }
}
class NativeDragSource {
  initializeExposedProperties() {
    Object.keys(this.config.exposeProperties).forEach((property) => {
      Object.defineProperty(this.item, property, {
        configurable: true,
        enumerable: true,
        get() {
          console.warn(`Browser doesn't allow reading "${property}" until the drop event.`);
          return null;
        }
      });
    });
  }
  loadDataTransfer(dataTransfer) {
    if (dataTransfer) {
      const newProperties = {};
      Object.keys(this.config.exposeProperties).forEach((property) => {
        const propertyFn = this.config.exposeProperties[property];
        if (propertyFn != null) {
          newProperties[property] = {
            value: propertyFn(dataTransfer, this.config.matchesTypes),
            configurable: true,
            enumerable: true
          };
        }
      });
      Object.defineProperties(this.item, newProperties);
    }
  }
  canDrag() {
    return true;
  }
  beginDrag() {
    return this.item;
  }
  isDragging(monitor, handle) {
    return handle === monitor.getSourceId();
  }
  endDrag() {
  }
  constructor(config) {
    this.config = config;
    this.item = {};
    this.initializeExposedProperties();
  }
}
const FILE = "__NATIVE_FILE__";
const URL$1 = "__NATIVE_URL__";
const TEXT = "__NATIVE_TEXT__";
const HTML = "__NATIVE_HTML__";
const NativeTypes = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  FILE,
  HTML,
  TEXT,
  URL: URL$1
}, Symbol.toStringTag, { value: "Module" }));
function getDataFromDataTransfer(dataTransfer, typesToTry, defaultValue) {
  const result = typesToTry.reduce(
    (resultSoFar, typeToTry) => resultSoFar || dataTransfer.getData(typeToTry),
    ""
  );
  return result != null ? result : defaultValue;
}
const nativeTypesConfig = {
  [FILE]: {
    exposeProperties: {
      files: (dataTransfer) => Array.prototype.slice.call(dataTransfer.files),
      items: (dataTransfer) => dataTransfer.items,
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Files"
    ]
  },
  [HTML]: {
    exposeProperties: {
      html: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Html",
      "text/html"
    ]
  },
  [URL$1]: {
    exposeProperties: {
      urls: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, "").split("\n"),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Url",
      "text/uri-list"
    ]
  },
  [TEXT]: {
    exposeProperties: {
      text: (dataTransfer, matchesTypes) => getDataFromDataTransfer(dataTransfer, matchesTypes, ""),
      dataTransfer: (dataTransfer) => dataTransfer
    },
    matchesTypes: [
      "Text",
      "text/plain"
    ]
  }
};
function createNativeDragSource(type, dataTransfer) {
  const config = nativeTypesConfig[type];
  if (!config) {
    throw new Error(`native type ${type} has no configuration`);
  }
  const result = new NativeDragSource(config);
  result.loadDataTransfer(dataTransfer);
  return result;
}
function matchNativeItemType(dataTransfer) {
  if (!dataTransfer) {
    return null;
  }
  const dataTransferTypes = Array.prototype.slice.call(dataTransfer.types || []);
  return Object.keys(nativeTypesConfig).filter((nativeItemType) => {
    const typeConfig = nativeTypesConfig[nativeItemType];
    if (!(typeConfig === null || typeConfig === void 0 ? void 0 : typeConfig.matchesTypes)) {
      return false;
    }
    return typeConfig.matchesTypes.some(
      (t2) => dataTransferTypes.indexOf(t2) > -1
    );
  })[0] || null;
}
const isFirefox = memoize(
  () => /firefox/i.test(navigator.userAgent)
);
const isSafari = memoize(
  () => Boolean(window.safari)
);
class MonotonicInterpolant {
  interpolate(x2) {
    const { xs, ys, c1s, c2s, c3s } = this;
    let i2 = xs.length - 1;
    if (x2 === xs[i2]) {
      return ys[i2];
    }
    let low = 0;
    let high = c3s.length - 1;
    let mid;
    while (low <= high) {
      mid = Math.floor(0.5 * (low + high));
      const xHere = xs[mid];
      if (xHere < x2) {
        low = mid + 1;
      } else if (xHere > x2) {
        high = mid - 1;
      } else {
        return ys[mid];
      }
    }
    i2 = Math.max(0, high);
    const diff = x2 - xs[i2];
    const diffSq = diff * diff;
    return ys[i2] + c1s[i2] * diff + c2s[i2] * diffSq + c3s[i2] * diff * diffSq;
  }
  constructor(xs, ys) {
    const { length } = xs;
    const indexes = [];
    for (let i2 = 0; i2 < length; i2++) {
      indexes.push(i2);
    }
    indexes.sort(
      (a2, b2) => xs[a2] < xs[b2] ? -1 : 1
    );
    const dxs = [];
    const ms = [];
    let dx;
    let dy;
    for (let i1 = 0; i1 < length - 1; i1++) {
      dx = xs[i1 + 1] - xs[i1];
      dy = ys[i1 + 1] - ys[i1];
      dxs.push(dx);
      ms.push(dy / dx);
    }
    const c1s = [
      ms[0]
    ];
    for (let i2 = 0; i2 < dxs.length - 1; i2++) {
      const m22 = ms[i2];
      const mNext = ms[i2 + 1];
      if (m22 * mNext <= 0) {
        c1s.push(0);
      } else {
        dx = dxs[i2];
        const dxNext = dxs[i2 + 1];
        const common = dx + dxNext;
        c1s.push(3 * common / ((common + dxNext) / m22 + (common + dx) / mNext));
      }
    }
    c1s.push(ms[ms.length - 1]);
    const c2s = [];
    const c3s = [];
    let m2;
    for (let i3 = 0; i3 < c1s.length - 1; i3++) {
      m2 = ms[i3];
      const c1 = c1s[i3];
      const invDx = 1 / dxs[i3];
      const common = c1 + c1s[i3 + 1] - m2 - m2;
      c2s.push((m2 - c1 - common) * invDx);
      c3s.push(common * invDx * invDx);
    }
    this.xs = xs;
    this.ys = ys;
    this.c1s = c1s;
    this.c2s = c2s;
    this.c3s = c3s;
  }
}
const ELEMENT_NODE = 1;
function getNodeClientOffset(node) {
  const el2 = node.nodeType === ELEMENT_NODE ? node : node.parentElement;
  if (!el2) {
    return null;
  }
  const { top, left } = el2.getBoundingClientRect();
  return {
    x: left,
    y: top
  };
}
function getEventClientOffset(e2) {
  return {
    x: e2.clientX,
    y: e2.clientY
  };
}
function isImageNode(node) {
  var ref;
  return node.nodeName === "IMG" && (isFirefox() || !((ref = document.documentElement) === null || ref === void 0 ? void 0 : ref.contains(node)));
}
function getDragPreviewSize(isImage2, dragPreview, sourceWidth, sourceHeight) {
  let dragPreviewWidth = isImage2 ? dragPreview.width : sourceWidth;
  let dragPreviewHeight = isImage2 ? dragPreview.height : sourceHeight;
  if (isSafari() && isImage2) {
    dragPreviewHeight /= window.devicePixelRatio;
    dragPreviewWidth /= window.devicePixelRatio;
  }
  return {
    dragPreviewWidth,
    dragPreviewHeight
  };
}
function getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint) {
  const isImage2 = isImageNode(dragPreview);
  const dragPreviewNode = isImage2 ? sourceNode : dragPreview;
  const dragPreviewNodeOffsetFromClient = getNodeClientOffset(dragPreviewNode);
  const offsetFromDragPreview = {
    x: clientOffset.x - dragPreviewNodeOffsetFromClient.x,
    y: clientOffset.y - dragPreviewNodeOffsetFromClient.y
  };
  const { offsetWidth: sourceWidth, offsetHeight: sourceHeight } = sourceNode;
  const { anchorX, anchorY } = anchorPoint;
  const { dragPreviewWidth, dragPreviewHeight } = getDragPreviewSize(isImage2, dragPreview, sourceWidth, sourceHeight);
  const calculateYOffset = () => {
    const interpolantY = new MonotonicInterpolant([
      0,
      0.5,
      1
    ], [
      // Dock to the top
      offsetFromDragPreview.y,
      // Align at the center
      offsetFromDragPreview.y / sourceHeight * dragPreviewHeight,
      // Dock to the bottom
      offsetFromDragPreview.y + dragPreviewHeight - sourceHeight
    ]);
    let y2 = interpolantY.interpolate(anchorY);
    if (isSafari() && isImage2) {
      y2 += (window.devicePixelRatio - 1) * dragPreviewHeight;
    }
    return y2;
  };
  const calculateXOffset = () => {
    const interpolantX = new MonotonicInterpolant([
      0,
      0.5,
      1
    ], [
      // Dock to the left
      offsetFromDragPreview.x,
      // Align at the center
      offsetFromDragPreview.x / sourceWidth * dragPreviewWidth,
      // Dock to the right
      offsetFromDragPreview.x + dragPreviewWidth - sourceWidth
    ]);
    return interpolantX.interpolate(anchorX);
  };
  const { offsetX, offsetY } = offsetPoint;
  const isManualOffsetX = offsetX === 0 || offsetX;
  const isManualOffsetY = offsetY === 0 || offsetY;
  return {
    x: isManualOffsetX ? offsetX : calculateXOffset(),
    y: isManualOffsetY ? offsetY : calculateYOffset()
  };
}
class OptionsReader {
  get window() {
    if (this.globalContext) {
      return this.globalContext;
    } else if (typeof window !== "undefined") {
      return window;
    }
    return void 0;
  }
  get document() {
    var ref;
    if ((ref = this.globalContext) === null || ref === void 0 ? void 0 : ref.document) {
      return this.globalContext.document;
    } else if (this.window) {
      return this.window.document;
    } else {
      return void 0;
    }
  }
  get rootElement() {
    var ref;
    return ((ref = this.optionsArgs) === null || ref === void 0 ? void 0 : ref.rootElement) || this.window;
  }
  constructor(globalContext, options) {
    this.ownerDocument = null;
    this.globalContext = globalContext;
    this.optionsArgs = options;
  }
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function _objectSpread(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    var ownKeys = Object.keys(source);
    if (typeof Object.getOwnPropertySymbols === "function") {
      ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
        return Object.getOwnPropertyDescriptor(source, sym).enumerable;
      }));
    }
    ownKeys.forEach(function(key) {
      _defineProperty(target, key, source[key]);
    });
  }
  return target;
}
class HTML5BackendImpl {
  /**
  * Generate profiling statistics for the HTML5Backend.
  */
  profile() {
    var ref, ref1;
    return {
      sourcePreviewNodes: this.sourcePreviewNodes.size,
      sourcePreviewNodeOptions: this.sourcePreviewNodeOptions.size,
      sourceNodeOptions: this.sourceNodeOptions.size,
      sourceNodes: this.sourceNodes.size,
      dragStartSourceIds: ((ref = this.dragStartSourceIds) === null || ref === void 0 ? void 0 : ref.length) || 0,
      dropTargetIds: this.dropTargetIds.length,
      dragEnterTargetIds: this.dragEnterTargetIds.length,
      dragOverTargetIds: ((ref1 = this.dragOverTargetIds) === null || ref1 === void 0 ? void 0 : ref1.length) || 0
    };
  }
  // public for test
  get window() {
    return this.options.window;
  }
  get document() {
    return this.options.document;
  }
  /**
  * Get the root element to use for event subscriptions
  */
  get rootElement() {
    return this.options.rootElement;
  }
  setup() {
    const root = this.rootElement;
    if (root === void 0) {
      return;
    }
    if (root.__isReactDndBackendSetUp) {
      throw new Error("Cannot have two HTML5 backends at the same time.");
    }
    root.__isReactDndBackendSetUp = true;
    this.addEventListeners(root);
  }
  teardown() {
    const root = this.rootElement;
    if (root === void 0) {
      return;
    }
    root.__isReactDndBackendSetUp = false;
    this.removeEventListeners(this.rootElement);
    this.clearCurrentDragSourceNode();
    if (this.asyncEndDragFrameId) {
      var ref;
      (ref = this.window) === null || ref === void 0 ? void 0 : ref.cancelAnimationFrame(this.asyncEndDragFrameId);
    }
  }
  connectDragPreview(sourceId, node, options) {
    this.sourcePreviewNodeOptions.set(sourceId, options);
    this.sourcePreviewNodes.set(sourceId, node);
    return () => {
      this.sourcePreviewNodes.delete(sourceId);
      this.sourcePreviewNodeOptions.delete(sourceId);
    };
  }
  connectDragSource(sourceId, node, options) {
    this.sourceNodes.set(sourceId, node);
    this.sourceNodeOptions.set(sourceId, options);
    const handleDragStart = (e2) => this.handleDragStart(e2, sourceId);
    const handleSelectStart = (e2) => this.handleSelectStart(e2);
    node.setAttribute("draggable", "true");
    node.addEventListener("dragstart", handleDragStart);
    node.addEventListener("selectstart", handleSelectStart);
    return () => {
      this.sourceNodes.delete(sourceId);
      this.sourceNodeOptions.delete(sourceId);
      node.removeEventListener("dragstart", handleDragStart);
      node.removeEventListener("selectstart", handleSelectStart);
      node.setAttribute("draggable", "false");
    };
  }
  connectDropTarget(targetId, node) {
    const handleDragEnter = (e2) => this.handleDragEnter(e2, targetId);
    const handleDragOver = (e2) => this.handleDragOver(e2, targetId);
    const handleDrop = (e2) => this.handleDrop(e2, targetId);
    node.addEventListener("dragenter", handleDragEnter);
    node.addEventListener("dragover", handleDragOver);
    node.addEventListener("drop", handleDrop);
    return () => {
      node.removeEventListener("dragenter", handleDragEnter);
      node.removeEventListener("dragover", handleDragOver);
      node.removeEventListener("drop", handleDrop);
    };
  }
  addEventListeners(target) {
    if (!target.addEventListener) {
      return;
    }
    target.addEventListener("dragstart", this.handleTopDragStart);
    target.addEventListener("dragstart", this.handleTopDragStartCapture, true);
    target.addEventListener("dragend", this.handleTopDragEndCapture, true);
    target.addEventListener("dragenter", this.handleTopDragEnter);
    target.addEventListener("dragenter", this.handleTopDragEnterCapture, true);
    target.addEventListener("dragleave", this.handleTopDragLeaveCapture, true);
    target.addEventListener("dragover", this.handleTopDragOver);
    target.addEventListener("dragover", this.handleTopDragOverCapture, true);
    target.addEventListener("drop", this.handleTopDrop);
    target.addEventListener("drop", this.handleTopDropCapture, true);
  }
  removeEventListeners(target) {
    if (!target.removeEventListener) {
      return;
    }
    target.removeEventListener("dragstart", this.handleTopDragStart);
    target.removeEventListener("dragstart", this.handleTopDragStartCapture, true);
    target.removeEventListener("dragend", this.handleTopDragEndCapture, true);
    target.removeEventListener("dragenter", this.handleTopDragEnter);
    target.removeEventListener("dragenter", this.handleTopDragEnterCapture, true);
    target.removeEventListener("dragleave", this.handleTopDragLeaveCapture, true);
    target.removeEventListener("dragover", this.handleTopDragOver);
    target.removeEventListener("dragover", this.handleTopDragOverCapture, true);
    target.removeEventListener("drop", this.handleTopDrop);
    target.removeEventListener("drop", this.handleTopDropCapture, true);
  }
  getCurrentSourceNodeOptions() {
    const sourceId = this.monitor.getSourceId();
    const sourceNodeOptions = this.sourceNodeOptions.get(sourceId);
    return _objectSpread({
      dropEffect: this.altKeyPressed ? "copy" : "move"
    }, sourceNodeOptions || {});
  }
  getCurrentDropEffect() {
    if (this.isDraggingNativeItem()) {
      return "copy";
    }
    return this.getCurrentSourceNodeOptions().dropEffect;
  }
  getCurrentSourcePreviewNodeOptions() {
    const sourceId = this.monitor.getSourceId();
    const sourcePreviewNodeOptions = this.sourcePreviewNodeOptions.get(sourceId);
    return _objectSpread({
      anchorX: 0.5,
      anchorY: 0.5,
      captureDraggingState: false
    }, sourcePreviewNodeOptions || {});
  }
  isDraggingNativeItem() {
    const itemType = this.monitor.getItemType();
    return Object.keys(NativeTypes).some(
      (key) => NativeTypes[key] === itemType
    );
  }
  beginDragNativeItem(type, dataTransfer) {
    this.clearCurrentDragSourceNode();
    this.currentNativeSource = createNativeDragSource(type, dataTransfer);
    this.currentNativeHandle = this.registry.addSource(type, this.currentNativeSource);
    this.actions.beginDrag([
      this.currentNativeHandle
    ]);
  }
  setCurrentDragSourceNode(node) {
    this.clearCurrentDragSourceNode();
    this.currentDragSourceNode = node;
    const MOUSE_MOVE_TIMEOUT = 1e3;
    this.mouseMoveTimeoutTimer = setTimeout(() => {
      var ref;
      return (ref = this.rootElement) === null || ref === void 0 ? void 0 : ref.addEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
    }, MOUSE_MOVE_TIMEOUT);
  }
  clearCurrentDragSourceNode() {
    if (this.currentDragSourceNode) {
      this.currentDragSourceNode = null;
      if (this.rootElement) {
        var ref;
        (ref = this.window) === null || ref === void 0 ? void 0 : ref.clearTimeout(this.mouseMoveTimeoutTimer || void 0);
        this.rootElement.removeEventListener("mousemove", this.endDragIfSourceWasRemovedFromDOM, true);
      }
      this.mouseMoveTimeoutTimer = null;
      return true;
    }
    return false;
  }
  handleDragStart(e2, sourceId) {
    if (e2.defaultPrevented) {
      return;
    }
    if (!this.dragStartSourceIds) {
      this.dragStartSourceIds = [];
    }
    this.dragStartSourceIds.unshift(sourceId);
  }
  handleDragEnter(_e, targetId) {
    this.dragEnterTargetIds.unshift(targetId);
  }
  handleDragOver(_e, targetId) {
    if (this.dragOverTargetIds === null) {
      this.dragOverTargetIds = [];
    }
    this.dragOverTargetIds.unshift(targetId);
  }
  handleDrop(_e, targetId) {
    this.dropTargetIds.unshift(targetId);
  }
  constructor(manager, globalContext, options) {
    this.sourcePreviewNodes = /* @__PURE__ */ new Map();
    this.sourcePreviewNodeOptions = /* @__PURE__ */ new Map();
    this.sourceNodes = /* @__PURE__ */ new Map();
    this.sourceNodeOptions = /* @__PURE__ */ new Map();
    this.dragStartSourceIds = null;
    this.dropTargetIds = [];
    this.dragEnterTargetIds = [];
    this.currentNativeSource = null;
    this.currentNativeHandle = null;
    this.currentDragSourceNode = null;
    this.altKeyPressed = false;
    this.mouseMoveTimeoutTimer = null;
    this.asyncEndDragFrameId = null;
    this.dragOverTargetIds = null;
    this.lastClientOffset = null;
    this.hoverRafId = null;
    this.getSourceClientOffset = (sourceId) => {
      const source = this.sourceNodes.get(sourceId);
      return source && getNodeClientOffset(source) || null;
    };
    this.endDragNativeItem = () => {
      if (!this.isDraggingNativeItem()) {
        return;
      }
      this.actions.endDrag();
      if (this.currentNativeHandle) {
        this.registry.removeSource(this.currentNativeHandle);
      }
      this.currentNativeHandle = null;
      this.currentNativeSource = null;
    };
    this.isNodeInDocument = (node) => {
      return Boolean(node && this.document && this.document.body && this.document.body.contains(node));
    };
    this.endDragIfSourceWasRemovedFromDOM = () => {
      const node = this.currentDragSourceNode;
      if (node == null || this.isNodeInDocument(node)) {
        return;
      }
      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.scheduleHover = (dragOverTargetIds) => {
      if (this.hoverRafId === null && typeof requestAnimationFrame !== "undefined") {
        this.hoverRafId = requestAnimationFrame(() => {
          if (this.monitor.isDragging()) {
            this.actions.hover(dragOverTargetIds || [], {
              clientOffset: this.lastClientOffset
            });
          }
          this.hoverRafId = null;
        });
      }
    };
    this.cancelHover = () => {
      if (this.hoverRafId !== null && typeof cancelAnimationFrame !== "undefined") {
        cancelAnimationFrame(this.hoverRafId);
        this.hoverRafId = null;
      }
    };
    this.handleTopDragStartCapture = () => {
      this.clearCurrentDragSourceNode();
      this.dragStartSourceIds = [];
    };
    this.handleTopDragStart = (e2) => {
      if (e2.defaultPrevented) {
        return;
      }
      const { dragStartSourceIds } = this;
      this.dragStartSourceIds = null;
      const clientOffset = getEventClientOffset(e2);
      if (this.monitor.isDragging()) {
        this.actions.endDrag();
        this.cancelHover();
      }
      this.actions.beginDrag(dragStartSourceIds || [], {
        publishSource: false,
        getSourceClientOffset: this.getSourceClientOffset,
        clientOffset
      });
      const { dataTransfer } = e2;
      const nativeType = matchNativeItemType(dataTransfer);
      if (this.monitor.isDragging()) {
        if (dataTransfer && typeof dataTransfer.setDragImage === "function") {
          const sourceId = this.monitor.getSourceId();
          const sourceNode = this.sourceNodes.get(sourceId);
          const dragPreview = this.sourcePreviewNodes.get(sourceId) || sourceNode;
          if (dragPreview) {
            const { anchorX, anchorY, offsetX, offsetY } = this.getCurrentSourcePreviewNodeOptions();
            const anchorPoint = {
              anchorX,
              anchorY
            };
            const offsetPoint = {
              offsetX,
              offsetY
            };
            const dragPreviewOffset = getDragPreviewOffset(sourceNode, dragPreview, clientOffset, anchorPoint, offsetPoint);
            dataTransfer.setDragImage(dragPreview, dragPreviewOffset.x, dragPreviewOffset.y);
          }
        }
        try {
          dataTransfer === null || dataTransfer === void 0 ? void 0 : dataTransfer.setData("application/json", {});
        } catch (err) {
        }
        this.setCurrentDragSourceNode(e2.target);
        const { captureDraggingState } = this.getCurrentSourcePreviewNodeOptions();
        if (!captureDraggingState) {
          setTimeout(
            () => this.actions.publishDragSource(),
            0
          );
        } else {
          this.actions.publishDragSource();
        }
      } else if (nativeType) {
        this.beginDragNativeItem(nativeType);
      } else if (dataTransfer && !dataTransfer.types && (e2.target && !e2.target.hasAttribute || !e2.target.hasAttribute("draggable"))) {
        return;
      } else {
        e2.preventDefault();
      }
    };
    this.handleTopDragEndCapture = () => {
      if (this.clearCurrentDragSourceNode() && this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.handleTopDragEnterCapture = (e2) => {
      this.dragEnterTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      }
      const isFirstEnter = this.enterLeaveCounter.enter(e2.target);
      if (!isFirstEnter || this.monitor.isDragging()) {
        return;
      }
      const { dataTransfer } = e2;
      const nativeType = matchNativeItemType(dataTransfer);
      if (nativeType) {
        this.beginDragNativeItem(nativeType, dataTransfer);
      }
    };
    this.handleTopDragEnter = (e2) => {
      const { dragEnterTargetIds } = this;
      this.dragEnterTargetIds = [];
      if (!this.monitor.isDragging()) {
        return;
      }
      this.altKeyPressed = e2.altKey;
      if (dragEnterTargetIds.length > 0) {
        this.actions.hover(dragEnterTargetIds, {
          clientOffset: getEventClientOffset(e2)
        });
      }
      const canDrop = dragEnterTargetIds.some(
        (targetId) => this.monitor.canDropOnTarget(targetId)
      );
      if (canDrop) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = this.getCurrentDropEffect();
        }
      }
    };
    this.handleTopDragOverCapture = (e2) => {
      this.dragOverTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      }
    };
    this.handleTopDragOver = (e2) => {
      const { dragOverTargetIds } = this;
      this.dragOverTargetIds = [];
      if (!this.monitor.isDragging()) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = "none";
        }
        return;
      }
      this.altKeyPressed = e2.altKey;
      this.lastClientOffset = getEventClientOffset(e2);
      this.scheduleHover(dragOverTargetIds);
      const canDrop = (dragOverTargetIds || []).some(
        (targetId) => this.monitor.canDropOnTarget(targetId)
      );
      if (canDrop) {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = this.getCurrentDropEffect();
        }
      } else if (this.isDraggingNativeItem()) {
        e2.preventDefault();
      } else {
        e2.preventDefault();
        if (e2.dataTransfer) {
          e2.dataTransfer.dropEffect = "none";
        }
      }
    };
    this.handleTopDragLeaveCapture = (e2) => {
      if (this.isDraggingNativeItem()) {
        e2.preventDefault();
      }
      const isLastLeave = this.enterLeaveCounter.leave(e2.target);
      if (!isLastLeave) {
        return;
      }
      if (this.isDraggingNativeItem()) {
        setTimeout(
          () => this.endDragNativeItem(),
          0
        );
      }
      this.cancelHover();
    };
    this.handleTopDropCapture = (e2) => {
      this.dropTargetIds = [];
      if (this.isDraggingNativeItem()) {
        var ref;
        e2.preventDefault();
        (ref = this.currentNativeSource) === null || ref === void 0 ? void 0 : ref.loadDataTransfer(e2.dataTransfer);
      } else if (matchNativeItemType(e2.dataTransfer)) {
        e2.preventDefault();
      }
      this.enterLeaveCounter.reset();
    };
    this.handleTopDrop = (e2) => {
      const { dropTargetIds } = this;
      this.dropTargetIds = [];
      this.actions.hover(dropTargetIds, {
        clientOffset: getEventClientOffset(e2)
      });
      this.actions.drop({
        dropEffect: this.getCurrentDropEffect()
      });
      if (this.isDraggingNativeItem()) {
        this.endDragNativeItem();
      } else if (this.monitor.isDragging()) {
        this.actions.endDrag();
      }
      this.cancelHover();
    };
    this.handleSelectStart = (e2) => {
      const target = e2.target;
      if (typeof target.dragDrop !== "function") {
        return;
      }
      if (target.tagName === "INPUT" || target.tagName === "SELECT" || target.tagName === "TEXTAREA" || target.isContentEditable) {
        return;
      }
      e2.preventDefault();
      target.dragDrop();
    };
    this.options = new OptionsReader(globalContext, options);
    this.actions = manager.getActions();
    this.monitor = manager.getMonitor();
    this.registry = manager.getRegistry();
    this.enterLeaveCounter = new EnterLeaveCounter(this.isNodeInDocument);
  }
}
const HTML5Backend = function createBackend(manager, context, options) {
  return new HTML5BackendImpl(manager, context, options);
};
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i2;
  for (i2 = 0; i2 < sourceKeys.length; i2++) {
    key = sourceKeys[i2];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }
  return target;
}
var _excluded$Q = ["color"];
var CaretSortIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Q);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M4.93179 5.43179C4.75605 5.60753 4.75605 5.89245 4.93179 6.06819C5.10753 6.24392 5.39245 6.24392 5.56819 6.06819L7.49999 4.13638L9.43179 6.06819C9.60753 6.24392 9.89245 6.24392 10.0682 6.06819C10.2439 5.89245 10.2439 5.60753 10.0682 5.43179L7.81819 3.18179C7.73379 3.0974 7.61933 3.04999 7.49999 3.04999C7.38064 3.04999 7.26618 3.0974 7.18179 3.18179L4.93179 5.43179ZM10.0682 9.56819C10.2439 9.39245 10.2439 9.10753 10.0682 8.93179C9.89245 8.75606 9.60753 8.75606 9.43179 8.93179L7.49999 10.8636L5.56819 8.93179C5.39245 8.75606 5.10753 8.75606 4.93179 8.93179C4.75605 9.10753 4.75605 9.39245 4.93179 9.56819L7.18179 11.8182C7.35753 11.9939 7.64245 11.9939 7.81819 11.8182L10.0682 9.56819Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$T = ["color"];
var CheckIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$T);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.4669 3.72684C11.7558 3.91574 11.8369 4.30308 11.648 4.59198L7.39799 11.092C7.29783 11.2452 7.13556 11.3467 6.95402 11.3699C6.77247 11.3931 6.58989 11.3355 6.45446 11.2124L3.70446 8.71241C3.44905 8.48022 3.43023 8.08494 3.66242 7.82953C3.89461 7.57412 4.28989 7.55529 4.5453 7.78749L6.75292 9.79441L10.6018 3.90792C10.7907 3.61902 11.178 3.53795 11.4669 3.72684Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$W = ["color"];
var ChevronDownIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$W);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.13523 6.15803C3.3241 5.95657 3.64052 5.94637 3.84197 6.13523L7.5 9.56464L11.158 6.13523C11.3595 5.94637 11.6759 5.95657 11.8648 6.15803C12.0536 6.35949 12.0434 6.67591 11.842 6.86477L7.84197 10.6148C7.64964 10.7951 7.35036 10.7951 7.15803 10.6148L3.15803 6.86477C2.95657 6.67591 2.94637 6.35949 3.13523 6.15803Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$Y = ["color"];
var ChevronRightIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Y);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M6.1584 3.13508C6.35985 2.94621 6.67627 2.95642 6.86514 3.15788L10.6151 7.15788C10.7954 7.3502 10.7954 7.64949 10.6151 7.84182L6.86514 11.8418C6.67627 12.0433 6.35985 12.0535 6.1584 11.8646C5.95694 11.6757 5.94673 11.3593 6.1356 11.1579L9.565 7.49985L6.1356 3.84182C5.94673 3.64036 5.95694 3.32394 6.1584 3.13508Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$Z = ["color"];
var ChevronUpIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$Z);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M3.13523 8.84197C3.3241 9.04343 3.64052 9.05363 3.84197 8.86477L7.5 5.43536L11.158 8.86477C11.3595 9.05363 11.6759 9.04343 11.8648 8.84197C12.0536 8.64051 12.0434 8.32409 11.842 8.13523L7.84197 4.38523C7.64964 4.20492 7.35036 4.20492 7.15803 4.38523L3.15803 8.13523C2.95657 8.32409 2.94637 8.64051 3.13523 8.84197Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1r = ["color"];
var Cross2Icon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1r);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M11.7816 4.03157C12.0062 3.80702 12.0062 3.44295 11.7816 3.2184C11.5571 2.99385 11.193 2.99385 10.9685 3.2184L7.50005 6.68682L4.03164 3.2184C3.80708 2.99385 3.44301 2.99385 3.21846 3.2184C2.99391 3.44295 2.99391 3.80702 3.21846 4.03157L6.68688 7.49999L3.21846 10.9684C2.99391 11.193 2.99391 11.557 3.21846 11.7816C3.44301 12.0061 3.80708 12.0061 4.03164 11.7816L7.50005 8.31316L10.9685 11.7816C11.193 12.0061 11.5571 12.0061 11.7816 11.7816C12.0062 11.557 12.0062 11.193 11.7816 10.9684L8.31322 7.49999L11.7816 4.03157Z",
    fill: color,
    fillRule: "evenodd",
    clipRule: "evenodd"
  }));
});
var _excluded$1I = ["color"];
var DotFilledIcon = /* @__PURE__ */ reactExports.forwardRef(function(_ref, forwardedRef) {
  var _ref$color = _ref.color, color = _ref$color === void 0 ? "currentColor" : _ref$color, props = _objectWithoutPropertiesLoose(_ref, _excluded$1I);
  return reactExports.createElement("svg", Object.assign({
    width: "15",
    height: "15",
    viewBox: "0 0 15 15",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg"
  }, props, {
    ref: forwardedRef
  }), reactExports.createElement("path", {
    d: "M9.875 7.5C9.875 8.81168 8.81168 9.875 7.5 9.875C6.18832 9.875 5.125 8.81168 5.125 7.5C5.125 6.18832 6.18832 5.125 7.5 5.125C8.81168 5.125 9.875 6.18832 9.875 7.5Z",
    fill: color
  }));
});
function clamp$1(value, [min2, max2]) {
  return Math.min(max2, Math.max(min2, value));
}
function composeEventHandlers(originalEventHandler, ourEventHandler, { checkForDefaultPrevented = true } = {}) {
  return function handleEvent(event) {
    originalEventHandler?.(event);
    if (checkForDefaultPrevented === false || !event.defaultPrevented) {
      return ourEventHandler?.(event);
    }
  };
}
function createContextScope$1(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    function Provider(props) {
      const { scope: scope2, children, ...context } = props;
      const Context = scope2?.[scopeName][index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    }
    function useContext2(consumerName, scope2) {
      const Context = scope2?.[scopeName][index2] || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    Provider.displayName = rootComponentName + "Provider";
    return [Provider, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope2) {
      const contexts = scope2?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope2, [scopeName]: contexts } }),
        [scope2, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes$1(createScope, ...createContextScopeDeps)];
}
function composeContextScopes$1(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
function setRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref !== null && ref !== void 0) {
    ref.current = value;
  }
}
function composeRefs(...refs) {
  return (node) => refs.forEach((ref) => setRef(ref, node));
}
function useComposedRefs(...refs) {
  return reactExports.useCallback(composeRefs(...refs), refs);
}
var Slot = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  const childrenArray = reactExports.Children.toArray(children);
  const slottable = childrenArray.find(isSlottable);
  if (slottable) {
    const newElement = slottable.props.children;
    const newChildren = childrenArray.map((child) => {
      if (child === slottable) {
        if (reactExports.Children.count(newElement) > 1) return reactExports.Children.only(null);
        return reactExports.isValidElement(newElement) ? newElement.props.children : null;
      } else {
        return child;
      }
    });
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children: reactExports.isValidElement(newElement) ? reactExports.cloneElement(newElement, void 0, newChildren) : null });
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(SlotClone, { ...slotProps, ref: forwardedRef, children });
});
Slot.displayName = "Slot";
var SlotClone = reactExports.forwardRef((props, forwardedRef) => {
  const { children, ...slotProps } = props;
  if (reactExports.isValidElement(children)) {
    const childrenRef = getElementRef$1(children);
    return reactExports.cloneElement(children, {
      ...mergeProps(slotProps, children.props),
      // @ts-ignore
      ref: forwardedRef ? composeRefs(forwardedRef, childrenRef) : childrenRef
    });
  }
  return reactExports.Children.count(children) > 1 ? reactExports.Children.only(null) : null;
});
SlotClone.displayName = "SlotClone";
var Slottable = ({ children }) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children });
};
function isSlottable(child) {
  return reactExports.isValidElement(child) && child.type === Slottable;
}
function mergeProps(slotProps, childProps) {
  const overrideProps = { ...childProps };
  for (const propName in childProps) {
    const slotPropValue = slotProps[propName];
    const childPropValue = childProps[propName];
    const isHandler = /^on[A-Z]/.test(propName);
    if (isHandler) {
      if (slotPropValue && childPropValue) {
        overrideProps[propName] = (...args) => {
          childPropValue(...args);
          slotPropValue(...args);
        };
      } else if (slotPropValue) {
        overrideProps[propName] = slotPropValue;
      }
    } else if (propName === "style") {
      overrideProps[propName] = { ...slotPropValue, ...childPropValue };
    } else if (propName === "className") {
      overrideProps[propName] = [slotPropValue, childPropValue].filter(Boolean).join(" ");
    }
  }
  return { ...slotProps, ...overrideProps };
}
function getElementRef$1(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
function createCollection(name) {
  const PROVIDER_NAME = name + "CollectionProvider";
  const [createCollectionContext, createCollectionScope2] = createContextScope$1(PROVIDER_NAME);
  const [CollectionProviderImpl, useCollectionContext] = createCollectionContext(
    PROVIDER_NAME,
    { collectionRef: { current: null }, itemMap: /* @__PURE__ */ new Map() }
  );
  const CollectionProvider = (props) => {
    const { scope: scope2, children } = props;
    const ref = React.useRef(null);
    const itemMap = React.useRef(/* @__PURE__ */ new Map()).current;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(CollectionProviderImpl, { scope: scope2, itemMap, collectionRef: ref, children });
  };
  CollectionProvider.displayName = PROVIDER_NAME;
  const COLLECTION_SLOT_NAME = name + "CollectionSlot";
  const CollectionSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope: scope2, children } = props;
      const context = useCollectionContext(COLLECTION_SLOT_NAME, scope2);
      const composedRefs = useComposedRefs(forwardedRef, context.collectionRef);
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ref: composedRefs, children });
    }
  );
  CollectionSlot.displayName = COLLECTION_SLOT_NAME;
  const ITEM_SLOT_NAME = name + "CollectionItemSlot";
  const ITEM_DATA_ATTR = "data-radix-collection-item";
  const CollectionItemSlot = React.forwardRef(
    (props, forwardedRef) => {
      const { scope: scope2, children, ...itemData } = props;
      const ref = React.useRef(null);
      const composedRefs = useComposedRefs(forwardedRef, ref);
      const context = useCollectionContext(ITEM_SLOT_NAME, scope2);
      React.useEffect(() => {
        context.itemMap.set(ref, { ref, ...itemData });
        return () => void context.itemMap.delete(ref);
      });
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Slot, { ...{ [ITEM_DATA_ATTR]: "" }, ref: composedRefs, children });
    }
  );
  CollectionItemSlot.displayName = ITEM_SLOT_NAME;
  function useCollection2(scope2) {
    const context = useCollectionContext(name + "CollectionConsumer", scope2);
    const getItems = React.useCallback(() => {
      const collectionNode = context.collectionRef.current;
      if (!collectionNode) return [];
      const orderedNodes = Array.from(collectionNode.querySelectorAll(`[${ITEM_DATA_ATTR}]`));
      const items = Array.from(context.itemMap.values());
      const orderedItems = items.sort(
        (a2, b2) => orderedNodes.indexOf(a2.ref.current) - orderedNodes.indexOf(b2.ref.current)
      );
      return orderedItems;
    }, [context.collectionRef, context.itemMap]);
    return getItems;
  }
  return [
    { Provider: CollectionProvider, Slot: CollectionSlot, ItemSlot: CollectionItemSlot },
    useCollection2,
    createCollectionScope2
  ];
}
function createContext2(rootComponentName, defaultContext) {
  const Context = reactExports.createContext(defaultContext);
  const Provider = (props) => {
    const { children, ...context } = props;
    const value = reactExports.useMemo(() => context, Object.values(context));
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
  };
  Provider.displayName = rootComponentName + "Provider";
  function useContext2(consumerName) {
    const context = reactExports.useContext(Context);
    if (context) return context;
    if (defaultContext !== void 0) return defaultContext;
    throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
  }
  return [Provider, useContext2];
}
function createContextScope(scopeName, createContextScopeDeps = []) {
  let defaultContexts = [];
  function createContext3(rootComponentName, defaultContext) {
    const BaseContext = reactExports.createContext(defaultContext);
    const index2 = defaultContexts.length;
    defaultContexts = [...defaultContexts, defaultContext];
    const Provider = (props) => {
      const { scope: scope2, children, ...context } = props;
      const Context = scope2?.[scopeName]?.[index2] || BaseContext;
      const value = reactExports.useMemo(() => context, Object.values(context));
      return /* @__PURE__ */ jsxRuntimeExports.jsx(Context.Provider, { value, children });
    };
    Provider.displayName = rootComponentName + "Provider";
    function useContext2(consumerName, scope2) {
      const Context = scope2?.[scopeName]?.[index2] || BaseContext;
      const context = reactExports.useContext(Context);
      if (context) return context;
      if (defaultContext !== void 0) return defaultContext;
      throw new Error(`\`${consumerName}\` must be used within \`${rootComponentName}\``);
    }
    return [Provider, useContext2];
  }
  const createScope = () => {
    const scopeContexts = defaultContexts.map((defaultContext) => {
      return reactExports.createContext(defaultContext);
    });
    return function useScope(scope2) {
      const contexts = scope2?.[scopeName] || scopeContexts;
      return reactExports.useMemo(
        () => ({ [`__scope${scopeName}`]: { ...scope2, [scopeName]: contexts } }),
        [scope2, contexts]
      );
    };
  };
  createScope.scopeName = scopeName;
  return [createContext3, composeContextScopes(createScope, ...createContextScopeDeps)];
}
function composeContextScopes(...scopes) {
  const baseScope = scopes[0];
  if (scopes.length === 1) return baseScope;
  const createScope = () => {
    const scopeHooks = scopes.map((createScope2) => ({
      useScope: createScope2(),
      scopeName: createScope2.scopeName
    }));
    return function useComposedScopes(overrideScopes) {
      const nextScopes = scopeHooks.reduce((nextScopes2, { useScope, scopeName }) => {
        const scopeProps = useScope(overrideScopes);
        const currentScope = scopeProps[`__scope${scopeName}`];
        return { ...nextScopes2, ...currentScope };
      }, {});
      return reactExports.useMemo(() => ({ [`__scope${baseScope.scopeName}`]: nextScopes }), [nextScopes]);
    };
  };
  createScope.scopeName = baseScope.scopeName;
  return createScope;
}
var DirectionContext = reactExports.createContext(void 0);
function useDirection(localDir) {
  const globalDir = reactExports.useContext(DirectionContext);
  return localDir || globalDir || "ltr";
}
var NODES = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var Primitive = NODES.reduce((primitive, node) => {
  const Node2 = reactExports.forwardRef((props, forwardedRef) => {
    const { asChild, ...primitiveProps } = props;
    const Comp = asChild ? Slot : node;
    if (typeof window !== "undefined") {
      window[Symbol.for("radix-ui")] = true;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Comp, { ...primitiveProps, ref: forwardedRef });
  });
  Node2.displayName = `Primitive.${node}`;
  return { ...primitive, [node]: Node2 };
}, {});
function dispatchDiscreteCustomEvent(target, event) {
  if (target) reactDomExports.flushSync(() => target.dispatchEvent(event));
}
function useCallbackRef$1(callback) {
  const callbackRef = reactExports.useRef(callback);
  reactExports.useEffect(() => {
    callbackRef.current = callback;
  });
  return reactExports.useMemo(() => (...args) => callbackRef.current?.(...args), []);
}
function useEscapeKeydown(onEscapeKeyDownProp, ownerDocument = globalThis?.document) {
  const onEscapeKeyDown = useCallbackRef$1(onEscapeKeyDownProp);
  reactExports.useEffect(() => {
    const handleKeyDown = (event) => {
      if (event.key === "Escape") {
        onEscapeKeyDown(event);
      }
    };
    ownerDocument.addEventListener("keydown", handleKeyDown, { capture: true });
    return () => ownerDocument.removeEventListener("keydown", handleKeyDown, { capture: true });
  }, [onEscapeKeyDown, ownerDocument]);
}
var DISMISSABLE_LAYER_NAME = "DismissableLayer";
var CONTEXT_UPDATE = "dismissableLayer.update";
var POINTER_DOWN_OUTSIDE = "dismissableLayer.pointerDownOutside";
var FOCUS_OUTSIDE = "dismissableLayer.focusOutside";
var originalBodyPointerEvents;
var DismissableLayerContext = reactExports.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var DismissableLayer = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      disableOutsidePointerEvents = false,
      onEscapeKeyDown,
      onPointerDownOutside,
      onFocusOutside,
      onInteractOutside,
      onDismiss,
      ...layerProps
    } = props;
    const context = reactExports.useContext(DismissableLayerContext);
    const [node, setNode] = reactExports.useState(null);
    const ownerDocument = node?.ownerDocument ?? globalThis?.document;
    const [, force] = reactExports.useState({});
    const composedRefs = useComposedRefs(forwardedRef, (node2) => setNode(node2));
    const layers = Array.from(context.layers);
    const [highestLayerWithOutsidePointerEventsDisabled] = [...context.layersWithOutsidePointerEventsDisabled].slice(-1);
    const highestLayerWithOutsidePointerEventsDisabledIndex = layers.indexOf(highestLayerWithOutsidePointerEventsDisabled);
    const index2 = node ? layers.indexOf(node) : -1;
    const isBodyPointerEventsDisabled = context.layersWithOutsidePointerEventsDisabled.size > 0;
    const isPointerEventsEnabled = index2 >= highestLayerWithOutsidePointerEventsDisabledIndex;
    const pointerDownOutside = usePointerDownOutside((event) => {
      const target = event.target;
      const isPointerDownOnBranch = [...context.branches].some((branch) => branch.contains(target));
      if (!isPointerEventsEnabled || isPointerDownOnBranch) return;
      onPointerDownOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    const focusOutside = useFocusOutside((event) => {
      const target = event.target;
      const isFocusInBranch = [...context.branches].some((branch) => branch.contains(target));
      if (isFocusInBranch) return;
      onFocusOutside?.(event);
      onInteractOutside?.(event);
      if (!event.defaultPrevented) onDismiss?.();
    }, ownerDocument);
    useEscapeKeydown((event) => {
      const isHighestLayer = index2 === context.layers.size - 1;
      if (!isHighestLayer) return;
      onEscapeKeyDown?.(event);
      if (!event.defaultPrevented && onDismiss) {
        event.preventDefault();
        onDismiss();
      }
    }, ownerDocument);
    reactExports.useEffect(() => {
      if (!node) return;
      if (disableOutsidePointerEvents) {
        if (context.layersWithOutsidePointerEventsDisabled.size === 0) {
          originalBodyPointerEvents = ownerDocument.body.style.pointerEvents;
          ownerDocument.body.style.pointerEvents = "none";
        }
        context.layersWithOutsidePointerEventsDisabled.add(node);
      }
      context.layers.add(node);
      dispatchUpdate();
      return () => {
        if (disableOutsidePointerEvents && context.layersWithOutsidePointerEventsDisabled.size === 1) {
          ownerDocument.body.style.pointerEvents = originalBodyPointerEvents;
        }
      };
    }, [node, ownerDocument, disableOutsidePointerEvents, context]);
    reactExports.useEffect(() => {
      return () => {
        if (!node) return;
        context.layers.delete(node);
        context.layersWithOutsidePointerEventsDisabled.delete(node);
        dispatchUpdate();
      };
    }, [node, context]);
    reactExports.useEffect(() => {
      const handleUpdate = () => force({});
      document.addEventListener(CONTEXT_UPDATE, handleUpdate);
      return () => document.removeEventListener(CONTEXT_UPDATE, handleUpdate);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        ...layerProps,
        ref: composedRefs,
        style: {
          pointerEvents: isBodyPointerEventsDisabled ? isPointerEventsEnabled ? "auto" : "none" : void 0,
          ...props.style
        },
        onFocusCapture: composeEventHandlers(props.onFocusCapture, focusOutside.onFocusCapture),
        onBlurCapture: composeEventHandlers(props.onBlurCapture, focusOutside.onBlurCapture),
        onPointerDownCapture: composeEventHandlers(
          props.onPointerDownCapture,
          pointerDownOutside.onPointerDownCapture
        )
      }
    );
  }
);
DismissableLayer.displayName = DISMISSABLE_LAYER_NAME;
var BRANCH_NAME = "DismissableLayerBranch";
var DismissableLayerBranch = reactExports.forwardRef((props, forwardedRef) => {
  const context = reactExports.useContext(DismissableLayerContext);
  const ref = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, ref);
  reactExports.useEffect(() => {
    const node = ref.current;
    if (node) {
      context.branches.add(node);
      return () => {
        context.branches.delete(node);
      };
    }
  }, [context.branches]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...props, ref: composedRefs });
});
DismissableLayerBranch.displayName = BRANCH_NAME;
function usePointerDownOutside(onPointerDownOutside, ownerDocument = globalThis?.document) {
  const handlePointerDownOutside = useCallbackRef$1(onPointerDownOutside);
  const isPointerInsideReactTreeRef = reactExports.useRef(false);
  const handleClickRef = reactExports.useRef(() => {
  });
  reactExports.useEffect(() => {
    const handlePointerDown = (event) => {
      if (event.target && !isPointerInsideReactTreeRef.current) {
        let handleAndDispatchPointerDownOutsideEvent2 = function() {
          handleAndDispatchCustomEvent(
            POINTER_DOWN_OUTSIDE,
            handlePointerDownOutside,
            eventDetail,
            { discrete: true }
          );
        };
        const eventDetail = { originalEvent: event };
        if (event.pointerType === "touch") {
          ownerDocument.removeEventListener("click", handleClickRef.current);
          handleClickRef.current = handleAndDispatchPointerDownOutsideEvent2;
          ownerDocument.addEventListener("click", handleClickRef.current, { once: true });
        } else {
          handleAndDispatchPointerDownOutsideEvent2();
        }
      } else {
        ownerDocument.removeEventListener("click", handleClickRef.current);
      }
      isPointerInsideReactTreeRef.current = false;
    };
    const timerId = window.setTimeout(() => {
      ownerDocument.addEventListener("pointerdown", handlePointerDown);
    }, 0);
    return () => {
      window.clearTimeout(timerId);
      ownerDocument.removeEventListener("pointerdown", handlePointerDown);
      ownerDocument.removeEventListener("click", handleClickRef.current);
    };
  }, [ownerDocument, handlePointerDownOutside]);
  return {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => isPointerInsideReactTreeRef.current = true
  };
}
function useFocusOutside(onFocusOutside, ownerDocument = globalThis?.document) {
  const handleFocusOutside = useCallbackRef$1(onFocusOutside);
  const isFocusInsideReactTreeRef = reactExports.useRef(false);
  reactExports.useEffect(() => {
    const handleFocus = (event) => {
      if (event.target && !isFocusInsideReactTreeRef.current) {
        const eventDetail = { originalEvent: event };
        handleAndDispatchCustomEvent(FOCUS_OUTSIDE, handleFocusOutside, eventDetail, {
          discrete: false
        });
      }
    };
    ownerDocument.addEventListener("focusin", handleFocus);
    return () => ownerDocument.removeEventListener("focusin", handleFocus);
  }, [ownerDocument, handleFocusOutside]);
  return {
    onFocusCapture: () => isFocusInsideReactTreeRef.current = true,
    onBlurCapture: () => isFocusInsideReactTreeRef.current = false
  };
}
function dispatchUpdate() {
  const event = new CustomEvent(CONTEXT_UPDATE);
  document.dispatchEvent(event);
}
function handleAndDispatchCustomEvent(name, handler, detail, { discrete }) {
  const target = detail.originalEvent.target;
  const event = new CustomEvent(name, { bubbles: false, cancelable: true, detail });
  if (handler) target.addEventListener(name, handler, { once: true });
  if (discrete) {
    dispatchDiscreteCustomEvent(target, event);
  } else {
    target.dispatchEvent(event);
  }
}
var count$1 = 0;
function useFocusGuards() {
  reactExports.useEffect(() => {
    const edgeGuards = document.querySelectorAll("[data-radix-focus-guard]");
    document.body.insertAdjacentElement("afterbegin", edgeGuards[0] ?? createFocusGuard());
    document.body.insertAdjacentElement("beforeend", edgeGuards[1] ?? createFocusGuard());
    count$1++;
    return () => {
      if (count$1 === 1) {
        document.querySelectorAll("[data-radix-focus-guard]").forEach((node) => node.remove());
      }
      count$1--;
    };
  }, []);
}
function createFocusGuard() {
  const element = document.createElement("span");
  element.setAttribute("data-radix-focus-guard", "");
  element.tabIndex = 0;
  element.style.outline = "none";
  element.style.opacity = "0";
  element.style.position = "fixed";
  element.style.pointerEvents = "none";
  return element;
}
var AUTOFOCUS_ON_MOUNT = "focusScope.autoFocusOnMount";
var AUTOFOCUS_ON_UNMOUNT = "focusScope.autoFocusOnUnmount";
var EVENT_OPTIONS = { bubbles: false, cancelable: true };
var FOCUS_SCOPE_NAME = "FocusScope";
var FocusScope = reactExports.forwardRef((props, forwardedRef) => {
  const {
    loop = false,
    trapped = false,
    onMountAutoFocus: onMountAutoFocusProp,
    onUnmountAutoFocus: onUnmountAutoFocusProp,
    ...scopeProps
  } = props;
  const [container, setContainer] = reactExports.useState(null);
  const onMountAutoFocus = useCallbackRef$1(onMountAutoFocusProp);
  const onUnmountAutoFocus = useCallbackRef$1(onUnmountAutoFocusProp);
  const lastFocusedElementRef = reactExports.useRef(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContainer(node));
  const focusScope = reactExports.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  reactExports.useEffect(() => {
    if (trapped) {
      let handleFocusIn2 = function(event) {
        if (focusScope.paused || !container) return;
        const target = event.target;
        if (container.contains(target)) {
          lastFocusedElementRef.current = target;
        } else {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleFocusOut2 = function(event) {
        if (focusScope.paused || !container) return;
        const relatedTarget = event.relatedTarget;
        if (relatedTarget === null) return;
        if (!container.contains(relatedTarget)) {
          focus(lastFocusedElementRef.current, { select: true });
        }
      }, handleMutations2 = function(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) return;
        for (const mutation of mutations) {
          if (mutation.removedNodes.length > 0) focus(container);
        }
      };
      document.addEventListener("focusin", handleFocusIn2);
      document.addEventListener("focusout", handleFocusOut2);
      const mutationObserver = new MutationObserver(handleMutations2);
      if (container) mutationObserver.observe(container, { childList: true, subtree: true });
      return () => {
        document.removeEventListener("focusin", handleFocusIn2);
        document.removeEventListener("focusout", handleFocusOut2);
        mutationObserver.disconnect();
      };
    }
  }, [trapped, container, focusScope.paused]);
  reactExports.useEffect(() => {
    if (container) {
      focusScopesStack.add(focusScope);
      const previouslyFocusedElement = document.activeElement;
      const hasFocusedCandidate = container.contains(previouslyFocusedElement);
      if (!hasFocusedCandidate) {
        const mountEvent = new CustomEvent(AUTOFOCUS_ON_MOUNT, EVENT_OPTIONS);
        container.addEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        container.dispatchEvent(mountEvent);
        if (!mountEvent.defaultPrevented) {
          focusFirst(removeLinks(getTabbableCandidates(container)), { select: true });
          if (document.activeElement === previouslyFocusedElement) {
            focus(container);
          }
        }
      }
      return () => {
        container.removeEventListener(AUTOFOCUS_ON_MOUNT, onMountAutoFocus);
        setTimeout(() => {
          const unmountEvent = new CustomEvent(AUTOFOCUS_ON_UNMOUNT, EVENT_OPTIONS);
          container.addEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          container.dispatchEvent(unmountEvent);
          if (!unmountEvent.defaultPrevented) {
            focus(previouslyFocusedElement ?? document.body, { select: true });
          }
          container.removeEventListener(AUTOFOCUS_ON_UNMOUNT, onUnmountAutoFocus);
          focusScopesStack.remove(focusScope);
        }, 0);
      };
    }
  }, [container, onMountAutoFocus, onUnmountAutoFocus, focusScope]);
  const handleKeyDown = reactExports.useCallback(
    (event) => {
      if (!loop && !trapped) return;
      if (focusScope.paused) return;
      const isTabKey = event.key === "Tab" && !event.altKey && !event.ctrlKey && !event.metaKey;
      const focusedElement = document.activeElement;
      if (isTabKey && focusedElement) {
        const container2 = event.currentTarget;
        const [first, last2] = getTabbableEdges(container2);
        const hasTabbableElementsInside = first && last2;
        if (!hasTabbableElementsInside) {
          if (focusedElement === container2) event.preventDefault();
        } else {
          if (!event.shiftKey && focusedElement === last2) {
            event.preventDefault();
            if (loop) focus(first, { select: true });
          } else if (event.shiftKey && focusedElement === first) {
            event.preventDefault();
            if (loop) focus(last2, { select: true });
          }
        }
      }
    },
    [loop, trapped, focusScope.paused]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { tabIndex: -1, ...scopeProps, ref: composedRefs, onKeyDown: handleKeyDown });
});
FocusScope.displayName = FOCUS_SCOPE_NAME;
function focusFirst(candidates, { select = false } = {}) {
  const previouslyFocusedElement = document.activeElement;
  for (const candidate of candidates) {
    focus(candidate, { select });
    if (document.activeElement !== previouslyFocusedElement) return;
  }
}
function getTabbableEdges(container) {
  const candidates = getTabbableCandidates(container);
  const first = findVisible(candidates, container);
  const last2 = findVisible(candidates.reverse(), container);
  return [first, last2];
}
function getTabbableCandidates(container) {
  const nodes = [];
  const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (node) => {
      const isHiddenInput = node.tagName === "INPUT" && node.type === "hidden";
      if (node.disabled || node.hidden || isHiddenInput) return NodeFilter.FILTER_SKIP;
      return node.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  while (walker.nextNode()) nodes.push(walker.currentNode);
  return nodes;
}
function findVisible(elements, container) {
  for (const element of elements) {
    if (!isHidden(element, { upTo: container })) return element;
  }
}
function isHidden(node, { upTo }) {
  if (getComputedStyle(node).visibility === "hidden") return true;
  while (node) {
    if (upTo !== void 0 && node === upTo) return false;
    if (getComputedStyle(node).display === "none") return true;
    node = node.parentElement;
  }
  return false;
}
function isSelectableInput(element) {
  return element instanceof HTMLInputElement && "select" in element;
}
function focus(element, { select = false } = {}) {
  if (element && element.focus) {
    const previouslyFocusedElement = document.activeElement;
    element.focus({ preventScroll: true });
    if (element !== previouslyFocusedElement && isSelectableInput(element) && select)
      element.select();
  }
}
var focusScopesStack = createFocusScopesStack();
function createFocusScopesStack() {
  let stack = [];
  return {
    add(focusScope) {
      const activeFocusScope = stack[0];
      if (focusScope !== activeFocusScope) {
        activeFocusScope?.pause();
      }
      stack = arrayRemove(stack, focusScope);
      stack.unshift(focusScope);
    },
    remove(focusScope) {
      stack = arrayRemove(stack, focusScope);
      stack[0]?.resume();
    }
  };
}
function arrayRemove(array, item) {
  const updatedArray = [...array];
  const index2 = updatedArray.indexOf(item);
  if (index2 !== -1) {
    updatedArray.splice(index2, 1);
  }
  return updatedArray;
}
function removeLinks(items) {
  return items.filter((item) => item.tagName !== "A");
}
var useLayoutEffect2 = Boolean(globalThis?.document) ? reactExports.useLayoutEffect : () => {
};
var useReactId = React$1["useId".toString()] || (() => void 0);
var count = 0;
function useId(deterministicId) {
  const [id2, setId] = reactExports.useState(useReactId());
  useLayoutEffect2(() => {
    setId((reactId) => reactId ?? String(count++));
  }, [deterministicId]);
  return id2 ? `radix-${id2}` : "";
}
const sides = ["top", "right", "bottom", "left"];
const min = Math.min;
const max = Math.max;
const round = Math.round;
const floor = Math.floor;
const createCoords = (v2) => ({
  x: v2,
  y: v2
});
const oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
const oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl2 = ["right", "left"];
  const tb2 = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl2 : lr;
      return isStart ? lr : rl2;
    case "left":
    case "right":
      return isStart ? tb2 : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  const {
    x: x2,
    y: y2,
    width,
    height
  } = rect;
  return {
    width,
    height,
    top: y2,
    left: x2,
    right: x2 + width,
    bottom: y2 + height,
    x: x2,
    y: y2
  };
}
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
const computePosition$1 = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x: x2,
    y: y2
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i2 = 0; i2 < validMiddleware.length; i2++) {
    const {
      name,
      fn
    } = validMiddleware[i2];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x: x2,
      y: y2,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x2 = nextX != null ? nextX : x2;
    y2 = nextY != null ? nextY : y2;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x: x2,
          y: y2
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i2 = -1;
    }
  }
  return {
    x: x2,
    y: y2,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x: x2,
    y: y2,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    x: x2,
    y: y2,
    width: rects.floating.width,
    height: rects.floating.height
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
const arrow$3 = (options) => ({
  name: "arrow",
  options,
  async fn(state) {
    const {
      x: x2,
      y: y2,
      placement,
      rects,
      platform: platform2,
      elements,
      middlewareData
    } = state;
    const {
      element,
      padding = 0
    } = evaluate(options, state) || {};
    if (element == null) {
      return {};
    }
    const paddingObject = getPaddingObject(padding);
    const coords = {
      x: x2,
      y: y2
    };
    const axis = getAlignmentAxis(placement);
    const length = getAxisLength(axis);
    const arrowDimensions = await platform2.getDimensions(element);
    const isYAxis = axis === "y";
    const minProp = isYAxis ? "top" : "left";
    const maxProp = isYAxis ? "bottom" : "right";
    const clientProp = isYAxis ? "clientHeight" : "clientWidth";
    const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
    const startDiff = coords[axis] - rects.reference[axis];
    const arrowOffsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(element));
    let clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
    if (!clientSize || !await (platform2.isElement == null ? void 0 : platform2.isElement(arrowOffsetParent))) {
      clientSize = elements.floating[clientProp] || rects.floating[length];
    }
    const centerToReference = endDiff / 2 - startDiff / 2;
    const largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
    const minPadding = min(paddingObject[minProp], largestPossiblePadding);
    const maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
    const min$1 = minPadding;
    const max2 = clientSize - arrowDimensions[length] - maxPadding;
    const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
    const offset2 = clamp(min$1, center, max2);
    const shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset2 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
    const alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
    return {
      [axis]: coords[axis] + alignmentOffset,
      data: {
        [axis]: offset2,
        centerOffset: center - offset2 - alignmentOffset,
        ...shouldAddOffset && {
          alignmentOffset
        }
      },
      reset: shouldAddOffset
    };
  }
});
const flip$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const initialSideAxis = getSideAxis(initialPlacement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      const hasFallbackAxisSideDirection = fallbackAxisSideDirection !== "none";
      if (!specifiedFallbackPlacements && hasFallbackAxisSideDirection) {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d2) => d2.overflows[0] <= 0).sort((a2, b2) => a2.overflows[1] - b2.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$filter2;
              const placement2 = (_overflowsData$filter2 = overflowsData.filter((d2) => {
                if (hasFallbackAxisSideDirection) {
                  const currentSideAxis = getSideAxis(d2.placement);
                  return currentSideAxis === initialSideAxis || // Create a bias to the `y` side axis due to horizontal
                  // reading directions favoring greater width.
                  currentSideAxis === "y";
                }
                return true;
              }).map((d2) => [d2.placement, d2.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a2, b2) => a2[1] - b2[1])[0]) == null ? void 0 : _overflowsData$filter2[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some((side) => overflow[side] >= 0);
}
const hide$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    async fn(state) {
      const {
        rects
      } = state;
      const {
        strategy = "referenceHidden",
        ...detectOverflowOptions
      } = evaluate(options, state);
      switch (strategy) {
        case "referenceHidden": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            elementContext: "reference"
          });
          const offsets = getSideOffsets(overflow, rects.reference);
          return {
            data: {
              referenceHiddenOffsets: offsets,
              referenceHidden: isAnySideFullyClipped(offsets)
            }
          };
        }
        case "escaped": {
          const overflow = await detectOverflow(state, {
            ...detectOverflowOptions,
            altBoundary: true
          });
          const offsets = getSideOffsets(overflow, rects.floating);
          return {
            data: {
              escapedOffsets: offsets,
              escaped: isAnySideFullyClipped(offsets)
            }
          };
        }
        default: {
          return {};
        }
      }
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: rawValue.mainAxis || 0,
    crossAxis: rawValue.crossAxis || 0,
    alignmentAxis: rawValue.alignmentAxis
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
const offset$2 = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x: x2,
        y: y2,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x2 + diffCoords.x,
        y: y2 + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
const shift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x: x2,
        y: y2,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x3,
              y: y3
            } = _ref;
            return {
              x: x3,
              y: y3
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x2,
          y: limitedCoords.y - y2,
          enabled: {
            [mainAxis]: checkMainAxis,
            [crossAxis]: checkCrossAxis
          }
        }
      };
    }
  };
};
const limitShift$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    options,
    fn(state) {
      const {
        x: x2,
        y: y2,
        placement,
        rects,
        middlewareData
      } = state;
      const {
        offset: offset2 = 0,
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true
      } = evaluate(options, state);
      const coords = {
        x: x2,
        y: y2
      };
      const crossAxis = getSideAxis(placement);
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      const rawOffset = evaluate(offset2, state);
      const computedOffset = typeof rawOffset === "number" ? {
        mainAxis: rawOffset,
        crossAxis: 0
      } : {
        mainAxis: 0,
        crossAxis: 0,
        ...rawOffset
      };
      if (checkMainAxis) {
        const len = mainAxis === "y" ? "height" : "width";
        const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
        const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
        if (mainAxisCoord < limitMin) {
          mainAxisCoord = limitMin;
        } else if (mainAxisCoord > limitMax) {
          mainAxisCoord = limitMax;
        }
      }
      if (checkCrossAxis) {
        var _middlewareData$offse, _middlewareData$offse2;
        const len = mainAxis === "y" ? "width" : "height";
        const isOriginSide = ["top", "left"].includes(getSide(placement));
        const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse[crossAxis]) || 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
        const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : ((_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) || 0) - (isOriginSide ? computedOffset.crossAxis : 0);
        if (crossAxisCoord < limitMin) {
          crossAxisCoord = limitMin;
        } else if (crossAxisCoord > limitMax) {
          crossAxisCoord = limitMax;
        }
      }
      return {
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      };
    }
  };
};
const size$2 = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    async fn(state) {
      var _state$middlewareData, _state$middlewareData2;
      const {
        placement,
        rects,
        platform: platform2,
        elements
      } = state;
      const {
        apply = () => {
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const side = getSide(placement);
      const alignment = getAlignment(placement);
      const isYAxis = getSideAxis(placement) === "y";
      const {
        width,
        height
      } = rects.floating;
      let heightSide;
      let widthSide;
      if (side === "top" || side === "bottom") {
        heightSide = side;
        widthSide = alignment === (await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
      } else {
        widthSide = side;
        heightSide = alignment === "end" ? "top" : "bottom";
      }
      const maximumClippingHeight = height - overflow.top - overflow.bottom;
      const maximumClippingWidth = width - overflow.left - overflow.right;
      const overflowAvailableHeight = min(height - overflow[heightSide], maximumClippingHeight);
      const overflowAvailableWidth = min(width - overflow[widthSide], maximumClippingWidth);
      const noShift = !state.middlewareData.shift;
      let availableHeight = overflowAvailableHeight;
      let availableWidth = overflowAvailableWidth;
      if ((_state$middlewareData = state.middlewareData.shift) != null && _state$middlewareData.enabled.x) {
        availableWidth = maximumClippingWidth;
      }
      if ((_state$middlewareData2 = state.middlewareData.shift) != null && _state$middlewareData2.enabled.y) {
        availableHeight = maximumClippingHeight;
      }
      if (noShift && !alignment) {
        const xMin = max(overflow.left, 0);
        const xMax = max(overflow.right, 0);
        const yMin = max(overflow.top, 0);
        const yMax = max(overflow.bottom, 0);
        if (isYAxis) {
          availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
        } else {
          availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
        }
      }
      await apply({
        ...state,
        availableWidth,
        availableHeight
      });
      const nextDimensions = await platform2.getDimensions(elements.floating);
      if (width !== nextDimensions.width || height !== nextDimensions.height) {
        return {
          reset: {
            rects: true
          }
        };
      }
      return {};
    }
  };
};
function hasWindow() {
  return typeof window !== "undefined";
}
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement$1(value) {
  if (!hasWindow()) {
    return false;
  }
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (!hasWindow() || typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle$1(element);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element) {
  return ["table", "td", "th"].includes(getNodeName(element));
}
function isTopLayer(element) {
  return [":popover-open", ":modal"].some((selector) => {
    try {
      return element.matches(selector);
    } catch (e2) {
      return false;
    }
  });
}
function isContainingBlock(elementOrCss) {
  const webkit = isWebKit();
  const css = isElement(elementOrCss) ? getComputedStyle$1(elementOrCss) : elementOrCss;
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element) {
  let currentNode = getParentNode(element);
  while (isHTMLElement$1(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else if (isTopLayer(currentNode)) {
      return null;
    }
    currentNode = getParentNode(currentNode);
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle$1(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.scrollX,
    scrollTop: element.scrollY
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement$1(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    const frameElement = getFrameElement(win);
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], frameElement && traverseIframes ? getOverflowAncestors(frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}
function getFrameElement(win) {
  return win.parent && Object.getPrototypeOf(win.parent) ? win.frameElement : null;
}
function getCssDimensions(element) {
  const css = getComputedStyle$1(element);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement$1(element);
  const offsetWidth = hasOffset ? element.offsetWidth : width;
  const offsetHeight = hasOffset ? element.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  const domElement = unwrapElement(element);
  if (!isHTMLElement$1(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x2 = ($ ? round(rect.width) : rect.width) / width;
  let y2 = ($ ? round(rect.height) : rect.height) / height;
  if (!x2 || !Number.isFinite(x2)) {
    x2 = 1;
  }
  if (!y2 || !Number.isFinite(y2)) {
    y2 = 1;
  }
  return {
    x: x2,
    y: y2
  };
}
const noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element) {
  const win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element.getBoundingClientRect();
  const domElement = unwrapElement(element);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x2 = (clientRect.left + visualOffsets.x) / scale.x;
  let y2 = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = getFrameElement(currentWin);
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle$1(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x2 *= iframeScale.x;
      y2 *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x2 += left;
      y2 += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = getFrameElement(currentWin);
    }
  }
  return rectToClientRect({
    width,
    height,
    x: x2,
    y: y2
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement$1(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element, rect) {
  const leftScroll = getNodeScroll(element).scrollLeft;
  if (!rect) {
    return getBoundingClientRect(getDocumentElement(element)).left + leftScroll;
  }
  return rect.left + leftScroll;
}
function getDocumentRect(element) {
  const html = getDocumentElement(element);
  const scroll = getNodeScroll(element);
  const body = element.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x2 = -scroll.scrollLeft + getWindowScrollBarX(element);
  const y2 = -scroll.scrollTop;
  if (getComputedStyle$1(body).direction === "rtl") {
    x2 += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getViewportRect(element, strategy) {
  const win = getWindow(element);
  const html = getDocumentElement(element);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x2 = 0;
  let y2 = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x2 = visualViewport.offsetLeft;
      y2 = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getInnerBoundingClientRect(element, strategy) {
  const clientRect = getBoundingClientRect(element, true, strategy === "fixed");
  const top = clientRect.top + element.clientTop;
  const left = clientRect.left + element.clientLeft;
  const scale = isHTMLElement$1(element) ? getScale(element) : createCoords(1);
  const width = element.clientWidth * scale.x;
  const height = element.clientHeight * scale.y;
  const x2 = left * scale.x;
  const y2 = top * scale.y;
  return {
    width,
    height,
    x: x2,
    y: y2
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  const parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle$1(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  const cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element, [], false).filter((el2) => isElement(el2) && getNodeName(el2) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle$1(element).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle$1(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element) ? [] : getClippingElementAncestors(element, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  const {
    width,
    height
  } = getCssDimensions(element);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement$1(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  let htmlX = 0;
  let htmlY = 0;
  if (documentElement && !isOffsetParentAnElement && !isFixed) {
    const htmlRect = documentElement.getBoundingClientRect();
    htmlY = htmlRect.top + scroll.scrollTop;
    htmlX = htmlRect.left + scroll.scrollLeft - // RTL <body> scrollbar.
    getWindowScrollBarX(documentElement, htmlRect);
  }
  const x2 = rect.left + scroll.scrollLeft - offsets.x - htmlX;
  const y2 = rect.top + scroll.scrollTop - offsets.y - htmlY;
  return {
    x: x2,
    y: y2,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element) {
  return getComputedStyle$1(element).position === "static";
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement$1(element) || getComputedStyle$1(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  let rawOffsetParent = element.offsetParent;
  if (getDocumentElement(element) === rawOffsetParent) {
    rawOffsetParent = rawOffsetParent.ownerDocument.body;
  }
  return rawOffsetParent;
}
function getOffsetParent(element, polyfill) {
  const win = getWindow(element);
  if (isTopLayer(element)) {
    return win;
  }
  if (!isHTMLElement$1(element)) {
    let svgOffsetParent = getParentNode(element);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element) || win;
}
const getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element) {
  return getComputedStyle$1(element).direction === "rtl";
}
const platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e2) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
const offset$1 = offset$2;
const shift$1 = shift$2;
const flip$1 = flip$2;
const size$1 = size$2;
const hide$1 = hide$2;
const arrow$2 = arrow$3;
const limitShift$1 = limitShift$2;
const computePosition = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition$1(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};
var index = typeof document !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
function deepEqual$1(a2, b2) {
  if (a2 === b2) {
    return true;
  }
  if (typeof a2 !== typeof b2) {
    return false;
  }
  if (typeof a2 === "function" && a2.toString() === b2.toString()) {
    return true;
  }
  let length;
  let i2;
  let keys;
  if (a2 && b2 && typeof a2 === "object") {
    if (Array.isArray(a2)) {
      length = a2.length;
      if (length !== b2.length) return false;
      for (i2 = length; i2-- !== 0; ) {
        if (!deepEqual$1(a2[i2], b2[i2])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a2);
    length = keys.length;
    if (length !== Object.keys(b2).length) {
      return false;
    }
    for (i2 = length; i2-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b2, keys[i2])) {
        return false;
      }
    }
    for (i2 = length; i2-- !== 0; ) {
      const key = keys[i2];
      if (key === "_owner" && a2.$$typeof) {
        continue;
      }
      if (!deepEqual$1(a2[key], b2[key])) {
        return false;
      }
    }
    return true;
  }
  return a2 !== a2 && b2 !== b2;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  const win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  const dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  const ref = reactExports.useRef(value);
  index(() => {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2,
    elements: {
      reference: externalReference,
      floating: externalFloating
    } = {},
    transform = true,
    whileElementsMounted,
    open
  } = options;
  const [data, setData] = reactExports.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  });
  const [latestMiddleware, setLatestMiddleware] = reactExports.useState(middleware);
  if (!deepEqual$1(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  const [_reference, _setReference] = reactExports.useState(null);
  const [_floating, _setFloating] = reactExports.useState(null);
  const setReference = reactExports.useCallback((node) => {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  const setFloating = reactExports.useCallback((node) => {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  const referenceEl = externalReference || _reference;
  const floatingEl = externalFloating || _floating;
  const referenceRef = reactExports.useRef(null);
  const floatingRef = reactExports.useRef(null);
  const dataRef = reactExports.useRef(data);
  const hasWhileElementsMounted = whileElementsMounted != null;
  const whileElementsMountedRef = useLatestRef(whileElementsMounted);
  const platformRef = useLatestRef(platform2);
  const openRef = useLatestRef(open);
  const update = reactExports.useCallback(() => {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    const config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition(referenceRef.current, floatingRef.current, config).then((data2) => {
      const fullData = {
        ...data2,
        // The floating element's position may be recomputed while it's closed
        // but still mounted (such as when transitioning out). To ensure
        // `isPositioned` will be `false` initially on the next open, avoid
        // setting it to `true` when `open === false` (must be specified).
        isPositioned: openRef.current !== false
      };
      if (isMountedRef.current && !deepEqual$1(dataRef.current, fullData)) {
        dataRef.current = fullData;
        reactDomExports.flushSync(() => {
          setData(fullData);
        });
      }
    });
  }, [latestMiddleware, placement, strategy, platformRef, openRef]);
  index(() => {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData((data2) => ({
        ...data2,
        isPositioned: false
      }));
    }
  }, [open]);
  const isMountedRef = reactExports.useRef(false);
  index(() => {
    isMountedRef.current = true;
    return () => {
      isMountedRef.current = false;
    };
  }, []);
  index(() => {
    if (referenceEl) referenceRef.current = referenceEl;
    if (floatingEl) floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [referenceEl, floatingEl, update, whileElementsMountedRef, hasWhileElementsMounted]);
  const refs = reactExports.useMemo(() => ({
    reference: referenceRef,
    floating: floatingRef,
    setReference,
    setFloating
  }), [setReference, setFloating]);
  const elements = reactExports.useMemo(() => ({
    reference: referenceEl,
    floating: floatingEl
  }), [referenceEl, floatingEl]);
  const floatingStyles = reactExports.useMemo(() => {
    const initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    const x2 = roundByDPR(elements.floating, data.x);
    const y2 = roundByDPR(elements.floating, data.y);
    if (transform) {
      return {
        ...initialStyles,
        transform: "translate(" + x2 + "px, " + y2 + "px)",
        ...getDPR(elements.floating) >= 1.5 && {
          willChange: "transform"
        }
      };
    }
    return {
      position: strategy,
      left: x2,
      top: y2
    };
  }, [strategy, transform, elements.floating, data.x, data.y]);
  return reactExports.useMemo(() => ({
    ...data,
    update,
    refs,
    elements,
    floatingStyles
  }), [data, update, refs, elements, floatingStyles]);
}
const arrow$1 = (options) => {
  function isRef2(value) {
    return {}.hasOwnProperty.call(value, "current");
  }
  return {
    name: "arrow",
    options,
    fn(state) {
      const {
        element,
        padding
      } = typeof options === "function" ? options(state) : options;
      if (element && isRef2(element)) {
        if (element.current != null) {
          return arrow$2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow$2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
const offset = (options, deps) => ({
  ...offset$1(options),
  options: [options, deps]
});
const shift = (options, deps) => ({
  ...shift$1(options),
  options: [options, deps]
});
const limitShift = (options, deps) => ({
  ...limitShift$1(options),
  options: [options, deps]
});
const flip = (options, deps) => ({
  ...flip$1(options),
  options: [options, deps]
});
const size = (options, deps) => ({
  ...size$1(options),
  options: [options, deps]
});
const hide = (options, deps) => ({
  ...hide$1(options),
  options: [options, deps]
});
const arrow = (options, deps) => ({
  ...arrow$1(options),
  options: [options, deps]
});
var NAME$2 = "Arrow";
var Arrow$1 = reactExports.forwardRef((props, forwardedRef) => {
  const { children, width = 10, height = 5, ...arrowProps } = props;
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.svg,
    {
      ...arrowProps,
      ref: forwardedRef,
      width,
      height,
      viewBox: "0 0 30 10",
      preserveAspectRatio: "none",
      children: props.asChild ? children : /* @__PURE__ */ jsxRuntimeExports.jsx("polygon", { points: "0,0 30,0 15,10" })
    }
  );
});
Arrow$1.displayName = NAME$2;
var Root$5 = Arrow$1;
function useSize(element) {
  const [size2, setSize] = reactExports.useState(void 0);
  useLayoutEffect2(() => {
    if (element) {
      setSize({ width: element.offsetWidth, height: element.offsetHeight });
      const resizeObserver = new ResizeObserver((entries) => {
        if (!Array.isArray(entries)) {
          return;
        }
        if (!entries.length) {
          return;
        }
        const entry = entries[0];
        let width;
        let height;
        if ("borderBoxSize" in entry) {
          const borderSizeEntry = entry["borderBoxSize"];
          const borderSize = Array.isArray(borderSizeEntry) ? borderSizeEntry[0] : borderSizeEntry;
          width = borderSize["inlineSize"];
          height = borderSize["blockSize"];
        } else {
          width = element.offsetWidth;
          height = element.offsetHeight;
        }
        setSize({ width, height });
      });
      resizeObserver.observe(element, { box: "border-box" });
      return () => resizeObserver.unobserve(element);
    } else {
      setSize(void 0);
    }
  }, [element]);
  return size2;
}
var POPPER_NAME = "Popper";
var [createPopperContext, createPopperScope] = createContextScope$1(POPPER_NAME);
var [PopperProvider, usePopperContext] = createPopperContext(POPPER_NAME);
var Popper = (props) => {
  const { __scopePopper, children } = props;
  const [anchor, setAnchor] = reactExports.useState(null);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PopperProvider, { scope: __scopePopper, anchor, onAnchorChange: setAnchor, children });
};
Popper.displayName = POPPER_NAME;
var ANCHOR_NAME = "PopperAnchor";
var PopperAnchor = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopePopper, virtualRef, ...anchorProps } = props;
    const context = usePopperContext(ANCHOR_NAME, __scopePopper);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    reactExports.useEffect(() => {
      context.onAnchorChange(virtualRef?.current || ref.current);
    });
    return virtualRef ? null : /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...anchorProps, ref: composedRefs });
  }
);
PopperAnchor.displayName = ANCHOR_NAME;
var CONTENT_NAME$2 = "PopperContent";
var [PopperContentProvider, useContentContext] = createPopperContext(CONTENT_NAME$2);
var PopperContent = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopePopper,
      side = "bottom",
      sideOffset = 0,
      align = "center",
      alignOffset = 0,
      arrowPadding = 0,
      avoidCollisions = true,
      collisionBoundary = [],
      collisionPadding: collisionPaddingProp = 0,
      sticky = "partial",
      hideWhenDetached = false,
      updatePositionStrategy = "optimized",
      onPlaced,
      ...contentProps
    } = props;
    const context = usePopperContext(CONTENT_NAME$2, __scopePopper);
    const [content, setContent] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [arrow$12, setArrow] = reactExports.useState(null);
    const arrowSize = useSize(arrow$12);
    const arrowWidth = arrowSize?.width ?? 0;
    const arrowHeight = arrowSize?.height ?? 0;
    const desiredPlacement = side + (align !== "center" ? "-" + align : "");
    const collisionPadding = typeof collisionPaddingProp === "number" ? collisionPaddingProp : { top: 0, right: 0, bottom: 0, left: 0, ...collisionPaddingProp };
    const boundary = Array.isArray(collisionBoundary) ? collisionBoundary : [collisionBoundary];
    const hasExplicitBoundaries = boundary.length > 0;
    const detectOverflowOptions = {
      padding: collisionPadding,
      boundary: boundary.filter(isNotNull),
      // with `strategy: 'fixed'`, this is the only way to get it to respect boundaries
      altBoundary: hasExplicitBoundaries
    };
    const { refs, floatingStyles, placement, isPositioned, middlewareData } = useFloating({
      // default to `fixed` strategy so users don't have to pick and we also avoid focus scroll issues
      strategy: "fixed",
      placement: desiredPlacement,
      whileElementsMounted: (...args) => {
        const cleanup = autoUpdate(...args, {
          animationFrame: updatePositionStrategy === "always"
        });
        return cleanup;
      },
      elements: {
        reference: context.anchor
      },
      middleware: [
        offset({ mainAxis: sideOffset + arrowHeight, alignmentAxis: alignOffset }),
        avoidCollisions && shift({
          mainAxis: true,
          crossAxis: false,
          limiter: sticky === "partial" ? limitShift() : void 0,
          ...detectOverflowOptions
        }),
        avoidCollisions && flip({ ...detectOverflowOptions }),
        size({
          ...detectOverflowOptions,
          apply: ({ elements, rects, availableWidth, availableHeight }) => {
            const { width: anchorWidth, height: anchorHeight } = rects.reference;
            const contentStyle = elements.floating.style;
            contentStyle.setProperty("--radix-popper-available-width", `${availableWidth}px`);
            contentStyle.setProperty("--radix-popper-available-height", `${availableHeight}px`);
            contentStyle.setProperty("--radix-popper-anchor-width", `${anchorWidth}px`);
            contentStyle.setProperty("--radix-popper-anchor-height", `${anchorHeight}px`);
          }
        }),
        arrow$12 && arrow({ element: arrow$12, padding: arrowPadding }),
        transformOrigin({ arrowWidth, arrowHeight }),
        hideWhenDetached && hide({ strategy: "referenceHidden", ...detectOverflowOptions })
      ]
    });
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const handlePlaced = useCallbackRef$1(onPlaced);
    useLayoutEffect2(() => {
      if (isPositioned) {
        handlePlaced?.();
      }
    }, [isPositioned, handlePlaced]);
    const arrowX = middlewareData.arrow?.x;
    const arrowY = middlewareData.arrow?.y;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const [contentZIndex, setContentZIndex] = reactExports.useState();
    useLayoutEffect2(() => {
      if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
    }, [content]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "div",
      {
        ref: refs.setFloating,
        "data-radix-popper-content-wrapper": "",
        style: {
          ...floatingStyles,
          transform: isPositioned ? floatingStyles.transform : "translate(0, -200%)",
          // keep off the page when measuring
          minWidth: "max-content",
          zIndex: contentZIndex,
          ["--radix-popper-transform-origin"]: [
            middlewareData.transformOrigin?.x,
            middlewareData.transformOrigin?.y
          ].join(" "),
          // hide the content if using the hide middleware and should be hidden
          // set visibility to hidden and disable pointer events so the UI behaves
          // as if the PopperContent isn't there at all
          ...middlewareData.hide?.referenceHidden && {
            visibility: "hidden",
            pointerEvents: "none"
          }
        },
        dir: props.dir,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          PopperContentProvider,
          {
            scope: __scopePopper,
            placedSide,
            onArrowChange: setArrow,
            arrowX,
            arrowY,
            shouldHideArrow: cannotCenterArrow,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                "data-side": placedSide,
                "data-align": placedAlign,
                ...contentProps,
                ref: composedRefs,
                style: {
                  ...contentProps.style,
                  // if the PopperContent hasn't been placed yet (not all measurements done)
                  // we prevent animations so that users's animation don't kick in too early referring wrong sides
                  animation: !isPositioned ? "none" : void 0
                }
              }
            )
          }
        )
      }
    );
  }
);
PopperContent.displayName = CONTENT_NAME$2;
var ARROW_NAME$1 = "PopperArrow";
var OPPOSITE_SIDE = {
  top: "bottom",
  right: "left",
  bottom: "top",
  left: "right"
};
var PopperArrow = reactExports.forwardRef(function PopperArrow2(props, forwardedRef) {
  const { __scopePopper, ...arrowProps } = props;
  const contentContext = useContentContext(ARROW_NAME$1, __scopePopper);
  const baseSide = OPPOSITE_SIDE[contentContext.placedSide];
  return (
    // we have to use an extra wrapper because `ResizeObserver` (used by `useSize`)
    // doesn't report size as we'd expect on SVG elements.
    // it reports their bounding box which is effectively the largest path inside the SVG.
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "span",
      {
        ref: contentContext.onArrowChange,
        style: {
          position: "absolute",
          left: contentContext.arrowX,
          top: contentContext.arrowY,
          [baseSide]: 0,
          transformOrigin: {
            top: "",
            right: "0 0",
            bottom: "center 0",
            left: "100% 0"
          }[contentContext.placedSide],
          transform: {
            top: "translateY(100%)",
            right: "translateY(50%) rotate(90deg) translateX(-50%)",
            bottom: `rotate(180deg)`,
            left: "translateY(50%) rotate(-90deg) translateX(50%)"
          }[contentContext.placedSide],
          visibility: contentContext.shouldHideArrow ? "hidden" : void 0
        },
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Root$5,
          {
            ...arrowProps,
            ref: forwardedRef,
            style: {
              ...arrowProps.style,
              // ensures the element can be measured correctly (mostly for if SVG)
              display: "block"
            }
          }
        )
      }
    )
  );
});
PopperArrow.displayName = ARROW_NAME$1;
function isNotNull(value) {
  return value !== null;
}
var transformOrigin = (options) => ({
  name: "transformOrigin",
  options,
  fn(data) {
    const { placement, rects, middlewareData } = data;
    const cannotCenterArrow = middlewareData.arrow?.centerOffset !== 0;
    const isArrowHidden = cannotCenterArrow;
    const arrowWidth = isArrowHidden ? 0 : options.arrowWidth;
    const arrowHeight = isArrowHidden ? 0 : options.arrowHeight;
    const [placedSide, placedAlign] = getSideAndAlignFromPlacement(placement);
    const noArrowAlign = { start: "0%", center: "50%", end: "100%" }[placedAlign];
    const arrowXCenter = (middlewareData.arrow?.x ?? 0) + arrowWidth / 2;
    const arrowYCenter = (middlewareData.arrow?.y ?? 0) + arrowHeight / 2;
    let x2 = "";
    let y2 = "";
    if (placedSide === "bottom") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${-arrowHeight}px`;
    } else if (placedSide === "top") {
      x2 = isArrowHidden ? noArrowAlign : `${arrowXCenter}px`;
      y2 = `${rects.floating.height + arrowHeight}px`;
    } else if (placedSide === "right") {
      x2 = `${-arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    } else if (placedSide === "left") {
      x2 = `${rects.floating.width + arrowHeight}px`;
      y2 = isArrowHidden ? noArrowAlign : `${arrowYCenter}px`;
    }
    return { data: { x: x2, y: y2 } };
  }
});
function getSideAndAlignFromPlacement(placement) {
  const [side, align = "center"] = placement.split("-");
  return [side, align];
}
var Root2$1 = Popper;
var Anchor = PopperAnchor;
var Content$1 = PopperContent;
var Arrow = PopperArrow;
var PORTAL_NAME$2 = "Portal";
var Portal$2 = reactExports.forwardRef((props, forwardedRef) => {
  const { container: containerProp, ...portalProps } = props;
  const [mounted, setMounted] = reactExports.useState(false);
  useLayoutEffect2(() => setMounted(true), []);
  const container = containerProp || mounted && globalThis?.document?.body;
  return container ? ReactDOM.createPortal(/* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { ...portalProps, ref: forwardedRef }), container) : null;
});
Portal$2.displayName = PORTAL_NAME$2;
function useControllableState({
  prop,
  defaultProp,
  onChange = () => {
  }
}) {
  const [uncontrolledProp, setUncontrolledProp] = useUncontrolledState({ defaultProp, onChange });
  const isControlled = prop !== void 0;
  const value = isControlled ? prop : uncontrolledProp;
  const handleChange = useCallbackRef$1(onChange);
  const setValue = reactExports.useCallback(
    (nextValue) => {
      if (isControlled) {
        const setter = nextValue;
        const value2 = typeof nextValue === "function" ? setter(prop) : nextValue;
        if (value2 !== prop) handleChange(value2);
      } else {
        setUncontrolledProp(nextValue);
      }
    },
    [isControlled, prop, setUncontrolledProp, handleChange]
  );
  return [value, setValue];
}
function useUncontrolledState({
  defaultProp,
  onChange
}) {
  const uncontrolledState = reactExports.useState(defaultProp);
  const [value] = uncontrolledState;
  const prevValueRef = reactExports.useRef(value);
  const handleChange = useCallbackRef$1(onChange);
  reactExports.useEffect(() => {
    if (prevValueRef.current !== value) {
      handleChange(value);
      prevValueRef.current = value;
    }
  }, [value, prevValueRef, handleChange]);
  return uncontrolledState;
}
function usePrevious(value) {
  const ref = reactExports.useRef({ value, previous: value });
  return reactExports.useMemo(() => {
    if (ref.current.value !== value) {
      ref.current.previous = ref.current.value;
      ref.current.value = value;
    }
    return ref.current.previous;
  }, [value]);
}
var NAME$1 = "VisuallyHidden";
var VisuallyHidden = reactExports.forwardRef(
  (props, forwardedRef) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...props,
        ref: forwardedRef,
        style: {
          // See: https://github.com/twbs/bootstrap/blob/master/scss/mixins/_screen-reader.scss
          position: "absolute",
          border: 0,
          width: 1,
          height: 1,
          padding: 0,
          margin: -1,
          overflow: "hidden",
          clip: "rect(0, 0, 0, 0)",
          whiteSpace: "nowrap",
          wordWrap: "normal",
          ...props.style
        }
      }
    );
  }
);
VisuallyHidden.displayName = NAME$1;
var getDefaultParent = function(originalTarget) {
  if (typeof document === "undefined") {
    return null;
  }
  var sampleTarget = Array.isArray(originalTarget) ? originalTarget[0] : originalTarget;
  return sampleTarget.ownerDocument.body;
};
var counterMap = /* @__PURE__ */ new WeakMap();
var uncontrolledNodes = /* @__PURE__ */ new WeakMap();
var markerMap = {};
var lockCount = 0;
var unwrapHost = function(node) {
  return node && (node.host || unwrapHost(node.parentNode));
};
var correctTargets = function(parent, targets) {
  return targets.map(function(target) {
    if (parent.contains(target)) {
      return target;
    }
    var correctedTarget = unwrapHost(target);
    if (correctedTarget && parent.contains(correctedTarget)) {
      return correctedTarget;
    }
    console.error("aria-hidden", target, "in not contained inside", parent, ". Doing nothing");
    return null;
  }).filter(function(x2) {
    return Boolean(x2);
  });
};
var applyAttributeToOthers = function(originalTarget, parentNode, markerName, controlAttribute) {
  var targets = correctTargets(parentNode, Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  if (!markerMap[markerName]) {
    markerMap[markerName] = /* @__PURE__ */ new WeakMap();
  }
  var markerCounter = markerMap[markerName];
  var hiddenNodes = [];
  var elementsToKeep = /* @__PURE__ */ new Set();
  var elementsToStop = new Set(targets);
  var keep = function(el2) {
    if (!el2 || elementsToKeep.has(el2)) {
      return;
    }
    elementsToKeep.add(el2);
    keep(el2.parentNode);
  };
  targets.forEach(keep);
  var deep = function(parent) {
    if (!parent || elementsToStop.has(parent)) {
      return;
    }
    Array.prototype.forEach.call(parent.children, function(node) {
      if (elementsToKeep.has(node)) {
        deep(node);
      } else {
        try {
          var attr = node.getAttribute(controlAttribute);
          var alreadyHidden = attr !== null && attr !== "false";
          var counterValue = (counterMap.get(node) || 0) + 1;
          var markerValue = (markerCounter.get(node) || 0) + 1;
          counterMap.set(node, counterValue);
          markerCounter.set(node, markerValue);
          hiddenNodes.push(node);
          if (counterValue === 1 && alreadyHidden) {
            uncontrolledNodes.set(node, true);
          }
          if (markerValue === 1) {
            node.setAttribute(markerName, "true");
          }
          if (!alreadyHidden) {
            node.setAttribute(controlAttribute, "true");
          }
        } catch (e2) {
          console.error("aria-hidden: cannot operate on ", node, e2);
        }
      }
    });
  };
  deep(parentNode);
  elementsToKeep.clear();
  lockCount++;
  return function() {
    hiddenNodes.forEach(function(node) {
      var counterValue = counterMap.get(node) - 1;
      var markerValue = markerCounter.get(node) - 1;
      counterMap.set(node, counterValue);
      markerCounter.set(node, markerValue);
      if (!counterValue) {
        if (!uncontrolledNodes.has(node)) {
          node.removeAttribute(controlAttribute);
        }
        uncontrolledNodes.delete(node);
      }
      if (!markerValue) {
        node.removeAttribute(markerName);
      }
    });
    lockCount--;
    if (!lockCount) {
      counterMap = /* @__PURE__ */ new WeakMap();
      counterMap = /* @__PURE__ */ new WeakMap();
      uncontrolledNodes = /* @__PURE__ */ new WeakMap();
      markerMap = {};
    }
  };
};
var hideOthers = function(originalTarget, parentNode, markerName) {
  if (markerName === void 0) {
    markerName = "data-aria-hidden";
  }
  var targets = Array.from(Array.isArray(originalTarget) ? originalTarget : [originalTarget]);
  var activeParentNode = getDefaultParent(originalTarget);
  if (!activeParentNode) {
    return function() {
      return null;
    };
  }
  targets.push.apply(targets, Array.from(activeParentNode.querySelectorAll("[aria-live]")));
  return applyAttributeToOthers(targets, activeParentNode, markerName, "aria-hidden");
};
var __assign = function() {
  __assign = Object.assign || function __assign2(t2) {
    for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
      s2 = arguments[i2];
      for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
    }
    return t2;
  };
  return __assign.apply(this, arguments);
};
function __rest(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l2 = from.length, ar; i2 < l2; i2++) {
    if (ar || !(i2 in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i2);
      ar[i2] = from[i2];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var zeroRightClassName = "right-scroll-bar-position";
var fullWidthClassName = "width-before-scroll-bar";
var noScrollbarsClassName = "with-scroll-bars-hidden";
var removedBarSizeVariable = "--removed-body-scroll-bar-size";
function assignRef(ref, value) {
  if (typeof ref === "function") {
    ref(value);
  } else if (ref) {
    ref.current = value;
  }
  return ref;
}
function useCallbackRef(initialValue, callback) {
  var ref = reactExports.useState(function() {
    return {
      // value
      value: initialValue,
      // last callback
      callback,
      // "memoized" public interface
      facade: {
        get current() {
          return ref.value;
        },
        set current(value) {
          var last2 = ref.value;
          if (last2 !== value) {
            ref.value = value;
            ref.callback(value, last2);
          }
        }
      }
    };
  })[0];
  ref.callback = callback;
  return ref.facade;
}
var useIsomorphicLayoutEffect = typeof window !== "undefined" ? reactExports.useLayoutEffect : reactExports.useEffect;
var currentValues = /* @__PURE__ */ new WeakMap();
function useMergeRefs(refs, defaultValue) {
  var callbackRef = useCallbackRef(null, function(newValue) {
    return refs.forEach(function(ref) {
      return assignRef(ref, newValue);
    });
  });
  useIsomorphicLayoutEffect(function() {
    var oldValue = currentValues.get(callbackRef);
    if (oldValue) {
      var prevRefs_1 = new Set(oldValue);
      var nextRefs_1 = new Set(refs);
      var current_1 = callbackRef.current;
      prevRefs_1.forEach(function(ref) {
        if (!nextRefs_1.has(ref)) {
          assignRef(ref, null);
        }
      });
      nextRefs_1.forEach(function(ref) {
        if (!prevRefs_1.has(ref)) {
          assignRef(ref, current_1);
        }
      });
    }
    currentValues.set(callbackRef, refs);
  }, [refs]);
  return callbackRef;
}
function ItoI(a2) {
  return a2;
}
function innerCreateMedium(defaults2, middleware) {
  if (middleware === void 0) {
    middleware = ItoI;
  }
  var buffer = [];
  var assigned = false;
  var medium = {
    read: function() {
      if (assigned) {
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      }
      if (buffer.length) {
        return buffer[buffer.length - 1];
      }
      return defaults2;
    },
    useMedium: function(data) {
      var item = middleware(data, assigned);
      buffer.push(item);
      return function() {
        buffer = buffer.filter(function(x2) {
          return x2 !== item;
        });
      };
    },
    assignSyncMedium: function(cb2) {
      assigned = true;
      while (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
      }
      buffer = {
        push: function(x2) {
          return cb2(x2);
        },
        filter: function() {
          return buffer;
        }
      };
    },
    assignMedium: function(cb2) {
      assigned = true;
      var pendingQueue = [];
      if (buffer.length) {
        var cbs = buffer;
        buffer = [];
        cbs.forEach(cb2);
        pendingQueue = buffer;
      }
      var executeQueue = function() {
        var cbs2 = pendingQueue;
        pendingQueue = [];
        cbs2.forEach(cb2);
      };
      var cycle = function() {
        return Promise.resolve().then(executeQueue);
      };
      cycle();
      buffer = {
        push: function(x2) {
          pendingQueue.push(x2);
          cycle();
        },
        filter: function(filter) {
          pendingQueue = pendingQueue.filter(filter);
          return buffer;
        }
      };
    }
  };
  return medium;
}
function createSidecarMedium(options) {
  if (options === void 0) {
    options = {};
  }
  var medium = innerCreateMedium(null);
  medium.options = __assign({ async: true, ssr: false }, options);
  return medium;
}
var SideCar$1 = function(_a) {
  var sideCar = _a.sideCar, rest = __rest(_a, ["sideCar"]);
  if (!sideCar) {
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  }
  var Target = sideCar.read();
  if (!Target) {
    throw new Error("Sidecar medium not found");
  }
  return reactExports.createElement(Target, __assign({}, rest));
};
SideCar$1.isSideCarExport = true;
function exportSidecar(medium, exported) {
  medium.useMedium(exported);
  return SideCar$1;
}
var effectCar = createSidecarMedium();
var nothing = function() {
  return;
};
var RemoveScroll = reactExports.forwardRef(function(props, parentRef) {
  var ref = reactExports.useRef(null);
  var _a = reactExports.useState({
    onScrollCapture: nothing,
    onWheelCapture: nothing,
    onTouchMoveCapture: nothing
  }), callbacks = _a[0], setCallbacks = _a[1];
  var forwardProps = props.forwardProps, children = props.children, className = props.className, removeScrollBar = props.removeScrollBar, enabled = props.enabled, shards = props.shards, sideCar = props.sideCar, noIsolation = props.noIsolation, inert = props.inert, allowPinchZoom = props.allowPinchZoom, _b = props.as, Container = _b === void 0 ? "div" : _b, gapMode = props.gapMode, rest = __rest(props, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]);
  var SideCar2 = sideCar;
  var containerRef = useMergeRefs([ref, parentRef]);
  var containerProps = __assign(__assign({}, rest), callbacks);
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    enabled && reactExports.createElement(SideCar2, { sideCar: effectCar, removeScrollBar, shards, noIsolation, inert, setCallbacks, allowPinchZoom: !!allowPinchZoom, lockRef: ref, gapMode }),
    forwardProps ? reactExports.cloneElement(reactExports.Children.only(children), __assign(__assign({}, containerProps), { ref: containerRef })) : reactExports.createElement(Container, __assign({}, containerProps, { className, ref: containerRef }), children)
  );
});
RemoveScroll.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
RemoveScroll.classNames = {
  fullWidth: fullWidthClassName,
  zeroRight: zeroRightClassName
};
var getNonce = function() {
  if (typeof __webpack_nonce__ !== "undefined") {
    return __webpack_nonce__;
  }
  return void 0;
};
function makeStyleTag() {
  if (!document)
    return null;
  var tag = document.createElement("style");
  tag.type = "text/css";
  var nonce = getNonce();
  if (nonce) {
    tag.setAttribute("nonce", nonce);
  }
  return tag;
}
function injectStyles(tag, css) {
  if (tag.styleSheet) {
    tag.styleSheet.cssText = css;
  } else {
    tag.appendChild(document.createTextNode(css));
  }
}
function insertStyleTag(tag) {
  var head = document.head || document.getElementsByTagName("head")[0];
  head.appendChild(tag);
}
var stylesheetSingleton = function() {
  var counter = 0;
  var stylesheet = null;
  return {
    add: function(style) {
      if (counter == 0) {
        if (stylesheet = makeStyleTag()) {
          injectStyles(stylesheet, style);
          insertStyleTag(stylesheet);
        }
      }
      counter++;
    },
    remove: function() {
      counter--;
      if (!counter && stylesheet) {
        stylesheet.parentNode && stylesheet.parentNode.removeChild(stylesheet);
        stylesheet = null;
      }
    }
  };
};
var styleHookSingleton = function() {
  var sheet = stylesheetSingleton();
  return function(styles, isDynamic) {
    reactExports.useEffect(function() {
      sheet.add(styles);
      return function() {
        sheet.remove();
      };
    }, [styles && isDynamic]);
  };
};
var styleSingleton = function() {
  var useStyle = styleHookSingleton();
  var Sheet = function(_a) {
    var styles = _a.styles, dynamic = _a.dynamic;
    useStyle(styles, dynamic);
    return null;
  };
  return Sheet;
};
var zeroGap = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var parse$1 = function(x2) {
  return parseInt(x2 || "", 10) || 0;
};
var getOffset = function(gapMode) {
  var cs = window.getComputedStyle(document.body);
  var left = cs[gapMode === "padding" ? "paddingLeft" : "marginLeft"];
  var top = cs[gapMode === "padding" ? "paddingTop" : "marginTop"];
  var right = cs[gapMode === "padding" ? "paddingRight" : "marginRight"];
  return [parse$1(left), parse$1(top), parse$1(right)];
};
var getGapWidth = function(gapMode) {
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  if (typeof window === "undefined") {
    return zeroGap;
  }
  var offsets = getOffset(gapMode);
  var documentWidth = document.documentElement.clientWidth;
  var windowWidth = window.innerWidth;
  return {
    left: offsets[0],
    top: offsets[1],
    right: offsets[2],
    gap: Math.max(0, windowWidth - documentWidth + offsets[2] - offsets[0])
  };
};
var Style = styleSingleton();
var lockAttribute = "data-scroll-locked";
var getStyles = function(_a, allowRelative, gapMode, important) {
  var left = _a.left, top = _a.top, right = _a.right, gap = _a.gap;
  if (gapMode === void 0) {
    gapMode = "margin";
  }
  return "\n  .".concat(noScrollbarsClassName, " {\n   overflow: hidden ").concat(important, ";\n   padding-right: ").concat(gap, "px ").concat(important, ";\n  }\n  body[").concat(lockAttribute, "] {\n    overflow: hidden ").concat(important, ";\n    overscroll-behavior: contain;\n    ").concat([
    allowRelative && "position: relative ".concat(important, ";"),
    gapMode === "margin" && "\n    padding-left: ".concat(left, "px;\n    padding-top: ").concat(top, "px;\n    padding-right: ").concat(right, "px;\n    margin-left:0;\n    margin-top:0;\n    margin-right: ").concat(gap, "px ").concat(important, ";\n    "),
    gapMode === "padding" && "padding-right: ".concat(gap, "px ").concat(important, ";")
  ].filter(Boolean).join(""), "\n  }\n  \n  .").concat(zeroRightClassName, " {\n    right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " {\n    margin-right: ").concat(gap, "px ").concat(important, ";\n  }\n  \n  .").concat(zeroRightClassName, " .").concat(zeroRightClassName, " {\n    right: 0 ").concat(important, ";\n  }\n  \n  .").concat(fullWidthClassName, " .").concat(fullWidthClassName, " {\n    margin-right: 0 ").concat(important, ";\n  }\n  \n  body[").concat(lockAttribute, "] {\n    ").concat(removedBarSizeVariable, ": ").concat(gap, "px;\n  }\n");
};
var getCurrentUseCounter = function() {
  var counter = parseInt(document.body.getAttribute(lockAttribute) || "0", 10);
  return isFinite(counter) ? counter : 0;
};
var useLockAttribute = function() {
  reactExports.useEffect(function() {
    document.body.setAttribute(lockAttribute, (getCurrentUseCounter() + 1).toString());
    return function() {
      var newCounter = getCurrentUseCounter() - 1;
      if (newCounter <= 0) {
        document.body.removeAttribute(lockAttribute);
      } else {
        document.body.setAttribute(lockAttribute, newCounter.toString());
      }
    };
  }, []);
};
var RemoveScrollBar = function(_a) {
  var noRelative = _a.noRelative, noImportant = _a.noImportant, _b = _a.gapMode, gapMode = _b === void 0 ? "margin" : _b;
  useLockAttribute();
  var gap = reactExports.useMemo(function() {
    return getGapWidth(gapMode);
  }, [gapMode]);
  return reactExports.createElement(Style, { styles: getStyles(gap, !noRelative, gapMode, !noImportant ? "!important" : "") });
};
var passiveSupported = false;
if (typeof window !== "undefined") {
  try {
    var options = Object.defineProperty({}, "passive", {
      get: function() {
        passiveSupported = true;
        return true;
      }
    });
    window.addEventListener("test", options, options);
    window.removeEventListener("test", options, options);
  } catch (err) {
    passiveSupported = false;
  }
}
var nonPassive = passiveSupported ? { passive: false } : false;
var alwaysContainsScroll = function(node) {
  return node.tagName === "TEXTAREA";
};
var elementCanBeScrolled = function(node, overflow) {
  if (!(node instanceof Element)) {
    return false;
  }
  var styles = window.getComputedStyle(node);
  return (
    // not-not-scrollable
    styles[overflow] !== "hidden" && // contains scroll inside self
    !(styles.overflowY === styles.overflowX && !alwaysContainsScroll(node) && styles[overflow] === "visible")
  );
};
var elementCouldBeVScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowY");
};
var elementCouldBeHScrolled = function(node) {
  return elementCanBeScrolled(node, "overflowX");
};
var locationCouldBeScrolled = function(axis, node) {
  var ownerDocument = node.ownerDocument;
  var current = node;
  do {
    if (typeof ShadowRoot !== "undefined" && current instanceof ShadowRoot) {
      current = current.host;
    }
    var isScrollable = elementCouldBeScrolled(axis, current);
    if (isScrollable) {
      var _a = getScrollVariables(axis, current), scrollHeight = _a[1], clientHeight = _a[2];
      if (scrollHeight > clientHeight) {
        return true;
      }
    }
    current = current.parentNode;
  } while (current && current !== ownerDocument.body);
  return false;
};
var getVScrollVariables = function(_a) {
  var scrollTop = _a.scrollTop, scrollHeight = _a.scrollHeight, clientHeight = _a.clientHeight;
  return [
    scrollTop,
    scrollHeight,
    clientHeight
  ];
};
var getHScrollVariables = function(_a) {
  var scrollLeft = _a.scrollLeft, scrollWidth = _a.scrollWidth, clientWidth = _a.clientWidth;
  return [
    scrollLeft,
    scrollWidth,
    clientWidth
  ];
};
var elementCouldBeScrolled = function(axis, node) {
  return axis === "v" ? elementCouldBeVScrolled(node) : elementCouldBeHScrolled(node);
};
var getScrollVariables = function(axis, node) {
  return axis === "v" ? getVScrollVariables(node) : getHScrollVariables(node);
};
var getDirectionFactor = function(axis, direction) {
  return axis === "h" && direction === "rtl" ? -1 : 1;
};
var handleScroll = function(axis, endTarget, event, sourceDelta, noOverscroll) {
  var directionFactor = getDirectionFactor(axis, window.getComputedStyle(endTarget).direction);
  var delta = directionFactor * sourceDelta;
  var target = event.target;
  var targetInLock = endTarget.contains(target);
  var shouldCancelScroll = false;
  var isDeltaPositive = delta > 0;
  var availableScroll = 0;
  var availableScrollTop = 0;
  do {
    var _a = getScrollVariables(axis, target), position = _a[0], scroll_1 = _a[1], capacity = _a[2];
    var elementScroll = scroll_1 - capacity - directionFactor * position;
    if (position || elementScroll) {
      if (elementCouldBeScrolled(axis, target)) {
        availableScroll += elementScroll;
        availableScrollTop += position;
      }
    }
    if (target instanceof ShadowRoot) {
      target = target.host;
    } else {
      target = target.parentNode;
    }
  } while (
    // portaled content
    !targetInLock && target !== document.body || // self content
    targetInLock && (endTarget.contains(target) || endTarget === target)
  );
  if (isDeltaPositive && (Math.abs(availableScroll) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  } else if (!isDeltaPositive && (Math.abs(availableScrollTop) < 1 || !noOverscroll)) {
    shouldCancelScroll = true;
  }
  return shouldCancelScroll;
};
var getTouchXY = function(event) {
  return "changedTouches" in event ? [event.changedTouches[0].clientX, event.changedTouches[0].clientY] : [0, 0];
};
var getDeltaXY = function(event) {
  return [event.deltaX, event.deltaY];
};
var extractRef = function(ref) {
  return ref && "current" in ref ? ref.current : ref;
};
var deltaCompare = function(x2, y2) {
  return x2[0] === y2[0] && x2[1] === y2[1];
};
var generateStyle = function(id2) {
  return "\n  .block-interactivity-".concat(id2, " {pointer-events: none;}\n  .allow-interactivity-").concat(id2, " {pointer-events: all;}\n");
};
var idCounter = 0;
var lockStack = [];
function RemoveScrollSideCar(props) {
  var shouldPreventQueue = reactExports.useRef([]);
  var touchStartRef = reactExports.useRef([0, 0]);
  var activeAxis = reactExports.useRef();
  var id2 = reactExports.useState(idCounter++)[0];
  var Style2 = reactExports.useState(styleSingleton)[0];
  var lastProps = reactExports.useRef(props);
  reactExports.useEffect(function() {
    lastProps.current = props;
  }, [props]);
  reactExports.useEffect(function() {
    if (props.inert) {
      document.body.classList.add("block-interactivity-".concat(id2));
      var allow_1 = __spreadArray([props.lockRef.current], (props.shards || []).map(extractRef), true).filter(Boolean);
      allow_1.forEach(function(el2) {
        return el2.classList.add("allow-interactivity-".concat(id2));
      });
      return function() {
        document.body.classList.remove("block-interactivity-".concat(id2));
        allow_1.forEach(function(el2) {
          return el2.classList.remove("allow-interactivity-".concat(id2));
        });
      };
    }
    return;
  }, [props.inert, props.lockRef.current, props.shards]);
  var shouldCancelEvent = reactExports.useCallback(function(event, parent) {
    if ("touches" in event && event.touches.length === 2 || event.type === "wheel" && event.ctrlKey) {
      return !lastProps.current.allowPinchZoom;
    }
    var touch = getTouchXY(event);
    var touchStart = touchStartRef.current;
    var deltaX = "deltaX" in event ? event.deltaX : touchStart[0] - touch[0];
    var deltaY = "deltaY" in event ? event.deltaY : touchStart[1] - touch[1];
    var currentAxis;
    var target = event.target;
    var moveDirection = Math.abs(deltaX) > Math.abs(deltaY) ? "h" : "v";
    if ("touches" in event && moveDirection === "h" && target.type === "range") {
      return false;
    }
    var canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    if (!canBeScrolledInMainDirection) {
      return true;
    }
    if (canBeScrolledInMainDirection) {
      currentAxis = moveDirection;
    } else {
      currentAxis = moveDirection === "v" ? "h" : "v";
      canBeScrolledInMainDirection = locationCouldBeScrolled(moveDirection, target);
    }
    if (!canBeScrolledInMainDirection) {
      return false;
    }
    if (!activeAxis.current && "changedTouches" in event && (deltaX || deltaY)) {
      activeAxis.current = currentAxis;
    }
    if (!currentAxis) {
      return true;
    }
    var cancelingAxis = activeAxis.current || currentAxis;
    return handleScroll(cancelingAxis, parent, event, cancelingAxis === "h" ? deltaX : deltaY, true);
  }, []);
  var shouldPrevent = reactExports.useCallback(function(_event) {
    var event = _event;
    if (!lockStack.length || lockStack[lockStack.length - 1] !== Style2) {
      return;
    }
    var delta = "deltaY" in event ? getDeltaXY(event) : getTouchXY(event);
    var sourceEvent = shouldPreventQueue.current.filter(function(e2) {
      return e2.name === event.type && (e2.target === event.target || event.target === e2.shadowParent) && deltaCompare(e2.delta, delta);
    })[0];
    if (sourceEvent && sourceEvent.should) {
      if (event.cancelable) {
        event.preventDefault();
      }
      return;
    }
    if (!sourceEvent) {
      var shardNodes = (lastProps.current.shards || []).map(extractRef).filter(Boolean).filter(function(node) {
        return node.contains(event.target);
      });
      var shouldStop = shardNodes.length > 0 ? shouldCancelEvent(event, shardNodes[0]) : !lastProps.current.noIsolation;
      if (shouldStop) {
        if (event.cancelable) {
          event.preventDefault();
        }
      }
    }
  }, []);
  var shouldCancel = reactExports.useCallback(function(name, delta, target, should) {
    var event = { name, delta, target, should, shadowParent: getOutermostShadowParent(target) };
    shouldPreventQueue.current.push(event);
    setTimeout(function() {
      shouldPreventQueue.current = shouldPreventQueue.current.filter(function(e2) {
        return e2 !== event;
      });
    }, 1);
  }, []);
  var scrollTouchStart = reactExports.useCallback(function(event) {
    touchStartRef.current = getTouchXY(event);
    activeAxis.current = void 0;
  }, []);
  var scrollWheel = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getDeltaXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  var scrollTouchMove = reactExports.useCallback(function(event) {
    shouldCancel(event.type, getTouchXY(event), event.target, shouldCancelEvent(event, props.lockRef.current));
  }, []);
  reactExports.useEffect(function() {
    lockStack.push(Style2);
    props.setCallbacks({
      onScrollCapture: scrollWheel,
      onWheelCapture: scrollWheel,
      onTouchMoveCapture: scrollTouchMove
    });
    document.addEventListener("wheel", shouldPrevent, nonPassive);
    document.addEventListener("touchmove", shouldPrevent, nonPassive);
    document.addEventListener("touchstart", scrollTouchStart, nonPassive);
    return function() {
      lockStack = lockStack.filter(function(inst) {
        return inst !== Style2;
      });
      document.removeEventListener("wheel", shouldPrevent, nonPassive);
      document.removeEventListener("touchmove", shouldPrevent, nonPassive);
      document.removeEventListener("touchstart", scrollTouchStart, nonPassive);
    };
  }, []);
  var removeScrollBar = props.removeScrollBar, inert = props.inert;
  return reactExports.createElement(
    reactExports.Fragment,
    null,
    inert ? reactExports.createElement(Style2, { styles: generateStyle(id2) }) : null,
    removeScrollBar ? reactExports.createElement(RemoveScrollBar, { gapMode: props.gapMode }) : null
  );
}
function getOutermostShadowParent(node) {
  var shadowParent = null;
  while (node !== null) {
    if (node instanceof ShadowRoot) {
      shadowParent = node.host;
      node = node.host;
    }
    node = node.parentNode;
  }
  return shadowParent;
}
const SideCar = exportSidecar(effectCar, RemoveScrollSideCar);
var ReactRemoveScroll = reactExports.forwardRef(function(props, ref) {
  return reactExports.createElement(RemoveScroll, __assign({}, props, { ref, sideCar: SideCar }));
});
ReactRemoveScroll.classNames = RemoveScroll.classNames;
var OPEN_KEYS = [" ", "Enter", "ArrowUp", "ArrowDown"];
var SELECTION_KEYS = [" ", "Enter"];
var SELECT_NAME = "Select";
var [Collection$1, useCollection$1, createCollectionScope$1] = createCollection(SELECT_NAME);
var [createSelectContext, createSelectScope] = createContextScope(SELECT_NAME, [
  createCollectionScope$1,
  createPopperScope
]);
var usePopperScope = createPopperScope();
var [SelectProvider, useSelectContext] = createSelectContext(SELECT_NAME);
var [SelectNativeOptionsProvider, useSelectNativeOptionsContext] = createSelectContext(SELECT_NAME);
var Select$1 = (props) => {
  const {
    __scopeSelect,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    value: valueProp,
    defaultValue,
    onValueChange,
    dir,
    name,
    autoComplete,
    disabled,
    required,
    form
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  const [trigger, setTrigger] = reactExports.useState(null);
  const [valueNode, setValueNode] = reactExports.useState(null);
  const [valueNodeHasChildren, setValueNodeHasChildren] = reactExports.useState(false);
  const direction = useDirection(dir);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  const [value, setValue] = useControllableState({
    prop: valueProp,
    defaultProp: defaultValue,
    onChange: onValueChange
  });
  const triggerPointerDownPosRef = reactExports.useRef(null);
  const isFormControl = trigger ? form || !!trigger.closest("form") : true;
  const [nativeOptionsSet, setNativeOptionsSet] = reactExports.useState(/* @__PURE__ */ new Set());
  const nativeSelectKey = Array.from(nativeOptionsSet).map((option) => option.props.value).join(";");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Root2$1, { ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
    SelectProvider,
    {
      required,
      scope: __scopeSelect,
      trigger,
      onTriggerChange: setTrigger,
      valueNode,
      onValueNodeChange: setValueNode,
      valueNodeHasChildren,
      onValueNodeHasChildrenChange: setValueNodeHasChildren,
      contentId: useId(),
      value,
      onValueChange: setValue,
      open,
      onOpenChange: setOpen,
      dir: direction,
      triggerPointerDownPosRef,
      disabled,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Provider, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SelectNativeOptionsProvider,
          {
            scope: props.__scopeSelect,
            onNativeOptionAdd: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => new Set(prev).add(option));
            }, []),
            onNativeOptionRemove: reactExports.useCallback((option) => {
              setNativeOptionsSet((prev) => {
                const optionsSet = new Set(prev);
                optionsSet.delete(option);
                return optionsSet;
              });
            }, []),
            children
          }
        ) }),
        isFormControl ? /* @__PURE__ */ jsxRuntimeExports.jsxs(
          BubbleSelect,
          {
            "aria-hidden": true,
            required,
            tabIndex: -1,
            name,
            autoComplete,
            value,
            onChange: (event) => setValue(event.target.value),
            disabled,
            form,
            children: [
              value === void 0 ? /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: "" }) : null,
              Array.from(nativeOptionsSet)
            ]
          },
          nativeSelectKey
        ) : null
      ]
    }
  ) });
};
Select$1.displayName = SELECT_NAME;
var TRIGGER_NAME$1 = "SelectTrigger";
var SelectTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, disabled = false, ...triggerProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(TRIGGER_NAME$1, __scopeSelect);
    const isDisabled = context.disabled || disabled;
    const composedRefs = useComposedRefs(forwardedRef, context.onTriggerChange);
    const getItems = useCollection$1(__scopeSelect);
    const pointerTypeRef = reactExports.useRef("touch");
    const [searchRef, handleTypeaheadSearch, resetTypeahead] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.value === context.value);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem !== void 0) {
        context.onValueChange(nextItem.value);
      }
    });
    const handleOpen = (pointerEvent) => {
      if (!isDisabled) {
        context.onOpenChange(true);
        resetTypeahead();
      }
      if (pointerEvent) {
        context.triggerPointerDownPosRef.current = {
          x: Math.round(pointerEvent.pageX),
          y: Math.round(pointerEvent.pageY)
        };
      }
    };
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Anchor, { asChild: true, ...popperScope, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        role: "combobox",
        "aria-controls": context.contentId,
        "aria-expanded": context.open,
        "aria-required": context.required,
        "aria-autocomplete": "none",
        dir: context.dir,
        "data-state": context.open ? "open" : "closed",
        disabled: isDisabled,
        "data-disabled": isDisabled ? "" : void 0,
        "data-placeholder": shouldShowPlaceholder(context.value) ? "" : void 0,
        ...triggerProps,
        ref: composedRefs,
        onClick: composeEventHandlers(triggerProps.onClick, (event) => {
          event.currentTarget.focus();
          if (pointerTypeRef.current !== "mouse") {
            handleOpen(event);
          }
        }),
        onPointerDown: composeEventHandlers(triggerProps.onPointerDown, (event) => {
          pointerTypeRef.current = event.pointerType;
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
          }
          if (event.button === 0 && event.ctrlKey === false && event.pointerType === "mouse") {
            handleOpen(event);
            event.preventDefault();
          }
        }),
        onKeyDown: composeEventHandlers(triggerProps.onKeyDown, (event) => {
          const isTypingAhead = searchRef.current !== "";
          const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
          if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
          if (isTypingAhead && event.key === " ") return;
          if (OPEN_KEYS.includes(event.key)) {
            handleOpen();
            event.preventDefault();
          }
        })
      }
    ) });
  }
);
SelectTrigger$1.displayName = TRIGGER_NAME$1;
var VALUE_NAME = "SelectValue";
var SelectValue$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, children, placeholder = "", ...valueProps } = props;
    const context = useSelectContext(VALUE_NAME, __scopeSelect);
    const { onValueNodeHasChildrenChange } = context;
    const hasChildren = children !== void 0;
    const composedRefs = useComposedRefs(forwardedRef, context.onValueNodeChange);
    useLayoutEffect2(() => {
      onValueNodeHasChildrenChange(hasChildren);
    }, [onValueNodeHasChildrenChange, hasChildren]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...valueProps,
        ref: composedRefs,
        style: { pointerEvents: "none" },
        children: shouldShowPlaceholder(context.value) ? /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: placeholder }) : children
      }
    );
  }
);
SelectValue$1.displayName = VALUE_NAME;
var ICON_NAME = "SelectIcon";
var SelectIcon = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, children, ...iconProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...iconProps, ref: forwardedRef, children: children || "▼" });
  }
);
SelectIcon.displayName = ICON_NAME;
var PORTAL_NAME$1 = "SelectPortal";
var SelectPortal = (props) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { asChild: true, ...props });
};
SelectPortal.displayName = PORTAL_NAME$1;
var CONTENT_NAME$1 = "SelectContent";
var SelectContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useSelectContext(CONTENT_NAME$1, props.__scopeSelect);
    const [fragment, setFragment] = reactExports.useState();
    useLayoutEffect2(() => {
      setFragment(new DocumentFragment());
    }, []);
    if (!context.open) {
      const frag = fragment;
      return frag ? reactDomExports.createPortal(
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentProvider, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: props.__scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: props.children }) }) }),
        frag
      ) : null;
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContentImpl, { ...props, ref: forwardedRef });
  }
);
SelectContent$1.displayName = CONTENT_NAME$1;
var CONTENT_MARGIN = 10;
var [SelectContentProvider, useSelectContentContext] = createSelectContext(CONTENT_NAME$1);
var CONTENT_IMPL_NAME = "SelectContentImpl";
var SelectContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      position = "item-aligned",
      onCloseAutoFocus,
      onEscapeKeyDown,
      onPointerDownOutside,
      //
      // PopperContent props
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions,
      //
      ...contentProps
    } = props;
    const context = useSelectContext(CONTENT_NAME$1, __scopeSelect);
    const [content, setContent] = reactExports.useState(null);
    const [viewport, setViewport] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
    const [selectedItem, setSelectedItem] = reactExports.useState(null);
    const [selectedItemText, setSelectedItemText] = reactExports.useState(
      null
    );
    const getItems = useCollection$1(__scopeSelect);
    const [isPositioned, setIsPositioned] = reactExports.useState(false);
    const firstValidItemFoundRef = reactExports.useRef(false);
    reactExports.useEffect(() => {
      if (content) return hideOthers(content);
    }, [content]);
    useFocusGuards();
    const focusFirst2 = reactExports.useCallback(
      (candidates) => {
        const [firstItem, ...restItems] = getItems().map((item) => item.ref.current);
        const [lastItem] = restItems.slice(-1);
        const PREVIOUSLY_FOCUSED_ELEMENT = document.activeElement;
        for (const candidate of candidates) {
          if (candidate === PREVIOUSLY_FOCUSED_ELEMENT) return;
          candidate?.scrollIntoView({ block: "nearest" });
          if (candidate === firstItem && viewport) viewport.scrollTop = 0;
          if (candidate === lastItem && viewport) viewport.scrollTop = viewport.scrollHeight;
          candidate?.focus();
          if (document.activeElement !== PREVIOUSLY_FOCUSED_ELEMENT) return;
        }
      },
      [getItems, viewport]
    );
    const focusSelectedItem = reactExports.useCallback(
      () => focusFirst2([selectedItem, content]),
      [focusFirst2, selectedItem, content]
    );
    reactExports.useEffect(() => {
      if (isPositioned) {
        focusSelectedItem();
      }
    }, [isPositioned, focusSelectedItem]);
    const { onOpenChange, triggerPointerDownPosRef } = context;
    reactExports.useEffect(() => {
      if (content) {
        let pointerMoveDelta = { x: 0, y: 0 };
        const handlePointerMove = (event) => {
          pointerMoveDelta = {
            x: Math.abs(Math.round(event.pageX) - (triggerPointerDownPosRef.current?.x ?? 0)),
            y: Math.abs(Math.round(event.pageY) - (triggerPointerDownPosRef.current?.y ?? 0))
          };
        };
        const handlePointerUp = (event) => {
          if (pointerMoveDelta.x <= 10 && pointerMoveDelta.y <= 10) {
            event.preventDefault();
          } else {
            if (!content.contains(event.target)) {
              onOpenChange(false);
            }
          }
          document.removeEventListener("pointermove", handlePointerMove);
          triggerPointerDownPosRef.current = null;
        };
        if (triggerPointerDownPosRef.current !== null) {
          document.addEventListener("pointermove", handlePointerMove);
          document.addEventListener("pointerup", handlePointerUp, { capture: true, once: true });
        }
        return () => {
          document.removeEventListener("pointermove", handlePointerMove);
          document.removeEventListener("pointerup", handlePointerUp, { capture: true });
        };
      }
    }, [content, onOpenChange, triggerPointerDownPosRef]);
    reactExports.useEffect(() => {
      const close = () => onOpenChange(false);
      window.addEventListener("blur", close);
      window.addEventListener("resize", close);
      return () => {
        window.removeEventListener("blur", close);
        window.removeEventListener("resize", close);
      };
    }, [onOpenChange]);
    const [searchRef, handleTypeaheadSearch] = useTypeaheadSearch((search) => {
      const enabledItems = getItems().filter((item) => !item.disabled);
      const currentItem = enabledItems.find((item) => item.ref.current === document.activeElement);
      const nextItem = findNextItem(enabledItems, search, currentItem);
      if (nextItem) {
        setTimeout(() => nextItem.ref.current.focus());
      }
    });
    const itemRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItem(node);
          if (isFirstValidItem) firstValidItemFoundRef.current = true;
        }
      },
      [context.value]
    );
    const handleItemLeave = reactExports.useCallback(() => content?.focus(), [content]);
    const itemTextRefCallback = reactExports.useCallback(
      (node, value, disabled) => {
        const isFirstValidItem = !firstValidItemFoundRef.current && !disabled;
        const isSelectedItem = context.value !== void 0 && context.value === value;
        if (isSelectedItem || isFirstValidItem) {
          setSelectedItemText(node);
        }
      },
      [context.value]
    );
    const SelectPosition = position === "popper" ? SelectPopperPosition : SelectItemAlignedPosition;
    const popperContentProps = SelectPosition === SelectPopperPosition ? {
      side,
      sideOffset,
      align,
      alignOffset,
      arrowPadding,
      collisionBoundary,
      collisionPadding,
      sticky,
      hideWhenDetached,
      avoidCollisions
    } : {};
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectContentProvider,
      {
        scope: __scopeSelect,
        content,
        viewport,
        onViewportChange: setViewport,
        itemRefCallback,
        selectedItem,
        onItemLeave: handleItemLeave,
        itemTextRefCallback,
        focusSelectedItem,
        selectedItemText,
        position,
        isPositioned,
        searchRef,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          FocusScope,
          {
            asChild: true,
            trapped: context.open,
            onMountAutoFocus: (event) => {
              event.preventDefault();
            },
            onUnmountAutoFocus: composeEventHandlers(onCloseAutoFocus, (event) => {
              context.trigger?.focus({ preventScroll: true });
              event.preventDefault();
            }),
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              DismissableLayer,
              {
                asChild: true,
                disableOutsidePointerEvents: true,
                onEscapeKeyDown,
                onPointerDownOutside,
                onFocusOutside: (event) => event.preventDefault(),
                onDismiss: () => context.onOpenChange(false),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  SelectPosition,
                  {
                    role: "listbox",
                    id: context.contentId,
                    "data-state": context.open ? "open" : "closed",
                    dir: context.dir,
                    onContextMenu: (event) => event.preventDefault(),
                    ...contentProps,
                    ...popperContentProps,
                    onPlaced: () => setIsPositioned(true),
                    ref: composedRefs,
                    style: {
                      // flex layout so we can place the scroll buttons properly
                      display: "flex",
                      flexDirection: "column",
                      // reset the outline by default as the content MAY get focused
                      outline: "none",
                      ...contentProps.style
                    },
                    onKeyDown: composeEventHandlers(contentProps.onKeyDown, (event) => {
                      const isModifierKey = event.ctrlKey || event.altKey || event.metaKey;
                      if (event.key === "Tab") event.preventDefault();
                      if (!isModifierKey && event.key.length === 1) handleTypeaheadSearch(event.key);
                      if (["ArrowUp", "ArrowDown", "Home", "End"].includes(event.key)) {
                        const items = getItems().filter((item) => !item.disabled);
                        let candidateNodes = items.map((item) => item.ref.current);
                        if (["ArrowUp", "End"].includes(event.key)) {
                          candidateNodes = candidateNodes.slice().reverse();
                        }
                        if (["ArrowUp", "ArrowDown"].includes(event.key)) {
                          const currentElement = event.target;
                          const currentIndex = candidateNodes.indexOf(currentElement);
                          candidateNodes = candidateNodes.slice(currentIndex + 1);
                        }
                        setTimeout(() => focusFirst2(candidateNodes));
                        event.preventDefault();
                      }
                    })
                  }
                )
              }
            )
          }
        ) })
      }
    );
  }
);
SelectContentImpl.displayName = CONTENT_IMPL_NAME;
var ITEM_ALIGNED_POSITION_NAME = "SelectItemAlignedPosition";
var SelectItemAlignedPosition = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onPlaced, ...popperProps } = props;
  const context = useSelectContext(CONTENT_NAME$1, __scopeSelect);
  const contentContext = useSelectContentContext(CONTENT_NAME$1, __scopeSelect);
  const [contentWrapper, setContentWrapper] = reactExports.useState(null);
  const [content, setContent] = reactExports.useState(null);
  const composedRefs = useComposedRefs(forwardedRef, (node) => setContent(node));
  const getItems = useCollection$1(__scopeSelect);
  const shouldExpandOnScrollRef = reactExports.useRef(false);
  const shouldRepositionRef = reactExports.useRef(true);
  const { viewport, selectedItem, selectedItemText, focusSelectedItem } = contentContext;
  const position = reactExports.useCallback(() => {
    if (context.trigger && context.valueNode && contentWrapper && content && viewport && selectedItem && selectedItemText) {
      const triggerRect = context.trigger.getBoundingClientRect();
      const contentRect = content.getBoundingClientRect();
      const valueNodeRect = context.valueNode.getBoundingClientRect();
      const itemTextRect = selectedItemText.getBoundingClientRect();
      if (context.dir !== "rtl") {
        const itemTextOffset = itemTextRect.left - contentRect.left;
        const left = valueNodeRect.left - itemTextOffset;
        const leftDelta = triggerRect.left - left;
        const minContentWidth = triggerRect.width + leftDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const rightEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedLeft = clamp$1(left, [
          CONTENT_MARGIN,
          // Prevents the content from going off the starting edge of the
          // viewport. It may still go off the ending edge, but this can be
          // controlled by the user since they may want to manage overflow in a
          // specific way.
          // https://github.com/radix-ui/primitives/issues/2049
          Math.max(CONTENT_MARGIN, rightEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.left = clampedLeft + "px";
      } else {
        const itemTextOffset = contentRect.right - itemTextRect.right;
        const right = window.innerWidth - valueNodeRect.right - itemTextOffset;
        const rightDelta = window.innerWidth - triggerRect.right - right;
        const minContentWidth = triggerRect.width + rightDelta;
        const contentWidth = Math.max(minContentWidth, contentRect.width);
        const leftEdge = window.innerWidth - CONTENT_MARGIN;
        const clampedRight = clamp$1(right, [
          CONTENT_MARGIN,
          Math.max(CONTENT_MARGIN, leftEdge - contentWidth)
        ]);
        contentWrapper.style.minWidth = minContentWidth + "px";
        contentWrapper.style.right = clampedRight + "px";
      }
      const items = getItems();
      const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
      const itemsHeight = viewport.scrollHeight;
      const contentStyles = window.getComputedStyle(content);
      const contentBorderTopWidth = parseInt(contentStyles.borderTopWidth, 10);
      const contentPaddingTop = parseInt(contentStyles.paddingTop, 10);
      const contentBorderBottomWidth = parseInt(contentStyles.borderBottomWidth, 10);
      const contentPaddingBottom = parseInt(contentStyles.paddingBottom, 10);
      const fullContentHeight = contentBorderTopWidth + contentPaddingTop + itemsHeight + contentPaddingBottom + contentBorderBottomWidth;
      const minContentHeight = Math.min(selectedItem.offsetHeight * 5, fullContentHeight);
      const viewportStyles = window.getComputedStyle(viewport);
      const viewportPaddingTop = parseInt(viewportStyles.paddingTop, 10);
      const viewportPaddingBottom = parseInt(viewportStyles.paddingBottom, 10);
      const topEdgeToTriggerMiddle = triggerRect.top + triggerRect.height / 2 - CONTENT_MARGIN;
      const triggerMiddleToBottomEdge = availableHeight - topEdgeToTriggerMiddle;
      const selectedItemHalfHeight = selectedItem.offsetHeight / 2;
      const itemOffsetMiddle = selectedItem.offsetTop + selectedItemHalfHeight;
      const contentTopToItemMiddle = contentBorderTopWidth + contentPaddingTop + itemOffsetMiddle;
      const itemMiddleToContentBottom = fullContentHeight - contentTopToItemMiddle;
      const willAlignWithoutTopOverflow = contentTopToItemMiddle <= topEdgeToTriggerMiddle;
      if (willAlignWithoutTopOverflow) {
        const isLastItem = items.length > 0 && selectedItem === items[items.length - 1].ref.current;
        contentWrapper.style.bottom = "0px";
        const viewportOffsetBottom = content.clientHeight - viewport.offsetTop - viewport.offsetHeight;
        const clampedTriggerMiddleToBottomEdge = Math.max(
          triggerMiddleToBottomEdge,
          selectedItemHalfHeight + // viewport might have padding bottom, include it to avoid a scrollable viewport
          (isLastItem ? viewportPaddingBottom : 0) + viewportOffsetBottom + contentBorderBottomWidth
        );
        const height = contentTopToItemMiddle + clampedTriggerMiddleToBottomEdge;
        contentWrapper.style.height = height + "px";
      } else {
        const isFirstItem = items.length > 0 && selectedItem === items[0].ref.current;
        contentWrapper.style.top = "0px";
        const clampedTopEdgeToTriggerMiddle = Math.max(
          topEdgeToTriggerMiddle,
          contentBorderTopWidth + viewport.offsetTop + // viewport might have padding top, include it to avoid a scrollable viewport
          (isFirstItem ? viewportPaddingTop : 0) + selectedItemHalfHeight
        );
        const height = clampedTopEdgeToTriggerMiddle + itemMiddleToContentBottom;
        contentWrapper.style.height = height + "px";
        viewport.scrollTop = contentTopToItemMiddle - topEdgeToTriggerMiddle + viewport.offsetTop;
      }
      contentWrapper.style.margin = `${CONTENT_MARGIN}px 0`;
      contentWrapper.style.minHeight = minContentHeight + "px";
      contentWrapper.style.maxHeight = availableHeight + "px";
      onPlaced?.();
      requestAnimationFrame(() => shouldExpandOnScrollRef.current = true);
    }
  }, [
    getItems,
    context.trigger,
    context.valueNode,
    contentWrapper,
    content,
    viewport,
    selectedItem,
    selectedItemText,
    context.dir,
    onPlaced
  ]);
  useLayoutEffect2(() => position(), [position]);
  const [contentZIndex, setContentZIndex] = reactExports.useState();
  useLayoutEffect2(() => {
    if (content) setContentZIndex(window.getComputedStyle(content).zIndex);
  }, [content]);
  const handleScrollButtonChange = reactExports.useCallback(
    (node) => {
      if (node && shouldRepositionRef.current === true) {
        position();
        focusSelectedItem?.();
        shouldRepositionRef.current = false;
      }
    },
    [position, focusSelectedItem]
  );
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectViewportProvider,
    {
      scope: __scopeSelect,
      contentWrapper,
      shouldExpandOnScrollRef,
      onScrollButtonChange: handleScrollButtonChange,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        "div",
        {
          ref: setContentWrapper,
          style: {
            display: "flex",
            flexDirection: "column",
            position: "fixed",
            zIndex: contentZIndex
          },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.div,
            {
              ...popperProps,
              ref: composedRefs,
              style: {
                // When we get the height of the content, it includes borders. If we were to set
                // the height without having `boxSizing: 'border-box'` it would be too big.
                boxSizing: "border-box",
                // We need to ensure the content doesn't get taller than the wrapper
                maxHeight: "100%",
                ...popperProps.style
              }
            }
          )
        }
      )
    }
  );
});
SelectItemAlignedPosition.displayName = ITEM_ALIGNED_POSITION_NAME;
var POPPER_POSITION_NAME = "SelectPopperPosition";
var SelectPopperPosition = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeSelect,
    align = "start",
    collisionPadding = CONTENT_MARGIN,
    ...popperProps
  } = props;
  const popperScope = usePopperScope(__scopeSelect);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Content$1,
    {
      ...popperScope,
      ...popperProps,
      ref: forwardedRef,
      align,
      collisionPadding,
      style: {
        // Ensure border-box for floating-ui calculations
        boxSizing: "border-box",
        ...popperProps.style,
        // re-namespace exposed content custom properties
        ...{
          "--radix-select-content-transform-origin": "var(--radix-popper-transform-origin)",
          "--radix-select-content-available-width": "var(--radix-popper-available-width)",
          "--radix-select-content-available-height": "var(--radix-popper-available-height)",
          "--radix-select-trigger-width": "var(--radix-popper-anchor-width)",
          "--radix-select-trigger-height": "var(--radix-popper-anchor-height)"
        }
      }
    }
  );
});
SelectPopperPosition.displayName = POPPER_POSITION_NAME;
var [SelectViewportProvider, useSelectViewportContext] = createSelectContext(CONTENT_NAME$1, {});
var VIEWPORT_NAME$1 = "SelectViewport";
var SelectViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, nonce, ...viewportProps } = props;
    const contentContext = useSelectContentContext(VIEWPORT_NAME$1, __scopeSelect);
    const viewportContext = useSelectViewportContext(VIEWPORT_NAME$1, __scopeSelect);
    const composedRefs = useComposedRefs(forwardedRef, contentContext.onViewportChange);
    const prevScrollTopRef = reactExports.useRef(0);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `[data-radix-select-viewport]{scrollbar-width:none;-ms-overflow-style:none;-webkit-overflow-scrolling:touch;}[data-radix-select-viewport]::-webkit-scrollbar{display:none}`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Collection$1.Slot, { scope: __scopeSelect, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-select-viewport": "",
          role: "presentation",
          ...viewportProps,
          ref: composedRefs,
          style: {
            // we use position: 'relative' here on the `viewport` so that when we call
            // `selectedItem.offsetTop` in calculations, the offset is relative to the viewport
            // (independent of the scrollUpButton).
            position: "relative",
            flex: 1,
            // Viewport should only be scrollable in the vertical direction.
            // This won't work in vertical writing modes, so we'll need to
            // revisit this if/when that is supported
            // https://developer.chrome.com/blog/vertical-form-controls
            overflow: "hidden auto",
            ...viewportProps.style
          },
          onScroll: composeEventHandlers(viewportProps.onScroll, (event) => {
            const viewport = event.currentTarget;
            const { contentWrapper, shouldExpandOnScrollRef } = viewportContext;
            if (shouldExpandOnScrollRef?.current && contentWrapper) {
              const scrolledBy = Math.abs(prevScrollTopRef.current - viewport.scrollTop);
              if (scrolledBy > 0) {
                const availableHeight = window.innerHeight - CONTENT_MARGIN * 2;
                const cssMinHeight = parseFloat(contentWrapper.style.minHeight);
                const cssHeight = parseFloat(contentWrapper.style.height);
                const prevHeight = Math.max(cssMinHeight, cssHeight);
                if (prevHeight < availableHeight) {
                  const nextHeight = prevHeight + scrolledBy;
                  const clampedNextHeight = Math.min(availableHeight, nextHeight);
                  const heightDiff = nextHeight - clampedNextHeight;
                  contentWrapper.style.height = clampedNextHeight + "px";
                  if (contentWrapper.style.bottom === "0px") {
                    viewport.scrollTop = heightDiff > 0 ? heightDiff : 0;
                    contentWrapper.style.justifyContent = "flex-end";
                  }
                }
              }
            }
            prevScrollTopRef.current = viewport.scrollTop;
          })
        }
      ) })
    ] });
  }
);
SelectViewport.displayName = VIEWPORT_NAME$1;
var GROUP_NAME = "SelectGroup";
var [SelectGroupContextProvider, useSelectGroupContext] = createSelectContext(GROUP_NAME);
var SelectGroup$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...groupProps } = props;
    const groupId = useId();
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SelectGroupContextProvider, { scope: __scopeSelect, id: groupId, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { role: "group", "aria-labelledby": groupId, ...groupProps, ref: forwardedRef }) });
  }
);
SelectGroup$1.displayName = GROUP_NAME;
var LABEL_NAME = "SelectLabel";
var SelectLabel$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...labelProps } = props;
    const groupContext = useSelectGroupContext(LABEL_NAME, __scopeSelect);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { id: groupContext.id, ...labelProps, ref: forwardedRef });
  }
);
SelectLabel$1.displayName = LABEL_NAME;
var ITEM_NAME = "SelectItem";
var [SelectItemContextProvider, useSelectItemContext] = createSelectContext(ITEM_NAME);
var SelectItem$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSelect,
      value,
      disabled = false,
      textValue: textValueProp,
      ...itemProps
    } = props;
    const context = useSelectContext(ITEM_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_NAME, __scopeSelect);
    const isSelected = context.value === value;
    const [textValue, setTextValue] = reactExports.useState(textValueProp ?? "");
    const [isFocused, setIsFocused] = reactExports.useState(false);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => contentContext.itemRefCallback?.(node, value, disabled)
    );
    const textId = useId();
    const pointerTypeRef = reactExports.useRef("touch");
    const handleSelect = () => {
      if (!disabled) {
        context.onValueChange(value);
        context.onOpenChange(false);
      }
    };
    if (value === "") {
      throw new Error(
        "A <Select.Item /> must have a value prop that is not an empty string. This is because the Select value can be set to an empty string to clear the selection and show the placeholder."
      );
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SelectItemContextProvider,
      {
        scope: __scopeSelect,
        value,
        disabled,
        textId,
        isSelected,
        onItemTextChange: reactExports.useCallback((node) => {
          setTextValue((prevTextValue) => prevTextValue || (node?.textContent ?? "").trim());
        }, []),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Collection$1.ItemSlot,
          {
            scope: __scopeSelect,
            value,
            disabled,
            textValue,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              Primitive.div,
              {
                role: "option",
                "aria-labelledby": textId,
                "data-highlighted": isFocused ? "" : void 0,
                "aria-selected": isSelected && isFocused,
                "data-state": isSelected ? "checked" : "unchecked",
                "aria-disabled": disabled || void 0,
                "data-disabled": disabled ? "" : void 0,
                tabIndex: disabled ? void 0 : -1,
                ...itemProps,
                ref: composedRefs,
                onFocus: composeEventHandlers(itemProps.onFocus, () => setIsFocused(true)),
                onBlur: composeEventHandlers(itemProps.onBlur, () => setIsFocused(false)),
                onClick: composeEventHandlers(itemProps.onClick, () => {
                  if (pointerTypeRef.current !== "mouse") handleSelect();
                }),
                onPointerUp: composeEventHandlers(itemProps.onPointerUp, () => {
                  if (pointerTypeRef.current === "mouse") handleSelect();
                }),
                onPointerDown: composeEventHandlers(itemProps.onPointerDown, (event) => {
                  pointerTypeRef.current = event.pointerType;
                }),
                onPointerMove: composeEventHandlers(itemProps.onPointerMove, (event) => {
                  pointerTypeRef.current = event.pointerType;
                  if (disabled) {
                    contentContext.onItemLeave?.();
                  } else if (pointerTypeRef.current === "mouse") {
                    event.currentTarget.focus({ preventScroll: true });
                  }
                }),
                onPointerLeave: composeEventHandlers(itemProps.onPointerLeave, (event) => {
                  if (event.currentTarget === document.activeElement) {
                    contentContext.onItemLeave?.();
                  }
                }),
                onKeyDown: composeEventHandlers(itemProps.onKeyDown, (event) => {
                  const isTypingAhead = contentContext.searchRef?.current !== "";
                  if (isTypingAhead && event.key === " ") return;
                  if (SELECTION_KEYS.includes(event.key)) handleSelect();
                  if (event.key === " ") event.preventDefault();
                })
              }
            )
          }
        )
      }
    );
  }
);
SelectItem$1.displayName = ITEM_NAME;
var ITEM_TEXT_NAME = "SelectItemText";
var SelectItemText = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, className, style, ...itemTextProps } = props;
    const context = useSelectContext(ITEM_TEXT_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ITEM_TEXT_NAME, __scopeSelect);
    const itemContext = useSelectItemContext(ITEM_TEXT_NAME, __scopeSelect);
    const nativeOptionsContext = useSelectNativeOptionsContext(ITEM_TEXT_NAME, __scopeSelect);
    const [itemTextNode, setItemTextNode] = reactExports.useState(null);
    const composedRefs = useComposedRefs(
      forwardedRef,
      (node) => setItemTextNode(node),
      itemContext.onItemTextChange,
      (node) => contentContext.itemTextRefCallback?.(node, itemContext.value, itemContext.disabled)
    );
    const textContent = itemTextNode?.textContent;
    const nativeOption = reactExports.useMemo(
      () => /* @__PURE__ */ jsxRuntimeExports.jsx("option", { value: itemContext.value, disabled: itemContext.disabled, children: textContent }, itemContext.value),
      [itemContext.disabled, itemContext.value, textContent]
    );
    const { onNativeOptionAdd, onNativeOptionRemove } = nativeOptionsContext;
    useLayoutEffect2(() => {
      onNativeOptionAdd(nativeOption);
      return () => onNativeOptionRemove(nativeOption);
    }, [onNativeOptionAdd, onNativeOptionRemove, nativeOption]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { id: itemContext.textId, ...itemTextProps, ref: composedRefs }),
      itemContext.isSelected && context.valueNode && !context.valueNodeHasChildren ? reactDomExports.createPortal(itemTextProps.children, context.valueNode) : null
    ] });
  }
);
SelectItemText.displayName = ITEM_TEXT_NAME;
var ITEM_INDICATOR_NAME = "SelectItemIndicator";
var SelectItemIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...itemIndicatorProps } = props;
    const itemContext = useSelectItemContext(ITEM_INDICATOR_NAME, __scopeSelect);
    return itemContext.isSelected ? /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.span, { "aria-hidden": true, ...itemIndicatorProps, ref: forwardedRef }) : null;
  }
);
SelectItemIndicator.displayName = ITEM_INDICATOR_NAME;
var SCROLL_UP_BUTTON_NAME = "SelectScrollUpButton";
var SelectScrollUpButton$1 = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_UP_BUTTON_NAME, props.__scopeSelect);
  const [canScrollUp, setCanScrollUp] = reactExports.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const canScrollUp2 = viewport.scrollTop > 0;
        setCanScrollUp(canScrollUp2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollUp ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop - selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollUpButton$1.displayName = SCROLL_UP_BUTTON_NAME;
var SCROLL_DOWN_BUTTON_NAME = "SelectScrollDownButton";
var SelectScrollDownButton$1 = reactExports.forwardRef((props, forwardedRef) => {
  const contentContext = useSelectContentContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const viewportContext = useSelectViewportContext(SCROLL_DOWN_BUTTON_NAME, props.__scopeSelect);
  const [canScrollDown, setCanScrollDown] = reactExports.useState(false);
  const composedRefs = useComposedRefs(forwardedRef, viewportContext.onScrollButtonChange);
  useLayoutEffect2(() => {
    if (contentContext.viewport && contentContext.isPositioned) {
      let handleScroll2 = function() {
        const maxScroll = viewport.scrollHeight - viewport.clientHeight;
        const canScrollDown2 = Math.ceil(viewport.scrollTop) < maxScroll;
        setCanScrollDown(canScrollDown2);
      };
      const viewport = contentContext.viewport;
      handleScroll2();
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [contentContext.viewport, contentContext.isPositioned]);
  return canScrollDown ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    SelectScrollButtonImpl,
    {
      ...props,
      ref: composedRefs,
      onAutoScroll: () => {
        const { viewport, selectedItem } = contentContext;
        if (viewport && selectedItem) {
          viewport.scrollTop = viewport.scrollTop + selectedItem.offsetHeight;
        }
      }
    }
  ) : null;
});
SelectScrollDownButton$1.displayName = SCROLL_DOWN_BUTTON_NAME;
var SelectScrollButtonImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeSelect, onAutoScroll, ...scrollIndicatorProps } = props;
  const contentContext = useSelectContentContext("SelectScrollButton", __scopeSelect);
  const autoScrollTimerRef = reactExports.useRef(null);
  const getItems = useCollection$1(__scopeSelect);
  const clearAutoScrollTimer = reactExports.useCallback(() => {
    if (autoScrollTimerRef.current !== null) {
      window.clearInterval(autoScrollTimerRef.current);
      autoScrollTimerRef.current = null;
    }
  }, []);
  reactExports.useEffect(() => {
    return () => clearAutoScrollTimer();
  }, [clearAutoScrollTimer]);
  useLayoutEffect2(() => {
    const activeItem = getItems().find((item) => item.ref.current === document.activeElement);
    activeItem?.ref.current?.scrollIntoView({ block: "nearest" });
  }, [getItems]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      "aria-hidden": true,
      ...scrollIndicatorProps,
      ref: forwardedRef,
      style: { flexShrink: 0, ...scrollIndicatorProps.style },
      onPointerDown: composeEventHandlers(scrollIndicatorProps.onPointerDown, () => {
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerMove: composeEventHandlers(scrollIndicatorProps.onPointerMove, () => {
        contentContext.onItemLeave?.();
        if (autoScrollTimerRef.current === null) {
          autoScrollTimerRef.current = window.setInterval(onAutoScroll, 50);
        }
      }),
      onPointerLeave: composeEventHandlers(scrollIndicatorProps.onPointerLeave, () => {
        clearAutoScrollTimer();
      })
    }
  );
});
var SEPARATOR_NAME = "SelectSeparator";
var SelectSeparator$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...separatorProps } = props;
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.div, { "aria-hidden": true, ...separatorProps, ref: forwardedRef });
  }
);
SelectSeparator$1.displayName = SEPARATOR_NAME;
var ARROW_NAME = "SelectArrow";
var SelectArrow = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSelect, ...arrowProps } = props;
    const popperScope = usePopperScope(__scopeSelect);
    const context = useSelectContext(ARROW_NAME, __scopeSelect);
    const contentContext = useSelectContentContext(ARROW_NAME, __scopeSelect);
    return context.open && contentContext.position === "popper" ? /* @__PURE__ */ jsxRuntimeExports.jsx(Arrow, { ...popperScope, ...arrowProps, ref: forwardedRef }) : null;
  }
);
SelectArrow.displayName = ARROW_NAME;
function shouldShowPlaceholder(value) {
  return value === "" || value === void 0;
}
var BubbleSelect = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { value, ...selectProps } = props;
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const prevValue = usePrevious(value);
    reactExports.useEffect(() => {
      const select = ref.current;
      const selectProto = window.HTMLSelectElement.prototype;
      const descriptor = Object.getOwnPropertyDescriptor(
        selectProto,
        "value"
      );
      const setValue = descriptor.set;
      if (prevValue !== value && setValue) {
        const event = new Event("change", { bubbles: true });
        setValue.call(select, value);
        select.dispatchEvent(event);
      }
    }, [prevValue, value]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(VisuallyHidden, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx("select", { ...selectProps, ref: composedRefs, defaultValue: value }) });
  }
);
BubbleSelect.displayName = "BubbleSelect";
function useTypeaheadSearch(onSearchChange) {
  const handleSearchChange = useCallbackRef$1(onSearchChange);
  const searchRef = reactExports.useRef("");
  const timerRef = reactExports.useRef(0);
  const handleTypeaheadSearch = reactExports.useCallback(
    (key) => {
      const search = searchRef.current + key;
      handleSearchChange(search);
      (function updateSearch(value) {
        searchRef.current = value;
        window.clearTimeout(timerRef.current);
        if (value !== "") timerRef.current = window.setTimeout(() => updateSearch(""), 1e3);
      })(search);
    },
    [handleSearchChange]
  );
  const resetTypeahead = reactExports.useCallback(() => {
    searchRef.current = "";
    window.clearTimeout(timerRef.current);
  }, []);
  reactExports.useEffect(() => {
    return () => window.clearTimeout(timerRef.current);
  }, []);
  return [searchRef, handleTypeaheadSearch, resetTypeahead];
}
function findNextItem(items, search, currentItem) {
  const isRepeated = search.length > 1 && Array.from(search).every((char) => char === search[0]);
  const normalizedSearch = isRepeated ? search[0] : search;
  const currentItemIndex = currentItem ? items.indexOf(currentItem) : -1;
  let wrappedItems = wrapArray(items, Math.max(currentItemIndex, 0));
  const excludeCurrentItem = normalizedSearch.length === 1;
  if (excludeCurrentItem) wrappedItems = wrappedItems.filter((v2) => v2 !== currentItem);
  const nextItem = wrappedItems.find(
    (item) => item.textValue.toLowerCase().startsWith(normalizedSearch.toLowerCase())
  );
  return nextItem !== currentItem ? nextItem : void 0;
}
function wrapArray(array, startIndex) {
  return array.map((_2, index2) => array[(startIndex + index2) % array.length]);
}
var Root2 = Select$1;
var Trigger$1 = SelectTrigger$1;
var Value = SelectValue$1;
var Icon$1 = SelectIcon;
var Portal$1 = SelectPortal;
var Content2 = SelectContent$1;
var Viewport$1 = SelectViewport;
var Group = SelectGroup$1;
var Label$2 = SelectLabel$1;
var Item = SelectItem$1;
var ItemText = SelectItemText;
var ItemIndicator = SelectItemIndicator;
var ScrollUpButton = SelectScrollUpButton$1;
var ScrollDownButton = SelectScrollDownButton$1;
var Separator = SelectSeparator$1;
function r$3(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (f2 = r$3(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  } else for (f2 in e2) e2[f2] && (n2 && (n2 += " "), n2 += f2);
  return n2;
}
function clsx$1() {
  for (var e2, t2, f2 = 0, n2 = "", o2 = arguments.length; f2 < o2; f2++) (e2 = arguments[f2]) && (t2 = r$3(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const CLASS_PART_SEPARATOR = "-";
const createClassGroupUtils = (config) => {
  const classMap = createClassMap(config);
  const {
    conflictingClassGroups,
    conflictingClassGroupModifiers
  } = config;
  const getClassGroupId = (className) => {
    const classParts = className.split(CLASS_PART_SEPARATOR);
    if (classParts[0] === "" && classParts.length !== 1) {
      classParts.shift();
    }
    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);
  };
  const getConflictingClassGroupIds = (classGroupId, hasPostfixModifier) => {
    const conflicts = conflictingClassGroups[classGroupId] || [];
    if (hasPostfixModifier && conflictingClassGroupModifiers[classGroupId]) {
      return [...conflicts, ...conflictingClassGroupModifiers[classGroupId]];
    }
    return conflicts;
  };
  return {
    getClassGroupId,
    getConflictingClassGroupIds
  };
};
const getGroupRecursive = (classParts, classPartObject) => {
  if (classParts.length === 0) {
    return classPartObject.classGroupId;
  }
  const currentClassPart = classParts[0];
  const nextClassPartObject = classPartObject.nextPart.get(currentClassPart);
  const classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : void 0;
  if (classGroupFromNextClassPart) {
    return classGroupFromNextClassPart;
  }
  if (classPartObject.validators.length === 0) {
    return void 0;
  }
  const classRest = classParts.join(CLASS_PART_SEPARATOR);
  return classPartObject.validators.find(({
    validator
  }) => validator(classRest))?.classGroupId;
};
const arbitraryPropertyRegex = /^\[(.+)\]$/;
const getGroupIdForArbitraryProperty = (className) => {
  if (arbitraryPropertyRegex.test(className)) {
    const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];
    const property = arbitraryPropertyClassName?.substring(0, arbitraryPropertyClassName.indexOf(":"));
    if (property) {
      return "arbitrary.." + property;
    }
  }
};
const createClassMap = (config) => {
  const {
    theme,
    prefix: prefix2
  } = config;
  const classMap = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  const prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix2);
  prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {
    processClassesRecursively(classGroup, classMap, classGroupId, theme);
  });
  return classMap;
};
const processClassesRecursively = (classGroup, classPartObject, classGroupId, theme) => {
  classGroup.forEach((classDefinition) => {
    if (typeof classDefinition === "string") {
      const classPartObjectToEdit = classDefinition === "" ? classPartObject : getPart(classPartObject, classDefinition);
      classPartObjectToEdit.classGroupId = classGroupId;
      return;
    }
    if (typeof classDefinition === "function") {
      if (isThemeGetter(classDefinition)) {
        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);
        return;
      }
      classPartObject.validators.push({
        validator: classDefinition,
        classGroupId
      });
      return;
    }
    Object.entries(classDefinition).forEach(([key, classGroup2]) => {
      processClassesRecursively(classGroup2, getPart(classPartObject, key), classGroupId, theme);
    });
  });
};
const getPart = (classPartObject, path2) => {
  let currentClassPartObject = classPartObject;
  path2.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {
    if (!currentClassPartObject.nextPart.has(pathPart)) {
      currentClassPartObject.nextPart.set(pathPart, {
        nextPart: /* @__PURE__ */ new Map(),
        validators: []
      });
    }
    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);
  });
  return currentClassPartObject;
};
const isThemeGetter = (func) => func.isThemeGetter;
const getPrefixedClassGroupEntries = (classGroupEntries, prefix2) => {
  if (!prefix2) {
    return classGroupEntries;
  }
  return classGroupEntries.map(([classGroupId, classGroup]) => {
    const prefixedClassGroup = classGroup.map((classDefinition) => {
      if (typeof classDefinition === "string") {
        return prefix2 + classDefinition;
      }
      if (typeof classDefinition === "object") {
        return Object.fromEntries(Object.entries(classDefinition).map(([key, value]) => [prefix2 + key, value]));
      }
      return classDefinition;
    });
    return [classGroupId, prefixedClassGroup];
  });
};
const createLruCache = (maxCacheSize) => {
  if (maxCacheSize < 1) {
    return {
      get: () => void 0,
      set: () => {
      }
    };
  }
  let cacheSize = 0;
  let cache = /* @__PURE__ */ new Map();
  let previousCache = /* @__PURE__ */ new Map();
  const update = (key, value) => {
    cache.set(key, value);
    cacheSize++;
    if (cacheSize > maxCacheSize) {
      cacheSize = 0;
      previousCache = cache;
      cache = /* @__PURE__ */ new Map();
    }
  };
  return {
    get(key) {
      let value = cache.get(key);
      if (value !== void 0) {
        return value;
      }
      if ((value = previousCache.get(key)) !== void 0) {
        update(key, value);
        return value;
      }
    },
    set(key, value) {
      if (cache.has(key)) {
        cache.set(key, value);
      } else {
        update(key, value);
      }
    }
  };
};
const IMPORTANT_MODIFIER = "!";
const createParseClassName = (config) => {
  const {
    separator,
    experimentalParseClassName
  } = config;
  const isSeparatorSingleCharacter = separator.length === 1;
  const firstSeparatorCharacter = separator[0];
  const separatorLength = separator.length;
  const parseClassName = (className) => {
    const modifiers = [];
    let bracketDepth = 0;
    let modifierStart = 0;
    let postfixModifierPosition;
    for (let index2 = 0; index2 < className.length; index2++) {
      let currentCharacter = className[index2];
      if (bracketDepth === 0) {
        if (currentCharacter === firstSeparatorCharacter && (isSeparatorSingleCharacter || className.slice(index2, index2 + separatorLength) === separator)) {
          modifiers.push(className.slice(modifierStart, index2));
          modifierStart = index2 + separatorLength;
          continue;
        }
        if (currentCharacter === "/") {
          postfixModifierPosition = index2;
          continue;
        }
      }
      if (currentCharacter === "[") {
        bracketDepth++;
      } else if (currentCharacter === "]") {
        bracketDepth--;
      }
    }
    const baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);
    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);
    const baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;
    const maybePostfixModifierPosition = postfixModifierPosition && postfixModifierPosition > modifierStart ? postfixModifierPosition - modifierStart : void 0;
    return {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    };
  };
  if (experimentalParseClassName) {
    return (className) => experimentalParseClassName({
      className,
      parseClassName
    });
  }
  return parseClassName;
};
const sortModifiers = (modifiers) => {
  if (modifiers.length <= 1) {
    return modifiers;
  }
  const sortedModifiers = [];
  let unsortedModifiers = [];
  modifiers.forEach((modifier) => {
    const isArbitraryVariant = modifier[0] === "[";
    if (isArbitraryVariant) {
      sortedModifiers.push(...unsortedModifiers.sort(), modifier);
      unsortedModifiers = [];
    } else {
      unsortedModifiers.push(modifier);
    }
  });
  sortedModifiers.push(...unsortedModifiers.sort());
  return sortedModifiers;
};
const createConfigUtils = (config) => ({
  cache: createLruCache(config.cacheSize),
  parseClassName: createParseClassName(config),
  ...createClassGroupUtils(config)
});
const SPLIT_CLASSES_REGEX = /\s+/;
const mergeClassList = (classList, configUtils) => {
  const {
    parseClassName,
    getClassGroupId,
    getConflictingClassGroupIds
  } = configUtils;
  const classGroupsInConflict = [];
  const classNames = classList.trim().split(SPLIT_CLASSES_REGEX);
  let result = "";
  for (let index2 = classNames.length - 1; index2 >= 0; index2 -= 1) {
    const originalClassName = classNames[index2];
    const {
      modifiers,
      hasImportantModifier,
      baseClassName,
      maybePostfixModifierPosition
    } = parseClassName(originalClassName);
    let hasPostfixModifier = Boolean(maybePostfixModifierPosition);
    let classGroupId = getClassGroupId(hasPostfixModifier ? baseClassName.substring(0, maybePostfixModifierPosition) : baseClassName);
    if (!classGroupId) {
      if (!hasPostfixModifier) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      classGroupId = getClassGroupId(baseClassName);
      if (!classGroupId) {
        result = originalClassName + (result.length > 0 ? " " + result : result);
        continue;
      }
      hasPostfixModifier = false;
    }
    const variantModifier = sortModifiers(modifiers).join(":");
    const modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;
    const classId = modifierId + classGroupId;
    if (classGroupsInConflict.includes(classId)) {
      continue;
    }
    classGroupsInConflict.push(classId);
    const conflictGroups = getConflictingClassGroupIds(classGroupId, hasPostfixModifier);
    for (let i2 = 0; i2 < conflictGroups.length; ++i2) {
      const group = conflictGroups[i2];
      classGroupsInConflict.push(modifierId + group);
    }
    result = originalClassName + (result.length > 0 ? " " + result : result);
  }
  return result;
};
function twJoin() {
  let index2 = 0;
  let argument;
  let resolvedValue;
  let string = "";
  while (index2 < arguments.length) {
    if (argument = arguments[index2++]) {
      if (resolvedValue = toValue(argument)) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
}
const toValue = (mix) => {
  if (typeof mix === "string") {
    return mix;
  }
  let resolvedValue;
  let string = "";
  for (let k2 = 0; k2 < mix.length; k2++) {
    if (mix[k2]) {
      if (resolvedValue = toValue(mix[k2])) {
        string && (string += " ");
        string += resolvedValue;
      }
    }
  }
  return string;
};
function createTailwindMerge(createConfigFirst, ...createConfigRest) {
  let configUtils;
  let cacheGet;
  let cacheSet;
  let functionToCall = initTailwindMerge;
  function initTailwindMerge(classList) {
    const config = createConfigRest.reduce((previousConfig, createConfigCurrent) => createConfigCurrent(previousConfig), createConfigFirst());
    configUtils = createConfigUtils(config);
    cacheGet = configUtils.cache.get;
    cacheSet = configUtils.cache.set;
    functionToCall = tailwindMerge;
    return tailwindMerge(classList);
  }
  function tailwindMerge(classList) {
    const cachedResult = cacheGet(classList);
    if (cachedResult) {
      return cachedResult;
    }
    const result = mergeClassList(classList, configUtils);
    cacheSet(classList, result);
    return result;
  }
  return function callTailwindMerge() {
    return functionToCall(twJoin.apply(null, arguments));
  };
}
const fromTheme = (key) => {
  const themeGetter = (theme) => theme[key] || [];
  themeGetter.isThemeGetter = true;
  return themeGetter;
};
const arbitraryValueRegex = /^\[(?:([a-z-]+):)?(.+)\]$/i;
const fractionRegex = /^\d+\/\d+$/;
const stringLengths = /* @__PURE__ */ new Set(["px", "full", "screen"]);
const tshirtUnitRegex = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
const lengthUnitRegex = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
const colorFunctionRegex = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
const shadowRegex = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
const imageRegex = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
const isLength = (value) => isNumber(value) || stringLengths.has(value) || fractionRegex.test(value);
const isArbitraryLength = (value) => getIsArbitraryValue(value, "length", isLengthOnly);
const isNumber = (value) => Boolean(value) && !Number.isNaN(Number(value));
const isArbitraryNumber = (value) => getIsArbitraryValue(value, "number", isNumber);
const isInteger = (value) => Boolean(value) && Number.isInteger(Number(value));
const isPercent = (value) => value.endsWith("%") && isNumber(value.slice(0, -1));
const isArbitraryValue = (value) => arbitraryValueRegex.test(value);
const isTshirtSize = (value) => tshirtUnitRegex.test(value);
const sizeLabels = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
const isArbitrarySize = (value) => getIsArbitraryValue(value, sizeLabels, isNever);
const isArbitraryPosition = (value) => getIsArbitraryValue(value, "position", isNever);
const imageLabels = /* @__PURE__ */ new Set(["image", "url"]);
const isArbitraryImage = (value) => getIsArbitraryValue(value, imageLabels, isImage);
const isArbitraryShadow = (value) => getIsArbitraryValue(value, "", isShadow);
const isAny = () => true;
const getIsArbitraryValue = (value, label, testValue) => {
  const result = arbitraryValueRegex.exec(value);
  if (result) {
    if (result[1]) {
      return typeof label === "string" ? result[1] === label : label.has(result[1]);
    }
    return testValue(result[2]);
  }
  return false;
};
const isLengthOnly = (value) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  lengthUnitRegex.test(value) && !colorFunctionRegex.test(value)
);
const isNever = () => false;
const isShadow = (value) => shadowRegex.test(value);
const isImage = (value) => imageRegex.test(value);
const getDefaultConfig = () => {
  const colors = fromTheme("colors");
  const spacing = fromTheme("spacing");
  const blur = fromTheme("blur");
  const brightness = fromTheme("brightness");
  const borderColor = fromTheme("borderColor");
  const borderRadius = fromTheme("borderRadius");
  const borderSpacing = fromTheme("borderSpacing");
  const borderWidth = fromTheme("borderWidth");
  const contrast = fromTheme("contrast");
  const grayscale = fromTheme("grayscale");
  const hueRotate = fromTheme("hueRotate");
  const invert = fromTheme("invert");
  const gap = fromTheme("gap");
  const gradientColorStops = fromTheme("gradientColorStops");
  const gradientColorStopPositions = fromTheme("gradientColorStopPositions");
  const inset = fromTheme("inset");
  const margin = fromTheme("margin");
  const opacity = fromTheme("opacity");
  const padding = fromTheme("padding");
  const saturate = fromTheme("saturate");
  const scale = fromTheme("scale");
  const sepia = fromTheme("sepia");
  const skew = fromTheme("skew");
  const space = fromTheme("space");
  const translate = fromTheme("translate");
  const getOverscroll = () => ["auto", "contain", "none"];
  const getOverflow = () => ["auto", "hidden", "clip", "visible", "scroll"];
  const getSpacingWithAutoAndArbitrary = () => ["auto", isArbitraryValue, spacing];
  const getSpacingWithArbitrary = () => [isArbitraryValue, spacing];
  const getLengthWithEmptyAndArbitrary = () => ["", isLength, isArbitraryLength];
  const getNumberWithAutoAndArbitrary = () => ["auto", isNumber, isArbitraryValue];
  const getPositions = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"];
  const getLineStyles = () => ["solid", "dashed", "dotted", "double", "none"];
  const getBlendModes = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
  const getAlign = () => ["start", "end", "center", "between", "around", "evenly", "stretch"];
  const getZeroAndEmpty = () => ["", "0", isArbitraryValue];
  const getBreaks = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"];
  const getNumberAndArbitrary = () => [isNumber, isArbitraryValue];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [isAny],
      spacing: [isLength, isArbitraryLength],
      blur: ["none", "", isTshirtSize, isArbitraryValue],
      brightness: getNumberAndArbitrary(),
      borderColor: [colors],
      borderRadius: ["none", "", "full", isTshirtSize, isArbitraryValue],
      borderSpacing: getSpacingWithArbitrary(),
      borderWidth: getLengthWithEmptyAndArbitrary(),
      contrast: getNumberAndArbitrary(),
      grayscale: getZeroAndEmpty(),
      hueRotate: getNumberAndArbitrary(),
      invert: getZeroAndEmpty(),
      gap: getSpacingWithArbitrary(),
      gradientColorStops: [colors],
      gradientColorStopPositions: [isPercent, isArbitraryLength],
      inset: getSpacingWithAutoAndArbitrary(),
      margin: getSpacingWithAutoAndArbitrary(),
      opacity: getNumberAndArbitrary(),
      padding: getSpacingWithArbitrary(),
      saturate: getNumberAndArbitrary(),
      scale: getNumberAndArbitrary(),
      sepia: getZeroAndEmpty(),
      skew: getNumberAndArbitrary(),
      space: getSpacingWithArbitrary(),
      translate: getSpacingWithArbitrary()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", isArbitraryValue]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [isTshirtSize]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": getBreaks()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": getBreaks()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...getPositions(), isArbitraryValue]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: getOverflow()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": getOverflow()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": getOverflow()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: getOverscroll()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": getOverscroll()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": getOverscroll()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [inset]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [inset]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [inset]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [inset]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [inset]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [inset]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [inset]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [inset]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [inset]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", isInteger, isArbitraryValue]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: getSpacingWithAutoAndArbitrary()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", isArbitraryValue]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: getZeroAndEmpty()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: getZeroAndEmpty()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", isInteger, isArbitraryValue]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [isAny]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [isAny]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [isInteger, isArbitraryValue]
        }, isArbitraryValue]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": getNumberWithAutoAndArbitrary()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", isArbitraryValue]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [gap]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [gap]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [gap]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...getAlign()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...getAlign(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...getAlign(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [padding]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [padding]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [padding]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [padding]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [padding]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [padding]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [padding]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [padding]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [padding]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [margin]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [margin]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [margin]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [margin]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [margin]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [margin]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [margin]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [margin]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [margin]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [space]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [space]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", isArbitraryValue, spacing]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [isArbitraryValue, spacing, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [isArbitraryValue, spacing, "none", "full", "min", "max", "fit", "prose", {
          screen: [isTshirtSize]
        }, isTshirtSize]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [isArbitraryValue, spacing, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [isArbitraryValue, spacing, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [isArbitraryValue, spacing, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", isTshirtSize, isArbitraryLength]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", isArbitraryNumber]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [isAny]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractons"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", isArbitraryValue]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", isNumber, isArbitraryNumber]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", isLength, isArbitraryValue]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", isArbitraryValue]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", isArbitraryValue]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [colors]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [opacity]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [colors]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [opacity]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...getLineStyles(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", isLength, isArbitraryLength]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", isLength, isArbitraryValue]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [colors]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: getSpacingWithArbitrary()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", isArbitraryValue]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", isArbitraryValue]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [opacity]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...getPositions(), isArbitraryPosition]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", isArbitrarySize]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, isArbitraryImage]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [colors]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [gradientColorStopPositions]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [gradientColorStops]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [gradientColorStops]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [borderRadius]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [borderRadius]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [borderRadius]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [borderRadius]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [borderRadius]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [borderRadius]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [borderRadius]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [borderRadius]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [borderRadius]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [borderRadius]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [borderRadius]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [borderRadius]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [borderRadius]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [borderRadius]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [borderRadius]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [borderWidth]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [borderWidth]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [borderWidth]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [borderWidth]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [borderWidth]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [borderWidth]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [borderWidth]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [borderWidth]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [borderWidth]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [opacity]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...getLineStyles(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [borderWidth]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [borderWidth]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [opacity]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: getLineStyles()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [borderColor]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [borderColor]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [borderColor]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [borderColor]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [borderColor]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [borderColor]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [borderColor]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [borderColor]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [borderColor]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [borderColor]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...getLineStyles()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [isLength, isArbitraryValue]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [isLength, isArbitraryLength]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [colors]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: getLengthWithEmptyAndArbitrary()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [colors]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [opacity]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [isLength, isArbitraryLength]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [colors]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", isTshirtSize, isArbitraryShadow]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [isAny]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [opacity]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...getBlendModes(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": getBlendModes()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [blur]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [brightness]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [contrast]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", isTshirtSize, isArbitraryValue]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [grayscale]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [hueRotate]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [invert]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [saturate]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [sepia]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [blur]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [brightness]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [contrast]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [grayscale]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [hueRotate]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [invert]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [opacity]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [saturate]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [sepia]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [borderSpacing]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [borderSpacing]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [borderSpacing]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", isArbitraryValue]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: getNumberAndArbitrary()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", isArbitraryValue]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: getNumberAndArbitrary()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", isArbitraryValue]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [scale]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [scale]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [scale]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [isInteger, isArbitraryValue]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [translate]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [translate]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [skew]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [skew]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", isArbitraryValue]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", colors]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", isArbitraryValue]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [colors]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": getSpacingWithArbitrary()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", isArbitraryValue]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [colors, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [isLength, isArbitraryLength, isArbitraryNumber]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [colors, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
const twMerge = /* @__PURE__ */ createTailwindMerge(getDefaultConfig);
function cn(...inputs) {
  return twMerge(clsx$1(inputs));
}
const Select = Root2;
const SelectGroup = Group;
const SelectValue = Value;
const SelectTrigger = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Trigger$1,
  {
    ref,
    className: cn(
      "flex h-9 w-full items-center justify-between whitespace-nowrap rounded-md border border-input bg-transparent px-3 py-2 text-sm shadow-sm ring-offset-background placeholder:text-muted-foreground focus:outline-none focus:ring-1 focus:ring-ring disabled:cursor-not-allowed disabled:opacity-50 [&>span]:line-clamp-1",
      className
    ),
    ...props,
    children: [
      children,
      /* @__PURE__ */ jsxRuntimeExports.jsx(Icon$1, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(CaretSortIcon, { className: "h-4 w-4 opacity-50" }) })
    ]
  }
));
SelectTrigger.displayName = Trigger$1.displayName;
const SelectScrollUpButton = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollUpButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronUpIcon, {})
  }
));
SelectScrollUpButton.displayName = ScrollUpButton.displayName;
const SelectScrollDownButton = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollDownButton,
  {
    ref,
    className: cn(
      "flex cursor-default items-center justify-center py-1",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronDownIcon, {})
  }
));
SelectScrollDownButton.displayName = ScrollDownButton.displayName;
const SelectContent = reactExports.forwardRef(({ className, children, position = "popper", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$1, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Content2,
  {
    ref,
    className: cn(
      "relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border bg-popover text-popover-foreground shadow-md data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2",
      position === "popper" && "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
      className
    ),
    position,
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollUpButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Viewport$1,
        {
          className: cn(
            "p-1",
            position === "popper" && "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)]"
          ),
          children
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectScrollDownButton, {})
    ]
  }
) }));
SelectContent.displayName = Content2.displayName;
const SelectLabel = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Label$2,
  {
    ref,
    className: cn("px-2 py-1.5 text-sm font-semibold", className),
    ...props
  }
));
SelectLabel.displayName = Label$2.displayName;
const SelectItem = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Item,
  {
    ref,
    className: cn(
      "relative flex w-full cursor-default select-none items-center rounded-sm py-1.5 pl-2 pr-8 text-sm outline-none focus:bg-accent focus:text-accent-foreground data-[disabled]:pointer-events-none data-[disabled]:opacity-50",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "absolute right-2 flex h-3.5 w-3.5 items-center justify-center", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ItemIndicator, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(CheckIcon, { className: "h-4 w-4" }) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ItemText, { children })
    ]
  }
));
SelectItem.displayName = Item.displayName;
const SelectSeparator = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Separator,
  {
    ref,
    className: cn("-mx-1 my-1 h-px bg-muted", className),
    ...props
  }
));
SelectSeparator.displayName = Separator.displayName;
const SpeedToggleButton = reactExports.memo(function SpeedToggleButton2({
  duration,
  onValueChange
}) {
  const { t: t2 } = useTranslation("SpeedToggleButton");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Select, { value: (250 / duration).toString(), onValueChange, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectGroup, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectLabel, { children: t2("speed") }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: Number.MAX_SAFE_INTEGER.toString(), children: "Max" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "4", children: "4x" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "2", children: "2x" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "1", children: "1x" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "0.5", children: "0.5x" }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: "0.25", children: "0.25x" })
    ] }) })
  ] });
});
function r$2(e2) {
  var t2, f2, n2 = "";
  if ("string" == typeof e2 || "number" == typeof e2) n2 += e2;
  else if ("object" == typeof e2) if (Array.isArray(e2)) for (t2 = 0; t2 < e2.length; t2++) e2[t2] && (f2 = r$2(e2[t2])) && (n2 && (n2 += " "), n2 += f2);
  else for (t2 in e2) e2[t2] && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
function clsx() {
  for (var e2, t2, f2 = 0, n2 = ""; f2 < arguments.length; ) (e2 = arguments[f2++]) && (t2 = r$2(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
const falsyToString = (value) => typeof value === "boolean" ? "".concat(value) : value === 0 ? "0" : value;
const cx = clsx;
const cva = (base, config) => {
  return (props) => {
    var ref;
    if ((config === null || config === void 0 ? void 0 : config.variants) == null) return cx(base, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
    const { variants: variants2, defaultVariants } = config;
    const getVariantClassNames = Object.keys(variants2).map((variant) => {
      const variantProp = props === null || props === void 0 ? void 0 : props[variant];
      const defaultVariantProp = defaultVariants === null || defaultVariants === void 0 ? void 0 : defaultVariants[variant];
      if (variantProp === null) return null;
      const variantKey = falsyToString(variantProp) || falsyToString(defaultVariantProp);
      return variants2[variant][variantKey];
    });
    const propsWithoutUndefined = props && Object.entries(props).reduce((acc, param) => {
      let [key, value] = param;
      if (value === void 0) {
        return acc;
      }
      acc[key] = value;
      return acc;
    }, {});
    const getCompoundVariantClassNames = config === null || config === void 0 ? void 0 : (ref = config.compoundVariants) === null || ref === void 0 ? void 0 : ref.reduce((acc, param1) => {
      let { class: cvClass, className: cvClassName, ...compoundVariantOptions } = param1;
      return Object.entries(compoundVariantOptions).every((param) => {
        let [key, value] = param;
        return Array.isArray(value) ? value.includes({
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key]) : {
          ...defaultVariants,
          ...propsWithoutUndefined
        }[key] === value;
      }) ? [
        ...acc,
        cvClass,
        cvClassName
      ] : acc;
    }, []);
    return cx(base, getVariantClassNames, getCompoundVariantClassNames, props === null || props === void 0 ? void 0 : props.class, props === null || props === void 0 ? void 0 : props.className);
  };
};
const buttonVariants = cva(
  "inline-flex items-center justify-center whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        reversedOutline: "border text-primary-foreground border-input bg-primary shadow-sm hover:bg-primary/70",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
const Button = reactExports.forwardRef(
  ({ className, variant, size: size2, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button";
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Comp,
      {
        className: cn(buttonVariants({ variant, size: size2, className })),
        ref,
        ...props
      }
    );
  }
);
Button.displayName = "Button";
function useStateMachine$1(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var Presence = (props) => {
  const { present, children } = props;
  const presence = usePresence(present);
  const child = typeof children === "function" ? children({ present: presence.isPresent }) : reactExports.Children.only(children);
  const ref = useComposedRefs(presence.ref, getElementRef(child));
  const forceMount = typeof children === "function";
  return forceMount || presence.isPresent ? reactExports.cloneElement(child, { ref }) : null;
};
Presence.displayName = "Presence";
function usePresence(present) {
  const [node, setNode] = reactExports.useState();
  const stylesRef = reactExports.useRef({});
  const prevPresentRef = reactExports.useRef(present);
  const prevAnimationNameRef = reactExports.useRef("none");
  const initialState2 = present ? "mounted" : "unmounted";
  const [state, send] = useStateMachine$1(initialState2, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  reactExports.useEffect(() => {
    const currentAnimationName = getAnimationName(stylesRef.current);
    prevAnimationNameRef.current = state === "mounted" ? currentAnimationName : "none";
  }, [state]);
  useLayoutEffect2(() => {
    const styles = stylesRef.current;
    const wasPresent = prevPresentRef.current;
    const hasPresentChanged = wasPresent !== present;
    if (hasPresentChanged) {
      const prevAnimationName = prevAnimationNameRef.current;
      const currentAnimationName = getAnimationName(styles);
      if (present) {
        send("MOUNT");
      } else if (currentAnimationName === "none" || styles?.display === "none") {
        send("UNMOUNT");
      } else {
        const isAnimating = prevAnimationName !== currentAnimationName;
        if (wasPresent && isAnimating) {
          send("ANIMATION_OUT");
        } else {
          send("UNMOUNT");
        }
      }
      prevPresentRef.current = present;
    }
  }, [present, send]);
  useLayoutEffect2(() => {
    if (node) {
      let timeoutId;
      const ownerWindow = node.ownerDocument.defaultView ?? window;
      const handleAnimationEnd = (event) => {
        const currentAnimationName = getAnimationName(stylesRef.current);
        const isCurrentAnimation = currentAnimationName.includes(event.animationName);
        if (event.target === node && isCurrentAnimation) {
          send("ANIMATION_END");
          if (!prevPresentRef.current) {
            const currentFillMode = node.style.animationFillMode;
            node.style.animationFillMode = "forwards";
            timeoutId = ownerWindow.setTimeout(() => {
              if (node.style.animationFillMode === "forwards") {
                node.style.animationFillMode = currentFillMode;
              }
            });
          }
        }
      };
      const handleAnimationStart = (event) => {
        if (event.target === node) {
          prevAnimationNameRef.current = getAnimationName(stylesRef.current);
        }
      };
      node.addEventListener("animationstart", handleAnimationStart);
      node.addEventListener("animationcancel", handleAnimationEnd);
      node.addEventListener("animationend", handleAnimationEnd);
      return () => {
        ownerWindow.clearTimeout(timeoutId);
        node.removeEventListener("animationstart", handleAnimationStart);
        node.removeEventListener("animationcancel", handleAnimationEnd);
        node.removeEventListener("animationend", handleAnimationEnd);
      };
    } else {
      send("ANIMATION_END");
    }
  }, [node, send]);
  return {
    isPresent: ["mounted", "unmountSuspended"].includes(state),
    ref: reactExports.useCallback((node2) => {
      if (node2) stylesRef.current = getComputedStyle(node2);
      setNode(node2);
    }, [])
  };
}
function getAnimationName(styles) {
  return styles?.animationName || "none";
}
function getElementRef(element) {
  let getter = Object.getOwnPropertyDescriptor(element.props, "ref")?.get;
  let mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.ref;
  }
  getter = Object.getOwnPropertyDescriptor(element, "ref")?.get;
  mayWarn = getter && "isReactWarning" in getter && getter.isReactWarning;
  if (mayWarn) {
    return element.props.ref;
  }
  return element.props.ref || element.ref;
}
var DIALOG_NAME = "Dialog";
var [createDialogContext, createDialogScope] = createContextScope(DIALOG_NAME);
var [DialogProvider, useDialogContext] = createDialogContext(DIALOG_NAME);
var Dialog$1 = (props) => {
  const {
    __scopeDialog,
    children,
    open: openProp,
    defaultOpen,
    onOpenChange,
    modal = true
  } = props;
  const triggerRef = reactExports.useRef(null);
  const contentRef = reactExports.useRef(null);
  const [open = false, setOpen] = useControllableState({
    prop: openProp,
    defaultProp: defaultOpen,
    onChange: onOpenChange
  });
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    DialogProvider,
    {
      scope: __scopeDialog,
      triggerRef,
      contentRef,
      contentId: useId(),
      titleId: useId(),
      descriptionId: useId(),
      open,
      onOpenChange: setOpen,
      onOpenToggle: reactExports.useCallback(() => setOpen((prevOpen) => !prevOpen), [setOpen]),
      modal,
      children
    }
  );
};
Dialog$1.displayName = DIALOG_NAME;
var TRIGGER_NAME = "DialogTrigger";
var DialogTrigger$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...triggerProps } = props;
    const context = useDialogContext(TRIGGER_NAME, __scopeDialog);
    const composedTriggerRef = useComposedRefs(forwardedRef, context.triggerRef);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": context.open,
        "aria-controls": context.contentId,
        "data-state": getState$1(context.open),
        ...triggerProps,
        ref: composedTriggerRef,
        onClick: composeEventHandlers(props.onClick, context.onOpenToggle)
      }
    );
  }
);
DialogTrigger$1.displayName = TRIGGER_NAME;
var PORTAL_NAME = "DialogPortal";
var [PortalProvider, usePortalContext] = createDialogContext(PORTAL_NAME, {
  forceMount: void 0
});
var DialogPortal$1 = (props) => {
  const { __scopeDialog, forceMount, children, container } = props;
  const context = useDialogContext(PORTAL_NAME, __scopeDialog);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(PortalProvider, { scope: __scopeDialog, forceMount, children: reactExports.Children.map(children, (child) => /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Portal$2, { asChild: true, container, children: child }) })) });
};
DialogPortal$1.displayName = PORTAL_NAME;
var OVERLAY_NAME = "DialogOverlay";
var DialogOverlay$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(OVERLAY_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, props.__scopeDialog);
    return context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlayImpl, { ...overlayProps, ref: forwardedRef }) }) : null;
  }
);
DialogOverlay$1.displayName = OVERLAY_NAME;
var DialogOverlayImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...overlayProps } = props;
    const context = useDialogContext(OVERLAY_NAME, __scopeDialog);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      /* @__PURE__ */ jsxRuntimeExports.jsx(ReactRemoveScroll, { as: Slot, allowPinchZoom: true, shards: [context.contentRef], children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-state": getState$1(context.open),
          ...overlayProps,
          ref: forwardedRef,
          style: { pointerEvents: "auto", ...overlayProps.style }
        }
      ) })
    );
  }
);
var CONTENT_NAME = "DialogContent";
var DialogContent$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const portalContext = usePortalContext(CONTENT_NAME, props.__scopeDialog);
    const { forceMount = portalContext.forceMount, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || context.open, children: context.modal ? /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentModal, { ...contentProps, ref: forwardedRef }) : /* @__PURE__ */ jsxRuntimeExports.jsx(DialogContentNonModal, { ...contentProps, ref: forwardedRef }) });
  }
);
DialogContent$1.displayName = CONTENT_NAME;
var DialogContentModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, context.contentRef, contentRef);
    reactExports.useEffect(() => {
      const content = contentRef.current;
      if (content) return hideOthers(content);
    }, []);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: composedRefs,
        trapFocus: context.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: composeEventHandlers(props.onCloseAutoFocus, (event) => {
          event.preventDefault();
          context.triggerRef.current?.focus();
        }),
        onPointerDownOutside: composeEventHandlers(props.onPointerDownOutside, (event) => {
          const originalEvent = event.detail.originalEvent;
          const ctrlLeftClick = originalEvent.button === 0 && originalEvent.ctrlKey === true;
          const isRightClick = originalEvent.button === 2 || ctrlLeftClick;
          if (isRightClick) event.preventDefault();
        }),
        onFocusOutside: composeEventHandlers(
          props.onFocusOutside,
          (event) => event.preventDefault()
        )
      }
    );
  }
);
var DialogContentNonModal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useDialogContext(CONTENT_NAME, props.__scopeDialog);
    const hasInteractedOutsideRef = reactExports.useRef(false);
    const hasPointerDownOutsideRef = reactExports.useRef(false);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      DialogContentImpl,
      {
        ...props,
        ref: forwardedRef,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (event) => {
          props.onCloseAutoFocus?.(event);
          if (!event.defaultPrevented) {
            if (!hasInteractedOutsideRef.current) context.triggerRef.current?.focus();
            event.preventDefault();
          }
          hasInteractedOutsideRef.current = false;
          hasPointerDownOutsideRef.current = false;
        },
        onInteractOutside: (event) => {
          props.onInteractOutside?.(event);
          if (!event.defaultPrevented) {
            hasInteractedOutsideRef.current = true;
            if (event.detail.originalEvent.type === "pointerdown") {
              hasPointerDownOutsideRef.current = true;
            }
          }
          const target = event.target;
          const targetIsTrigger = context.triggerRef.current?.contains(target);
          if (targetIsTrigger) event.preventDefault();
          if (event.detail.originalEvent.type === "focusin" && hasPointerDownOutsideRef.current) {
            event.preventDefault();
          }
        }
      }
    );
  }
);
var DialogContentImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, trapFocus, onOpenAutoFocus, onCloseAutoFocus, ...contentProps } = props;
    const context = useDialogContext(CONTENT_NAME, __scopeDialog);
    const contentRef = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, contentRef);
    useFocusGuards();
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        FocusScope,
        {
          asChild: true,
          loop: true,
          trapped: trapFocus,
          onMountAutoFocus: onOpenAutoFocus,
          onUnmountAutoFocus: onCloseAutoFocus,
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            DismissableLayer,
            {
              role: "dialog",
              id: context.contentId,
              "aria-describedby": context.descriptionId,
              "aria-labelledby": context.titleId,
              "data-state": getState$1(context.open),
              ...contentProps,
              ref: composedRefs,
              onDismiss: () => context.onOpenChange(false)
            }
          )
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(TitleWarning, { titleId: context.titleId }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DescriptionWarning, { contentRef, descriptionId: context.descriptionId })
      ] })
    ] });
  }
);
var TITLE_NAME = "DialogTitle";
var DialogTitle$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...titleProps } = props;
    const context = useDialogContext(TITLE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.h2, { id: context.titleId, ...titleProps, ref: forwardedRef });
  }
);
DialogTitle$1.displayName = TITLE_NAME;
var DESCRIPTION_NAME = "DialogDescription";
var DialogDescription$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...descriptionProps } = props;
    const context = useDialogContext(DESCRIPTION_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Primitive.p, { id: context.descriptionId, ...descriptionProps, ref: forwardedRef });
  }
);
DialogDescription$1.displayName = DESCRIPTION_NAME;
var CLOSE_NAME = "DialogClose";
var DialogClose = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeDialog, ...closeProps } = props;
    const context = useDialogContext(CLOSE_NAME, __scopeDialog);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.button,
      {
        type: "button",
        ...closeProps,
        ref: forwardedRef,
        onClick: composeEventHandlers(props.onClick, () => context.onOpenChange(false))
      }
    );
  }
);
DialogClose.displayName = CLOSE_NAME;
function getState$1(open) {
  return open ? "open" : "closed";
}
var TITLE_WARNING_NAME = "DialogTitleWarning";
var [WarningProvider, useWarningContext] = createContext2(TITLE_WARNING_NAME, {
  contentName: CONTENT_NAME,
  titleName: TITLE_NAME,
  docsSlug: "dialog"
});
var TitleWarning = ({ titleId }) => {
  const titleWarningContext = useWarningContext(TITLE_WARNING_NAME);
  const MESSAGE = `\`${titleWarningContext.contentName}\` requires a \`${titleWarningContext.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${titleWarningContext.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${titleWarningContext.docsSlug}`;
  reactExports.useEffect(() => {
    if (titleId) {
      const hasTitle = document.getElementById(titleId);
      if (!hasTitle) console.error(MESSAGE);
    }
  }, [MESSAGE, titleId]);
  return null;
};
var DESCRIPTION_WARNING_NAME = "DialogDescriptionWarning";
var DescriptionWarning = ({ contentRef, descriptionId }) => {
  const descriptionWarningContext = useWarningContext(DESCRIPTION_WARNING_NAME);
  const MESSAGE = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${descriptionWarningContext.contentName}}.`;
  reactExports.useEffect(() => {
    const describedById = contentRef.current?.getAttribute("aria-describedby");
    if (descriptionId && describedById) {
      const hasDescription = document.getElementById(descriptionId);
      if (!hasDescription) console.warn(MESSAGE);
    }
  }, [MESSAGE, contentRef, descriptionId]);
  return null;
};
var Root$4 = Dialog$1;
var Trigger = DialogTrigger$1;
var Portal = DialogPortal$1;
var Overlay = DialogOverlay$1;
var Content = DialogContent$1;
var Title = DialogTitle$1;
var Description = DialogDescription$1;
var Close = DialogClose;
const Dialog = Root$4;
const DialogTrigger = Trigger;
const DialogPortal = Portal;
const DialogOverlay = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Overlay,
  {
    ref,
    className: cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    ),
    ...props
  }
));
DialogOverlay.displayName = Overlay.displayName;
const DialogContent = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogPortal, { children: [
  /* @__PURE__ */ jsxRuntimeExports.jsx(DialogOverlay, {}),
  /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Content,
    {
      ref,
      className: cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      ),
      ...props,
      children: [
        children,
        /* @__PURE__ */ jsxRuntimeExports.jsxs(Close, { className: "absolute right-4 top-4 rounded-sm opacity-70 ring-offset-background transition-opacity hover:opacity-100 focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none data-[state=open]:bg-accent data-[state=open]:text-muted-foreground", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Cross2Icon, { className: "h-4 w-4" }),
          /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Close" })
        ] })
      ]
    }
  )
] }));
DialogContent.displayName = Content.displayName;
const DialogHeader = ({
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    ),
    ...props
  }
);
DialogHeader.displayName = "DialogHeader";
const DialogFooter = ({
  className,
  ...props
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "div",
  {
    className: cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    ),
    ...props
  }
);
DialogFooter.displayName = "DialogFooter";
const DialogTitle = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Title,
  {
    ref,
    className: cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    ),
    ...props
  }
));
DialogTitle.displayName = Title.displayName;
const DialogDescription = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Description,
  {
    ref,
    className: cn("text-sm text-muted-foreground", className),
    ...props
  }
));
DialogDescription.displayName = Description.displayName;
function useStateMachine(initialState2, machine) {
  return reactExports.useReducer((state, event) => {
    const nextState = machine[state][event];
    return nextState ?? state;
  }, initialState2);
}
var SCROLL_AREA_NAME = "ScrollArea";
var [createScrollAreaContext, createScrollAreaScope] = createContextScope(SCROLL_AREA_NAME);
var [ScrollAreaProvider, useScrollAreaContext] = createScrollAreaContext(SCROLL_AREA_NAME);
var ScrollArea$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeScrollArea,
      type = "hover",
      dir,
      scrollHideDelay = 600,
      ...scrollAreaProps
    } = props;
    const [scrollArea, setScrollArea] = reactExports.useState(null);
    const [viewport, setViewport] = reactExports.useState(null);
    const [content, setContent] = reactExports.useState(null);
    const [scrollbarX, setScrollbarX] = reactExports.useState(null);
    const [scrollbarY, setScrollbarY] = reactExports.useState(null);
    const [cornerWidth, setCornerWidth] = reactExports.useState(0);
    const [cornerHeight, setCornerHeight] = reactExports.useState(0);
    const [scrollbarXEnabled, setScrollbarXEnabled] = reactExports.useState(false);
    const [scrollbarYEnabled, setScrollbarYEnabled] = reactExports.useState(false);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setScrollArea(node));
    const direction = useDirection(dir);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaProvider,
      {
        scope: __scopeScrollArea,
        type,
        dir: direction,
        scrollHideDelay,
        scrollArea,
        viewport,
        onViewportChange: setViewport,
        content,
        onContentChange: setContent,
        scrollbarX,
        onScrollbarXChange: setScrollbarX,
        scrollbarXEnabled,
        onScrollbarXEnabledChange: setScrollbarXEnabled,
        scrollbarY,
        onScrollbarYChange: setScrollbarY,
        scrollbarYEnabled,
        onScrollbarYEnabledChange: setScrollbarYEnabled,
        onCornerWidthChange: setCornerWidth,
        onCornerHeightChange: setCornerHeight,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          Primitive.div,
          {
            dir: direction,
            ...scrollAreaProps,
            ref: composedRefs,
            style: {
              position: "relative",
              // Pass corner sizes as CSS vars to reduce re-renders of context consumers
              ["--radix-scroll-area-corner-width"]: cornerWidth + "px",
              ["--radix-scroll-area-corner-height"]: cornerHeight + "px",
              ...props.style
            }
          }
        )
      }
    );
  }
);
ScrollArea$1.displayName = SCROLL_AREA_NAME;
var VIEWPORT_NAME = "ScrollAreaViewport";
var ScrollAreaViewport = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, children, asChild, nonce, ...viewportProps } = props;
    const context = useScrollAreaContext(VIEWPORT_NAME, __scopeScrollArea);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref, context.onViewportChange);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "style",
        {
          dangerouslySetInnerHTML: {
            __html: `
[data-radix-scroll-area-viewport] {
  scrollbar-width: none;
  -ms-overflow-style: none;
  -webkit-overflow-scrolling: touch;
}
[data-radix-scroll-area-viewport]::-webkit-scrollbar {
  display: none;
}
:where([data-radix-scroll-area-viewport]) {
  display: flex;
  flex-direction: column;
  align-items: stretch;
}
:where([data-radix-scroll-area-content]) {
  flex-grow: 1;
}
`
          },
          nonce
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          "data-radix-scroll-area-viewport": "",
          ...viewportProps,
          asChild,
          ref: composedRefs,
          style: {
            /**
             * We don't support `visible` because the intention is to have at least one scrollbar
             * if this component is used and `visible` will behave like `auto` in that case
             * https://developer.mozilla.org/en-US/docs/Web/CSS/overflow#description
             *
             * We don't handle `auto` because the intention is for the native implementation
             * to be hidden if using this component. We just want to ensure the node is scrollable
             * so could have used either `scroll` or `auto` here. We picked `scroll` to prevent
             * the browser from having to work out whether to render native scrollbars or not,
             * we tell it to with the intention of hiding them in CSS.
             */
            overflowX: context.scrollbarXEnabled ? "scroll" : "hidden",
            overflowY: context.scrollbarYEnabled ? "scroll" : "hidden",
            ...props.style
          },
          children: getSubtree({ asChild, children }, (children2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            "div",
            {
              "data-radix-scroll-area-content": "",
              ref: context.onContentChange,
              style: { minWidth: context.scrollbarXEnabled ? "fit-content" : void 0 },
              children: children2
            }
          ))
        }
      )
    ] });
  }
);
ScrollAreaViewport.displayName = VIEWPORT_NAME;
var SCROLLBAR_NAME = "ScrollAreaScrollbar";
var ScrollAreaScrollbar = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...scrollbarProps } = props;
    const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
    const { onScrollbarXEnabledChange, onScrollbarYEnabledChange } = context;
    const isHorizontal = props.orientation === "horizontal";
    reactExports.useEffect(() => {
      isHorizontal ? onScrollbarXEnabledChange(true) : onScrollbarYEnabledChange(true);
      return () => {
        isHorizontal ? onScrollbarXEnabledChange(false) : onScrollbarYEnabledChange(false);
      };
    }, [isHorizontal, onScrollbarXEnabledChange, onScrollbarYEnabledChange]);
    return context.type === "hover" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarHover, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "scroll" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarScroll, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "auto" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarAuto, { ...scrollbarProps, ref: forwardedRef, forceMount }) : context.type === "always" ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaScrollbarVisible, { ...scrollbarProps, ref: forwardedRef }) : null;
  }
);
ScrollAreaScrollbar.displayName = SCROLLBAR_NAME;
var ScrollAreaScrollbarHover = reactExports.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [visible, setVisible] = reactExports.useState(false);
  reactExports.useEffect(() => {
    const scrollArea = context.scrollArea;
    let hideTimer = 0;
    if (scrollArea) {
      const handlePointerEnter = () => {
        window.clearTimeout(hideTimer);
        setVisible(true);
      };
      const handlePointerLeave = () => {
        hideTimer = window.setTimeout(() => setVisible(false), context.scrollHideDelay);
      };
      scrollArea.addEventListener("pointerenter", handlePointerEnter);
      scrollArea.addEventListener("pointerleave", handlePointerLeave);
      return () => {
        window.clearTimeout(hideTimer);
        scrollArea.removeEventListener("pointerenter", handlePointerEnter);
        scrollArea.removeEventListener("pointerleave", handlePointerLeave);
      };
    }
  }, [context.scrollArea, context.scrollHideDelay]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarAuto,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarScroll = reactExports.forwardRef((props, forwardedRef) => {
  const { forceMount, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const isHorizontal = props.orientation === "horizontal";
  const debounceScrollEnd = useDebounceCallback(() => send("SCROLL_END"), 100);
  const [state, send] = useStateMachine("hidden", {
    hidden: {
      SCROLL: "scrolling"
    },
    scrolling: {
      SCROLL_END: "idle",
      POINTER_ENTER: "interacting"
    },
    interacting: {
      SCROLL: "interacting",
      POINTER_LEAVE: "idle"
    },
    idle: {
      HIDE: "hidden",
      SCROLL: "scrolling",
      POINTER_ENTER: "interacting"
    }
  });
  reactExports.useEffect(() => {
    if (state === "idle") {
      const hideTimer = window.setTimeout(() => send("HIDE"), context.scrollHideDelay);
      return () => window.clearTimeout(hideTimer);
    }
  }, [state, context.scrollHideDelay, send]);
  reactExports.useEffect(() => {
    const viewport = context.viewport;
    const scrollDirection = isHorizontal ? "scrollLeft" : "scrollTop";
    if (viewport) {
      let prevScrollPos = viewport[scrollDirection];
      const handleScroll2 = () => {
        const scrollPos = viewport[scrollDirection];
        const hasScrollInDirectionChanged = prevScrollPos !== scrollPos;
        if (hasScrollInDirectionChanged) {
          send("SCROLL");
          debounceScrollEnd();
        }
        prevScrollPos = scrollPos;
      };
      viewport.addEventListener("scroll", handleScroll2);
      return () => viewport.removeEventListener("scroll", handleScroll2);
    }
  }, [context.viewport, isHorizontal, send, debounceScrollEnd]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || state !== "hidden", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": state === "hidden" ? "hidden" : "visible",
      ...scrollbarProps,
      ref: forwardedRef,
      onPointerEnter: composeEventHandlers(props.onPointerEnter, () => send("POINTER_ENTER")),
      onPointerLeave: composeEventHandlers(props.onPointerLeave, () => send("POINTER_LEAVE"))
    }
  ) });
});
var ScrollAreaScrollbarAuto = reactExports.forwardRef((props, forwardedRef) => {
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const { forceMount, ...scrollbarProps } = props;
  const [visible, setVisible] = reactExports.useState(false);
  const isHorizontal = props.orientation === "horizontal";
  const handleResize = useDebounceCallback(() => {
    if (context.viewport) {
      const isOverflowX = context.viewport.offsetWidth < context.viewport.scrollWidth;
      const isOverflowY = context.viewport.offsetHeight < context.viewport.scrollHeight;
      setVisible(isHorizontal ? isOverflowX : isOverflowY);
    }
  }, 10);
  useResizeObserver(context.viewport, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || visible, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarVisible,
    {
      "data-state": visible ? "visible" : "hidden",
      ...scrollbarProps,
      ref: forwardedRef
    }
  ) });
});
var ScrollAreaScrollbarVisible = reactExports.forwardRef((props, forwardedRef) => {
  const { orientation = "vertical", ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const thumbRef = reactExports.useRef(null);
  const pointerOffsetRef = reactExports.useRef(0);
  const [sizes, setSizes] = reactExports.useState({
    content: 0,
    viewport: 0,
    scrollbar: { size: 0, paddingStart: 0, paddingEnd: 0 }
  });
  const thumbRatio = getThumbRatio(sizes.viewport, sizes.content);
  const commonProps = {
    ...scrollbarProps,
    sizes,
    onSizesChange: setSizes,
    hasThumb: Boolean(thumbRatio > 0 && thumbRatio < 1),
    onThumbChange: (thumb) => thumbRef.current = thumb,
    onThumbPointerUp: () => pointerOffsetRef.current = 0,
    onThumbPointerDown: (pointerPos) => pointerOffsetRef.current = pointerPos
  };
  function getScrollPosition(pointerPos, dir) {
    return getScrollPositionFromPointer(pointerPos, pointerOffsetRef.current, sizes, dir);
  }
  if (orientation === "horizontal") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarX,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollLeft;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes, context.dir);
            thumbRef.current.style.transform = `translate3d(${offset2}px, 0, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollLeft = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) {
            context.viewport.scrollLeft = getScrollPosition(pointerPos, context.dir);
          }
        }
      }
    );
  }
  if (orientation === "vertical") {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      ScrollAreaScrollbarY,
      {
        ...commonProps,
        ref: forwardedRef,
        onThumbPositionChange: () => {
          if (context.viewport && thumbRef.current) {
            const scrollPos = context.viewport.scrollTop;
            const offset2 = getThumbOffsetFromScroll(scrollPos, sizes);
            thumbRef.current.style.transform = `translate3d(0, ${offset2}px, 0)`;
          }
        },
        onWheelScroll: (scrollPos) => {
          if (context.viewport) context.viewport.scrollTop = scrollPos;
        },
        onDragScroll: (pointerPos) => {
          if (context.viewport) context.viewport.scrollTop = getScrollPosition(pointerPos);
        }
      }
    );
  }
  return null;
});
var ScrollAreaScrollbarX = reactExports.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = reactExports.useState();
  const ref = reactExports.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarXChange);
  reactExports.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "horizontal",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        bottom: 0,
        left: context.dir === "rtl" ? "var(--radix-scroll-area-corner-width)" : 0,
        right: context.dir === "ltr" ? "var(--radix-scroll-area-corner-width)" : 0,
        ["--radix-scroll-area-thumb-width"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.x),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.x),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollLeft + event.deltaX;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollWidth,
            viewport: context.viewport.offsetWidth,
            scrollbar: {
              size: ref.current.clientWidth,
              paddingStart: toInt(computedStyle.paddingLeft),
              paddingEnd: toInt(computedStyle.paddingRight)
            }
          });
        }
      }
    }
  );
});
var ScrollAreaScrollbarY = reactExports.forwardRef((props, forwardedRef) => {
  const { sizes, onSizesChange, ...scrollbarProps } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, props.__scopeScrollArea);
  const [computedStyle, setComputedStyle] = reactExports.useState();
  const ref = reactExports.useRef(null);
  const composeRefs2 = useComposedRefs(forwardedRef, ref, context.onScrollbarYChange);
  reactExports.useEffect(() => {
    if (ref.current) setComputedStyle(getComputedStyle(ref.current));
  }, [ref]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollAreaScrollbarImpl,
    {
      "data-orientation": "vertical",
      ...scrollbarProps,
      ref: composeRefs2,
      sizes,
      style: {
        top: 0,
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: "var(--radix-scroll-area-corner-height)",
        ["--radix-scroll-area-thumb-height"]: getThumbSize(sizes) + "px",
        ...props.style
      },
      onThumbPointerDown: (pointerPos) => props.onThumbPointerDown(pointerPos.y),
      onDragScroll: (pointerPos) => props.onDragScroll(pointerPos.y),
      onWheelScroll: (event, maxScrollPos) => {
        if (context.viewport) {
          const scrollPos = context.viewport.scrollTop + event.deltaY;
          props.onWheelScroll(scrollPos);
          if (isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos)) {
            event.preventDefault();
          }
        }
      },
      onResize: () => {
        if (ref.current && context.viewport && computedStyle) {
          onSizesChange({
            content: context.viewport.scrollHeight,
            viewport: context.viewport.offsetHeight,
            scrollbar: {
              size: ref.current.clientHeight,
              paddingStart: toInt(computedStyle.paddingTop),
              paddingEnd: toInt(computedStyle.paddingBottom)
            }
          });
        }
      }
    }
  );
});
var [ScrollbarProvider, useScrollbarContext] = createScrollAreaContext(SCROLLBAR_NAME);
var ScrollAreaScrollbarImpl = reactExports.forwardRef((props, forwardedRef) => {
  const {
    __scopeScrollArea,
    sizes,
    hasThumb,
    onThumbChange,
    onThumbPointerUp,
    onThumbPointerDown,
    onThumbPositionChange,
    onDragScroll,
    onWheelScroll,
    onResize,
    ...scrollbarProps
  } = props;
  const context = useScrollAreaContext(SCROLLBAR_NAME, __scopeScrollArea);
  const [scrollbar, setScrollbar] = reactExports.useState(null);
  const composeRefs2 = useComposedRefs(forwardedRef, (node) => setScrollbar(node));
  const rectRef = reactExports.useRef(null);
  const prevWebkitUserSelectRef = reactExports.useRef("");
  const viewport = context.viewport;
  const maxScrollPos = sizes.content - sizes.viewport;
  const handleWheelScroll = useCallbackRef$1(onWheelScroll);
  const handleThumbPositionChange = useCallbackRef$1(onThumbPositionChange);
  const handleResize = useDebounceCallback(onResize, 10);
  function handleDragScroll(event) {
    if (rectRef.current) {
      const x2 = event.clientX - rectRef.current.left;
      const y2 = event.clientY - rectRef.current.top;
      onDragScroll({ x: x2, y: y2 });
    }
  }
  reactExports.useEffect(() => {
    const handleWheel = (event) => {
      const element = event.target;
      const isScrollbarWheel = scrollbar?.contains(element);
      if (isScrollbarWheel) handleWheelScroll(event, maxScrollPos);
    };
    document.addEventListener("wheel", handleWheel, { passive: false });
    return () => document.removeEventListener("wheel", handleWheel, { passive: false });
  }, [viewport, scrollbar, maxScrollPos, handleWheelScroll]);
  reactExports.useEffect(handleThumbPositionChange, [sizes, handleThumbPositionChange]);
  useResizeObserver(scrollbar, handleResize);
  useResizeObserver(context.content, handleResize);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    ScrollbarProvider,
    {
      scope: __scopeScrollArea,
      scrollbar,
      hasThumb,
      onThumbChange: useCallbackRef$1(onThumbChange),
      onThumbPointerUp: useCallbackRef$1(onThumbPointerUp),
      onThumbPositionChange: handleThumbPositionChange,
      onThumbPointerDown: useCallbackRef$1(onThumbPointerDown),
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.div,
        {
          ...scrollbarProps,
          ref: composeRefs2,
          style: { position: "absolute", ...scrollbarProps.style },
          onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
            const mainPointer = 0;
            if (event.button === mainPointer) {
              const element = event.target;
              element.setPointerCapture(event.pointerId);
              rectRef.current = scrollbar.getBoundingClientRect();
              prevWebkitUserSelectRef.current = document.body.style.webkitUserSelect;
              document.body.style.webkitUserSelect = "none";
              if (context.viewport) context.viewport.style.scrollBehavior = "auto";
              handleDragScroll(event);
            }
          }),
          onPointerMove: composeEventHandlers(props.onPointerMove, handleDragScroll),
          onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
            const element = event.target;
            if (element.hasPointerCapture(event.pointerId)) {
              element.releasePointerCapture(event.pointerId);
            }
            document.body.style.webkitUserSelect = prevWebkitUserSelectRef.current;
            if (context.viewport) context.viewport.style.scrollBehavior = "";
            rectRef.current = null;
          })
        }
      )
    }
  );
});
var THUMB_NAME$1 = "ScrollAreaThumb";
var ScrollAreaThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { forceMount, ...thumbProps } = props;
    const scrollbarContext = useScrollbarContext(THUMB_NAME$1, props.__scopeScrollArea);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || scrollbarContext.hasThumb, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumbImpl, { ref: forwardedRef, ...thumbProps }) });
  }
);
var ScrollAreaThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeScrollArea, style, ...thumbProps } = props;
    const scrollAreaContext = useScrollAreaContext(THUMB_NAME$1, __scopeScrollArea);
    const scrollbarContext = useScrollbarContext(THUMB_NAME$1, __scopeScrollArea);
    const { onThumbPositionChange } = scrollbarContext;
    const composedRef = useComposedRefs(
      forwardedRef,
      (node) => scrollbarContext.onThumbChange(node)
    );
    const removeUnlinkedScrollListenerRef = reactExports.useRef();
    const debounceScrollEnd = useDebounceCallback(() => {
      if (removeUnlinkedScrollListenerRef.current) {
        removeUnlinkedScrollListenerRef.current();
        removeUnlinkedScrollListenerRef.current = void 0;
      }
    }, 100);
    reactExports.useEffect(() => {
      const viewport = scrollAreaContext.viewport;
      if (viewport) {
        const handleScroll2 = () => {
          debounceScrollEnd();
          if (!removeUnlinkedScrollListenerRef.current) {
            const listener = addUnlinkedScrollListener(viewport, onThumbPositionChange);
            removeUnlinkedScrollListenerRef.current = listener;
            onThumbPositionChange();
          }
        };
        onThumbPositionChange();
        viewport.addEventListener("scroll", handleScroll2);
        return () => viewport.removeEventListener("scroll", handleScroll2);
      }
    }, [scrollAreaContext.viewport, debounceScrollEnd, onThumbPositionChange]);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.div,
      {
        "data-state": scrollbarContext.hasThumb ? "visible" : "hidden",
        ...thumbProps,
        ref: composedRef,
        style: {
          width: "var(--radix-scroll-area-thumb-width)",
          height: "var(--radix-scroll-area-thumb-height)",
          ...style
        },
        onPointerDownCapture: composeEventHandlers(props.onPointerDownCapture, (event) => {
          const thumb = event.target;
          const thumbRect = thumb.getBoundingClientRect();
          const x2 = event.clientX - thumbRect.left;
          const y2 = event.clientY - thumbRect.top;
          scrollbarContext.onThumbPointerDown({ x: x2, y: y2 });
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, scrollbarContext.onThumbPointerUp)
      }
    );
  }
);
ScrollAreaThumb.displayName = THUMB_NAME$1;
var CORNER_NAME = "ScrollAreaCorner";
var ScrollAreaCorner = reactExports.forwardRef(
  (props, forwardedRef) => {
    const context = useScrollAreaContext(CORNER_NAME, props.__scopeScrollArea);
    const hasBothScrollbarsVisible = Boolean(context.scrollbarX && context.scrollbarY);
    const hasCorner = context.type !== "scroll" && hasBothScrollbarsVisible;
    return hasCorner ? /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaCornerImpl, { ...props, ref: forwardedRef }) : null;
  }
);
ScrollAreaCorner.displayName = CORNER_NAME;
var ScrollAreaCornerImpl = reactExports.forwardRef((props, forwardedRef) => {
  const { __scopeScrollArea, ...cornerProps } = props;
  const context = useScrollAreaContext(CORNER_NAME, __scopeScrollArea);
  const [width, setWidth] = reactExports.useState(0);
  const [height, setHeight] = reactExports.useState(0);
  const hasSize = Boolean(width && height);
  useResizeObserver(context.scrollbarX, () => {
    const height2 = context.scrollbarX?.offsetHeight || 0;
    context.onCornerHeightChange(height2);
    setHeight(height2);
  });
  useResizeObserver(context.scrollbarY, () => {
    const width2 = context.scrollbarY?.offsetWidth || 0;
    context.onCornerWidthChange(width2);
    setWidth(width2);
  });
  return hasSize ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.div,
    {
      ...cornerProps,
      ref: forwardedRef,
      style: {
        width,
        height,
        position: "absolute",
        right: context.dir === "ltr" ? 0 : void 0,
        left: context.dir === "rtl" ? 0 : void 0,
        bottom: 0,
        ...props.style
      }
    }
  ) : null;
});
function toInt(value) {
  return value ? parseInt(value, 10) : 0;
}
function getThumbRatio(viewportSize, contentSize) {
  const ratio = viewportSize / contentSize;
  return isNaN(ratio) ? 0 : ratio;
}
function getThumbSize(sizes) {
  const ratio = getThumbRatio(sizes.viewport, sizes.content);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const thumbSize = (sizes.scrollbar.size - scrollbarPadding) * ratio;
  return Math.max(thumbSize, 18);
}
function getScrollPositionFromPointer(pointerPos, pointerOffset, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const thumbCenter = thumbSizePx / 2;
  const offset2 = pointerOffset || thumbCenter;
  const thumbOffsetFromEnd = thumbSizePx - offset2;
  const minPointerPos = sizes.scrollbar.paddingStart + offset2;
  const maxPointerPos = sizes.scrollbar.size - sizes.scrollbar.paddingEnd - thumbOffsetFromEnd;
  const maxScrollPos = sizes.content - sizes.viewport;
  const scrollRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const interpolate = linearScale$1([minPointerPos, maxPointerPos], scrollRange);
  return interpolate(pointerPos);
}
function getThumbOffsetFromScroll(scrollPos, sizes, dir = "ltr") {
  const thumbSizePx = getThumbSize(sizes);
  const scrollbarPadding = sizes.scrollbar.paddingStart + sizes.scrollbar.paddingEnd;
  const scrollbar = sizes.scrollbar.size - scrollbarPadding;
  const maxScrollPos = sizes.content - sizes.viewport;
  const maxThumbPos = scrollbar - thumbSizePx;
  const scrollClampRange = dir === "ltr" ? [0, maxScrollPos] : [maxScrollPos * -1, 0];
  const scrollWithoutMomentum = clamp$1(scrollPos, scrollClampRange);
  const interpolate = linearScale$1([0, maxScrollPos], [0, maxThumbPos]);
  return interpolate(scrollWithoutMomentum);
}
function linearScale$1(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function isScrollingWithinScrollbarBounds(scrollPos, maxScrollPos) {
  return scrollPos > 0 && scrollPos < maxScrollPos;
}
var addUnlinkedScrollListener = (node, handler = () => {
}) => {
  let prevPosition = { left: node.scrollLeft, top: node.scrollTop };
  let rAF = 0;
  (function loop() {
    const position = { left: node.scrollLeft, top: node.scrollTop };
    const isHorizontalScroll = prevPosition.left !== position.left;
    const isVerticalScroll = prevPosition.top !== position.top;
    if (isHorizontalScroll || isVerticalScroll) handler();
    prevPosition = position;
    rAF = window.requestAnimationFrame(loop);
  })();
  return () => window.cancelAnimationFrame(rAF);
};
function useDebounceCallback(callback, delay) {
  const handleCallback = useCallbackRef$1(callback);
  const debounceTimerRef = reactExports.useRef(0);
  reactExports.useEffect(() => () => window.clearTimeout(debounceTimerRef.current), []);
  return reactExports.useCallback(() => {
    window.clearTimeout(debounceTimerRef.current);
    debounceTimerRef.current = window.setTimeout(handleCallback, delay);
  }, [handleCallback, delay]);
}
function useResizeObserver(element, onResize) {
  const handleResize = useCallbackRef$1(onResize);
  useLayoutEffect2(() => {
    let rAF = 0;
    if (element) {
      const resizeObserver = new ResizeObserver(() => {
        cancelAnimationFrame(rAF);
        rAF = window.requestAnimationFrame(handleResize);
      });
      resizeObserver.observe(element);
      return () => {
        window.cancelAnimationFrame(rAF);
        resizeObserver.unobserve(element);
      };
    }
  }, [element, handleResize]);
}
function getSubtree(options, content) {
  const { asChild, children } = options;
  if (!asChild) return typeof content === "function" ? content(children) : content;
  const firstChild = reactExports.Children.only(children);
  return reactExports.cloneElement(firstChild, {
    children: typeof content === "function" ? content(firstChild.props.children) : content
  });
}
var Root$3 = ScrollArea$1;
var Viewport = ScrollAreaViewport;
var Corner = ScrollAreaCorner;
const ScrollArea = reactExports.forwardRef(({ className, children, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Root$3,
  {
    ref,
    className: cn("relative overflow-hidden", className),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Viewport, { className: "h-full w-full rounded-[inherit]", children }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollBar, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Corner, {})
    ]
  }
));
ScrollArea.displayName = Root$3.displayName;
const ScrollBar = reactExports.forwardRef(({ className, orientation = "vertical", ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  ScrollAreaScrollbar,
  {
    ref,
    orientation,
    className: cn(
      "flex touch-none select-none transition-colors",
      orientation === "vertical" && "h-full w-2.5 border-l border-l-transparent p-[1px]",
      orientation === "horizontal" && "h-2.5 flex-col border-t border-t-transparent p-[1px]",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollAreaThumb, { className: "relative flex-1 rounded-full bg-border" })
  }
));
ScrollBar.displayName = ScrollAreaScrollbar.displayName;
const exampleData = {
  10: {
    unsorted: [4, 8, 10, 7, 2, 3, 1, 9, 5, 6],
    partiallySorted: [1, 2, 3, 5, 4, 6, 7, 9, 8, 10],
    sorted: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10],
    reversed: [10, 9, 8, 7, 6, 5, 4, 3, 2, 1],
    duplicates: [8, 10, 3, 8, 4, 4, 3, 10, 3, 8]
  },
  30: {
    unsorted: [
      14,
      28,
      2,
      22,
      5,
      17,
      23,
      8,
      4,
      12,
      29,
      7,
      20,
      10,
      15,
      26,
      1,
      9,
      3,
      18,
      25,
      11,
      16,
      30,
      6,
      19,
      21,
      24,
      13,
      27
    ],
    partiallySorted: [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      11,
      13,
      10,
      12,
      14,
      15,
      16,
      17,
      18,
      19,
      21,
      23,
      20,
      22,
      24,
      25,
      26,
      27,
      28,
      29,
      30
    ],
    sorted: [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30
    ],
    reversed: [
      30,
      29,
      28,
      27,
      26,
      25,
      24,
      23,
      22,
      21,
      20,
      19,
      18,
      17,
      16,
      15,
      14,
      13,
      12,
      11,
      10,
      9,
      8,
      7,
      6,
      5,
      4,
      3,
      2,
      1
    ],
    duplicates: [
      24,
      8,
      25,
      24,
      20,
      15,
      25,
      30,
      25,
      25,
      11,
      24,
      20,
      24,
      8,
      30,
      15,
      11,
      4,
      8,
      4,
      4,
      11,
      15,
      4,
      20,
      11,
      4,
      4,
      25
    ]
  },
  100: {
    unsorted: [
      45,
      76,
      34,
      89,
      23,
      12,
      56,
      91,
      18,
      64,
      7,
      37,
      99,
      29,
      3,
      81,
      27,
      88,
      42,
      73,
      94,
      14,
      22,
      15,
      69,
      53,
      11,
      49,
      38,
      2,
      67,
      61,
      86,
      77,
      19,
      57,
      85,
      25,
      31,
      4,
      66,
      16,
      82,
      50,
      41,
      33,
      9,
      30,
      98,
      6,
      55,
      21,
      75,
      58,
      92,
      13,
      8,
      72,
      84,
      5,
      43,
      35,
      40,
      63,
      47,
      95,
      1,
      96,
      44,
      59,
      48,
      10,
      26,
      24,
      80,
      46,
      100,
      74,
      83,
      17,
      28,
      87,
      20,
      32,
      36,
      71,
      70,
      93,
      54,
      60,
      79,
      52,
      39,
      78,
      68,
      62,
      97,
      90,
      51,
      65
    ],
    partiallySorted: [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      11,
      13,
      10,
      12,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      23,
      25,
      24,
      22,
      27,
      26,
      28,
      29,
      30,
      31,
      33,
      32,
      34,
      35,
      36,
      37,
      39,
      38,
      40,
      41,
      43,
      42,
      44,
      45,
      47,
      46,
      49,
      48,
      50,
      51,
      53,
      52,
      54,
      55,
      56,
      57,
      59,
      58,
      60,
      61,
      63,
      62,
      64,
      65,
      66,
      67,
      69,
      68,
      70,
      71,
      72,
      73,
      74,
      75,
      77,
      76,
      78,
      79,
      80,
      81,
      83,
      82,
      84,
      85,
      87,
      86,
      88,
      89,
      90,
      91,
      93,
      92,
      94,
      95,
      96,
      97,
      98,
      99,
      100
    ],
    sorted: [
      1,
      2,
      3,
      4,
      5,
      6,
      7,
      8,
      9,
      10,
      11,
      12,
      13,
      14,
      15,
      16,
      17,
      18,
      19,
      20,
      21,
      22,
      23,
      24,
      25,
      26,
      27,
      28,
      29,
      30,
      31,
      32,
      33,
      34,
      35,
      36,
      37,
      38,
      39,
      40,
      41,
      42,
      43,
      44,
      45,
      46,
      47,
      48,
      49,
      50,
      51,
      52,
      53,
      54,
      55,
      56,
      57,
      58,
      59,
      60,
      61,
      62,
      63,
      64,
      65,
      66,
      67,
      68,
      69,
      70,
      71,
      72,
      73,
      74,
      75,
      76,
      77,
      78,
      79,
      80,
      81,
      82,
      83,
      84,
      85,
      86,
      87,
      88,
      89,
      90,
      91,
      92,
      93,
      94,
      95,
      96,
      97,
      98,
      99,
      100
    ],
    reversed: [
      100,
      99,
      98,
      97,
      96,
      95,
      94,
      93,
      92,
      91,
      90,
      89,
      88,
      87,
      86,
      85,
      84,
      83,
      82,
      81,
      80,
      79,
      78,
      77,
      76,
      75,
      74,
      73,
      72,
      71,
      70,
      69,
      68,
      67,
      66,
      65,
      64,
      63,
      62,
      61,
      60,
      59,
      58,
      57,
      56,
      55,
      54,
      53,
      52,
      51,
      50,
      49,
      48,
      47,
      46,
      45,
      44,
      43,
      42,
      41,
      40,
      39,
      38,
      37,
      36,
      35,
      34,
      33,
      32,
      31,
      30,
      29,
      28,
      27,
      26,
      25,
      24,
      23,
      22,
      21,
      20,
      19,
      18,
      17,
      16,
      15,
      14,
      13,
      12,
      11,
      10,
      9,
      8,
      7,
      6,
      5,
      4,
      3,
      2,
      1
    ],
    duplicates: [
      10,
      20,
      30,
      40,
      10,
      20,
      30,
      50,
      60,
      70,
      20,
      10,
      30,
      50,
      60,
      30,
      70,
      10,
      20,
      30,
      10,
      20,
      50,
      40,
      10,
      60,
      50,
      30,
      40,
      20,
      50,
      60,
      30,
      40,
      10,
      70,
      50,
      60,
      30,
      40,
      10,
      50,
      20,
      70,
      30,
      50,
      60,
      40,
      20,
      70,
      10,
      30,
      50,
      20,
      60,
      40,
      70,
      10,
      30,
      50,
      60,
      30,
      40,
      10,
      70,
      20,
      50,
      30,
      40,
      60,
      10,
      20,
      70,
      30,
      50,
      60,
      30,
      40,
      20,
      10,
      70,
      30,
      50,
      20,
      60,
      40,
      70,
      10,
      30,
      20,
      60,
      50,
      40,
      40,
      10,
      20,
      30,
      60,
      60,
      50
    ]
  }
};
function ExampleDataButton() {
  const { setDefaultChartData } = useGlobalChartsInfo();
  const { t: t2 } = useTranslation("ExampleDataButton");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", children: t2("button") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "flex h-3/6 min-h-64 w-96 flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: t2("title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: t2("description") })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-0 flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-y-2 pl-1 pr-5", children: Object.entries(exampleData).map(([count2, variants2], index2) => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-col space-y-2", children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("count", { count: Number(count2) }) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-wrap gap-2", children: Object.entries(variants2).map(([key, value]) => /* @__PURE__ */ jsxRuntimeExports.jsx(
          Button,
          {
            variant: "outline",
            onClick: () => setDefaultChartData(value),
            children: t2(key)
          },
          key
        )) })
      ] }, index2)) }) })
    ] })
  ] });
}
const ChartInfoContext = reactExports.createContext(
  void 0
);
function ChartInfoProvider({ children }) {
  const { defaultChartDataRef } = useGlobalChartsInfo();
  const chartActionRef = reactExports.useRef(CHART_ACTION.COMPARE);
  const maxChartActionCounterRef = reactExports.useRef(0);
  const maxChartCompareCounterRef = reactExports.useRef(0);
  const chartDataRef = reactExports.useRef(defaultChartDataRef.current);
  const chartActionCounterRef = reactExports.useRef(0);
  const chartCompareCounterRef = reactExports.useRef(0);
  const sortVariablesRef = reactExports.useRef({});
  const value = {
    chartActionRef,
    maxChartActionCounterRef,
    maxChartCompareCounterRef,
    chartDataRef,
    chartActionCounterRef,
    chartCompareCounterRef,
    sortVariablesRef
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ChartInfoContext.Provider, { value, children });
}
function useChartInfo() {
  const context = reactExports.useContext(ChartInfoContext);
  if (!context) {
    throw new Error("useChartInfo must be used within ChartInfoProvider");
  }
  return context;
}
const bubbleSortCode = `function bubbleSort(arr: number[]) {
  const n = arr.length

  for (let i = 0; i < n - 1; i++) {
    let swapped = false
    for (let j = 0; j < n - i - 1; j++) {
      if (arr[j] > arr[j + 1]) {
        const temp = arr[j]
        arr[j] = arr[j + 1]
        arr[j + 1] = temp
        swapped = true
      }
    }

    if (swapped === false) {
      break
    }
  }
}`;
function swapChartDataFields(chartData, firstPosition, secondPosition) {
  const updatedFields = [...chartData.current.fields];
  updatedFields[firstPosition] = {
    ...chartData.current.fields[firstPosition],
    number: chartData.current.fields[secondPosition].number
  };
  updatedFields[secondPosition] = {
    ...chartData.current.fields[secondPosition],
    number: chartData.current.fields[firstPosition].number
  };
  chartData.current = {
    ...chartData.current,
    fields: updatedFields
  };
}
function replaceChartDataFields(chartData, position, number) {
  const updatedFields = [...chartData.current.fields];
  updatedFields[position] = {
    ...chartData.current.fields[position],
    number
  };
  chartData.current = {
    ...chartData.current,
    fields: updatedFields
  };
}
function visualizeChartDataFields(chartData, compareCounter, action, numbers) {
  if (action === CHART_ACTION.COMPARE) {
    compareCounter.current++;
  }
  chartData.current = {
    ...chartData.current,
    visualization: {
      action,
      numbers
    }
  };
}
function* bubbleSort(chartData, compareCounter) {
  let swapped = false;
  const n2 = chartData.current.fields.length;
  for (let i2 = 0; i2 < n2 - 1; i2++) {
    swapped = false;
    for (let j = 0; j < n2 - i2 - 1; j++) {
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.COMPARE,
        [j, j + 1]
      );
      yield 0;
      if (chartData.current.fields[j].number > chartData.current.fields[j + 1].number) {
        visualizeChartDataFields(
          chartData,
          compareCounter,
          CHART_ACTION.ANIMATE_SWAP,
          [j, j + 1]
        );
        yield 0;
        swapChartDataFields(chartData, j, j + 1);
        swapped = true;
      }
    }
    if (swapped === false) {
      break;
    }
  }
  return;
}
const info$3 = {
  best: "O(n)",
  average: "O(n^(2))",
  worst: "O(n^(2))",
  memory: "O(1)",
  stable: true
};
const useBubbleSort = () => {
  const { chartDataRef, chartCompareCounterRef } = useChartInfo();
  const generatorRef = reactExports.useRef(
    bubbleSort(chartDataRef, chartCompareCounterRef)
  );
  const reset = reactExports.useCallback(() => {
    generatorRef.current = bubbleSort(chartDataRef, chartCompareCounterRef);
  }, [chartCompareCounterRef, chartDataRef]);
  return {
    sortFunctionGeneratorRef: generatorRef,
    reset,
    info: info$3,
    code: bubbleSortCode
  };
};
const heapifyFunctionCode = `function heapify(arr: number[], n: number, i: number) {
  let largest = i
  const l = 2 * i + 1
  const r = 2 * i + 2

  if (l < n && arr[l] > arr[largest]) {
    largest = l
  }

  if (r < n && arr[r] > arr[largest]) {
    largest = r
  }

  if (largest !== i) {
    const temp = arr[i]
    arr[i] = arr[largest]
    arr[largest] = temp

    heapify(arr, n, largest)
  }
}`;
const heapSortFunctionCode = `function heapSort(arr: number[]) {
  const n = arr.length

  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i)
  }

  for (let i = n - 1; i > 0; i--) {
    const temp = arr[0]
    arr[0] = arr[i]
    arr[i] = temp

    heapify(arr, i, 0)
  }
}`;
const heapSortCode = heapifyFunctionCode + "\n\n" + heapSortFunctionCode;
function* heapify(chartData, compareCounter, n2, i2) {
  let largest = i2;
  const l2 = 2 * i2 + 1;
  const r2 = 2 * i2 + 2;
  if (l2 < n2) {
    visualizeChartDataFields(chartData, compareCounter, CHART_ACTION.COMPARE, [
      l2,
      largest
    ]);
    yield 0;
    if (chartData.current.fields[l2].number > chartData.current.fields[largest].number) {
      largest = l2;
    }
  }
  if (r2 < n2) {
    visualizeChartDataFields(chartData, compareCounter, CHART_ACTION.COMPARE, [
      r2,
      largest
    ]);
    yield 0;
    if (chartData.current.fields[r2].number > chartData.current.fields[largest].number) {
      largest = r2;
    }
  }
  if (largest !== i2) {
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_SWAP,
      [i2, largest]
    );
    yield 0;
    swapChartDataFields(chartData, i2, largest);
    yield* heapify(chartData, compareCounter, n2, largest);
  }
  return;
}
function* heapSort(chartData, compareCounter) {
  const n2 = chartData.current.fields.length;
  for (let i2 = Math.floor(n2 / 2) - 1; i2 >= 0; i2--) {
    yield* heapify(chartData, compareCounter, n2, i2);
  }
  for (let i2 = n2 - 1; i2 > 0; i2--) {
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_SWAP,
      [0, i2]
    );
    yield 0;
    swapChartDataFields(chartData, 0, i2);
    yield* heapify(chartData, compareCounter, i2, 0);
  }
  return;
}
const info$2 = {
  best: "O(n log n)",
  average: "O(n log n)",
  worst: "O(n log n)",
  memory: "O(1)",
  stable: false
};
const useHeapSort = () => {
  const { chartDataRef, chartCompareCounterRef } = useChartInfo();
  const generatorRef = reactExports.useRef(
    heapSort(chartDataRef, chartCompareCounterRef)
  );
  const reset = reactExports.useCallback(() => {
    generatorRef.current = heapSort(chartDataRef, chartCompareCounterRef);
  }, [chartCompareCounterRef, chartDataRef]);
  return {
    sortFunctionGeneratorRef: generatorRef,
    reset,
    info: info$2,
    code: heapSortCode
  };
};
const insertionSortCode = `function insertionSort(arr: number[]) {
  const n = arr.length

  for (let i = 1; i < n; i++) {
    const current = arr[i]
    let j = i - 1

    while (j >= 0 && arr[j] > current) {
      arr[j + 1] = arr[j]

      j--
    }
    arr[j + 1] = current
  }
}`;
function* insertionSort(chartData, compareCounter) {
  const n2 = chartData.current.fields.length;
  for (let i2 = 1; i2 < n2; i2++) {
    const current = chartData.current.fields[i2].number;
    let j = i2 - 1;
    while (j >= 0) {
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.COMPARE,
        [j, j + 1]
      );
      yield 0;
      if (chartData.current.fields[j].number <= current) {
        break;
      }
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.ANIMATE_SWAP,
        [j, j + 1]
      );
      yield 0;
      swapChartDataFields(chartData, j, j + 1);
      j = j - 1;
    }
  }
  return;
}
const info$1 = {
  best: "O(n)",
  average: "O(n^(2))",
  worst: "O(n^(2))",
  memory: "O(1)",
  stable: true
};
const useInsertionSort = () => {
  const { chartDataRef, chartCompareCounterRef } = useChartInfo();
  const generatorRef = reactExports.useRef(
    insertionSort(chartDataRef, chartCompareCounterRef)
  );
  const reset = reactExports.useCallback(() => {
    generatorRef.current = insertionSort(chartDataRef, chartCompareCounterRef);
  }, [chartCompareCounterRef, chartDataRef]);
  return {
    sortFunctionGeneratorRef: generatorRef,
    reset,
    info: info$1,
    code: insertionSortCode
  };
};
const mergeFunctionCode = `function merge(arr: number[], left: number, mid: number, right: number) {
  const n1 = mid - left + 1
  const n2 = right - mid

  const L = new Array(n1)
  const R = new Array(n2)

  for (let i = 0; i < n1; i++) {
    L[i] = arr[left + i]
  }
  for (let j = 0; j < n2; j++) {
    R[j] = arr[mid + 1 + j]
  }

  let i = 0
  let j = 0
  let k = left

  while (i < n1 && j < n2) {
    if (L[i] <= R[j]) {
      arr[k] = L[i]
      i++
    } else {
      arr[k] = R[j]
      j++
    }
    k++
  }

  while (i < n1) {
    arr[k] = L[i]
    i++
    k++
  }

  while (j < n2) {
    arr[k] = R[j]
    j++
    k++
  }
}`;
const mergeSortTopBottomFunctionCode = `function mergeSort(arr: number[], left: number, right: number) {
  if (left >= right) {
    return
  }

  const mid = Math.floor(left + (right - left) / 2)
  mergeSort(arr, left, mid)
  mergeSort(arr, mid + 1, right)
  merge(arr, left, mid, right)
}`;
const mergeSortBottomUpFunctionCode = `function mergeSort(arr: number[]) {
  const n = arr.length

  for (let curr_size = 1; curr_size <= n - 1; curr_size *= 2) {
    for (let left = 0; left < n - 1; left += 2 * curr_size) {
      const mid = Math.min(left + curr_size - 1, n - 1)
      const right = Math.min(left + 2 * curr_size - 1, n - 1)

      merge(arr, left, mid, right)
    }
  }
}`;
const mergeSortTopBottomCode = mergeFunctionCode + "\n\n" + mergeSortTopBottomFunctionCode;
const mergeSortBottomUpCode = mergeFunctionCode + "\n\n" + mergeSortBottomUpFunctionCode;
function* merge(chartData, compareCounter, left, mid, right) {
  const n1 = mid - left + 1;
  const n2 = right - mid;
  const L2 = chartData.current.fields.slice(left, left + n1).map((field) => field.number);
  const R2 = chartData.current.fields.slice(mid + 1, mid + 1 + n2).map((field) => field.number);
  let i2 = 0;
  let j = 0;
  let k2 = left;
  while (i2 < n1 && j < n2) {
    visualizeChartDataFields(chartData, compareCounter, CHART_ACTION.COMPARE, [
      left + i2,
      mid + 1 + j
    ]);
    yield 0;
    if (L2[i2] <= R2[j]) {
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.ANIMATE_REPLACE,
        [k2, L2[i2]]
      );
      yield 0;
      replaceChartDataFields(chartData, k2, L2[i2]);
      i2++;
    } else {
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.ANIMATE_REPLACE,
        [k2, R2[j]]
      );
      yield 0;
      replaceChartDataFields(chartData, k2, R2[j]);
      j++;
    }
    k2++;
  }
  while (i2 < n1) {
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_REPLACE,
      [k2, L2[i2]]
    );
    yield 0;
    replaceChartDataFields(chartData, k2, L2[i2]);
    i2++;
    k2++;
  }
  while (j < n2) {
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_REPLACE,
      [k2, R2[j]]
    );
    yield 0;
    replaceChartDataFields(chartData, k2, R2[j]);
    j++;
    k2++;
  }
  return;
}
function* mergeSortTopBottom(chartData, compareCounter, left, right) {
  if (left >= right) {
    return;
  }
  const mid = Math.floor(left + (right - left) / 2);
  yield* mergeSortTopBottom(chartData, compareCounter, left, mid);
  yield* mergeSortTopBottom(chartData, compareCounter, mid + 1, right);
  yield* merge(chartData, compareCounter, left, mid, right);
  return;
}
function* mergeSortBottomUp(chartData, compareCounter) {
  const n2 = chartData.current.fields.length;
  for (let curr_size = 1; curr_size <= n2 - 1; curr_size *= 2) {
    for (let left = 0; left < n2 - 1; left += 2 * curr_size) {
      const mid = Math.min(left + curr_size - 1, n2 - 1);
      const right = Math.min(left + 2 * curr_size - 1, n2 - 1);
      yield* merge(chartData, compareCounter, left, mid, right);
    }
  }
}
const variants$2 = [
  {
    info: {
      best: "O(n log n)",
      average: "(n log n)",
      worst: "O(n log n)",
      memory: "O(n)",
      stable: true
    },
    code: mergeSortTopBottomCode,
    variables: {
      sortFunction: mergeSortTopBottom
    }
  },
  {
    info: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n log n)",
      memory: "O(n)",
      stable: true
    },
    code: mergeSortBottomUpCode,
    variables: {
      sortFunction: mergeSortBottomUp
    }
  }
];
const useMergeSort = (variant = 0) => {
  const { chartDataRef, chartCompareCounterRef } = useChartInfo();
  const generatorRef = reactExports.useRef(
    variants$2[variant].variables.sortFunction(
      chartDataRef,
      chartCompareCounterRef,
      0,
      chartDataRef.current.fields.length - 1
    )
  );
  const reset = reactExports.useCallback(() => {
    generatorRef.current = variants$2[variant].variables.sortFunction(
      chartDataRef,
      chartCompareCounterRef,
      0,
      chartDataRef.current.fields.length - 1
    );
  }, [chartCompareCounterRef, chartDataRef, variant]);
  return {
    sortFunctionGeneratorRef: generatorRef,
    reset,
    info: variants$2[variant].info,
    code: variants$2[variant].code
  };
};
const PARTITION_TYPE = {
  LOMUTO: "LOMUTO",
  HOARE: "HOARE"
};
function* partitionLomuto(chartData, compareCounter, pivotFunction, low, high) {
  const pivotGenerator = pivotFunction(chartData, compareCounter, low, high);
  let pivotResult = pivotGenerator.next();
  while (!pivotResult.done) {
    yield pivotResult.value;
    pivotResult = pivotGenerator.next();
  }
  const pivot = pivotResult.value;
  let i2 = low - 1;
  for (let j = low; j <= high - 1; j++) {
    visualizeChartDataFields(chartData, compareCounter, CHART_ACTION.COMPARE, [
      j,
      pivot
    ]);
    yield 0;
    if (chartData.current.fields[j].number < chartData.current.fields[pivot].number) {
      i2++;
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.ANIMATE_SWAP,
        [i2, j]
      );
      yield 0;
      swapChartDataFields(chartData, i2, j);
    }
  }
  visualizeChartDataFields(
    chartData,
    compareCounter,
    CHART_ACTION.ANIMATE_SWAP,
    [i2 + 1, high]
  );
  yield 0;
  swapChartDataFields(chartData, i2 + 1, high);
  return i2 + 1;
}
function* partitionHoare(chartData, compareCounter, pivotFunction, low, high) {
  const pivotGenerator = pivotFunction(chartData, compareCounter, low, high);
  let pivotResult = pivotGenerator.next();
  while (!pivotResult.done) {
    yield pivotResult.value;
    pivotResult = pivotGenerator.next();
  }
  let pivot = pivotResult.value;
  let i2 = low - 1;
  let j = high + 1;
  while (true) {
    do {
      i2++;
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.COMPARE,
        [i2, pivot]
      );
      yield 0;
    } while (chartData.current.fields[i2].number < chartData.current.fields[pivot].number);
    do {
      j--;
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.COMPARE,
        [pivot, j]
      );
      yield 0;
    } while (chartData.current.fields[j].number > chartData.current.fields[pivot].number);
    if (i2 >= j) {
      return j;
    }
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_SWAP,
      [i2, j]
    );
    yield 0;
    if (i2 === pivot) {
      pivot = j;
    } else if (j === pivot) {
      pivot = i2;
    }
    swapChartDataFields(chartData, i2, j);
  }
}
function* quickSort(chartData, compareCounter, variant, low, high) {
  const partition = variant.variables.partitionType === PARTITION_TYPE.LOMUTO ? partitionLomuto : partitionHoare;
  if (low < high) {
    const partitionGenerator = partition(
      chartData,
      compareCounter,
      variant.variables.pivotFunction,
      low,
      high
    );
    let partitionResult = partitionGenerator.next();
    while (!partitionResult.done) {
      yield partitionResult.value;
      partitionResult = partitionGenerator.next();
    }
    const index2 = partitionResult.value;
    if (variant.variables.partitionType === PARTITION_TYPE.LOMUTO) {
      yield* quickSort(chartData, compareCounter, variant, low, index2 - 1);
    } else {
      yield* quickSort(chartData, compareCounter, variant, low, index2);
    }
    yield* quickSort(chartData, compareCounter, variant, index2 + 1, high);
  }
  return;
}
function* pivotEnd(_chartData, _compareCounter, _low, high) {
  return high;
}
function* pivotStart(_chartData, _compareCounter, low) {
  return low;
}
function* pivotMiddle(_chartData, _compareCounter, low, high) {
  return Math.floor((low + high) / 2);
}
function* pivotMedianOfThree(chartData, compareCounter, low, high) {
  const mid = Math.floor((low + high) / 2);
  visualizeChartDataFields(chartData, compareCounter, CHART_ACTION.COMPARE, [
    mid,
    low
  ]);
  yield 0;
  if (chartData.current.fields[mid].number < chartData.current.fields[low].number) {
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_SWAP,
      [low, mid]
    );
    yield 0;
    swapChartDataFields(chartData, low, mid);
  }
  visualizeChartDataFields(chartData, compareCounter, CHART_ACTION.COMPARE, [
    high,
    low
  ]);
  yield 0;
  if (chartData.current.fields[high].number < chartData.current.fields[low].number) {
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_SWAP,
      [low, high]
    );
    yield 0;
    swapChartDataFields(chartData, low, high);
  }
  visualizeChartDataFields(chartData, compareCounter, CHART_ACTION.COMPARE, [
    mid,
    high
  ]);
  yield 0;
  if (chartData.current.fields[mid].number < chartData.current.fields[high].number) {
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_SWAP,
      [mid, high]
    );
    yield 0;
    swapChartDataFields(chartData, mid, high);
  }
  return high;
}
const pivotMedianOfThreeFunctionCode = `function pivotMedianOfThree(arr: number[], low: number, high: number) {
  const mid = Math.floor((low + high) / 2)

  if (arr[mid] < arr[low]) {
    const temp = arr[low]
    arr[low] = arr[mid]
    arr[mid] = temp
  }

  if (arr[high] < arr[low]) {
    const temp = arr[low]
    arr[low] = arr[high]
    arr[high] = temp
  }

  if (arr[mid] < arr[high]) {
    const temp = arr[mid]
    arr[mid] = arr[high]
    arr[high] = temp
  }

  return high
}`;
const partitionLomutoFunctionCode = (pivotFunction) => `function partitionLomuto(arr: number[], low: number, high: number) {
  const pivot = ${pivotFunction}
  let i = low - 1

  for (let j = low; j <= high - 1; j++) {
    if (arr[j] < pivot) {
      i++
      const temp = arr[i]
      arr[i] = arr[j]
      arr[j] = temp
    }
  }

  arr[high] = arr[i + 1]
  arr[i + 1] = pivot
  return i + 1
}`;
const quickSortLomutoFunctionCode = `function quickSortLomuto(arr: number[], low: number, high: number) {
  if (low < high) {
    const index = partitionLomuto(arr, low, high)

    quickSortLomuto(arr, low, index - 1)
    quickSortLomuto(arr, index + 1, high)
  }
}`;
const partitionHoareFunctionCode = (pivotFunction) => `function partitionHoare(arr: number[], low: number, high: number) {
  const pivot = ${pivotFunction}

  let i = low - 1
  let j = high + 1

  while (true) {
    do {
      i++
    } while (arr[i] < pivot)

    do {
      j--
    } while (arr[j] > pivot)

    if (i >= j) {
      return j
    }

    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
  }
}`;
const quickSortHoareFunctionCode = `function quickSortHoare(arr: number[], low: number, high: number) {
  if (low < high) {
    const index = partitionHoare(arr, low, high)

    quickSortHoare(arr, low, index)
    quickSortHoare(arr, index + 1, high)
  }
}`;
const quickSortLomutoEndCode = partitionLomutoFunctionCode(`arr[high]`) + "\n\n" + quickSortLomutoFunctionCode;
const quickSortLomutoMedianCode = pivotMedianOfThreeFunctionCode + "\n\n" + partitionLomutoFunctionCode(`arr[pivotMedianOfThree(arr, low, high)]`) + "\n\n" + quickSortLomutoFunctionCode;
const quickSortHoareStartCode = partitionHoareFunctionCode(`arr[low]`) + "\n\n" + quickSortHoareFunctionCode;
const quickSortHoareMiddleCode = partitionHoareFunctionCode(`arr[Math.floor((low + high) / 2)]`) + "\n\n" + quickSortHoareFunctionCode;
const variants$1 = [
  {
    info: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n^(2))",
      memory: "O(log n)",
      stable: false
    },
    code: quickSortLomutoEndCode,
    variables: {
      partitionType: PARTITION_TYPE.LOMUTO,
      pivotFunction: pivotEnd
    }
  },
  {
    info: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n^(2))",
      memory: "O(log n)",
      stable: false
    },
    code: quickSortLomutoMedianCode,
    variables: {
      partitionType: PARTITION_TYPE.LOMUTO,
      pivotFunction: pivotMedianOfThree
    }
  },
  {
    info: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n^(2))",
      memory: "O(log n)",
      stable: false
    },
    code: quickSortHoareStartCode,
    variables: {
      partitionType: PARTITION_TYPE.HOARE,
      pivotFunction: pivotStart
    }
  },
  {
    info: {
      best: "O(n log n)",
      average: "O(n log n)",
      worst: "O(n^(2))",
      memory: "O(log n)",
      stable: false
    },
    code: quickSortHoareMiddleCode,
    variables: {
      partitionType: PARTITION_TYPE.HOARE,
      pivotFunction: pivotMiddle
    }
  }
];
const useQuickSort = (variant = 0) => {
  const { chartDataRef, chartCompareCounterRef } = useChartInfo();
  const generatorRef = reactExports.useRef(
    quickSort(
      chartDataRef,
      chartCompareCounterRef,
      variants$1[variant],
      0,
      chartDataRef.current.fields.length - 1
    )
  );
  const reset = reactExports.useCallback(() => {
    generatorRef.current = quickSort(
      chartDataRef,
      chartCompareCounterRef,
      variants$1[variant],
      0,
      chartDataRef.current.fields.length - 1
    );
  }, [chartCompareCounterRef, chartDataRef, variant]);
  return {
    sortFunctionGeneratorRef: generatorRef,
    reset,
    info: variants$1[variant].info,
    code: variants$1[variant].code
  };
};
const selectionSortCode = `function selectionSort(arr: number[]) {
  const n = arr.length

  for (let i = 0; i < n - 1; i++) {
    let min_idx = i

    for (let j = i + 1; j < n; j++) {
      if (arr[j] < arr[min_idx]) {
        min_idx = j
      }
    }

    const temp = arr[i]
    arr[i] = arr[min_idx]
    arr[min_idx] = temp
  }
}`;
function* selectionSort(chartData, compareCounter) {
  const n2 = chartData.current.fields.length;
  for (let i2 = 0; i2 < n2 - 1; i2++) {
    let min_idx = i2;
    for (let j = i2 + 1; j < n2; j++) {
      visualizeChartDataFields(
        chartData,
        compareCounter,
        CHART_ACTION.COMPARE,
        [min_idx, j]
      );
      yield 0;
      if (chartData.current.fields[j].number < chartData.current.fields[min_idx].number) {
        min_idx = j;
      }
    }
    visualizeChartDataFields(
      chartData,
      compareCounter,
      CHART_ACTION.ANIMATE_SWAP,
      [i2, min_idx]
    );
    yield 0;
    swapChartDataFields(chartData, i2, min_idx);
  }
  return;
}
const info = {
  best: "O(n^(2))",
  average: "O(n^(2))",
  worst: "O(n^(2))",
  memory: "O(1)",
  stable: false
};
const useSelectionSort = () => {
  const { chartDataRef, chartCompareCounterRef } = useChartInfo();
  const generatorRef = reactExports.useRef(
    selectionSort(chartDataRef, chartCompareCounterRef)
  );
  const reset = reactExports.useCallback(() => {
    generatorRef.current = selectionSort(chartDataRef, chartCompareCounterRef);
  }, [chartCompareCounterRef, chartDataRef]);
  return {
    sortFunctionGeneratorRef: generatorRef,
    reset,
    info,
    code: selectionSortCode
  };
};
function* shellSort(chartData, compareCounter, variant) {
  const n2 = chartData.current.fields.length;
  const gapFunction = variant.variables.gapFunction;
  for (let gap = gapFunction(n2); gap > 0; gap = gapFunction(gap)) {
    for (let i2 = gap; i2 < n2; i2++) {
      let temp = i2;
      for (let j = i2; j >= gap; j -= gap) {
        visualizeChartDataFields(
          chartData,
          compareCounter,
          CHART_ACTION.COMPARE,
          [j - gap, temp]
        );
        yield 0;
        if (chartData.current.fields[j - gap].number <= chartData.current.fields[temp].number) {
          break;
        }
        visualizeChartDataFields(
          chartData,
          compareCounter,
          CHART_ACTION.ANIMATE_SWAP,
          [j - gap, j]
        );
        yield 0;
        if (temp === j) {
          temp = j - gap;
        } else if (temp === j - gap) {
          temp = j;
        }
        swapChartDataFields(chartData, j - gap, j);
      }
    }
  }
  return;
}
function gapShell(num) {
  return Math.floor(num / 2);
}
function gapHibbard(num) {
  let k2 = 1;
  while (Math.pow(2, k2) - 1 < num) {
    k2++;
  }
  return Math.floor(Math.pow(2, k2 - 1) - 1);
}
function gapSedgewick(num) {
  if (num === 1) {
    return 0;
  }
  let k2 = 1;
  let gap = 1;
  let newGap = 1;
  while (newGap < num) {
    gap = newGap;
    if (k2 % 2) {
      newGap = 8 * Math.pow(2, k2) - 6 * Math.pow(2, (k2 + 1) / 2) + 1;
    } else {
      newGap = 9 * (Math.pow(2, k2) - Math.pow(2, k2 / 2)) + 1;
    }
    k2++;
  }
  return gap;
}
const gapHibbardFunctionCode = `function gapHibbard(num: number) {
  let k = 1
  while (Math.pow(2, k) - 1 < num) {
    k++
  }
  return Math.floor(Math.pow(2, k - 1) - 1)
}`;
const gapSedgewickFunctionCode = `function gapSedgewick(num: number) {
  if (num === 1) {
    return 0
  }

  let k = 1
  let gap = 1
  let newGap = 1

  while (newGap < num) {
    gap = newGap

    if (k % 2) {
      newGap = 8 * Math.pow(2, k) - 6 * Math.pow(2, (k + 1) / 2) + 1
    } else {
      newGap = 9 * (Math.pow(2, k) - Math.pow(2, k / 2)) + 1
    }

    k++
  }

  return gap
}`;
const shellSortFunctionCode = (gapFunction1, gapFunction2) => `function shellSort(arr: number[]) {
  const n = arr.length

  for (let gap = ${gapFunction1}; gap > 0; gap = ${gapFunction2}) {
    for (let i = gap; i < n; i++) {
      const temp = arr[i]
      let j = i

      while (j >= gap && arr[j - gap] > temp) {
        arr[j] = arr[j - gap]
        j -= gap
      }
      arr[j] = temp
    }
  }
}`;
const shellSortShellCode = shellSortFunctionCode(
  `Math.floor(n / 2)`,
  `Math.floor(gap / 2)`
);
const shellSortHibbardCode = gapHibbardFunctionCode + "\n\n" + shellSortFunctionCode(`gapHibbard(n)`, `gapHibbard(gap)`);
const shellSortSedgewickCode = gapSedgewickFunctionCode + "\n\n" + shellSortFunctionCode(`gapSedgewick(n)`, `gapSedgewick(gap)`);
var reactKatex = { exports: {} };
var propTypes = { exports: {} };
var ReactPropTypesSecret$1 = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
var ReactPropTypesSecret_1 = ReactPropTypesSecret$1;
var ReactPropTypesSecret = ReactPropTypesSecret_1;
function emptyFunction() {
}
function emptyFunctionWithReset() {
}
emptyFunctionWithReset.resetWarningCache = emptyFunction;
var factoryWithThrowingShims = function() {
  function shim2(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      return;
    }
    var err = new Error(
      "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
    );
    err.name = "Invariant Violation";
    throw err;
  }
  shim2.isRequired = shim2;
  function getShim() {
    return shim2;
  }
  var ReactPropTypes = {
    array: shim2,
    bigint: shim2,
    bool: shim2,
    func: shim2,
    number: shim2,
    object: shim2,
    string: shim2,
    symbol: shim2,
    any: shim2,
    arrayOf: getShim,
    element: shim2,
    elementType: shim2,
    instanceOf: getShim,
    node: shim2,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim,
    checkPropTypes: emptyFunctionWithReset,
    resetWarningCache: emptyFunction
  };
  ReactPropTypes.PropTypes = ReactPropTypes;
  return ReactPropTypes;
};
{
  propTypes.exports = factoryWithThrowingShims();
}
var propTypesExports = propTypes.exports;
var katex = { exports: {} };
var hasRequiredKatex;
function requireKatex() {
  if (hasRequiredKatex) return katex.exports;
  hasRequiredKatex = 1;
  (function(module, exports) {
    (function webpackUniversalModuleDefinition(root, factory) {
      module.exports = factory();
    })(typeof self !== "undefined" ? self : commonjsGlobal, function() {
      return (
        /******/
        function() {
          var __webpack_require__ = {};
          !function() {
            __webpack_require__.d = function(exports2, definition) {
              for (var key in definition) {
                if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
                  Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
                }
              }
            };
          }();
          !function() {
            __webpack_require__.o = function(obj, prop) {
              return Object.prototype.hasOwnProperty.call(obj, prop);
            };
          }();
          var __webpack_exports__ = {};
          __webpack_require__.d(__webpack_exports__, {
            "default": function() {
              return (
                /* binding */
                katex_webpack
              );
            }
          });
          class ParseError {
            // Error start position based on passed-in Token or ParseNode.
            // Length of affected text based on passed-in Token or ParseNode.
            // The underlying error message without any context added.
            constructor(message, token) {
              this.name = void 0;
              this.position = void 0;
              this.length = void 0;
              this.rawMessage = void 0;
              let error = "KaTeX parse error: " + message;
              let start;
              let end;
              const loc = token && token.loc;
              if (loc && loc.start <= loc.end) {
                const input = loc.lexer.input;
                start = loc.start;
                end = loc.end;
                if (start === input.length) {
                  error += " at end of input: ";
                } else {
                  error += " at position " + (start + 1) + ": ";
                }
                const underlined = input.slice(start, end).replace(/[^]/g, "$&̲");
                let left;
                if (start > 15) {
                  left = "…" + input.slice(start - 15, start);
                } else {
                  left = input.slice(0, start);
                }
                let right;
                if (end + 15 < input.length) {
                  right = input.slice(end, end + 15) + "…";
                } else {
                  right = input.slice(end);
                }
                error += left + underlined + right;
              }
              const self2 = new Error(error);
              self2.name = "ParseError";
              self2.__proto__ = ParseError.prototype;
              self2.position = start;
              if (start != null && end != null) {
                self2.length = end - start;
              }
              self2.rawMessage = message;
              return self2;
            }
          }
          ParseError.prototype.__proto__ = Error.prototype;
          var src_ParseError = ParseError;
          const contains = function(list, elem) {
            return list.indexOf(elem) !== -1;
          };
          const deflt = function(setting, defaultIfUndefined) {
            return setting === void 0 ? defaultIfUndefined : setting;
          };
          const uppercase = /([A-Z])/g;
          const hyphenate = function(str) {
            return str.replace(uppercase, "-$1").toLowerCase();
          };
          const ESCAPE_LOOKUP = {
            "&": "&amp;",
            ">": "&gt;",
            "<": "&lt;",
            '"': "&quot;",
            "'": "&#x27;"
          };
          const ESCAPE_REGEX = /[&><"']/g;
          function utils_escape(text) {
            return String(text).replace(ESCAPE_REGEX, (match) => ESCAPE_LOOKUP[match]);
          }
          const getBaseElem = function(group) {
            if (group.type === "ordgroup") {
              if (group.body.length === 1) {
                return getBaseElem(group.body[0]);
              } else {
                return group;
              }
            } else if (group.type === "color") {
              if (group.body.length === 1) {
                return getBaseElem(group.body[0]);
              } else {
                return group;
              }
            } else if (group.type === "font") {
              return getBaseElem(group.body);
            } else {
              return group;
            }
          };
          const isCharacterBox = function(group) {
            const baseElem = getBaseElem(group);
            return baseElem.type === "mathord" || baseElem.type === "textord" || baseElem.type === "atom";
          };
          const assert = function(value) {
            if (!value) {
              throw new Error("Expected non-null, but got " + String(value));
            }
            return value;
          };
          const protocolFromUrl = function(url) {
            const protocol = /^[\x00-\x20]*([^\\/#?]*?)(:|&#0*58|&#x0*3a|&colon)/i.exec(url);
            if (!protocol) {
              return "_relative";
            }
            if (protocol[2] !== ":") {
              return null;
            }
            if (!/^[a-zA-Z][a-zA-Z0-9+\-.]*$/.test(protocol[1])) {
              return null;
            }
            return protocol[1].toLowerCase();
          };
          var utils = {
            contains,
            deflt,
            escape: utils_escape,
            hyphenate,
            getBaseElem,
            isCharacterBox,
            protocolFromUrl
          };
          const SETTINGS_SCHEMA = {
            displayMode: {
              type: "boolean",
              description: "Render math in display mode, which puts the math in display style (so \\int and \\sum are large, for example), and centers the math on the page on its own line.",
              cli: "-d, --display-mode"
            },
            output: {
              type: {
                enum: ["htmlAndMathml", "html", "mathml"]
              },
              description: "Determines the markup language of the output.",
              cli: "-F, --format <type>"
            },
            leqno: {
              type: "boolean",
              description: "Render display math in leqno style (left-justified tags)."
            },
            fleqn: {
              type: "boolean",
              description: "Render display math flush left."
            },
            throwOnError: {
              type: "boolean",
              default: true,
              cli: "-t, --no-throw-on-error",
              cliDescription: "Render errors (in the color given by --error-color) instead of throwing a ParseError exception when encountering an error."
            },
            errorColor: {
              type: "string",
              default: "#cc0000",
              cli: "-c, --error-color <color>",
              cliDescription: "A color string given in the format 'rgb' or 'rrggbb' (no #). This option determines the color of errors rendered by the -t option.",
              cliProcessor: (color) => "#" + color
            },
            macros: {
              type: "object",
              cli: "-m, --macro <def>",
              cliDescription: "Define custom macro of the form '\\foo:expansion' (use multiple -m arguments for multiple macros).",
              cliDefault: [],
              cliProcessor: (def, defs) => {
                defs.push(def);
                return defs;
              }
            },
            minRuleThickness: {
              type: "number",
              description: "Specifies a minimum thickness, in ems, for fraction lines, `\\sqrt` top lines, `{array}` vertical lines, `\\hline`, `\\hdashline`, `\\underline`, `\\overline`, and the borders of `\\fbox`, `\\boxed`, and `\\fcolorbox`.",
              processor: (t2) => Math.max(0, t2),
              cli: "--min-rule-thickness <size>",
              cliProcessor: parseFloat
            },
            colorIsTextColor: {
              type: "boolean",
              description: "Makes \\color behave like LaTeX's 2-argument \\textcolor, instead of LaTeX's one-argument \\color mode change.",
              cli: "-b, --color-is-text-color"
            },
            strict: {
              type: [{
                enum: ["warn", "ignore", "error"]
              }, "boolean", "function"],
              description: "Turn on strict / LaTeX faithfulness mode, which throws an error if the input uses features that are not supported by LaTeX.",
              cli: "-S, --strict",
              cliDefault: false
            },
            trust: {
              type: ["boolean", "function"],
              description: "Trust the input, enabling all HTML features such as \\url.",
              cli: "-T, --trust"
            },
            maxSize: {
              type: "number",
              default: Infinity,
              description: "If non-zero, all user-specified sizes, e.g. in \\rule{500em}{500em}, will be capped to maxSize ems. Otherwise, elements and spaces can be arbitrarily large",
              processor: (s2) => Math.max(0, s2),
              cli: "-s, --max-size <n>",
              cliProcessor: parseInt
            },
            maxExpand: {
              type: "number",
              default: 1e3,
              description: "Limit the number of macro expansions to the specified number, to prevent e.g. infinite macro loops. If set to Infinity, the macro expander will try to fully expand as in LaTeX.",
              processor: (n2) => Math.max(0, n2),
              cli: "-e, --max-expand <n>",
              cliProcessor: (n2) => n2 === "Infinity" ? Infinity : parseInt(n2)
            },
            globalGroup: {
              type: "boolean",
              cli: false
            }
          };
          function getDefaultValue(schema) {
            if (schema.default) {
              return schema.default;
            }
            const type = schema.type;
            const defaultType = Array.isArray(type) ? type[0] : type;
            if (typeof defaultType !== "string") {
              return defaultType.enum[0];
            }
            switch (defaultType) {
              case "boolean":
                return false;
              case "string":
                return "";
              case "number":
                return 0;
              case "object":
                return {};
            }
          }
          class Settings {
            constructor(options) {
              this.displayMode = void 0;
              this.output = void 0;
              this.leqno = void 0;
              this.fleqn = void 0;
              this.throwOnError = void 0;
              this.errorColor = void 0;
              this.macros = void 0;
              this.minRuleThickness = void 0;
              this.colorIsTextColor = void 0;
              this.strict = void 0;
              this.trust = void 0;
              this.maxSize = void 0;
              this.maxExpand = void 0;
              this.globalGroup = void 0;
              options = options || {};
              for (const prop in SETTINGS_SCHEMA) {
                if (SETTINGS_SCHEMA.hasOwnProperty(prop)) {
                  const schema = SETTINGS_SCHEMA[prop];
                  this[prop] = options[prop] !== void 0 ? schema.processor ? schema.processor(options[prop]) : options[prop] : getDefaultValue(schema);
                }
              }
            }
            /**
             * Report nonstrict (non-LaTeX-compatible) input.
             * Can safely not be called if `this.strict` is false in JavaScript.
             */
            reportNonstrict(errorCode, errorMsg, token) {
              let strict = this.strict;
              if (typeof strict === "function") {
                strict = strict(errorCode, errorMsg, token);
              }
              if (!strict || strict === "ignore") {
                return;
              } else if (strict === true || strict === "error") {
                throw new src_ParseError("LaTeX-incompatible input and strict mode is set to 'error': " + (errorMsg + " [" + errorCode + "]"), token);
              } else if (strict === "warn") {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
              } else {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
              }
            }
            /**
             * Check whether to apply strict (LaTeX-adhering) behavior for unusual
             * input (like `\\`).  Unlike `nonstrict`, will not throw an error;
             * instead, "error" translates to a return value of `true`, while "ignore"
             * translates to a return value of `false`.  May still print a warning:
             * "warn" prints a warning and returns `false`.
             * This is for the second category of `errorCode`s listed in the README.
             */
            useStrictBehavior(errorCode, errorMsg, token) {
              let strict = this.strict;
              if (typeof strict === "function") {
                try {
                  strict = strict(errorCode, errorMsg, token);
                } catch (error) {
                  strict = "error";
                }
              }
              if (!strict || strict === "ignore") {
                return false;
              } else if (strict === true || strict === "error") {
                return true;
              } else if (strict === "warn") {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to 'warn': " + (errorMsg + " [" + errorCode + "]"));
                return false;
              } else {
                typeof console !== "undefined" && console.warn("LaTeX-incompatible input and strict mode is set to " + ("unrecognized '" + strict + "': " + errorMsg + " [" + errorCode + "]"));
                return false;
              }
            }
            /**
             * Check whether to test potentially dangerous input, and return
             * `true` (trusted) or `false` (untrusted).  The sole argument `context`
             * should be an object with `command` field specifying the relevant LaTeX
             * command (as a string starting with `\`), and any other arguments, etc.
             * If `context` has a `url` field, a `protocol` field will automatically
             * get added by this function (changing the specified object).
             */
            isTrusted(context) {
              if (context.url && !context.protocol) {
                const protocol = utils.protocolFromUrl(context.url);
                if (protocol == null) {
                  return false;
                }
                context.protocol = protocol;
              }
              const trust = typeof this.trust === "function" ? this.trust(context) : this.trust;
              return Boolean(trust);
            }
          }
          class Style2 {
            constructor(id2, size2, cramped) {
              this.id = void 0;
              this.size = void 0;
              this.cramped = void 0;
              this.id = id2;
              this.size = size2;
              this.cramped = cramped;
            }
            /**
             * Get the style of a superscript given a base in the current style.
             */
            sup() {
              return styles[sup[this.id]];
            }
            /**
             * Get the style of a subscript given a base in the current style.
             */
            sub() {
              return styles[sub[this.id]];
            }
            /**
             * Get the style of a fraction numerator given the fraction in the current
             * style.
             */
            fracNum() {
              return styles[fracNum[this.id]];
            }
            /**
             * Get the style of a fraction denominator given the fraction in the current
             * style.
             */
            fracDen() {
              return styles[fracDen[this.id]];
            }
            /**
             * Get the cramped version of a style (in particular, cramping a cramped style
             * doesn't change the style).
             */
            cramp() {
              return styles[cramp[this.id]];
            }
            /**
             * Get a text or display version of this style.
             */
            text() {
              return styles[Style_text[this.id]];
            }
            /**
             * Return true if this style is tightly spaced (scriptstyle/scriptscriptstyle)
             */
            isTight() {
              return this.size >= 2;
            }
          }
          const D2 = 0;
          const Dc2 = 1;
          const T2 = 2;
          const Tc2 = 3;
          const S2 = 4;
          const Sc2 = 5;
          const SS = 6;
          const SSc = 7;
          const styles = [new Style2(D2, 0, false), new Style2(Dc2, 0, true), new Style2(T2, 1, false), new Style2(Tc2, 1, true), new Style2(S2, 2, false), new Style2(Sc2, 2, true), new Style2(SS, 3, false), new Style2(SSc, 3, true)];
          const sup = [S2, Sc2, S2, Sc2, SS, SSc, SS, SSc];
          const sub = [Sc2, Sc2, Sc2, Sc2, SSc, SSc, SSc, SSc];
          const fracNum = [T2, Tc2, S2, Sc2, SS, SSc, SS, SSc];
          const fracDen = [Tc2, Tc2, Sc2, Sc2, SSc, SSc, SSc, SSc];
          const cramp = [Dc2, Dc2, Tc2, Tc2, Sc2, Sc2, SSc, SSc];
          const Style_text = [D2, Dc2, T2, Tc2, T2, Tc2, T2, Tc2];
          var src_Style = {
            DISPLAY: styles[D2],
            TEXT: styles[T2],
            SCRIPT: styles[S2],
            SCRIPTSCRIPT: styles[SS]
          };
          const scriptData = [{
            // Latin characters beyond the Latin-1 characters we have metrics for.
            // Needed for Czech, Hungarian and Turkish text, for example.
            name: "latin",
            blocks: [
              [256, 591],
              // Latin Extended-A and Latin Extended-B
              [768, 879]
              // Combining Diacritical marks
            ]
          }, {
            // The Cyrillic script used by Russian and related languages.
            // A Cyrillic subset used to be supported as explicitly defined
            // symbols in symbols.js
            name: "cyrillic",
            blocks: [[1024, 1279]]
          }, {
            // Armenian
            name: "armenian",
            blocks: [[1328, 1423]]
          }, {
            // The Brahmic scripts of South and Southeast Asia
            // Devanagari (0900–097F)
            // Bengali (0980–09FF)
            // Gurmukhi (0A00–0A7F)
            // Gujarati (0A80–0AFF)
            // Oriya (0B00–0B7F)
            // Tamil (0B80–0BFF)
            // Telugu (0C00–0C7F)
            // Kannada (0C80–0CFF)
            // Malayalam (0D00–0D7F)
            // Sinhala (0D80–0DFF)
            // Thai (0E00–0E7F)
            // Lao (0E80–0EFF)
            // Tibetan (0F00–0FFF)
            // Myanmar (1000–109F)
            name: "brahmic",
            blocks: [[2304, 4255]]
          }, {
            name: "georgian",
            blocks: [[4256, 4351]]
          }, {
            // Chinese and Japanese.
            // The "k" in cjk is for Korean, but we've separated Korean out
            name: "cjk",
            blocks: [
              [12288, 12543],
              // CJK symbols and punctuation, Hiragana, Katakana
              [19968, 40879],
              // CJK ideograms
              [65280, 65376]
              // Fullwidth punctuation
              // TODO: add halfwidth Katakana and Romanji glyphs
            ]
          }, {
            // Korean
            name: "hangul",
            blocks: [[44032, 55215]]
          }];
          function scriptFromCodepoint(codepoint) {
            for (let i2 = 0; i2 < scriptData.length; i2++) {
              const script = scriptData[i2];
              for (let i3 = 0; i3 < script.blocks.length; i3++) {
                const block = script.blocks[i3];
                if (codepoint >= block[0] && codepoint <= block[1]) {
                  return script.name;
                }
              }
            }
            return null;
          }
          const allBlocks = [];
          scriptData.forEach((s2) => s2.blocks.forEach((b2) => allBlocks.push(...b2)));
          function supportedCodepoint(codepoint) {
            for (let i2 = 0; i2 < allBlocks.length; i2 += 2) {
              if (codepoint >= allBlocks[i2] && codepoint <= allBlocks[i2 + 1]) {
                return true;
              }
            }
            return false;
          }
          const hLinePad = 80;
          const sqrtMain = function(extraVinculum, hLinePad2) {
            return "M95," + (622 + extraVinculum + hLinePad2) + "\nc-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14\nc0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54\nc44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10\ns173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429\nc69,-144,104.5,-217.7,106.5,-221\nl" + extraVinculum / 2.075 + " -" + extraVinculum + "\nc5.3,-9.3,12,-14,20,-14\nH400000v" + (40 + extraVinculum) + "H845.2724\ns-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7\nc-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z\nM" + (834 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
          };
          const sqrtSize1 = function(extraVinculum, hLinePad2) {
            return "M263," + (601 + extraVinculum + hLinePad2) + "c0.7,0,18,39.7,52,119\nc34,79.3,68.167,158.7,102.5,238c34.3,79.3,51.8,119.3,52.5,120\nc340,-704.7,510.7,-1060.3,512,-1067\nl" + extraVinculum / 2.084 + " -" + extraVinculum + "\nc4.7,-7.3,11,-11,19,-11\nH40000v" + (40 + extraVinculum) + "H1012.3\ns-271.3,567,-271.3,567c-38.7,80.7,-84,175,-136,283c-52,108,-89.167,185.3,-111.5,232\nc-22.3,46.7,-33.8,70.3,-34.5,71c-4.7,4.7,-12.3,7,-23,7s-12,-1,-12,-1\ns-109,-253,-109,-253c-72.7,-168,-109.3,-252,-110,-252c-10.7,8,-22,16.7,-34,26\nc-22,17.3,-33.3,26,-34,26s-26,-26,-26,-26s76,-59,76,-59s76,-60,76,-60z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
          };
          const sqrtSize2 = function(extraVinculum, hLinePad2) {
            return "M983 " + (10 + extraVinculum + hLinePad2) + "\nl" + extraVinculum / 3.13 + " -" + extraVinculum + "\nc4,-6.7,10,-10,18,-10 H400000v" + (40 + extraVinculum) + "\nH1013.1s-83.4,268,-264.1,840c-180.7,572,-277,876.3,-289,913c-4.7,4.7,-12.7,7,-24,7\ns-12,0,-12,0c-1.3,-3.3,-3.7,-11.7,-7,-25c-35.3,-125.3,-106.7,-373.3,-214,-744\nc-10,12,-21,25,-33,39s-32,39,-32,39c-6,-5.3,-15,-14,-27,-26s25,-30,25,-30\nc26.7,-32.7,52,-63,76,-91s52,-60,52,-60s208,722,208,722\nc56,-175.3,126.3,-397.3,211,-666c84.7,-268.7,153.8,-488.2,207.5,-658.5\nc53.7,-170.3,84.5,-266.8,92.5,-289.5z\nM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "h-400000z";
          };
          const sqrtSize3 = function(extraVinculum, hLinePad2) {
            return "M424," + (2398 + extraVinculum + hLinePad2) + "\nc-1.3,-0.7,-38.5,-172,-111.5,-514c-73,-342,-109.8,-513.3,-110.5,-514\nc0,-2,-10.7,14.3,-32,49c-4.7,7.3,-9.8,15.7,-15.5,25c-5.7,9.3,-9.8,16,-12.5,20\ns-5,7,-5,7c-4,-3.3,-8.3,-7.7,-13,-13s-13,-13,-13,-13s76,-122,76,-122s77,-121,77,-121\ns209,968,209,968c0,-2,84.7,-361.7,254,-1079c169.3,-717.3,254.7,-1077.7,256,-1081\nl" + extraVinculum / 4.223 + " -" + extraVinculum + "c4,-6.7,10,-10,18,-10 H400000\nv" + (40 + extraVinculum) + "H1014.6\ns-87.3,378.7,-272.6,1166c-185.3,787.3,-279.3,1182.3,-282,1185\nc-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2z M" + (1001 + extraVinculum) + " " + hLinePad2 + "\nh400000v" + (40 + extraVinculum) + "h-400000z";
          };
          const sqrtSize4 = function(extraVinculum, hLinePad2) {
            return "M473," + (2713 + extraVinculum + hLinePad2) + "\nc339.3,-1799.3,509.3,-2700,510,-2702 l" + extraVinculum / 5.298 + " -" + extraVinculum + "\nc3.3,-7.3,9.3,-11,18,-11 H400000v" + (40 + extraVinculum) + "H1017.7\ns-90.5,478,-276.2,1466c-185.7,988,-279.5,1483,-281.5,1485c-2,6,-10,9,-24,9\nc-8,0,-12,-0.7,-12,-2c0,-1.3,-5.3,-32,-16,-92c-50.7,-293.3,-119.7,-693.3,-207,-1200\nc0,-1.3,-5.3,8.7,-16,30c-10.7,21.3,-21.3,42.7,-32,64s-16,33,-16,33s-26,-26,-26,-26\ns76,-153,76,-153s77,-151,77,-151c0.7,0.7,35.7,202,105,604c67.3,400.7,102,602.7,104,\n606zM" + (1001 + extraVinculum) + " " + hLinePad2 + "h400000v" + (40 + extraVinculum) + "H1017.7z";
          };
          const phasePath = function(y2) {
            const x2 = y2 / 2;
            return "M400000 " + y2 + " H0 L" + x2 + " 0 l65 45 L145 " + (y2 - 80) + " H400000z";
          };
          const sqrtTall = function(extraVinculum, hLinePad2, viewBoxHeight) {
            const vertSegment = viewBoxHeight - 54 - hLinePad2 - extraVinculum;
            return "M702 " + (extraVinculum + hLinePad2) + "H400000" + (40 + extraVinculum) + "\nH742v" + vertSegment + "l-4 4-4 4c-.667.7 -2 1.5-4 2.5s-4.167 1.833-6.5 2.5-5.5 1-9.5 1\nh-12l-28-84c-16.667-52-96.667 -294.333-240-727l-212 -643 -85 170\nc-4-3.333-8.333-7.667-13 -13l-13-13l77-155 77-156c66 199.333 139 419.667\n219 661 l218 661zM702 " + hLinePad2 + "H400000v" + (40 + extraVinculum) + "H742z";
          };
          const sqrtPath = function(size2, extraVinculum, viewBoxHeight) {
            extraVinculum = 1e3 * extraVinculum;
            let path3 = "";
            switch (size2) {
              case "sqrtMain":
                path3 = sqrtMain(extraVinculum, hLinePad);
                break;
              case "sqrtSize1":
                path3 = sqrtSize1(extraVinculum, hLinePad);
                break;
              case "sqrtSize2":
                path3 = sqrtSize2(extraVinculum, hLinePad);
                break;
              case "sqrtSize3":
                path3 = sqrtSize3(extraVinculum, hLinePad);
                break;
              case "sqrtSize4":
                path3 = sqrtSize4(extraVinculum, hLinePad);
                break;
              case "sqrtTall":
                path3 = sqrtTall(extraVinculum, hLinePad, viewBoxHeight);
            }
            return path3;
          };
          const innerPath = function(name, height) {
            switch (name) {
              case "⎜":
                return "M291 0 H417 V" + height + " H291z M291 0 H417 V" + height + " H291z";
              case "∣":
                return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z";
              case "∥":
                return "M145 0 H188 V" + height + " H145z M145 0 H188 V" + height + " H145z" + ("M367 0 H410 V" + height + " H367z M367 0 H410 V" + height + " H367z");
              case "⎟":
                return "M457 0 H583 V" + height + " H457z M457 0 H583 V" + height + " H457z";
              case "⎢":
                return "M319 0 H403 V" + height + " H319z M319 0 H403 V" + height + " H319z";
              case "⎥":
                return "M263 0 H347 V" + height + " H263z M263 0 H347 V" + height + " H263z";
              case "⎪":
                return "M384 0 H504 V" + height + " H384z M384 0 H504 V" + height + " H384z";
              case "⏐":
                return "M312 0 H355 V" + height + " H312z M312 0 H355 V" + height + " H312z";
              case "‖":
                return "M257 0 H300 V" + height + " H257z M257 0 H300 V" + height + " H257z" + ("M478 0 H521 V" + height + " H478z M478 0 H521 V" + height + " H478z");
              default:
                return "";
            }
          };
          const path2 = {
            // The doubleleftarrow geometry is from glyph U+21D0 in the font KaTeX Main
            doubleleftarrow: "M262 157\nl10-10c34-36 62.7-77 86-123 3.3-8 5-13.3 5-16 0-5.3-6.7-8-20-8-7.3\n 0-12.2.5-14.5 1.5-2.3 1-4.8 4.5-7.5 10.5-49.3 97.3-121.7 169.3-217 216-28\n 14-57.3 25-88 33-6.7 2-11 3.8-13 5.5-2 1.7-3 4.2-3 7.5s1 5.8 3 7.5\nc2 1.7 6.3 3.5 13 5.5 68 17.3 128.2 47.8 180.5 91.5 52.3 43.7 93.8 96.2 124.5\n 157.5 9.3 8 15.3 12.3 18 13h6c12-.7 18-4 18-10 0-2-1.7-7-5-15-23.3-46-52-87\n-86-123l-10-10h399738v-40H218c328 0 0 0 0 0l-10-8c-26.7-20-65.7-43-117-69 2.7\n-2 6-3.7 10-5 36.7-16 72.3-37.3 107-64l10-8h399782v-40z\nm8 0v40h399730v-40zm0 194v40h399730v-40z",
            // doublerightarrow is from glyph U+21D2 in font KaTeX Main
            doublerightarrow: "M399738 392l\n-10 10c-34 36-62.7 77-86 123-3.3 8-5 13.3-5 16 0 5.3 6.7 8 20 8 7.3 0 12.2-.5\n 14.5-1.5 2.3-1 4.8-4.5 7.5-10.5 49.3-97.3 121.7-169.3 217-216 28-14 57.3-25 88\n-33 6.7-2 11-3.8 13-5.5 2-1.7 3-4.2 3-7.5s-1-5.8-3-7.5c-2-1.7-6.3-3.5-13-5.5-68\n-17.3-128.2-47.8-180.5-91.5-52.3-43.7-93.8-96.2-124.5-157.5-9.3-8-15.3-12.3-18\n-13h-6c-12 .7-18 4-18 10 0 2 1.7 7 5 15 23.3 46 52 87 86 123l10 10H0v40h399782\nc-328 0 0 0 0 0l10 8c26.7 20 65.7 43 117 69-2.7 2-6 3.7-10 5-36.7 16-72.3 37.3\n-107 64l-10 8H0v40zM0 157v40h399730v-40zm0 194v40h399730v-40z",
            // leftarrow is from glyph U+2190 in font KaTeX Main
            leftarrow: "M400000 241H110l3-3c68.7-52.7 113.7-120\n 135-202 4-14.7 6-23 6-25 0-7.3-7-11-21-11-8 0-13.2.8-15.5 2.5-2.3 1.7-4.2 5.8\n-5.5 12.5-1.3 4.7-2.7 10.3-4 17-12 48.7-34.8 92-68.5 130S65.3 228.3 18 247\nc-10 4-16 7.7-18 11 0 8.7 6 14.3 18 17 47.3 18.7 87.8 47 121.5 85S196 441.3 208\n 490c.7 2 1.3 5 2 9s1.2 6.7 1.5 8c.3 1.3 1 3.3 2 6s2.2 4.5 3.5 5.5c1.3 1 3.3\n 1.8 6 2.5s6 1 10 1c14 0 21-3.7 21-11 0-2-2-10.3-6-25-20-79.3-65-146.7-135-202\n l-3-3h399890zM100 241v40h399900v-40z",
            // overbrace is from glyphs U+23A9/23A8/23A7 in font KaTeX_Size4-Regular
            leftbrace: "M6 548l-6-6v-35l6-11c56-104 135.3-181.3 238-232 57.3-28.7 117\n-45 179-50h399577v120H403c-43.3 7-81 15-113 26-100.7 33-179.7 91-237 174-2.7\n 5-6 9-10 13-.7 1-7.3 1-20 1H6z",
            leftbraceunder: "M0 6l6-6h17c12.688 0 19.313.3 20 1 4 4 7.313 8.3 10 13\n 35.313 51.3 80.813 93.8 136.5 127.5 55.688 33.7 117.188 55.8 184.5 66.5.688\n 0 2 .3 4 1 18.688 2.7 76 4.3 172 5h399450v120H429l-6-1c-124.688-8-235-61.7\n-331-161C60.687 138.7 32.312 99.3 7 54L0 41V6z",
            // overgroup is from the MnSymbol package (public domain)
            leftgroup: "M400000 80\nH435C64 80 168.3 229.4 21 260c-5.9 1.2-18 0-18 0-2 0-3-1-3-3v-38C76 61 257 0\n 435 0h399565z",
            leftgroupunder: "M400000 262\nH435C64 262 168.3 112.6 21 82c-5.9-1.2-18 0-18 0-2 0-3 1-3 3v38c76 158 257 219\n 435 219h399565z",
            // Harpoons are from glyph U+21BD in font KaTeX Main
            leftharpoon: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3\n-3.3 10.2-9.5 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5\n-18.3 3-21-1.3-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7\n-196 228-6.7 4.7-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40z",
            leftharpoonplus: "M0 267c.7 5.3 3 10 7 14h399993v-40H93c3.3-3.3 10.2-9.5\n 20.5-18.5s17.8-15.8 22.5-20.5c50.7-52 88-110.3 112-175 4-11.3 5-18.3 3-21-1.3\n-4-7.3-6-18-6-8 0-13 .7-15 2s-4.7 6.7-8 16c-42 98.7-107.3 174.7-196 228-6.7 4.7\n-10.7 8-12 10-1.3 2-2 5.7-2 11zm100-26v40h399900v-40zM0 435v40h400000v-40z\nm0 0v40h400000v-40z",
            leftharpoondown: "M7 241c-4 4-6.333 8.667-7 14 0 5.333.667 9 2 11s5.333\n 5.333 12 10c90.667 54 156 130 196 228 3.333 10.667 6.333 16.333 9 17 2 .667 5\n 1 9 1h5c10.667 0 16.667-2 18-6 2-2.667 1-9.667-3-21-32-87.333-82.667-157.667\n-152-211l-3-3h399907v-40zM93 281 H400000 v-40L7 241z",
            leftharpoondownplus: "M7 435c-4 4-6.3 8.7-7 14 0 5.3.7 9 2 11s5.3 5.3 12\n 10c90.7 54 156 130 196 228 3.3 10.7 6.3 16.3 9 17 2 .7 5 1 9 1h5c10.7 0 16.7\n-2 18-6 2-2.7 1-9.7-3-21-32-87.3-82.7-157.7-152-211l-3-3h399907v-40H7zm93 0\nv40h399900v-40zM0 241v40h399900v-40zm0 0v40h399900v-40z",
            // hook is from glyph U+21A9 in font KaTeX Main
            lefthook: "M400000 281 H103s-33-11.2-61-33.5S0 197.3 0 164s14.2-61.2 42.5\n-83.5C70.8 58.2 104 47 142 47 c16.7 0 25 6.7 25 20 0 12-8.7 18.7-26 20-40 3.3\n-68.7 15.7-86 37-10 12-15 25.3-15 40 0 22.7 9.8 40.7 29.5 54 19.7 13.3 43.5 21\n 71.5 23h399859zM103 281v-40h399897v40z",
            leftlinesegment: "M40 281 V428 H0 V94 H40 V241 H400000 v40z\nM40 281 V428 H0 V94 H40 V241 H400000 v40z",
            leftmapsto: "M40 281 V448H0V74H40V241H400000v40z\nM40 281 V448H0V74H40V241H400000v40z",
            // tofrom is from glyph U+21C4 in font KaTeX AMS Regular
            leftToFrom: "M0 147h400000v40H0zm0 214c68 40 115.7 95.7 143 167h22c15.3 0 23\n-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69-70-101l-7-8h399905v-40H95l7-8\nc28.7-32 52-65.7 70-101 10.7-23.3 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 265.3\n 68 321 0 361zm0-174v-40h399900v40zm100 154v40h399900v-40z",
            longequal: "M0 50 h400000 v40H0z m0 194h40000v40H0z\nM0 50 h400000 v40H0z m0 194h40000v40H0z",
            midbrace: "M200428 334\nc-100.7-8.3-195.3-44-280-108-55.3-42-101.7-93-139-153l-9-14c-2.7 4-5.7 8.7-9 14\n-53.3 86.7-123.7 153-211 199-66.7 36-137.3 56.3-212 62H0V214h199568c178.3-11.7\n 311.7-78.3 403-201 6-8 9.7-12 11-12 .7-.7 6.7-1 18-1s17.3.3 18 1c1.3 0 5 4 11\n 12 44.7 59.3 101.3 106.3 170 141s145.3 54.3 229 60h199572v120z",
            midbraceunder: "M199572 214\nc100.7 8.3 195.3 44 280 108 55.3 42 101.7 93 139 153l9 14c2.7-4 5.7-8.7 9-14\n 53.3-86.7 123.7-153 211-199 66.7-36 137.3-56.3 212-62h199568v120H200432c-178.3\n 11.7-311.7 78.3-403 201-6 8-9.7 12-11 12-.7.7-6.7 1-18 1s-17.3-.3-18-1c-1.3 0\n-5-4-11-12-44.7-59.3-101.3-106.3-170-141s-145.3-54.3-229-60H0V214z",
            oiintSize1: "M512.6 71.6c272.6 0 320.3 106.8 320.3 178.2 0 70.8-47.7 177.6\n-320.3 177.6S193.1 320.6 193.1 249.8c0-71.4 46.9-178.2 319.5-178.2z\nm368.1 178.2c0-86.4-60.9-215.4-368.1-215.4-306.4 0-367.3 129-367.3 215.4 0 85.8\n60.9 214.8 367.3 214.8 307.2 0 368.1-129 368.1-214.8z",
            oiintSize2: "M757.8 100.1c384.7 0 451.1 137.6 451.1 230 0 91.3-66.4 228.8\n-451.1 228.8-386.3 0-452.7-137.5-452.7-228.8 0-92.4 66.4-230 452.7-230z\nm502.4 230c0-111.2-82.4-277.2-502.4-277.2s-504 166-504 277.2\nc0 110 84 276 504 276s502.4-166 502.4-276z",
            oiiintSize1: "M681.4 71.6c408.9 0 480.5 106.8 480.5 178.2 0 70.8-71.6 177.6\n-480.5 177.6S202.1 320.6 202.1 249.8c0-71.4 70.5-178.2 479.3-178.2z\nm525.8 178.2c0-86.4-86.8-215.4-525.7-215.4-437.9 0-524.7 129-524.7 215.4 0\n85.8 86.8 214.8 524.7 214.8 438.9 0 525.7-129 525.7-214.8z",
            oiiintSize2: "M1021.2 53c603.6 0 707.8 165.8 707.8 277.2 0 110-104.2 275.8\n-707.8 275.8-606 0-710.2-165.8-710.2-275.8C311 218.8 415.2 53 1021.2 53z\nm770.4 277.1c0-131.2-126.4-327.6-770.5-327.6S248.4 198.9 248.4 330.1\nc0 130 128.8 326.4 772.7 326.4s770.5-196.4 770.5-326.4z",
            rightarrow: "M0 241v40h399891c-47.3 35.3-84 78-110 128\n-16.7 32-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20\n 11 8 0 13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7\n 39-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85\n-40.5-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n 151.7 139 205zm0 0v40h399900v-40z",
            rightbrace: "M400000 542l\n-6 6h-17c-12.7 0-19.3-.3-20-1-4-4-7.3-8.3-10-13-35.3-51.3-80.8-93.8-136.5-127.5\ns-117.2-55.8-184.5-66.5c-.7 0-2-.3-4-1-18.7-2.7-76-4.3-172-5H0V214h399571l6 1\nc124.7 8 235 61.7 331 161 31.3 33.3 59.7 72.7 85 118l7 13v35z",
            rightbraceunder: "M399994 0l6 6v35l-6 11c-56 104-135.3 181.3-238 232-57.3\n 28.7-117 45-179 50H-300V214h399897c43.3-7 81-15 113-26 100.7-33 179.7-91 237\n-174 2.7-5 6-9 10-13 .7-1 7.3-1 20-1h17z",
            rightgroup: "M0 80h399565c371 0 266.7 149.4 414 180 5.9 1.2 18 0 18 0 2 0\n 3-1 3-3v-38c-76-158-257-219-435-219H0z",
            rightgroupunder: "M0 262h399565c371 0 266.7-149.4 414-180 5.9-1.2 18 0 18\n 0 2 0 3 1 3 3v38c-76 158-257 219-435 219H0z",
            rightharpoon: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3\n-3.7-15.3-11-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2\n-10.7 0-16.7 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58\n 69.2 92 94.5zm0 0v40h399900v-40z",
            rightharpoonplus: "M0 241v40h399993c4.7-4.7 7-9.3 7-14 0-9.3-3.7-15.3-11\n-18-92.7-56.7-159-133.7-199-231-3.3-9.3-6-14.7-8-16-2-1.3-7-2-15-2-10.7 0-16.7\n 2-18 6-2 2.7-1 9.7 3 21 15.3 42 36.7 81.8 64 119.5 27.3 37.7 58 69.2 92 94.5z\nm0 0v40h399900v-40z m100 194v40h399900v-40zm0 0v40h399900v-40z",
            rightharpoondown: "M399747 511c0 7.3 6.7 11 20 11 8 0 13-.8 15-2.5s4.7-6.8\n 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3 8.5-5.8 9.5\n-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3-64.7 57-92 95\n-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 241v40h399900v-40z",
            rightharpoondownplus: "M399747 705c0 7.3 6.7 11 20 11 8 0 13-.8\n 15-2.5s4.7-6.8 8-15.5c40-94 99.3-166.3 178-217 13.3-8 20.3-12.3 21-13 5.3-3.3\n 8.5-5.8 9.5-7.5 1-1.7 1.5-5.2 1.5-10.5s-2.3-10.3-7-15H0v40h399908c-34 25.3\n-64.7 57-92 95-27.3 38-48.7 77.7-64 119-3.3 8.7-5 14-5 16zM0 435v40h399900v-40z\nm0-194v40h400000v-40zm0 0v40h400000v-40z",
            righthook: "M399859 241c-764 0 0 0 0 0 40-3.3 68.7-15.7 86-37 10-12 15-25.3\n 15-40 0-22.7-9.8-40.7-29.5-54-19.7-13.3-43.5-21-71.5-23-17.3-1.3-26-8-26-20 0\n-13.3 8.7-20 26-20 38 0 71 11.2 99 33.5 0 0 7 5.6 21 16.7 14 11.2 21 33.5 21\n 66.8s-14 61.2-42 83.5c-28 22.3-61 33.5-99 33.5L0 241z M0 281v-40h399859v40z",
            rightlinesegment: "M399960 241 V94 h40 V428 h-40 V281 H0 v-40z\nM399960 241 V94 h40 V428 h-40 V281 H0 v-40z",
            rightToFrom: "M400000 167c-70.7-42-118-97.7-142-167h-23c-15.3 0-23 .3-23\n 1 0 1.3 5.3 13.7 16 37 18 35.3 41.3 69 70 101l7 8H0v40h399905l-7 8c-28.7 32\n-52 65.7-70 101-10.7 23.3-16 35.7-16 37 0 .7 7.7 1 23 1h23c24-69.3 71.3-125 142\n-167z M100 147v40h399900v-40zM0 341v40h399900v-40z",
            // twoheadleftarrow is from glyph U+219E in font KaTeX AMS Regular
            twoheadleftarrow: "M0 167c68 40\n 115.7 95.7 143 167h22c15.3 0 23-.3 23-1 0-1.3-5.3-13.7-16-37-18-35.3-41.3-69\n-70-101l-7-8h125l9 7c50.7 39.3 85 86 103 140h46c0-4.7-6.3-18.7-19-42-18-35.3\n-40-67.3-66-96l-9-9h399716v-40H284l9-9c26-28.7 48-60.7 66-96 12.7-23.333 19\n-37.333 19-42h-46c-18 54-52.3 100.7-103 140l-9 7H95l7-8c28.7-32 52-65.7 70-101\n 10.7-23.333 16-35.7 16-37 0-.7-7.7-1-23-1h-22C115.7 71.3 68 127 0 167z",
            twoheadrightarrow: "M400000 167\nc-68-40-115.7-95.7-143-167h-22c-15.3 0-23 .3-23 1 0 1.3 5.3 13.7 16 37 18 35.3\n 41.3 69 70 101l7 8h-125l-9-7c-50.7-39.3-85-86-103-140h-46c0 4.7 6.3 18.7 19 42\n 18 35.3 40 67.3 66 96l9 9H0v40h399716l-9 9c-26 28.7-48 60.7-66 96-12.7 23.333\n-19 37.333-19 42h46c18-54 52.3-100.7 103-140l9-7h125l-7 8c-28.7 32-52 65.7-70\n 101-10.7 23.333-16 35.7-16 37 0 .7 7.7 1 23 1h22c27.3-71.3 75-127 143-167z",
            // tilde1 is a modified version of a glyph from the MnSymbol package
            tilde1: "M200 55.538c-77 0-168 73.953-177 73.953-3 0-7\n-2.175-9-5.437L2 97c-1-2-2-4-2-6 0-4 2-7 5-9l20-12C116 12 171 0 207 0c86 0\n 114 68 191 68 78 0 168-68 177-68 4 0 7 2 9 5l12 19c1 2.175 2 4.35 2 6.525 0\n 4.35-2 7.613-5 9.788l-19 13.05c-92 63.077-116.937 75.308-183 76.128\n-68.267.847-113-73.952-191-73.952z",
            // ditto tilde2, tilde3, & tilde4
            tilde2: "M344 55.266c-142 0-300.638 81.316-311.5 86.418\n-8.01 3.762-22.5 10.91-23.5 5.562L1 120c-1-2-1-3-1-4 0-5 3-9 8-10l18.4-9C160.9\n 31.9 283 0 358 0c148 0 188 122 331 122s314-97 326-97c4 0 8 2 10 7l7 21.114\nc1 2.14 1 3.21 1 4.28 0 5.347-3 9.626-7 10.696l-22.3 12.622C852.6 158.372 751\n 181.476 676 181.476c-149 0-189-126.21-332-126.21z",
            tilde3: "M786 59C457 59 32 175.242 13 175.242c-6 0-10-3.457\n-11-10.37L.15 138c-1-7 3-12 10-13l19.2-6.4C378.4 40.7 634.3 0 804.3 0c337 0\n 411.8 157 746.8 157 328 0 754-112 773-112 5 0 10 3 11 9l1 14.075c1 8.066-.697\n 16.595-6.697 17.492l-21.052 7.31c-367.9 98.146-609.15 122.696-778.15 122.696\n -338 0-409-156.573-744-156.573z",
            tilde4: "M786 58C457 58 32 177.487 13 177.487c-6 0-10-3.345\n-11-10.035L.15 143c-1-7 3-12 10-13l22-6.7C381.2 35 637.15 0 807.15 0c337 0 409\n 177 744 177 328 0 754-127 773-127 5 0 10 3 11 9l1 14.794c1 7.805-3 13.38-9\n 14.495l-20.7 5.574c-366.85 99.79-607.3 139.372-776.3 139.372-338 0-409\n -175.236-744-175.236z",
            // vec is from glyph U+20D7 in font KaTeX Main
            vec: "M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 5\n3.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 11\n10.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63\n-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1\n-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59\nH213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359\nc-16-25.333-24-45-24-59z",
            // widehat1 is a modified version of a glyph from the MnSymbol package
            widehat1: "M529 0h5l519 115c5 1 9 5 9 10 0 1-1 2-1 3l-4 22\nc-1 5-5 9-11 9h-2L532 67 19 159h-2c-5 0-9-4-11-9l-5-22c-1-6 2-12 8-13z",
            // ditto widehat2, widehat3, & widehat4
            widehat2: "M1181 0h2l1171 176c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 220h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widehat3: "M1181 0h2l1171 236c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 280h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            widehat4: "M1181 0h2l1171 296c6 0 10 5 10 11l-2 23c-1 6-5 10\n-11 10h-1L1182 67 15 340h-1c-6 0-10-4-11-10l-2-23c-1-6 4-11 10-11z",
            // widecheck paths are all inverted versions of widehat
            widecheck1: "M529,159h5l519,-115c5,-1,9,-5,9,-10c0,-1,-1,-2,-1,-3l-4,-22c-1,\n-5,-5,-9,-11,-9h-2l-512,92l-513,-92h-2c-5,0,-9,4,-11,9l-5,22c-1,6,2,12,8,13z",
            widecheck2: "M1181,220h2l1171,-176c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,153l-1167,-153h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            widecheck3: "M1181,280h2l1171,-236c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,213l-1167,-213h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            widecheck4: "M1181,340h2l1171,-296c6,0,10,-5,10,-11l-2,-23c-1,-6,-5,-10,\n-11,-10h-1l-1168,273l-1167,-273h-1c-6,0,-10,4,-11,10l-2,23c-1,6,4,11,10,11z",
            // The next ten paths support reaction arrows from the mhchem package.
            // Arrows for \ce{<-->} are offset from xAxis by 0.22ex, per mhchem in LaTeX
            // baraboveleftarrow is mostly from glyph U+2190 in font KaTeX Main
            baraboveleftarrow: "M400000 620h-399890l3 -3c68.7 -52.7 113.7 -120 135 -202\nc4 -14.7 6 -23 6 -25c0 -7.3 -7 -11 -21 -11c-8 0 -13.2 0.8 -15.5 2.5\nc-2.3 1.7 -4.2 5.8 -5.5 12.5c-1.3 4.7 -2.7 10.3 -4 17c-12 48.7 -34.8 92 -68.5 130\ns-74.2 66.3 -121.5 85c-10 4 -16 7.7 -18 11c0 8.7 6 14.3 18 17c47.3 18.7 87.8 47\n121.5 85s56.5 81.3 68.5 130c0.7 2 1.3 5 2 9s1.2 6.7 1.5 8c0.3 1.3 1 3.3 2 6\ns2.2 4.5 3.5 5.5c1.3 1 3.3 1.8 6 2.5s6 1 10 1c14 0 21 -3.7 21 -11\nc0 -2 -2 -10.3 -6 -25c-20 -79.3 -65 -146.7 -135 -202l-3 -3h399890z\nM100 620v40h399900v-40z M0 241v40h399900v-40zM0 241v40h399900v-40z",
            // rightarrowabovebar is mostly from glyph U+2192, KaTeX Main
            rightarrowabovebar: "M0 241v40h399891c-47.3 35.3-84 78-110 128-16.7 32\n-27.7 63.7-33 95 0 1.3-.2 2.7-.5 4-.3 1.3-.5 2.3-.5 3 0 7.3 6.7 11 20 11 8 0\n13.2-.8 15.5-2.5 2.3-1.7 4.2-5.5 5.5-11.5 2-13.3 5.7-27 11-41 14.7-44.7 39\n-84.5 73-119.5s73.7-60.2 119-75.5c6-2 9-5.7 9-11s-3-9-9-11c-45.3-15.3-85-40.5\n-119-75.5s-58.3-74.8-73-119.5c-4.7-14-8.3-27.3-11-40-1.3-6.7-3.2-10.8-5.5\n-12.5-2.3-1.7-7.5-2.5-15.5-2.5-14 0-21 3.7-21 11 0 2 2 10.3 6 25 20.7 83.3 67\n151.7 139 205zm96 379h399894v40H0zm0 0h399904v40H0z",
            // The short left harpoon has 0.5em (i.e. 500 units) kern on the left end.
            // Ref from mhchem.sty: \rlap{\raisebox{-.22ex}{$\kern0.5em
            baraboveshortleftharpoon: "M507,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17\nc2,0.7,5,1,9,1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21\nc-32,-87.3,-82.7,-157.7,-152,-211c0,0,-3,-3,-3,-3l399351,0l0,-40\nc-398570,0,-399437,0,-399437,0z M593 435 v40 H399500 v-40z\nM0 281 v-40 H399908 v40z M0 281 v-40 H399908 v40z",
            rightharpoonaboveshortbar: "M0,241 l0,40c399126,0,399993,0,399993,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM0 241 v40 H399908 v-40z M0 475 v-40 H399500 v40z M0 475 v-40 H399500 v40z",
            shortbaraboveleftharpoon: "M7,435c-4,4,-6.3,8.7,-7,14c0,5.3,0.7,9,2,11\nc1.3,2,5.3,5.3,12,10c90.7,54,156,130,196,228c3.3,10.7,6.3,16.3,9,17c2,0.7,5,1,9,\n1c0,0,5,0,5,0c10.7,0,16.7,-2,18,-6c2,-2.7,1,-9.7,-3,-21c-32,-87.3,-82.7,-157.7,\n-152,-211c0,0,-3,-3,-3,-3l399907,0l0,-40c-399126,0,-399993,0,-399993,0z\nM93 435 v40 H400000 v-40z M500 241 v40 H400000 v-40z M500 241 v40 H400000 v-40z",
            shortrightharpoonabovebar: "M53,241l0,40c398570,0,399437,0,399437,0\nc4.7,-4.7,7,-9.3,7,-14c0,-9.3,-3.7,-15.3,-11,-18c-92.7,-56.7,-159,-133.7,-199,\n-231c-3.3,-9.3,-6,-14.7,-8,-16c-2,-1.3,-7,-2,-15,-2c-10.7,0,-16.7,2,-18,6\nc-2,2.7,-1,9.7,3,21c15.3,42,36.7,81.8,64,119.5c27.3,37.7,58,69.2,92,94.5z\nM500 241 v40 H399408 v-40z M500 435 v40 H400000 v-40z"
          };
          const tallDelim = function(label, midHeight) {
            switch (label) {
              case "lbrack":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v1759 h347 v-84\nH403z M403 1759 V0 H319 V1759 v" + midHeight + " v1759 h84z";
              case "rbrack":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v1759 H0 v84 H347z\nM347 1759 V0 H263 V1759 v" + midHeight + " v1759 h84z";
              case "vert":
                return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z";
              case "doublevert":
                return "M145 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M188 15 H145 v585 v" + midHeight + " v585 h43z\nM367 15 v585 v" + midHeight + " v585 c2.667,10,9.667,15,21,15\nc10,0,16.667,-5,20,-15 v-585 v" + -midHeight + " v-585 c-2.667,-10,-9.667,-15,-21,-15\nc-10,0,-16.667,5,-20,15z M410 15 H367 v585 v" + midHeight + " v585 h43z";
              case "lfloor":
                return "M319 602 V0 H403 V602 v" + midHeight + " v1715 h263 v84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
              case "rfloor":
                return "M319 602 V0 H403 V602 v" + midHeight + " v1799 H0 v-84 H319z\nMM319 602 V0 H403 V602 v" + midHeight + " v1715 H319z";
              case "lceil":
                return "M403 1759 V84 H666 V0 H319 V1759 v" + midHeight + " v602 h84z\nM403 1759 V0 H319 V1759 v" + midHeight + " v602 h84z";
              case "rceil":
                return "M347 1759 V0 H0 V84 H263 V1759 v" + midHeight + " v602 h84z\nM347 1759 V0 h-84 V1759 v" + midHeight + " v602 h84z";
              case "lparen":
                return "M863,9c0,-2,-2,-5,-6,-9c0,0,-17,0,-17,0c-12.7,0,-19.3,0.3,-20,1\nc-5.3,5.3,-10.3,11,-15,17c-242.7,294.7,-395.3,682,-458,1162c-21.3,163.3,-33.3,349,\n-36,557 l0," + (midHeight + 84) + "c0.2,6,0,26,0,60c2,159.3,10,310.7,24,454c53.3,528,210,\n949.7,470,1265c4.7,6,9.7,11.7,15,17c0.7,0.7,7,1,19,1c0,0,18,0,18,0c4,-4,6,-7,6,-9\nc0,-2.7,-3.3,-8.7,-10,-18c-135.3,-192.7,-235.5,-414.3,-300.5,-665c-65,-250.7,-102.5,\n-544.7,-112.5,-882c-2,-104,-3,-167,-3,-189\nl0,-" + (midHeight + 92) + "c0,-162.7,5.7,-314,17,-454c20.7,-272,63.7,-513,129,-723c65.3,\n-210,155.3,-396.3,270,-559c6.7,-9.3,10,-15.3,10,-18z";
              case "rparen":
                return "M76,0c-16.7,0,-25,3,-25,9c0,2,2,6.3,6,13c21.3,28.7,42.3,60.3,\n63,95c96.7,156.7,172.8,332.5,228.5,527.5c55.7,195,92.8,416.5,111.5,664.5\nc11.3,139.3,17,290.7,17,454c0,28,1.7,43,3.3,45l0," + (midHeight + 9) + "\nc-3,4,-3.3,16.7,-3.3,38c0,162,-5.7,313.7,-17,455c-18.7,248,-55.8,469.3,-111.5,664\nc-55.7,194.7,-131.8,370.3,-228.5,527c-20.7,34.7,-41.7,66.3,-63,95c-2,3.3,-4,7,-6,11\nc0,7.3,5.7,11,17,11c0,0,11,0,11,0c9.3,0,14.3,-0.3,15,-1c5.3,-5.3,10.3,-11,15,-17\nc242.7,-294.7,395.3,-681.7,458,-1161c21.3,-164.7,33.3,-350.7,36,-558\nl0,-" + (midHeight + 144) + "c-2,-159.3,-10,-310.7,-24,-454c-53.3,-528,-210,-949.7,\n-470,-1265c-4.7,-6,-9.7,-11.7,-15,-17c-0.7,-0.7,-6.7,-1,-18,-1z";
              default:
                throw new Error("Unknown stretchy delimiter.");
            }
          };
          class DocumentFragment2 {
            // HtmlDomNode
            // Never used; needed for satisfying interface.
            constructor(children) {
              this.children = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              this.children = children;
              this.classes = [];
              this.height = 0;
              this.depth = 0;
              this.maxFontSize = 0;
              this.style = {};
            }
            hasClass(className) {
              return utils.contains(this.classes, className);
            }
            /** Convert the fragment into a node. */
            toNode() {
              const frag = document.createDocumentFragment();
              for (let i2 = 0; i2 < this.children.length; i2++) {
                frag.appendChild(this.children[i2].toNode());
              }
              return frag;
            }
            /** Convert the fragment into HTML markup. */
            toMarkup() {
              let markup = "";
              for (let i2 = 0; i2 < this.children.length; i2++) {
                markup += this.children[i2].toMarkup();
              }
              return markup;
            }
            /**
             * Converts the math node into a string, similar to innerText. Applies to
             * MathDomNode's only.
             */
            toText() {
              const toText = (child) => child.toText();
              return this.children.map(toText).join("");
            }
          }
          var fontMetricsData = {
            "AMS-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.68889, 0, 0, 0.72222],
              "66": [0, 0.68889, 0, 0, 0.66667],
              "67": [0, 0.68889, 0, 0, 0.72222],
              "68": [0, 0.68889, 0, 0, 0.72222],
              "69": [0, 0.68889, 0, 0, 0.66667],
              "70": [0, 0.68889, 0, 0, 0.61111],
              "71": [0, 0.68889, 0, 0, 0.77778],
              "72": [0, 0.68889, 0, 0, 0.77778],
              "73": [0, 0.68889, 0, 0, 0.38889],
              "74": [0.16667, 0.68889, 0, 0, 0.5],
              "75": [0, 0.68889, 0, 0, 0.77778],
              "76": [0, 0.68889, 0, 0, 0.66667],
              "77": [0, 0.68889, 0, 0, 0.94445],
              "78": [0, 0.68889, 0, 0, 0.72222],
              "79": [0.16667, 0.68889, 0, 0, 0.77778],
              "80": [0, 0.68889, 0, 0, 0.61111],
              "81": [0.16667, 0.68889, 0, 0, 0.77778],
              "82": [0, 0.68889, 0, 0, 0.72222],
              "83": [0, 0.68889, 0, 0, 0.55556],
              "84": [0, 0.68889, 0, 0, 0.66667],
              "85": [0, 0.68889, 0, 0, 0.72222],
              "86": [0, 0.68889, 0, 0, 0.72222],
              "87": [0, 0.68889, 0, 0, 1],
              "88": [0, 0.68889, 0, 0, 0.72222],
              "89": [0, 0.68889, 0, 0, 0.72222],
              "90": [0, 0.68889, 0, 0, 0.66667],
              "107": [0, 0.68889, 0, 0, 0.55556],
              "160": [0, 0, 0, 0, 0.25],
              "165": [0, 0.675, 0.025, 0, 0.75],
              "174": [0.15559, 0.69224, 0, 0, 0.94666],
              "240": [0, 0.68889, 0, 0, 0.55556],
              "295": [0, 0.68889, 0, 0, 0.54028],
              "710": [0, 0.825, 0, 0, 2.33334],
              "732": [0, 0.9, 0, 0, 2.33334],
              "770": [0, 0.825, 0, 0, 2.33334],
              "771": [0, 0.9, 0, 0, 2.33334],
              "989": [0.08167, 0.58167, 0, 0, 0.77778],
              "1008": [0, 0.43056, 0.04028, 0, 0.66667],
              "8245": [0, 0.54986, 0, 0, 0.275],
              "8463": [0, 0.68889, 0, 0, 0.54028],
              "8487": [0, 0.68889, 0, 0, 0.72222],
              "8498": [0, 0.68889, 0, 0, 0.55556],
              "8502": [0, 0.68889, 0, 0, 0.66667],
              "8503": [0, 0.68889, 0, 0, 0.44445],
              "8504": [0, 0.68889, 0, 0, 0.66667],
              "8513": [0, 0.68889, 0, 0, 0.63889],
              "8592": [-0.03598, 0.46402, 0, 0, 0.5],
              "8594": [-0.03598, 0.46402, 0, 0, 0.5],
              "8602": [-0.13313, 0.36687, 0, 0, 1],
              "8603": [-0.13313, 0.36687, 0, 0, 1],
              "8606": [0.01354, 0.52239, 0, 0, 1],
              "8608": [0.01354, 0.52239, 0, 0, 1],
              "8610": [0.01354, 0.52239, 0, 0, 1.11111],
              "8611": [0.01354, 0.52239, 0, 0, 1.11111],
              "8619": [0, 0.54986, 0, 0, 1],
              "8620": [0, 0.54986, 0, 0, 1],
              "8621": [-0.13313, 0.37788, 0, 0, 1.38889],
              "8622": [-0.13313, 0.36687, 0, 0, 1],
              "8624": [0, 0.69224, 0, 0, 0.5],
              "8625": [0, 0.69224, 0, 0, 0.5],
              "8630": [0, 0.43056, 0, 0, 1],
              "8631": [0, 0.43056, 0, 0, 1],
              "8634": [0.08198, 0.58198, 0, 0, 0.77778],
              "8635": [0.08198, 0.58198, 0, 0, 0.77778],
              "8638": [0.19444, 0.69224, 0, 0, 0.41667],
              "8639": [0.19444, 0.69224, 0, 0, 0.41667],
              "8642": [0.19444, 0.69224, 0, 0, 0.41667],
              "8643": [0.19444, 0.69224, 0, 0, 0.41667],
              "8644": [0.1808, 0.675, 0, 0, 1],
              "8646": [0.1808, 0.675, 0, 0, 1],
              "8647": [0.1808, 0.675, 0, 0, 1],
              "8648": [0.19444, 0.69224, 0, 0, 0.83334],
              "8649": [0.1808, 0.675, 0, 0, 1],
              "8650": [0.19444, 0.69224, 0, 0, 0.83334],
              "8651": [0.01354, 0.52239, 0, 0, 1],
              "8652": [0.01354, 0.52239, 0, 0, 1],
              "8653": [-0.13313, 0.36687, 0, 0, 1],
              "8654": [-0.13313, 0.36687, 0, 0, 1],
              "8655": [-0.13313, 0.36687, 0, 0, 1],
              "8666": [0.13667, 0.63667, 0, 0, 1],
              "8667": [0.13667, 0.63667, 0, 0, 1],
              "8669": [-0.13313, 0.37788, 0, 0, 1],
              "8672": [-0.064, 0.437, 0, 0, 1.334],
              "8674": [-0.064, 0.437, 0, 0, 1.334],
              "8705": [0, 0.825, 0, 0, 0.5],
              "8708": [0, 0.68889, 0, 0, 0.55556],
              "8709": [0.08167, 0.58167, 0, 0, 0.77778],
              "8717": [0, 0.43056, 0, 0, 0.42917],
              "8722": [-0.03598, 0.46402, 0, 0, 0.5],
              "8724": [0.08198, 0.69224, 0, 0, 0.77778],
              "8726": [0.08167, 0.58167, 0, 0, 0.77778],
              "8733": [0, 0.69224, 0, 0, 0.77778],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8737": [0, 0.69224, 0, 0, 0.72222],
              "8738": [0.03517, 0.52239, 0, 0, 0.72222],
              "8739": [0.08167, 0.58167, 0, 0, 0.22222],
              "8740": [0.25142, 0.74111, 0, 0, 0.27778],
              "8741": [0.08167, 0.58167, 0, 0, 0.38889],
              "8742": [0.25142, 0.74111, 0, 0, 0.5],
              "8756": [0, 0.69224, 0, 0, 0.66667],
              "8757": [0, 0.69224, 0, 0, 0.66667],
              "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8765": [-0.13313, 0.37788, 0, 0, 0.77778],
              "8769": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8770": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8774": [0.30274, 0.79383, 0, 0, 0.77778],
              "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
              "8778": [0.08167, 0.58167, 0, 0, 0.77778],
              "8782": [0.06062, 0.54986, 0, 0, 0.77778],
              "8783": [0.06062, 0.54986, 0, 0, 0.77778],
              "8785": [0.08198, 0.58198, 0, 0, 0.77778],
              "8786": [0.08198, 0.58198, 0, 0, 0.77778],
              "8787": [0.08198, 0.58198, 0, 0, 0.77778],
              "8790": [0, 0.69224, 0, 0, 0.77778],
              "8791": [0.22958, 0.72958, 0, 0, 0.77778],
              "8796": [0.08198, 0.91667, 0, 0, 0.77778],
              "8806": [0.25583, 0.75583, 0, 0, 0.77778],
              "8807": [0.25583, 0.75583, 0, 0, 0.77778],
              "8808": [0.25142, 0.75726, 0, 0, 0.77778],
              "8809": [0.25142, 0.75726, 0, 0, 0.77778],
              "8812": [0.25583, 0.75583, 0, 0, 0.5],
              "8814": [0.20576, 0.70576, 0, 0, 0.77778],
              "8815": [0.20576, 0.70576, 0, 0, 0.77778],
              "8816": [0.30274, 0.79383, 0, 0, 0.77778],
              "8817": [0.30274, 0.79383, 0, 0, 0.77778],
              "8818": [0.22958, 0.72958, 0, 0, 0.77778],
              "8819": [0.22958, 0.72958, 0, 0, 0.77778],
              "8822": [0.1808, 0.675, 0, 0, 0.77778],
              "8823": [0.1808, 0.675, 0, 0, 0.77778],
              "8828": [0.13667, 0.63667, 0, 0, 0.77778],
              "8829": [0.13667, 0.63667, 0, 0, 0.77778],
              "8830": [0.22958, 0.72958, 0, 0, 0.77778],
              "8831": [0.22958, 0.72958, 0, 0, 0.77778],
              "8832": [0.20576, 0.70576, 0, 0, 0.77778],
              "8833": [0.20576, 0.70576, 0, 0, 0.77778],
              "8840": [0.30274, 0.79383, 0, 0, 0.77778],
              "8841": [0.30274, 0.79383, 0, 0, 0.77778],
              "8842": [0.13597, 0.63597, 0, 0, 0.77778],
              "8843": [0.13597, 0.63597, 0, 0, 0.77778],
              "8847": [0.03517, 0.54986, 0, 0, 0.77778],
              "8848": [0.03517, 0.54986, 0, 0, 0.77778],
              "8858": [0.08198, 0.58198, 0, 0, 0.77778],
              "8859": [0.08198, 0.58198, 0, 0, 0.77778],
              "8861": [0.08198, 0.58198, 0, 0, 0.77778],
              "8862": [0, 0.675, 0, 0, 0.77778],
              "8863": [0, 0.675, 0, 0, 0.77778],
              "8864": [0, 0.675, 0, 0, 0.77778],
              "8865": [0, 0.675, 0, 0, 0.77778],
              "8872": [0, 0.69224, 0, 0, 0.61111],
              "8873": [0, 0.69224, 0, 0, 0.72222],
              "8874": [0, 0.69224, 0, 0, 0.88889],
              "8876": [0, 0.68889, 0, 0, 0.61111],
              "8877": [0, 0.68889, 0, 0, 0.61111],
              "8878": [0, 0.68889, 0, 0, 0.72222],
              "8879": [0, 0.68889, 0, 0, 0.72222],
              "8882": [0.03517, 0.54986, 0, 0, 0.77778],
              "8883": [0.03517, 0.54986, 0, 0, 0.77778],
              "8884": [0.13667, 0.63667, 0, 0, 0.77778],
              "8885": [0.13667, 0.63667, 0, 0, 0.77778],
              "8888": [0, 0.54986, 0, 0, 1.11111],
              "8890": [0.19444, 0.43056, 0, 0, 0.55556],
              "8891": [0.19444, 0.69224, 0, 0, 0.61111],
              "8892": [0.19444, 0.69224, 0, 0, 0.61111],
              "8901": [0, 0.54986, 0, 0, 0.27778],
              "8903": [0.08167, 0.58167, 0, 0, 0.77778],
              "8905": [0.08167, 0.58167, 0, 0, 0.77778],
              "8906": [0.08167, 0.58167, 0, 0, 0.77778],
              "8907": [0, 0.69224, 0, 0, 0.77778],
              "8908": [0, 0.69224, 0, 0, 0.77778],
              "8909": [-0.03598, 0.46402, 0, 0, 0.77778],
              "8910": [0, 0.54986, 0, 0, 0.76042],
              "8911": [0, 0.54986, 0, 0, 0.76042],
              "8912": [0.03517, 0.54986, 0, 0, 0.77778],
              "8913": [0.03517, 0.54986, 0, 0, 0.77778],
              "8914": [0, 0.54986, 0, 0, 0.66667],
              "8915": [0, 0.54986, 0, 0, 0.66667],
              "8916": [0, 0.69224, 0, 0, 0.66667],
              "8918": [0.0391, 0.5391, 0, 0, 0.77778],
              "8919": [0.0391, 0.5391, 0, 0, 0.77778],
              "8920": [0.03517, 0.54986, 0, 0, 1.33334],
              "8921": [0.03517, 0.54986, 0, 0, 1.33334],
              "8922": [0.38569, 0.88569, 0, 0, 0.77778],
              "8923": [0.38569, 0.88569, 0, 0, 0.77778],
              "8926": [0.13667, 0.63667, 0, 0, 0.77778],
              "8927": [0.13667, 0.63667, 0, 0, 0.77778],
              "8928": [0.30274, 0.79383, 0, 0, 0.77778],
              "8929": [0.30274, 0.79383, 0, 0, 0.77778],
              "8934": [0.23222, 0.74111, 0, 0, 0.77778],
              "8935": [0.23222, 0.74111, 0, 0, 0.77778],
              "8936": [0.23222, 0.74111, 0, 0, 0.77778],
              "8937": [0.23222, 0.74111, 0, 0, 0.77778],
              "8938": [0.20576, 0.70576, 0, 0, 0.77778],
              "8939": [0.20576, 0.70576, 0, 0, 0.77778],
              "8940": [0.30274, 0.79383, 0, 0, 0.77778],
              "8941": [0.30274, 0.79383, 0, 0, 0.77778],
              "8994": [0.19444, 0.69224, 0, 0, 0.77778],
              "8995": [0.19444, 0.69224, 0, 0, 0.77778],
              "9416": [0.15559, 0.69224, 0, 0, 0.90222],
              "9484": [0, 0.69224, 0, 0, 0.5],
              "9488": [0, 0.69224, 0, 0, 0.5],
              "9492": [0, 0.37788, 0, 0, 0.5],
              "9496": [0, 0.37788, 0, 0, 0.5],
              "9585": [0.19444, 0.68889, 0, 0, 0.88889],
              "9586": [0.19444, 0.74111, 0, 0, 0.88889],
              "9632": [0, 0.675, 0, 0, 0.77778],
              "9633": [0, 0.675, 0, 0, 0.77778],
              "9650": [0, 0.54986, 0, 0, 0.72222],
              "9651": [0, 0.54986, 0, 0, 0.72222],
              "9654": [0.03517, 0.54986, 0, 0, 0.77778],
              "9660": [0, 0.54986, 0, 0, 0.72222],
              "9661": [0, 0.54986, 0, 0, 0.72222],
              "9664": [0.03517, 0.54986, 0, 0, 0.77778],
              "9674": [0.11111, 0.69224, 0, 0, 0.66667],
              "9733": [0.19444, 0.69224, 0, 0, 0.94445],
              "10003": [0, 0.69224, 0, 0, 0.83334],
              "10016": [0, 0.69224, 0, 0, 0.83334],
              "10731": [0.11111, 0.69224, 0, 0, 0.66667],
              "10846": [0.19444, 0.75583, 0, 0, 0.61111],
              "10877": [0.13667, 0.63667, 0, 0, 0.77778],
              "10878": [0.13667, 0.63667, 0, 0, 0.77778],
              "10885": [0.25583, 0.75583, 0, 0, 0.77778],
              "10886": [0.25583, 0.75583, 0, 0, 0.77778],
              "10887": [0.13597, 0.63597, 0, 0, 0.77778],
              "10888": [0.13597, 0.63597, 0, 0, 0.77778],
              "10889": [0.26167, 0.75726, 0, 0, 0.77778],
              "10890": [0.26167, 0.75726, 0, 0, 0.77778],
              "10891": [0.48256, 0.98256, 0, 0, 0.77778],
              "10892": [0.48256, 0.98256, 0, 0, 0.77778],
              "10901": [0.13667, 0.63667, 0, 0, 0.77778],
              "10902": [0.13667, 0.63667, 0, 0, 0.77778],
              "10933": [0.25142, 0.75726, 0, 0, 0.77778],
              "10934": [0.25142, 0.75726, 0, 0, 0.77778],
              "10935": [0.26167, 0.75726, 0, 0, 0.77778],
              "10936": [0.26167, 0.75726, 0, 0, 0.77778],
              "10937": [0.26167, 0.75726, 0, 0, 0.77778],
              "10938": [0.26167, 0.75726, 0, 0, 0.77778],
              "10949": [0.25583, 0.75583, 0, 0, 0.77778],
              "10950": [0.25583, 0.75583, 0, 0, 0.77778],
              "10955": [0.28481, 0.79383, 0, 0, 0.77778],
              "10956": [0.28481, 0.79383, 0, 0, 0.77778],
              "57350": [0.08167, 0.58167, 0, 0, 0.22222],
              "57351": [0.08167, 0.58167, 0, 0, 0.38889],
              "57352": [0.08167, 0.58167, 0, 0, 0.77778],
              "57353": [0, 0.43056, 0.04028, 0, 0.66667],
              "57356": [0.25142, 0.75726, 0, 0, 0.77778],
              "57357": [0.25142, 0.75726, 0, 0, 0.77778],
              "57358": [0.41951, 0.91951, 0, 0, 0.77778],
              "57359": [0.30274, 0.79383, 0, 0, 0.77778],
              "57360": [0.30274, 0.79383, 0, 0, 0.77778],
              "57361": [0.41951, 0.91951, 0, 0, 0.77778],
              "57366": [0.25142, 0.75726, 0, 0, 0.77778],
              "57367": [0.25142, 0.75726, 0, 0, 0.77778],
              "57368": [0.25142, 0.75726, 0, 0, 0.77778],
              "57369": [0.25142, 0.75726, 0, 0, 0.77778],
              "57370": [0.13597, 0.63597, 0, 0, 0.77778],
              "57371": [0.13597, 0.63597, 0, 0, 0.77778]
            },
            "Caligraphic-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.68333, 0, 0.19445, 0.79847],
              "66": [0, 0.68333, 0.03041, 0.13889, 0.65681],
              "67": [0, 0.68333, 0.05834, 0.13889, 0.52653],
              "68": [0, 0.68333, 0.02778, 0.08334, 0.77139],
              "69": [0, 0.68333, 0.08944, 0.11111, 0.52778],
              "70": [0, 0.68333, 0.09931, 0.11111, 0.71875],
              "71": [0.09722, 0.68333, 0.0593, 0.11111, 0.59487],
              "72": [0, 0.68333, 965e-5, 0.11111, 0.84452],
              "73": [0, 0.68333, 0.07382, 0, 0.54452],
              "74": [0.09722, 0.68333, 0.18472, 0.16667, 0.67778],
              "75": [0, 0.68333, 0.01445, 0.05556, 0.76195],
              "76": [0, 0.68333, 0, 0.13889, 0.68972],
              "77": [0, 0.68333, 0, 0.13889, 1.2009],
              "78": [0, 0.68333, 0.14736, 0.08334, 0.82049],
              "79": [0, 0.68333, 0.02778, 0.11111, 0.79611],
              "80": [0, 0.68333, 0.08222, 0.08334, 0.69556],
              "81": [0.09722, 0.68333, 0, 0.11111, 0.81667],
              "82": [0, 0.68333, 0, 0.08334, 0.8475],
              "83": [0, 0.68333, 0.075, 0.13889, 0.60556],
              "84": [0, 0.68333, 0.25417, 0, 0.54464],
              "85": [0, 0.68333, 0.09931, 0.08334, 0.62583],
              "86": [0, 0.68333, 0.08222, 0, 0.61278],
              "87": [0, 0.68333, 0.08222, 0.08334, 0.98778],
              "88": [0, 0.68333, 0.14643, 0.13889, 0.7133],
              "89": [0.09722, 0.68333, 0.08222, 0.08334, 0.66834],
              "90": [0, 0.68333, 0.07944, 0.13889, 0.72473],
              "160": [0, 0, 0, 0, 0.25]
            },
            "Fraktur-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69141, 0, 0, 0.29574],
              "34": [0, 0.69141, 0, 0, 0.21471],
              "38": [0, 0.69141, 0, 0, 0.73786],
              "39": [0, 0.69141, 0, 0, 0.21201],
              "40": [0.24982, 0.74947, 0, 0, 0.38865],
              "41": [0.24982, 0.74947, 0, 0, 0.38865],
              "42": [0, 0.62119, 0, 0, 0.27764],
              "43": [0.08319, 0.58283, 0, 0, 0.75623],
              "44": [0, 0.10803, 0, 0, 0.27764],
              "45": [0.08319, 0.58283, 0, 0, 0.75623],
              "46": [0, 0.10803, 0, 0, 0.27764],
              "47": [0.24982, 0.74947, 0, 0, 0.50181],
              "48": [0, 0.47534, 0, 0, 0.50181],
              "49": [0, 0.47534, 0, 0, 0.50181],
              "50": [0, 0.47534, 0, 0, 0.50181],
              "51": [0.18906, 0.47534, 0, 0, 0.50181],
              "52": [0.18906, 0.47534, 0, 0, 0.50181],
              "53": [0.18906, 0.47534, 0, 0, 0.50181],
              "54": [0, 0.69141, 0, 0, 0.50181],
              "55": [0.18906, 0.47534, 0, 0, 0.50181],
              "56": [0, 0.69141, 0, 0, 0.50181],
              "57": [0.18906, 0.47534, 0, 0, 0.50181],
              "58": [0, 0.47534, 0, 0, 0.21606],
              "59": [0.12604, 0.47534, 0, 0, 0.21606],
              "61": [-0.13099, 0.36866, 0, 0, 0.75623],
              "63": [0, 0.69141, 0, 0, 0.36245],
              "65": [0, 0.69141, 0, 0, 0.7176],
              "66": [0, 0.69141, 0, 0, 0.88397],
              "67": [0, 0.69141, 0, 0, 0.61254],
              "68": [0, 0.69141, 0, 0, 0.83158],
              "69": [0, 0.69141, 0, 0, 0.66278],
              "70": [0.12604, 0.69141, 0, 0, 0.61119],
              "71": [0, 0.69141, 0, 0, 0.78539],
              "72": [0.06302, 0.69141, 0, 0, 0.7203],
              "73": [0, 0.69141, 0, 0, 0.55448],
              "74": [0.12604, 0.69141, 0, 0, 0.55231],
              "75": [0, 0.69141, 0, 0, 0.66845],
              "76": [0, 0.69141, 0, 0, 0.66602],
              "77": [0, 0.69141, 0, 0, 1.04953],
              "78": [0, 0.69141, 0, 0, 0.83212],
              "79": [0, 0.69141, 0, 0, 0.82699],
              "80": [0.18906, 0.69141, 0, 0, 0.82753],
              "81": [0.03781, 0.69141, 0, 0, 0.82699],
              "82": [0, 0.69141, 0, 0, 0.82807],
              "83": [0, 0.69141, 0, 0, 0.82861],
              "84": [0, 0.69141, 0, 0, 0.66899],
              "85": [0, 0.69141, 0, 0, 0.64576],
              "86": [0, 0.69141, 0, 0, 0.83131],
              "87": [0, 0.69141, 0, 0, 1.04602],
              "88": [0, 0.69141, 0, 0, 0.71922],
              "89": [0.18906, 0.69141, 0, 0, 0.83293],
              "90": [0.12604, 0.69141, 0, 0, 0.60201],
              "91": [0.24982, 0.74947, 0, 0, 0.27764],
              "93": [0.24982, 0.74947, 0, 0, 0.27764],
              "94": [0, 0.69141, 0, 0, 0.49965],
              "97": [0, 0.47534, 0, 0, 0.50046],
              "98": [0, 0.69141, 0, 0, 0.51315],
              "99": [0, 0.47534, 0, 0, 0.38946],
              "100": [0, 0.62119, 0, 0, 0.49857],
              "101": [0, 0.47534, 0, 0, 0.40053],
              "102": [0.18906, 0.69141, 0, 0, 0.32626],
              "103": [0.18906, 0.47534, 0, 0, 0.5037],
              "104": [0.18906, 0.69141, 0, 0, 0.52126],
              "105": [0, 0.69141, 0, 0, 0.27899],
              "106": [0, 0.69141, 0, 0, 0.28088],
              "107": [0, 0.69141, 0, 0, 0.38946],
              "108": [0, 0.69141, 0, 0, 0.27953],
              "109": [0, 0.47534, 0, 0, 0.76676],
              "110": [0, 0.47534, 0, 0, 0.52666],
              "111": [0, 0.47534, 0, 0, 0.48885],
              "112": [0.18906, 0.52396, 0, 0, 0.50046],
              "113": [0.18906, 0.47534, 0, 0, 0.48912],
              "114": [0, 0.47534, 0, 0, 0.38919],
              "115": [0, 0.47534, 0, 0, 0.44266],
              "116": [0, 0.62119, 0, 0, 0.33301],
              "117": [0, 0.47534, 0, 0, 0.5172],
              "118": [0, 0.52396, 0, 0, 0.5118],
              "119": [0, 0.52396, 0, 0, 0.77351],
              "120": [0.18906, 0.47534, 0, 0, 0.38865],
              "121": [0.18906, 0.47534, 0, 0, 0.49884],
              "122": [0.18906, 0.47534, 0, 0, 0.39054],
              "160": [0, 0, 0, 0, 0.25],
              "8216": [0, 0.69141, 0, 0, 0.21471],
              "8217": [0, 0.69141, 0, 0, 0.21471],
              "58112": [0, 0.62119, 0, 0, 0.49749],
              "58113": [0, 0.62119, 0, 0, 0.4983],
              "58114": [0.18906, 0.69141, 0, 0, 0.33328],
              "58115": [0.18906, 0.69141, 0, 0, 0.32923],
              "58116": [0.18906, 0.47534, 0, 0, 0.50343],
              "58117": [0, 0.69141, 0, 0, 0.33301],
              "58118": [0, 0.62119, 0, 0, 0.33409],
              "58119": [0, 0.47534, 0, 0, 0.50073]
            },
            "Main-Bold": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.35],
              "34": [0, 0.69444, 0, 0, 0.60278],
              "35": [0.19444, 0.69444, 0, 0, 0.95833],
              "36": [0.05556, 0.75, 0, 0, 0.575],
              "37": [0.05556, 0.75, 0, 0, 0.95833],
              "38": [0, 0.69444, 0, 0, 0.89444],
              "39": [0, 0.69444, 0, 0, 0.31944],
              "40": [0.25, 0.75, 0, 0, 0.44722],
              "41": [0.25, 0.75, 0, 0, 0.44722],
              "42": [0, 0.75, 0, 0, 0.575],
              "43": [0.13333, 0.63333, 0, 0, 0.89444],
              "44": [0.19444, 0.15556, 0, 0, 0.31944],
              "45": [0, 0.44444, 0, 0, 0.38333],
              "46": [0, 0.15556, 0, 0, 0.31944],
              "47": [0.25, 0.75, 0, 0, 0.575],
              "48": [0, 0.64444, 0, 0, 0.575],
              "49": [0, 0.64444, 0, 0, 0.575],
              "50": [0, 0.64444, 0, 0, 0.575],
              "51": [0, 0.64444, 0, 0, 0.575],
              "52": [0, 0.64444, 0, 0, 0.575],
              "53": [0, 0.64444, 0, 0, 0.575],
              "54": [0, 0.64444, 0, 0, 0.575],
              "55": [0, 0.64444, 0, 0, 0.575],
              "56": [0, 0.64444, 0, 0, 0.575],
              "57": [0, 0.64444, 0, 0, 0.575],
              "58": [0, 0.44444, 0, 0, 0.31944],
              "59": [0.19444, 0.44444, 0, 0, 0.31944],
              "60": [0.08556, 0.58556, 0, 0, 0.89444],
              "61": [-0.10889, 0.39111, 0, 0, 0.89444],
              "62": [0.08556, 0.58556, 0, 0, 0.89444],
              "63": [0, 0.69444, 0, 0, 0.54305],
              "64": [0, 0.69444, 0, 0, 0.89444],
              "65": [0, 0.68611, 0, 0, 0.86944],
              "66": [0, 0.68611, 0, 0, 0.81805],
              "67": [0, 0.68611, 0, 0, 0.83055],
              "68": [0, 0.68611, 0, 0, 0.88194],
              "69": [0, 0.68611, 0, 0, 0.75555],
              "70": [0, 0.68611, 0, 0, 0.72361],
              "71": [0, 0.68611, 0, 0, 0.90416],
              "72": [0, 0.68611, 0, 0, 0.9],
              "73": [0, 0.68611, 0, 0, 0.43611],
              "74": [0, 0.68611, 0, 0, 0.59444],
              "75": [0, 0.68611, 0, 0, 0.90138],
              "76": [0, 0.68611, 0, 0, 0.69166],
              "77": [0, 0.68611, 0, 0, 1.09166],
              "78": [0, 0.68611, 0, 0, 0.9],
              "79": [0, 0.68611, 0, 0, 0.86388],
              "80": [0, 0.68611, 0, 0, 0.78611],
              "81": [0.19444, 0.68611, 0, 0, 0.86388],
              "82": [0, 0.68611, 0, 0, 0.8625],
              "83": [0, 0.68611, 0, 0, 0.63889],
              "84": [0, 0.68611, 0, 0, 0.8],
              "85": [0, 0.68611, 0, 0, 0.88472],
              "86": [0, 0.68611, 0.01597, 0, 0.86944],
              "87": [0, 0.68611, 0.01597, 0, 1.18888],
              "88": [0, 0.68611, 0, 0, 0.86944],
              "89": [0, 0.68611, 0.02875, 0, 0.86944],
              "90": [0, 0.68611, 0, 0, 0.70277],
              "91": [0.25, 0.75, 0, 0, 0.31944],
              "92": [0.25, 0.75, 0, 0, 0.575],
              "93": [0.25, 0.75, 0, 0, 0.31944],
              "94": [0, 0.69444, 0, 0, 0.575],
              "95": [0.31, 0.13444, 0.03194, 0, 0.575],
              "97": [0, 0.44444, 0, 0, 0.55902],
              "98": [0, 0.69444, 0, 0, 0.63889],
              "99": [0, 0.44444, 0, 0, 0.51111],
              "100": [0, 0.69444, 0, 0, 0.63889],
              "101": [0, 0.44444, 0, 0, 0.52708],
              "102": [0, 0.69444, 0.10903, 0, 0.35139],
              "103": [0.19444, 0.44444, 0.01597, 0, 0.575],
              "104": [0, 0.69444, 0, 0, 0.63889],
              "105": [0, 0.69444, 0, 0, 0.31944],
              "106": [0.19444, 0.69444, 0, 0, 0.35139],
              "107": [0, 0.69444, 0, 0, 0.60694],
              "108": [0, 0.69444, 0, 0, 0.31944],
              "109": [0, 0.44444, 0, 0, 0.95833],
              "110": [0, 0.44444, 0, 0, 0.63889],
              "111": [0, 0.44444, 0, 0, 0.575],
              "112": [0.19444, 0.44444, 0, 0, 0.63889],
              "113": [0.19444, 0.44444, 0, 0, 0.60694],
              "114": [0, 0.44444, 0, 0, 0.47361],
              "115": [0, 0.44444, 0, 0, 0.45361],
              "116": [0, 0.63492, 0, 0, 0.44722],
              "117": [0, 0.44444, 0, 0, 0.63889],
              "118": [0, 0.44444, 0.01597, 0, 0.60694],
              "119": [0, 0.44444, 0.01597, 0, 0.83055],
              "120": [0, 0.44444, 0, 0, 0.60694],
              "121": [0.19444, 0.44444, 0.01597, 0, 0.60694],
              "122": [0, 0.44444, 0, 0, 0.51111],
              "123": [0.25, 0.75, 0, 0, 0.575],
              "124": [0.25, 0.75, 0, 0, 0.31944],
              "125": [0.25, 0.75, 0, 0, 0.575],
              "126": [0.35, 0.34444, 0, 0, 0.575],
              "160": [0, 0, 0, 0, 0.25],
              "163": [0, 0.69444, 0, 0, 0.86853],
              "168": [0, 0.69444, 0, 0, 0.575],
              "172": [0, 0.44444, 0, 0, 0.76666],
              "176": [0, 0.69444, 0, 0, 0.86944],
              "177": [0.13333, 0.63333, 0, 0, 0.89444],
              "184": [0.17014, 0, 0, 0, 0.51111],
              "198": [0, 0.68611, 0, 0, 1.04166],
              "215": [0.13333, 0.63333, 0, 0, 0.89444],
              "216": [0.04861, 0.73472, 0, 0, 0.89444],
              "223": [0, 0.69444, 0, 0, 0.59722],
              "230": [0, 0.44444, 0, 0, 0.83055],
              "247": [0.13333, 0.63333, 0, 0, 0.89444],
              "248": [0.09722, 0.54167, 0, 0, 0.575],
              "305": [0, 0.44444, 0, 0, 0.31944],
              "338": [0, 0.68611, 0, 0, 1.16944],
              "339": [0, 0.44444, 0, 0, 0.89444],
              "567": [0.19444, 0.44444, 0, 0, 0.35139],
              "710": [0, 0.69444, 0, 0, 0.575],
              "711": [0, 0.63194, 0, 0, 0.575],
              "713": [0, 0.59611, 0, 0, 0.575],
              "714": [0, 0.69444, 0, 0, 0.575],
              "715": [0, 0.69444, 0, 0, 0.575],
              "728": [0, 0.69444, 0, 0, 0.575],
              "729": [0, 0.69444, 0, 0, 0.31944],
              "730": [0, 0.69444, 0, 0, 0.86944],
              "732": [0, 0.69444, 0, 0, 0.575],
              "733": [0, 0.69444, 0, 0, 0.575],
              "915": [0, 0.68611, 0, 0, 0.69166],
              "916": [0, 0.68611, 0, 0, 0.95833],
              "920": [0, 0.68611, 0, 0, 0.89444],
              "923": [0, 0.68611, 0, 0, 0.80555],
              "926": [0, 0.68611, 0, 0, 0.76666],
              "928": [0, 0.68611, 0, 0, 0.9],
              "931": [0, 0.68611, 0, 0, 0.83055],
              "933": [0, 0.68611, 0, 0, 0.89444],
              "934": [0, 0.68611, 0, 0, 0.83055],
              "936": [0, 0.68611, 0, 0, 0.89444],
              "937": [0, 0.68611, 0, 0, 0.83055],
              "8211": [0, 0.44444, 0.03194, 0, 0.575],
              "8212": [0, 0.44444, 0.03194, 0, 1.14999],
              "8216": [0, 0.69444, 0, 0, 0.31944],
              "8217": [0, 0.69444, 0, 0, 0.31944],
              "8220": [0, 0.69444, 0, 0, 0.60278],
              "8221": [0, 0.69444, 0, 0, 0.60278],
              "8224": [0.19444, 0.69444, 0, 0, 0.51111],
              "8225": [0.19444, 0.69444, 0, 0, 0.51111],
              "8242": [0, 0.55556, 0, 0, 0.34444],
              "8407": [0, 0.72444, 0.15486, 0, 0.575],
              "8463": [0, 0.69444, 0, 0, 0.66759],
              "8465": [0, 0.69444, 0, 0, 0.83055],
              "8467": [0, 0.69444, 0, 0, 0.47361],
              "8472": [0.19444, 0.44444, 0, 0, 0.74027],
              "8476": [0, 0.69444, 0, 0, 0.83055],
              "8501": [0, 0.69444, 0, 0, 0.70277],
              "8592": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8593": [0.19444, 0.69444, 0, 0, 0.575],
              "8594": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8595": [0.19444, 0.69444, 0, 0, 0.575],
              "8596": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8597": [0.25, 0.75, 0, 0, 0.575],
              "8598": [0.19444, 0.69444, 0, 0, 1.14999],
              "8599": [0.19444, 0.69444, 0, 0, 1.14999],
              "8600": [0.19444, 0.69444, 0, 0, 1.14999],
              "8601": [0.19444, 0.69444, 0, 0, 1.14999],
              "8636": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8637": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8640": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8641": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8656": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8657": [0.19444, 0.69444, 0, 0, 0.70277],
              "8658": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8659": [0.19444, 0.69444, 0, 0, 0.70277],
              "8660": [-0.10889, 0.39111, 0, 0, 1.14999],
              "8661": [0.25, 0.75, 0, 0, 0.70277],
              "8704": [0, 0.69444, 0, 0, 0.63889],
              "8706": [0, 0.69444, 0.06389, 0, 0.62847],
              "8707": [0, 0.69444, 0, 0, 0.63889],
              "8709": [0.05556, 0.75, 0, 0, 0.575],
              "8711": [0, 0.68611, 0, 0, 0.95833],
              "8712": [0.08556, 0.58556, 0, 0, 0.76666],
              "8715": [0.08556, 0.58556, 0, 0, 0.76666],
              "8722": [0.13333, 0.63333, 0, 0, 0.89444],
              "8723": [0.13333, 0.63333, 0, 0, 0.89444],
              "8725": [0.25, 0.75, 0, 0, 0.575],
              "8726": [0.25, 0.75, 0, 0, 0.575],
              "8727": [-0.02778, 0.47222, 0, 0, 0.575],
              "8728": [-0.02639, 0.47361, 0, 0, 0.575],
              "8729": [-0.02639, 0.47361, 0, 0, 0.575],
              "8730": [0.18, 0.82, 0, 0, 0.95833],
              "8733": [0, 0.44444, 0, 0, 0.89444],
              "8734": [0, 0.44444, 0, 0, 1.14999],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8739": [0.25, 0.75, 0, 0, 0.31944],
              "8741": [0.25, 0.75, 0, 0, 0.575],
              "8743": [0, 0.55556, 0, 0, 0.76666],
              "8744": [0, 0.55556, 0, 0, 0.76666],
              "8745": [0, 0.55556, 0, 0, 0.76666],
              "8746": [0, 0.55556, 0, 0, 0.76666],
              "8747": [0.19444, 0.69444, 0.12778, 0, 0.56875],
              "8764": [-0.10889, 0.39111, 0, 0, 0.89444],
              "8768": [0.19444, 0.69444, 0, 0, 0.31944],
              "8771": [222e-5, 0.50222, 0, 0, 0.89444],
              "8773": [0.027, 0.638, 0, 0, 0.894],
              "8776": [0.02444, 0.52444, 0, 0, 0.89444],
              "8781": [222e-5, 0.50222, 0, 0, 0.89444],
              "8801": [222e-5, 0.50222, 0, 0, 0.89444],
              "8804": [0.19667, 0.69667, 0, 0, 0.89444],
              "8805": [0.19667, 0.69667, 0, 0, 0.89444],
              "8810": [0.08556, 0.58556, 0, 0, 1.14999],
              "8811": [0.08556, 0.58556, 0, 0, 1.14999],
              "8826": [0.08556, 0.58556, 0, 0, 0.89444],
              "8827": [0.08556, 0.58556, 0, 0, 0.89444],
              "8834": [0.08556, 0.58556, 0, 0, 0.89444],
              "8835": [0.08556, 0.58556, 0, 0, 0.89444],
              "8838": [0.19667, 0.69667, 0, 0, 0.89444],
              "8839": [0.19667, 0.69667, 0, 0, 0.89444],
              "8846": [0, 0.55556, 0, 0, 0.76666],
              "8849": [0.19667, 0.69667, 0, 0, 0.89444],
              "8850": [0.19667, 0.69667, 0, 0, 0.89444],
              "8851": [0, 0.55556, 0, 0, 0.76666],
              "8852": [0, 0.55556, 0, 0, 0.76666],
              "8853": [0.13333, 0.63333, 0, 0, 0.89444],
              "8854": [0.13333, 0.63333, 0, 0, 0.89444],
              "8855": [0.13333, 0.63333, 0, 0, 0.89444],
              "8856": [0.13333, 0.63333, 0, 0, 0.89444],
              "8857": [0.13333, 0.63333, 0, 0, 0.89444],
              "8866": [0, 0.69444, 0, 0, 0.70277],
              "8867": [0, 0.69444, 0, 0, 0.70277],
              "8868": [0, 0.69444, 0, 0, 0.89444],
              "8869": [0, 0.69444, 0, 0, 0.89444],
              "8900": [-0.02639, 0.47361, 0, 0, 0.575],
              "8901": [-0.02639, 0.47361, 0, 0, 0.31944],
              "8902": [-0.02778, 0.47222, 0, 0, 0.575],
              "8968": [0.25, 0.75, 0, 0, 0.51111],
              "8969": [0.25, 0.75, 0, 0, 0.51111],
              "8970": [0.25, 0.75, 0, 0, 0.51111],
              "8971": [0.25, 0.75, 0, 0, 0.51111],
              "8994": [-0.13889, 0.36111, 0, 0, 1.14999],
              "8995": [-0.13889, 0.36111, 0, 0, 1.14999],
              "9651": [0.19444, 0.69444, 0, 0, 1.02222],
              "9657": [-0.02778, 0.47222, 0, 0, 0.575],
              "9661": [0.19444, 0.69444, 0, 0, 1.02222],
              "9667": [-0.02778, 0.47222, 0, 0, 0.575],
              "9711": [0.19444, 0.69444, 0, 0, 1.14999],
              "9824": [0.12963, 0.69444, 0, 0, 0.89444],
              "9825": [0.12963, 0.69444, 0, 0, 0.89444],
              "9826": [0.12963, 0.69444, 0, 0, 0.89444],
              "9827": [0.12963, 0.69444, 0, 0, 0.89444],
              "9837": [0, 0.75, 0, 0, 0.44722],
              "9838": [0.19444, 0.69444, 0, 0, 0.44722],
              "9839": [0.19444, 0.69444, 0, 0, 0.44722],
              "10216": [0.25, 0.75, 0, 0, 0.44722],
              "10217": [0.25, 0.75, 0, 0, 0.44722],
              "10815": [0, 0.68611, 0, 0, 0.9],
              "10927": [0.19667, 0.69667, 0, 0, 0.89444],
              "10928": [0.19667, 0.69667, 0, 0, 0.89444],
              "57376": [0.19444, 0.69444, 0, 0, 0]
            },
            "Main-BoldItalic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.11417, 0, 0.38611],
              "34": [0, 0.69444, 0.07939, 0, 0.62055],
              "35": [0.19444, 0.69444, 0.06833, 0, 0.94444],
              "37": [0.05556, 0.75, 0.12861, 0, 0.94444],
              "38": [0, 0.69444, 0.08528, 0, 0.88555],
              "39": [0, 0.69444, 0.12945, 0, 0.35555],
              "40": [0.25, 0.75, 0.15806, 0, 0.47333],
              "41": [0.25, 0.75, 0.03306, 0, 0.47333],
              "42": [0, 0.75, 0.14333, 0, 0.59111],
              "43": [0.10333, 0.60333, 0.03306, 0, 0.88555],
              "44": [0.19444, 0.14722, 0, 0, 0.35555],
              "45": [0, 0.44444, 0.02611, 0, 0.41444],
              "46": [0, 0.14722, 0, 0, 0.35555],
              "47": [0.25, 0.75, 0.15806, 0, 0.59111],
              "48": [0, 0.64444, 0.13167, 0, 0.59111],
              "49": [0, 0.64444, 0.13167, 0, 0.59111],
              "50": [0, 0.64444, 0.13167, 0, 0.59111],
              "51": [0, 0.64444, 0.13167, 0, 0.59111],
              "52": [0.19444, 0.64444, 0.13167, 0, 0.59111],
              "53": [0, 0.64444, 0.13167, 0, 0.59111],
              "54": [0, 0.64444, 0.13167, 0, 0.59111],
              "55": [0.19444, 0.64444, 0.13167, 0, 0.59111],
              "56": [0, 0.64444, 0.13167, 0, 0.59111],
              "57": [0, 0.64444, 0.13167, 0, 0.59111],
              "58": [0, 0.44444, 0.06695, 0, 0.35555],
              "59": [0.19444, 0.44444, 0.06695, 0, 0.35555],
              "61": [-0.10889, 0.39111, 0.06833, 0, 0.88555],
              "63": [0, 0.69444, 0.11472, 0, 0.59111],
              "64": [0, 0.69444, 0.09208, 0, 0.88555],
              "65": [0, 0.68611, 0, 0, 0.86555],
              "66": [0, 0.68611, 0.0992, 0, 0.81666],
              "67": [0, 0.68611, 0.14208, 0, 0.82666],
              "68": [0, 0.68611, 0.09062, 0, 0.87555],
              "69": [0, 0.68611, 0.11431, 0, 0.75666],
              "70": [0, 0.68611, 0.12903, 0, 0.72722],
              "71": [0, 0.68611, 0.07347, 0, 0.89527],
              "72": [0, 0.68611, 0.17208, 0, 0.8961],
              "73": [0, 0.68611, 0.15681, 0, 0.47166],
              "74": [0, 0.68611, 0.145, 0, 0.61055],
              "75": [0, 0.68611, 0.14208, 0, 0.89499],
              "76": [0, 0.68611, 0, 0, 0.69777],
              "77": [0, 0.68611, 0.17208, 0, 1.07277],
              "78": [0, 0.68611, 0.17208, 0, 0.8961],
              "79": [0, 0.68611, 0.09062, 0, 0.85499],
              "80": [0, 0.68611, 0.0992, 0, 0.78721],
              "81": [0.19444, 0.68611, 0.09062, 0, 0.85499],
              "82": [0, 0.68611, 0.02559, 0, 0.85944],
              "83": [0, 0.68611, 0.11264, 0, 0.64999],
              "84": [0, 0.68611, 0.12903, 0, 0.7961],
              "85": [0, 0.68611, 0.17208, 0, 0.88083],
              "86": [0, 0.68611, 0.18625, 0, 0.86555],
              "87": [0, 0.68611, 0.18625, 0, 1.15999],
              "88": [0, 0.68611, 0.15681, 0, 0.86555],
              "89": [0, 0.68611, 0.19803, 0, 0.86555],
              "90": [0, 0.68611, 0.14208, 0, 0.70888],
              "91": [0.25, 0.75, 0.1875, 0, 0.35611],
              "93": [0.25, 0.75, 0.09972, 0, 0.35611],
              "94": [0, 0.69444, 0.06709, 0, 0.59111],
              "95": [0.31, 0.13444, 0.09811, 0, 0.59111],
              "97": [0, 0.44444, 0.09426, 0, 0.59111],
              "98": [0, 0.69444, 0.07861, 0, 0.53222],
              "99": [0, 0.44444, 0.05222, 0, 0.53222],
              "100": [0, 0.69444, 0.10861, 0, 0.59111],
              "101": [0, 0.44444, 0.085, 0, 0.53222],
              "102": [0.19444, 0.69444, 0.21778, 0, 0.4],
              "103": [0.19444, 0.44444, 0.105, 0, 0.53222],
              "104": [0, 0.69444, 0.09426, 0, 0.59111],
              "105": [0, 0.69326, 0.11387, 0, 0.35555],
              "106": [0.19444, 0.69326, 0.1672, 0, 0.35555],
              "107": [0, 0.69444, 0.11111, 0, 0.53222],
              "108": [0, 0.69444, 0.10861, 0, 0.29666],
              "109": [0, 0.44444, 0.09426, 0, 0.94444],
              "110": [0, 0.44444, 0.09426, 0, 0.64999],
              "111": [0, 0.44444, 0.07861, 0, 0.59111],
              "112": [0.19444, 0.44444, 0.07861, 0, 0.59111],
              "113": [0.19444, 0.44444, 0.105, 0, 0.53222],
              "114": [0, 0.44444, 0.11111, 0, 0.50167],
              "115": [0, 0.44444, 0.08167, 0, 0.48694],
              "116": [0, 0.63492, 0.09639, 0, 0.385],
              "117": [0, 0.44444, 0.09426, 0, 0.62055],
              "118": [0, 0.44444, 0.11111, 0, 0.53222],
              "119": [0, 0.44444, 0.11111, 0, 0.76777],
              "120": [0, 0.44444, 0.12583, 0, 0.56055],
              "121": [0.19444, 0.44444, 0.105, 0, 0.56166],
              "122": [0, 0.44444, 0.13889, 0, 0.49055],
              "126": [0.35, 0.34444, 0.11472, 0, 0.59111],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.69444, 0.11473, 0, 0.59111],
              "176": [0, 0.69444, 0, 0, 0.94888],
              "184": [0.17014, 0, 0, 0, 0.53222],
              "198": [0, 0.68611, 0.11431, 0, 1.02277],
              "216": [0.04861, 0.73472, 0.09062, 0, 0.88555],
              "223": [0.19444, 0.69444, 0.09736, 0, 0.665],
              "230": [0, 0.44444, 0.085, 0, 0.82666],
              "248": [0.09722, 0.54167, 0.09458, 0, 0.59111],
              "305": [0, 0.44444, 0.09426, 0, 0.35555],
              "338": [0, 0.68611, 0.11431, 0, 1.14054],
              "339": [0, 0.44444, 0.085, 0, 0.82666],
              "567": [0.19444, 0.44444, 0.04611, 0, 0.385],
              "710": [0, 0.69444, 0.06709, 0, 0.59111],
              "711": [0, 0.63194, 0.08271, 0, 0.59111],
              "713": [0, 0.59444, 0.10444, 0, 0.59111],
              "714": [0, 0.69444, 0.08528, 0, 0.59111],
              "715": [0, 0.69444, 0, 0, 0.59111],
              "728": [0, 0.69444, 0.10333, 0, 0.59111],
              "729": [0, 0.69444, 0.12945, 0, 0.35555],
              "730": [0, 0.69444, 0, 0, 0.94888],
              "732": [0, 0.69444, 0.11472, 0, 0.59111],
              "733": [0, 0.69444, 0.11472, 0, 0.59111],
              "915": [0, 0.68611, 0.12903, 0, 0.69777],
              "916": [0, 0.68611, 0, 0, 0.94444],
              "920": [0, 0.68611, 0.09062, 0, 0.88555],
              "923": [0, 0.68611, 0, 0, 0.80666],
              "926": [0, 0.68611, 0.15092, 0, 0.76777],
              "928": [0, 0.68611, 0.17208, 0, 0.8961],
              "931": [0, 0.68611, 0.11431, 0, 0.82666],
              "933": [0, 0.68611, 0.10778, 0, 0.88555],
              "934": [0, 0.68611, 0.05632, 0, 0.82666],
              "936": [0, 0.68611, 0.10778, 0, 0.88555],
              "937": [0, 0.68611, 0.0992, 0, 0.82666],
              "8211": [0, 0.44444, 0.09811, 0, 0.59111],
              "8212": [0, 0.44444, 0.09811, 0, 1.18221],
              "8216": [0, 0.69444, 0.12945, 0, 0.35555],
              "8217": [0, 0.69444, 0.12945, 0, 0.35555],
              "8220": [0, 0.69444, 0.16772, 0, 0.62055],
              "8221": [0, 0.69444, 0.07939, 0, 0.62055]
            },
            "Main-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.12417, 0, 0.30667],
              "34": [0, 0.69444, 0.06961, 0, 0.51444],
              "35": [0.19444, 0.69444, 0.06616, 0, 0.81777],
              "37": [0.05556, 0.75, 0.13639, 0, 0.81777],
              "38": [0, 0.69444, 0.09694, 0, 0.76666],
              "39": [0, 0.69444, 0.12417, 0, 0.30667],
              "40": [0.25, 0.75, 0.16194, 0, 0.40889],
              "41": [0.25, 0.75, 0.03694, 0, 0.40889],
              "42": [0, 0.75, 0.14917, 0, 0.51111],
              "43": [0.05667, 0.56167, 0.03694, 0, 0.76666],
              "44": [0.19444, 0.10556, 0, 0, 0.30667],
              "45": [0, 0.43056, 0.02826, 0, 0.35778],
              "46": [0, 0.10556, 0, 0, 0.30667],
              "47": [0.25, 0.75, 0.16194, 0, 0.51111],
              "48": [0, 0.64444, 0.13556, 0, 0.51111],
              "49": [0, 0.64444, 0.13556, 0, 0.51111],
              "50": [0, 0.64444, 0.13556, 0, 0.51111],
              "51": [0, 0.64444, 0.13556, 0, 0.51111],
              "52": [0.19444, 0.64444, 0.13556, 0, 0.51111],
              "53": [0, 0.64444, 0.13556, 0, 0.51111],
              "54": [0, 0.64444, 0.13556, 0, 0.51111],
              "55": [0.19444, 0.64444, 0.13556, 0, 0.51111],
              "56": [0, 0.64444, 0.13556, 0, 0.51111],
              "57": [0, 0.64444, 0.13556, 0, 0.51111],
              "58": [0, 0.43056, 0.0582, 0, 0.30667],
              "59": [0.19444, 0.43056, 0.0582, 0, 0.30667],
              "61": [-0.13313, 0.36687, 0.06616, 0, 0.76666],
              "63": [0, 0.69444, 0.1225, 0, 0.51111],
              "64": [0, 0.69444, 0.09597, 0, 0.76666],
              "65": [0, 0.68333, 0, 0, 0.74333],
              "66": [0, 0.68333, 0.10257, 0, 0.70389],
              "67": [0, 0.68333, 0.14528, 0, 0.71555],
              "68": [0, 0.68333, 0.09403, 0, 0.755],
              "69": [0, 0.68333, 0.12028, 0, 0.67833],
              "70": [0, 0.68333, 0.13305, 0, 0.65277],
              "71": [0, 0.68333, 0.08722, 0, 0.77361],
              "72": [0, 0.68333, 0.16389, 0, 0.74333],
              "73": [0, 0.68333, 0.15806, 0, 0.38555],
              "74": [0, 0.68333, 0.14028, 0, 0.525],
              "75": [0, 0.68333, 0.14528, 0, 0.76888],
              "76": [0, 0.68333, 0, 0, 0.62722],
              "77": [0, 0.68333, 0.16389, 0, 0.89666],
              "78": [0, 0.68333, 0.16389, 0, 0.74333],
              "79": [0, 0.68333, 0.09403, 0, 0.76666],
              "80": [0, 0.68333, 0.10257, 0, 0.67833],
              "81": [0.19444, 0.68333, 0.09403, 0, 0.76666],
              "82": [0, 0.68333, 0.03868, 0, 0.72944],
              "83": [0, 0.68333, 0.11972, 0, 0.56222],
              "84": [0, 0.68333, 0.13305, 0, 0.71555],
              "85": [0, 0.68333, 0.16389, 0, 0.74333],
              "86": [0, 0.68333, 0.18361, 0, 0.74333],
              "87": [0, 0.68333, 0.18361, 0, 0.99888],
              "88": [0, 0.68333, 0.15806, 0, 0.74333],
              "89": [0, 0.68333, 0.19383, 0, 0.74333],
              "90": [0, 0.68333, 0.14528, 0, 0.61333],
              "91": [0.25, 0.75, 0.1875, 0, 0.30667],
              "93": [0.25, 0.75, 0.10528, 0, 0.30667],
              "94": [0, 0.69444, 0.06646, 0, 0.51111],
              "95": [0.31, 0.12056, 0.09208, 0, 0.51111],
              "97": [0, 0.43056, 0.07671, 0, 0.51111],
              "98": [0, 0.69444, 0.06312, 0, 0.46],
              "99": [0, 0.43056, 0.05653, 0, 0.46],
              "100": [0, 0.69444, 0.10333, 0, 0.51111],
              "101": [0, 0.43056, 0.07514, 0, 0.46],
              "102": [0.19444, 0.69444, 0.21194, 0, 0.30667],
              "103": [0.19444, 0.43056, 0.08847, 0, 0.46],
              "104": [0, 0.69444, 0.07671, 0, 0.51111],
              "105": [0, 0.65536, 0.1019, 0, 0.30667],
              "106": [0.19444, 0.65536, 0.14467, 0, 0.30667],
              "107": [0, 0.69444, 0.10764, 0, 0.46],
              "108": [0, 0.69444, 0.10333, 0, 0.25555],
              "109": [0, 0.43056, 0.07671, 0, 0.81777],
              "110": [0, 0.43056, 0.07671, 0, 0.56222],
              "111": [0, 0.43056, 0.06312, 0, 0.51111],
              "112": [0.19444, 0.43056, 0.06312, 0, 0.51111],
              "113": [0.19444, 0.43056, 0.08847, 0, 0.46],
              "114": [0, 0.43056, 0.10764, 0, 0.42166],
              "115": [0, 0.43056, 0.08208, 0, 0.40889],
              "116": [0, 0.61508, 0.09486, 0, 0.33222],
              "117": [0, 0.43056, 0.07671, 0, 0.53666],
              "118": [0, 0.43056, 0.10764, 0, 0.46],
              "119": [0, 0.43056, 0.10764, 0, 0.66444],
              "120": [0, 0.43056, 0.12042, 0, 0.46389],
              "121": [0.19444, 0.43056, 0.08847, 0, 0.48555],
              "122": [0, 0.43056, 0.12292, 0, 0.40889],
              "126": [0.35, 0.31786, 0.11585, 0, 0.51111],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.66786, 0.10474, 0, 0.51111],
              "176": [0, 0.69444, 0, 0, 0.83129],
              "184": [0.17014, 0, 0, 0, 0.46],
              "198": [0, 0.68333, 0.12028, 0, 0.88277],
              "216": [0.04861, 0.73194, 0.09403, 0, 0.76666],
              "223": [0.19444, 0.69444, 0.10514, 0, 0.53666],
              "230": [0, 0.43056, 0.07514, 0, 0.71555],
              "248": [0.09722, 0.52778, 0.09194, 0, 0.51111],
              "338": [0, 0.68333, 0.12028, 0, 0.98499],
              "339": [0, 0.43056, 0.07514, 0, 0.71555],
              "710": [0, 0.69444, 0.06646, 0, 0.51111],
              "711": [0, 0.62847, 0.08295, 0, 0.51111],
              "713": [0, 0.56167, 0.10333, 0, 0.51111],
              "714": [0, 0.69444, 0.09694, 0, 0.51111],
              "715": [0, 0.69444, 0, 0, 0.51111],
              "728": [0, 0.69444, 0.10806, 0, 0.51111],
              "729": [0, 0.66786, 0.11752, 0, 0.30667],
              "730": [0, 0.69444, 0, 0, 0.83129],
              "732": [0, 0.66786, 0.11585, 0, 0.51111],
              "733": [0, 0.69444, 0.1225, 0, 0.51111],
              "915": [0, 0.68333, 0.13305, 0, 0.62722],
              "916": [0, 0.68333, 0, 0, 0.81777],
              "920": [0, 0.68333, 0.09403, 0, 0.76666],
              "923": [0, 0.68333, 0, 0, 0.69222],
              "926": [0, 0.68333, 0.15294, 0, 0.66444],
              "928": [0, 0.68333, 0.16389, 0, 0.74333],
              "931": [0, 0.68333, 0.12028, 0, 0.71555],
              "933": [0, 0.68333, 0.11111, 0, 0.76666],
              "934": [0, 0.68333, 0.05986, 0, 0.71555],
              "936": [0, 0.68333, 0.11111, 0, 0.76666],
              "937": [0, 0.68333, 0.10257, 0, 0.71555],
              "8211": [0, 0.43056, 0.09208, 0, 0.51111],
              "8212": [0, 0.43056, 0.09208, 0, 1.02222],
              "8216": [0, 0.69444, 0.12417, 0, 0.30667],
              "8217": [0, 0.69444, 0.12417, 0, 0.30667],
              "8220": [0, 0.69444, 0.1685, 0, 0.51444],
              "8221": [0, 0.69444, 0.06961, 0, 0.51444],
              "8463": [0, 0.68889, 0, 0, 0.54028]
            },
            "Main-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.27778],
              "34": [0, 0.69444, 0, 0, 0.5],
              "35": [0.19444, 0.69444, 0, 0, 0.83334],
              "36": [0.05556, 0.75, 0, 0, 0.5],
              "37": [0.05556, 0.75, 0, 0, 0.83334],
              "38": [0, 0.69444, 0, 0, 0.77778],
              "39": [0, 0.69444, 0, 0, 0.27778],
              "40": [0.25, 0.75, 0, 0, 0.38889],
              "41": [0.25, 0.75, 0, 0, 0.38889],
              "42": [0, 0.75, 0, 0, 0.5],
              "43": [0.08333, 0.58333, 0, 0, 0.77778],
              "44": [0.19444, 0.10556, 0, 0, 0.27778],
              "45": [0, 0.43056, 0, 0, 0.33333],
              "46": [0, 0.10556, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0, 0, 0.5],
              "48": [0, 0.64444, 0, 0, 0.5],
              "49": [0, 0.64444, 0, 0, 0.5],
              "50": [0, 0.64444, 0, 0, 0.5],
              "51": [0, 0.64444, 0, 0, 0.5],
              "52": [0, 0.64444, 0, 0, 0.5],
              "53": [0, 0.64444, 0, 0, 0.5],
              "54": [0, 0.64444, 0, 0, 0.5],
              "55": [0, 0.64444, 0, 0, 0.5],
              "56": [0, 0.64444, 0, 0, 0.5],
              "57": [0, 0.64444, 0, 0, 0.5],
              "58": [0, 0.43056, 0, 0, 0.27778],
              "59": [0.19444, 0.43056, 0, 0, 0.27778],
              "60": [0.0391, 0.5391, 0, 0, 0.77778],
              "61": [-0.13313, 0.36687, 0, 0, 0.77778],
              "62": [0.0391, 0.5391, 0, 0, 0.77778],
              "63": [0, 0.69444, 0, 0, 0.47222],
              "64": [0, 0.69444, 0, 0, 0.77778],
              "65": [0, 0.68333, 0, 0, 0.75],
              "66": [0, 0.68333, 0, 0, 0.70834],
              "67": [0, 0.68333, 0, 0, 0.72222],
              "68": [0, 0.68333, 0, 0, 0.76389],
              "69": [0, 0.68333, 0, 0, 0.68056],
              "70": [0, 0.68333, 0, 0, 0.65278],
              "71": [0, 0.68333, 0, 0, 0.78472],
              "72": [0, 0.68333, 0, 0, 0.75],
              "73": [0, 0.68333, 0, 0, 0.36111],
              "74": [0, 0.68333, 0, 0, 0.51389],
              "75": [0, 0.68333, 0, 0, 0.77778],
              "76": [0, 0.68333, 0, 0, 0.625],
              "77": [0, 0.68333, 0, 0, 0.91667],
              "78": [0, 0.68333, 0, 0, 0.75],
              "79": [0, 0.68333, 0, 0, 0.77778],
              "80": [0, 0.68333, 0, 0, 0.68056],
              "81": [0.19444, 0.68333, 0, 0, 0.77778],
              "82": [0, 0.68333, 0, 0, 0.73611],
              "83": [0, 0.68333, 0, 0, 0.55556],
              "84": [0, 0.68333, 0, 0, 0.72222],
              "85": [0, 0.68333, 0, 0, 0.75],
              "86": [0, 0.68333, 0.01389, 0, 0.75],
              "87": [0, 0.68333, 0.01389, 0, 1.02778],
              "88": [0, 0.68333, 0, 0, 0.75],
              "89": [0, 0.68333, 0.025, 0, 0.75],
              "90": [0, 0.68333, 0, 0, 0.61111],
              "91": [0.25, 0.75, 0, 0, 0.27778],
              "92": [0.25, 0.75, 0, 0, 0.5],
              "93": [0.25, 0.75, 0, 0, 0.27778],
              "94": [0, 0.69444, 0, 0, 0.5],
              "95": [0.31, 0.12056, 0.02778, 0, 0.5],
              "97": [0, 0.43056, 0, 0, 0.5],
              "98": [0, 0.69444, 0, 0, 0.55556],
              "99": [0, 0.43056, 0, 0, 0.44445],
              "100": [0, 0.69444, 0, 0, 0.55556],
              "101": [0, 0.43056, 0, 0, 0.44445],
              "102": [0, 0.69444, 0.07778, 0, 0.30556],
              "103": [0.19444, 0.43056, 0.01389, 0, 0.5],
              "104": [0, 0.69444, 0, 0, 0.55556],
              "105": [0, 0.66786, 0, 0, 0.27778],
              "106": [0.19444, 0.66786, 0, 0, 0.30556],
              "107": [0, 0.69444, 0, 0, 0.52778],
              "108": [0, 0.69444, 0, 0, 0.27778],
              "109": [0, 0.43056, 0, 0, 0.83334],
              "110": [0, 0.43056, 0, 0, 0.55556],
              "111": [0, 0.43056, 0, 0, 0.5],
              "112": [0.19444, 0.43056, 0, 0, 0.55556],
              "113": [0.19444, 0.43056, 0, 0, 0.52778],
              "114": [0, 0.43056, 0, 0, 0.39167],
              "115": [0, 0.43056, 0, 0, 0.39445],
              "116": [0, 0.61508, 0, 0, 0.38889],
              "117": [0, 0.43056, 0, 0, 0.55556],
              "118": [0, 0.43056, 0.01389, 0, 0.52778],
              "119": [0, 0.43056, 0.01389, 0, 0.72222],
              "120": [0, 0.43056, 0, 0, 0.52778],
              "121": [0.19444, 0.43056, 0.01389, 0, 0.52778],
              "122": [0, 0.43056, 0, 0, 0.44445],
              "123": [0.25, 0.75, 0, 0, 0.5],
              "124": [0.25, 0.75, 0, 0, 0.27778],
              "125": [0.25, 0.75, 0, 0, 0.5],
              "126": [0.35, 0.31786, 0, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "163": [0, 0.69444, 0, 0, 0.76909],
              "167": [0.19444, 0.69444, 0, 0, 0.44445],
              "168": [0, 0.66786, 0, 0, 0.5],
              "172": [0, 0.43056, 0, 0, 0.66667],
              "176": [0, 0.69444, 0, 0, 0.75],
              "177": [0.08333, 0.58333, 0, 0, 0.77778],
              "182": [0.19444, 0.69444, 0, 0, 0.61111],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "198": [0, 0.68333, 0, 0, 0.90278],
              "215": [0.08333, 0.58333, 0, 0, 0.77778],
              "216": [0.04861, 0.73194, 0, 0, 0.77778],
              "223": [0, 0.69444, 0, 0, 0.5],
              "230": [0, 0.43056, 0, 0, 0.72222],
              "247": [0.08333, 0.58333, 0, 0, 0.77778],
              "248": [0.09722, 0.52778, 0, 0, 0.5],
              "305": [0, 0.43056, 0, 0, 0.27778],
              "338": [0, 0.68333, 0, 0, 1.01389],
              "339": [0, 0.43056, 0, 0, 0.77778],
              "567": [0.19444, 0.43056, 0, 0, 0.30556],
              "710": [0, 0.69444, 0, 0, 0.5],
              "711": [0, 0.62847, 0, 0, 0.5],
              "713": [0, 0.56778, 0, 0, 0.5],
              "714": [0, 0.69444, 0, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0, 0, 0.5],
              "729": [0, 0.66786, 0, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.75],
              "732": [0, 0.66786, 0, 0, 0.5],
              "733": [0, 0.69444, 0, 0, 0.5],
              "915": [0, 0.68333, 0, 0, 0.625],
              "916": [0, 0.68333, 0, 0, 0.83334],
              "920": [0, 0.68333, 0, 0, 0.77778],
              "923": [0, 0.68333, 0, 0, 0.69445],
              "926": [0, 0.68333, 0, 0, 0.66667],
              "928": [0, 0.68333, 0, 0, 0.75],
              "931": [0, 0.68333, 0, 0, 0.72222],
              "933": [0, 0.68333, 0, 0, 0.77778],
              "934": [0, 0.68333, 0, 0, 0.72222],
              "936": [0, 0.68333, 0, 0, 0.77778],
              "937": [0, 0.68333, 0, 0, 0.72222],
              "8211": [0, 0.43056, 0.02778, 0, 0.5],
              "8212": [0, 0.43056, 0.02778, 0, 1],
              "8216": [0, 0.69444, 0, 0, 0.27778],
              "8217": [0, 0.69444, 0, 0, 0.27778],
              "8220": [0, 0.69444, 0, 0, 0.5],
              "8221": [0, 0.69444, 0, 0, 0.5],
              "8224": [0.19444, 0.69444, 0, 0, 0.44445],
              "8225": [0.19444, 0.69444, 0, 0, 0.44445],
              "8230": [0, 0.123, 0, 0, 1.172],
              "8242": [0, 0.55556, 0, 0, 0.275],
              "8407": [0, 0.71444, 0.15382, 0, 0.5],
              "8463": [0, 0.68889, 0, 0, 0.54028],
              "8465": [0, 0.69444, 0, 0, 0.72222],
              "8467": [0, 0.69444, 0, 0.11111, 0.41667],
              "8472": [0.19444, 0.43056, 0, 0.11111, 0.63646],
              "8476": [0, 0.69444, 0, 0, 0.72222],
              "8501": [0, 0.69444, 0, 0, 0.61111],
              "8592": [-0.13313, 0.36687, 0, 0, 1],
              "8593": [0.19444, 0.69444, 0, 0, 0.5],
              "8594": [-0.13313, 0.36687, 0, 0, 1],
              "8595": [0.19444, 0.69444, 0, 0, 0.5],
              "8596": [-0.13313, 0.36687, 0, 0, 1],
              "8597": [0.25, 0.75, 0, 0, 0.5],
              "8598": [0.19444, 0.69444, 0, 0, 1],
              "8599": [0.19444, 0.69444, 0, 0, 1],
              "8600": [0.19444, 0.69444, 0, 0, 1],
              "8601": [0.19444, 0.69444, 0, 0, 1],
              "8614": [0.011, 0.511, 0, 0, 1],
              "8617": [0.011, 0.511, 0, 0, 1.126],
              "8618": [0.011, 0.511, 0, 0, 1.126],
              "8636": [-0.13313, 0.36687, 0, 0, 1],
              "8637": [-0.13313, 0.36687, 0, 0, 1],
              "8640": [-0.13313, 0.36687, 0, 0, 1],
              "8641": [-0.13313, 0.36687, 0, 0, 1],
              "8652": [0.011, 0.671, 0, 0, 1],
              "8656": [-0.13313, 0.36687, 0, 0, 1],
              "8657": [0.19444, 0.69444, 0, 0, 0.61111],
              "8658": [-0.13313, 0.36687, 0, 0, 1],
              "8659": [0.19444, 0.69444, 0, 0, 0.61111],
              "8660": [-0.13313, 0.36687, 0, 0, 1],
              "8661": [0.25, 0.75, 0, 0, 0.61111],
              "8704": [0, 0.69444, 0, 0, 0.55556],
              "8706": [0, 0.69444, 0.05556, 0.08334, 0.5309],
              "8707": [0, 0.69444, 0, 0, 0.55556],
              "8709": [0.05556, 0.75, 0, 0, 0.5],
              "8711": [0, 0.68333, 0, 0, 0.83334],
              "8712": [0.0391, 0.5391, 0, 0, 0.66667],
              "8715": [0.0391, 0.5391, 0, 0, 0.66667],
              "8722": [0.08333, 0.58333, 0, 0, 0.77778],
              "8723": [0.08333, 0.58333, 0, 0, 0.77778],
              "8725": [0.25, 0.75, 0, 0, 0.5],
              "8726": [0.25, 0.75, 0, 0, 0.5],
              "8727": [-0.03472, 0.46528, 0, 0, 0.5],
              "8728": [-0.05555, 0.44445, 0, 0, 0.5],
              "8729": [-0.05555, 0.44445, 0, 0, 0.5],
              "8730": [0.2, 0.8, 0, 0, 0.83334],
              "8733": [0, 0.43056, 0, 0, 0.77778],
              "8734": [0, 0.43056, 0, 0, 1],
              "8736": [0, 0.69224, 0, 0, 0.72222],
              "8739": [0.25, 0.75, 0, 0, 0.27778],
              "8741": [0.25, 0.75, 0, 0, 0.5],
              "8743": [0, 0.55556, 0, 0, 0.66667],
              "8744": [0, 0.55556, 0, 0, 0.66667],
              "8745": [0, 0.55556, 0, 0, 0.66667],
              "8746": [0, 0.55556, 0, 0, 0.66667],
              "8747": [0.19444, 0.69444, 0.11111, 0, 0.41667],
              "8764": [-0.13313, 0.36687, 0, 0, 0.77778],
              "8768": [0.19444, 0.69444, 0, 0, 0.27778],
              "8771": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8773": [-0.022, 0.589, 0, 0, 0.778],
              "8776": [-0.01688, 0.48312, 0, 0, 0.77778],
              "8781": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8784": [-0.133, 0.673, 0, 0, 0.778],
              "8801": [-0.03625, 0.46375, 0, 0, 0.77778],
              "8804": [0.13597, 0.63597, 0, 0, 0.77778],
              "8805": [0.13597, 0.63597, 0, 0, 0.77778],
              "8810": [0.0391, 0.5391, 0, 0, 1],
              "8811": [0.0391, 0.5391, 0, 0, 1],
              "8826": [0.0391, 0.5391, 0, 0, 0.77778],
              "8827": [0.0391, 0.5391, 0, 0, 0.77778],
              "8834": [0.0391, 0.5391, 0, 0, 0.77778],
              "8835": [0.0391, 0.5391, 0, 0, 0.77778],
              "8838": [0.13597, 0.63597, 0, 0, 0.77778],
              "8839": [0.13597, 0.63597, 0, 0, 0.77778],
              "8846": [0, 0.55556, 0, 0, 0.66667],
              "8849": [0.13597, 0.63597, 0, 0, 0.77778],
              "8850": [0.13597, 0.63597, 0, 0, 0.77778],
              "8851": [0, 0.55556, 0, 0, 0.66667],
              "8852": [0, 0.55556, 0, 0, 0.66667],
              "8853": [0.08333, 0.58333, 0, 0, 0.77778],
              "8854": [0.08333, 0.58333, 0, 0, 0.77778],
              "8855": [0.08333, 0.58333, 0, 0, 0.77778],
              "8856": [0.08333, 0.58333, 0, 0, 0.77778],
              "8857": [0.08333, 0.58333, 0, 0, 0.77778],
              "8866": [0, 0.69444, 0, 0, 0.61111],
              "8867": [0, 0.69444, 0, 0, 0.61111],
              "8868": [0, 0.69444, 0, 0, 0.77778],
              "8869": [0, 0.69444, 0, 0, 0.77778],
              "8872": [0.249, 0.75, 0, 0, 0.867],
              "8900": [-0.05555, 0.44445, 0, 0, 0.5],
              "8901": [-0.05555, 0.44445, 0, 0, 0.27778],
              "8902": [-0.03472, 0.46528, 0, 0, 0.5],
              "8904": [5e-3, 0.505, 0, 0, 0.9],
              "8942": [0.03, 0.903, 0, 0, 0.278],
              "8943": [-0.19, 0.313, 0, 0, 1.172],
              "8945": [-0.1, 0.823, 0, 0, 1.282],
              "8968": [0.25, 0.75, 0, 0, 0.44445],
              "8969": [0.25, 0.75, 0, 0, 0.44445],
              "8970": [0.25, 0.75, 0, 0, 0.44445],
              "8971": [0.25, 0.75, 0, 0, 0.44445],
              "8994": [-0.14236, 0.35764, 0, 0, 1],
              "8995": [-0.14236, 0.35764, 0, 0, 1],
              "9136": [0.244, 0.744, 0, 0, 0.412],
              "9137": [0.244, 0.745, 0, 0, 0.412],
              "9651": [0.19444, 0.69444, 0, 0, 0.88889],
              "9657": [-0.03472, 0.46528, 0, 0, 0.5],
              "9661": [0.19444, 0.69444, 0, 0, 0.88889],
              "9667": [-0.03472, 0.46528, 0, 0, 0.5],
              "9711": [0.19444, 0.69444, 0, 0, 1],
              "9824": [0.12963, 0.69444, 0, 0, 0.77778],
              "9825": [0.12963, 0.69444, 0, 0, 0.77778],
              "9826": [0.12963, 0.69444, 0, 0, 0.77778],
              "9827": [0.12963, 0.69444, 0, 0, 0.77778],
              "9837": [0, 0.75, 0, 0, 0.38889],
              "9838": [0.19444, 0.69444, 0, 0, 0.38889],
              "9839": [0.19444, 0.69444, 0, 0, 0.38889],
              "10216": [0.25, 0.75, 0, 0, 0.38889],
              "10217": [0.25, 0.75, 0, 0, 0.38889],
              "10222": [0.244, 0.744, 0, 0, 0.412],
              "10223": [0.244, 0.745, 0, 0, 0.412],
              "10229": [0.011, 0.511, 0, 0, 1.609],
              "10230": [0.011, 0.511, 0, 0, 1.638],
              "10231": [0.011, 0.511, 0, 0, 1.859],
              "10232": [0.024, 0.525, 0, 0, 1.609],
              "10233": [0.024, 0.525, 0, 0, 1.638],
              "10234": [0.024, 0.525, 0, 0, 1.858],
              "10236": [0.011, 0.511, 0, 0, 1.638],
              "10815": [0, 0.68333, 0, 0, 0.75],
              "10927": [0.13597, 0.63597, 0, 0, 0.77778],
              "10928": [0.13597, 0.63597, 0, 0, 0.77778],
              "57376": [0.19444, 0.69444, 0, 0, 0]
            },
            "Math-BoldItalic": {
              "32": [0, 0, 0, 0, 0.25],
              "48": [0, 0.44444, 0, 0, 0.575],
              "49": [0, 0.44444, 0, 0, 0.575],
              "50": [0, 0.44444, 0, 0, 0.575],
              "51": [0.19444, 0.44444, 0, 0, 0.575],
              "52": [0.19444, 0.44444, 0, 0, 0.575],
              "53": [0.19444, 0.44444, 0, 0, 0.575],
              "54": [0, 0.64444, 0, 0, 0.575],
              "55": [0.19444, 0.44444, 0, 0, 0.575],
              "56": [0, 0.64444, 0, 0, 0.575],
              "57": [0.19444, 0.44444, 0, 0, 0.575],
              "65": [0, 0.68611, 0, 0, 0.86944],
              "66": [0, 0.68611, 0.04835, 0, 0.8664],
              "67": [0, 0.68611, 0.06979, 0, 0.81694],
              "68": [0, 0.68611, 0.03194, 0, 0.93812],
              "69": [0, 0.68611, 0.05451, 0, 0.81007],
              "70": [0, 0.68611, 0.15972, 0, 0.68889],
              "71": [0, 0.68611, 0, 0, 0.88673],
              "72": [0, 0.68611, 0.08229, 0, 0.98229],
              "73": [0, 0.68611, 0.07778, 0, 0.51111],
              "74": [0, 0.68611, 0.10069, 0, 0.63125],
              "75": [0, 0.68611, 0.06979, 0, 0.97118],
              "76": [0, 0.68611, 0, 0, 0.75555],
              "77": [0, 0.68611, 0.11424, 0, 1.14201],
              "78": [0, 0.68611, 0.11424, 0, 0.95034],
              "79": [0, 0.68611, 0.03194, 0, 0.83666],
              "80": [0, 0.68611, 0.15972, 0, 0.72309],
              "81": [0.19444, 0.68611, 0, 0, 0.86861],
              "82": [0, 0.68611, 421e-5, 0, 0.87235],
              "83": [0, 0.68611, 0.05382, 0, 0.69271],
              "84": [0, 0.68611, 0.15972, 0, 0.63663],
              "85": [0, 0.68611, 0.11424, 0, 0.80027],
              "86": [0, 0.68611, 0.25555, 0, 0.67778],
              "87": [0, 0.68611, 0.15972, 0, 1.09305],
              "88": [0, 0.68611, 0.07778, 0, 0.94722],
              "89": [0, 0.68611, 0.25555, 0, 0.67458],
              "90": [0, 0.68611, 0.06979, 0, 0.77257],
              "97": [0, 0.44444, 0, 0, 0.63287],
              "98": [0, 0.69444, 0, 0, 0.52083],
              "99": [0, 0.44444, 0, 0, 0.51342],
              "100": [0, 0.69444, 0, 0, 0.60972],
              "101": [0, 0.44444, 0, 0, 0.55361],
              "102": [0.19444, 0.69444, 0.11042, 0, 0.56806],
              "103": [0.19444, 0.44444, 0.03704, 0, 0.5449],
              "104": [0, 0.69444, 0, 0, 0.66759],
              "105": [0, 0.69326, 0, 0, 0.4048],
              "106": [0.19444, 0.69326, 0.0622, 0, 0.47083],
              "107": [0, 0.69444, 0.01852, 0, 0.6037],
              "108": [0, 0.69444, 88e-4, 0, 0.34815],
              "109": [0, 0.44444, 0, 0, 1.0324],
              "110": [0, 0.44444, 0, 0, 0.71296],
              "111": [0, 0.44444, 0, 0, 0.58472],
              "112": [0.19444, 0.44444, 0, 0, 0.60092],
              "113": [0.19444, 0.44444, 0.03704, 0, 0.54213],
              "114": [0, 0.44444, 0.03194, 0, 0.5287],
              "115": [0, 0.44444, 0, 0, 0.53125],
              "116": [0, 0.63492, 0, 0, 0.41528],
              "117": [0, 0.44444, 0, 0, 0.68102],
              "118": [0, 0.44444, 0.03704, 0, 0.56666],
              "119": [0, 0.44444, 0.02778, 0, 0.83148],
              "120": [0, 0.44444, 0, 0, 0.65903],
              "121": [0.19444, 0.44444, 0.03704, 0, 0.59028],
              "122": [0, 0.44444, 0.04213, 0, 0.55509],
              "160": [0, 0, 0, 0, 0.25],
              "915": [0, 0.68611, 0.15972, 0, 0.65694],
              "916": [0, 0.68611, 0, 0, 0.95833],
              "920": [0, 0.68611, 0.03194, 0, 0.86722],
              "923": [0, 0.68611, 0, 0, 0.80555],
              "926": [0, 0.68611, 0.07458, 0, 0.84125],
              "928": [0, 0.68611, 0.08229, 0, 0.98229],
              "931": [0, 0.68611, 0.05451, 0, 0.88507],
              "933": [0, 0.68611, 0.15972, 0, 0.67083],
              "934": [0, 0.68611, 0, 0, 0.76666],
              "936": [0, 0.68611, 0.11653, 0, 0.71402],
              "937": [0, 0.68611, 0.04835, 0, 0.8789],
              "945": [0, 0.44444, 0, 0, 0.76064],
              "946": [0.19444, 0.69444, 0.03403, 0, 0.65972],
              "947": [0.19444, 0.44444, 0.06389, 0, 0.59003],
              "948": [0, 0.69444, 0.03819, 0, 0.52222],
              "949": [0, 0.44444, 0, 0, 0.52882],
              "950": [0.19444, 0.69444, 0.06215, 0, 0.50833],
              "951": [0.19444, 0.44444, 0.03704, 0, 0.6],
              "952": [0, 0.69444, 0.03194, 0, 0.5618],
              "953": [0, 0.44444, 0, 0, 0.41204],
              "954": [0, 0.44444, 0, 0, 0.66759],
              "955": [0, 0.69444, 0, 0, 0.67083],
              "956": [0.19444, 0.44444, 0, 0, 0.70787],
              "957": [0, 0.44444, 0.06898, 0, 0.57685],
              "958": [0.19444, 0.69444, 0.03021, 0, 0.50833],
              "959": [0, 0.44444, 0, 0, 0.58472],
              "960": [0, 0.44444, 0.03704, 0, 0.68241],
              "961": [0.19444, 0.44444, 0, 0, 0.6118],
              "962": [0.09722, 0.44444, 0.07917, 0, 0.42361],
              "963": [0, 0.44444, 0.03704, 0, 0.68588],
              "964": [0, 0.44444, 0.13472, 0, 0.52083],
              "965": [0, 0.44444, 0.03704, 0, 0.63055],
              "966": [0.19444, 0.44444, 0, 0, 0.74722],
              "967": [0.19444, 0.44444, 0, 0, 0.71805],
              "968": [0.19444, 0.69444, 0.03704, 0, 0.75833],
              "969": [0, 0.44444, 0.03704, 0, 0.71782],
              "977": [0, 0.69444, 0, 0, 0.69155],
              "981": [0.19444, 0.69444, 0, 0, 0.7125],
              "982": [0, 0.44444, 0.03194, 0, 0.975],
              "1009": [0.19444, 0.44444, 0, 0, 0.6118],
              "1013": [0, 0.44444, 0, 0, 0.48333],
              "57649": [0, 0.44444, 0, 0, 0.39352],
              "57911": [0.19444, 0.44444, 0, 0, 0.43889]
            },
            "Math-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "48": [0, 0.43056, 0, 0, 0.5],
              "49": [0, 0.43056, 0, 0, 0.5],
              "50": [0, 0.43056, 0, 0, 0.5],
              "51": [0.19444, 0.43056, 0, 0, 0.5],
              "52": [0.19444, 0.43056, 0, 0, 0.5],
              "53": [0.19444, 0.43056, 0, 0, 0.5],
              "54": [0, 0.64444, 0, 0, 0.5],
              "55": [0.19444, 0.43056, 0, 0, 0.5],
              "56": [0, 0.64444, 0, 0, 0.5],
              "57": [0.19444, 0.43056, 0, 0, 0.5],
              "65": [0, 0.68333, 0, 0.13889, 0.75],
              "66": [0, 0.68333, 0.05017, 0.08334, 0.75851],
              "67": [0, 0.68333, 0.07153, 0.08334, 0.71472],
              "68": [0, 0.68333, 0.02778, 0.05556, 0.82792],
              "69": [0, 0.68333, 0.05764, 0.08334, 0.7382],
              "70": [0, 0.68333, 0.13889, 0.08334, 0.64306],
              "71": [0, 0.68333, 0, 0.08334, 0.78625],
              "72": [0, 0.68333, 0.08125, 0.05556, 0.83125],
              "73": [0, 0.68333, 0.07847, 0.11111, 0.43958],
              "74": [0, 0.68333, 0.09618, 0.16667, 0.55451],
              "75": [0, 0.68333, 0.07153, 0.05556, 0.84931],
              "76": [0, 0.68333, 0, 0.02778, 0.68056],
              "77": [0, 0.68333, 0.10903, 0.08334, 0.97014],
              "78": [0, 0.68333, 0.10903, 0.08334, 0.80347],
              "79": [0, 0.68333, 0.02778, 0.08334, 0.76278],
              "80": [0, 0.68333, 0.13889, 0.08334, 0.64201],
              "81": [0.19444, 0.68333, 0, 0.08334, 0.79056],
              "82": [0, 0.68333, 773e-5, 0.08334, 0.75929],
              "83": [0, 0.68333, 0.05764, 0.08334, 0.6132],
              "84": [0, 0.68333, 0.13889, 0.08334, 0.58438],
              "85": [0, 0.68333, 0.10903, 0.02778, 0.68278],
              "86": [0, 0.68333, 0.22222, 0, 0.58333],
              "87": [0, 0.68333, 0.13889, 0, 0.94445],
              "88": [0, 0.68333, 0.07847, 0.08334, 0.82847],
              "89": [0, 0.68333, 0.22222, 0, 0.58056],
              "90": [0, 0.68333, 0.07153, 0.08334, 0.68264],
              "97": [0, 0.43056, 0, 0, 0.52859],
              "98": [0, 0.69444, 0, 0, 0.42917],
              "99": [0, 0.43056, 0, 0.05556, 0.43276],
              "100": [0, 0.69444, 0, 0.16667, 0.52049],
              "101": [0, 0.43056, 0, 0.05556, 0.46563],
              "102": [0.19444, 0.69444, 0.10764, 0.16667, 0.48959],
              "103": [0.19444, 0.43056, 0.03588, 0.02778, 0.47697],
              "104": [0, 0.69444, 0, 0, 0.57616],
              "105": [0, 0.65952, 0, 0, 0.34451],
              "106": [0.19444, 0.65952, 0.05724, 0, 0.41181],
              "107": [0, 0.69444, 0.03148, 0, 0.5206],
              "108": [0, 0.69444, 0.01968, 0.08334, 0.29838],
              "109": [0, 0.43056, 0, 0, 0.87801],
              "110": [0, 0.43056, 0, 0, 0.60023],
              "111": [0, 0.43056, 0, 0.05556, 0.48472],
              "112": [0.19444, 0.43056, 0, 0.08334, 0.50313],
              "113": [0.19444, 0.43056, 0.03588, 0.08334, 0.44641],
              "114": [0, 0.43056, 0.02778, 0.05556, 0.45116],
              "115": [0, 0.43056, 0, 0.05556, 0.46875],
              "116": [0, 0.61508, 0, 0.08334, 0.36111],
              "117": [0, 0.43056, 0, 0.02778, 0.57246],
              "118": [0, 0.43056, 0.03588, 0.02778, 0.48472],
              "119": [0, 0.43056, 0.02691, 0.08334, 0.71592],
              "120": [0, 0.43056, 0, 0.02778, 0.57153],
              "121": [0.19444, 0.43056, 0.03588, 0.05556, 0.49028],
              "122": [0, 0.43056, 0.04398, 0.05556, 0.46505],
              "160": [0, 0, 0, 0, 0.25],
              "915": [0, 0.68333, 0.13889, 0.08334, 0.61528],
              "916": [0, 0.68333, 0, 0.16667, 0.83334],
              "920": [0, 0.68333, 0.02778, 0.08334, 0.76278],
              "923": [0, 0.68333, 0, 0.16667, 0.69445],
              "926": [0, 0.68333, 0.07569, 0.08334, 0.74236],
              "928": [0, 0.68333, 0.08125, 0.05556, 0.83125],
              "931": [0, 0.68333, 0.05764, 0.08334, 0.77986],
              "933": [0, 0.68333, 0.13889, 0.05556, 0.58333],
              "934": [0, 0.68333, 0, 0.08334, 0.66667],
              "936": [0, 0.68333, 0.11, 0.05556, 0.61222],
              "937": [0, 0.68333, 0.05017, 0.08334, 0.7724],
              "945": [0, 0.43056, 37e-4, 0.02778, 0.6397],
              "946": [0.19444, 0.69444, 0.05278, 0.08334, 0.56563],
              "947": [0.19444, 0.43056, 0.05556, 0, 0.51773],
              "948": [0, 0.69444, 0.03785, 0.05556, 0.44444],
              "949": [0, 0.43056, 0, 0.08334, 0.46632],
              "950": [0.19444, 0.69444, 0.07378, 0.08334, 0.4375],
              "951": [0.19444, 0.43056, 0.03588, 0.05556, 0.49653],
              "952": [0, 0.69444, 0.02778, 0.08334, 0.46944],
              "953": [0, 0.43056, 0, 0.05556, 0.35394],
              "954": [0, 0.43056, 0, 0, 0.57616],
              "955": [0, 0.69444, 0, 0, 0.58334],
              "956": [0.19444, 0.43056, 0, 0.02778, 0.60255],
              "957": [0, 0.43056, 0.06366, 0.02778, 0.49398],
              "958": [0.19444, 0.69444, 0.04601, 0.11111, 0.4375],
              "959": [0, 0.43056, 0, 0.05556, 0.48472],
              "960": [0, 0.43056, 0.03588, 0, 0.57003],
              "961": [0.19444, 0.43056, 0, 0.08334, 0.51702],
              "962": [0.09722, 0.43056, 0.07986, 0.08334, 0.36285],
              "963": [0, 0.43056, 0.03588, 0, 0.57141],
              "964": [0, 0.43056, 0.1132, 0.02778, 0.43715],
              "965": [0, 0.43056, 0.03588, 0.02778, 0.54028],
              "966": [0.19444, 0.43056, 0, 0.08334, 0.65417],
              "967": [0.19444, 0.43056, 0, 0.05556, 0.62569],
              "968": [0.19444, 0.69444, 0.03588, 0.11111, 0.65139],
              "969": [0, 0.43056, 0.03588, 0, 0.62245],
              "977": [0, 0.69444, 0, 0.08334, 0.59144],
              "981": [0.19444, 0.69444, 0, 0.08334, 0.59583],
              "982": [0, 0.43056, 0.02778, 0, 0.82813],
              "1009": [0.19444, 0.43056, 0, 0.08334, 0.51702],
              "1013": [0, 0.43056, 0, 0.05556, 0.4059],
              "57649": [0, 0.43056, 0, 0.02778, 0.32246],
              "57911": [0.19444, 0.43056, 0, 0.08334, 0.38403]
            },
            "SansSerif-Bold": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.36667],
              "34": [0, 0.69444, 0, 0, 0.55834],
              "35": [0.19444, 0.69444, 0, 0, 0.91667],
              "36": [0.05556, 0.75, 0, 0, 0.55],
              "37": [0.05556, 0.75, 0, 0, 1.02912],
              "38": [0, 0.69444, 0, 0, 0.83056],
              "39": [0, 0.69444, 0, 0, 0.30556],
              "40": [0.25, 0.75, 0, 0, 0.42778],
              "41": [0.25, 0.75, 0, 0, 0.42778],
              "42": [0, 0.75, 0, 0, 0.55],
              "43": [0.11667, 0.61667, 0, 0, 0.85556],
              "44": [0.10556, 0.13056, 0, 0, 0.30556],
              "45": [0, 0.45833, 0, 0, 0.36667],
              "46": [0, 0.13056, 0, 0, 0.30556],
              "47": [0.25, 0.75, 0, 0, 0.55],
              "48": [0, 0.69444, 0, 0, 0.55],
              "49": [0, 0.69444, 0, 0, 0.55],
              "50": [0, 0.69444, 0, 0, 0.55],
              "51": [0, 0.69444, 0, 0, 0.55],
              "52": [0, 0.69444, 0, 0, 0.55],
              "53": [0, 0.69444, 0, 0, 0.55],
              "54": [0, 0.69444, 0, 0, 0.55],
              "55": [0, 0.69444, 0, 0, 0.55],
              "56": [0, 0.69444, 0, 0, 0.55],
              "57": [0, 0.69444, 0, 0, 0.55],
              "58": [0, 0.45833, 0, 0, 0.30556],
              "59": [0.10556, 0.45833, 0, 0, 0.30556],
              "61": [-0.09375, 0.40625, 0, 0, 0.85556],
              "63": [0, 0.69444, 0, 0, 0.51945],
              "64": [0, 0.69444, 0, 0, 0.73334],
              "65": [0, 0.69444, 0, 0, 0.73334],
              "66": [0, 0.69444, 0, 0, 0.73334],
              "67": [0, 0.69444, 0, 0, 0.70278],
              "68": [0, 0.69444, 0, 0, 0.79445],
              "69": [0, 0.69444, 0, 0, 0.64167],
              "70": [0, 0.69444, 0, 0, 0.61111],
              "71": [0, 0.69444, 0, 0, 0.73334],
              "72": [0, 0.69444, 0, 0, 0.79445],
              "73": [0, 0.69444, 0, 0, 0.33056],
              "74": [0, 0.69444, 0, 0, 0.51945],
              "75": [0, 0.69444, 0, 0, 0.76389],
              "76": [0, 0.69444, 0, 0, 0.58056],
              "77": [0, 0.69444, 0, 0, 0.97778],
              "78": [0, 0.69444, 0, 0, 0.79445],
              "79": [0, 0.69444, 0, 0, 0.79445],
              "80": [0, 0.69444, 0, 0, 0.70278],
              "81": [0.10556, 0.69444, 0, 0, 0.79445],
              "82": [0, 0.69444, 0, 0, 0.70278],
              "83": [0, 0.69444, 0, 0, 0.61111],
              "84": [0, 0.69444, 0, 0, 0.73334],
              "85": [0, 0.69444, 0, 0, 0.76389],
              "86": [0, 0.69444, 0.01528, 0, 0.73334],
              "87": [0, 0.69444, 0.01528, 0, 1.03889],
              "88": [0, 0.69444, 0, 0, 0.73334],
              "89": [0, 0.69444, 0.0275, 0, 0.73334],
              "90": [0, 0.69444, 0, 0, 0.67223],
              "91": [0.25, 0.75, 0, 0, 0.34306],
              "93": [0.25, 0.75, 0, 0, 0.34306],
              "94": [0, 0.69444, 0, 0, 0.55],
              "95": [0.35, 0.10833, 0.03056, 0, 0.55],
              "97": [0, 0.45833, 0, 0, 0.525],
              "98": [0, 0.69444, 0, 0, 0.56111],
              "99": [0, 0.45833, 0, 0, 0.48889],
              "100": [0, 0.69444, 0, 0, 0.56111],
              "101": [0, 0.45833, 0, 0, 0.51111],
              "102": [0, 0.69444, 0.07639, 0, 0.33611],
              "103": [0.19444, 0.45833, 0.01528, 0, 0.55],
              "104": [0, 0.69444, 0, 0, 0.56111],
              "105": [0, 0.69444, 0, 0, 0.25556],
              "106": [0.19444, 0.69444, 0, 0, 0.28611],
              "107": [0, 0.69444, 0, 0, 0.53056],
              "108": [0, 0.69444, 0, 0, 0.25556],
              "109": [0, 0.45833, 0, 0, 0.86667],
              "110": [0, 0.45833, 0, 0, 0.56111],
              "111": [0, 0.45833, 0, 0, 0.55],
              "112": [0.19444, 0.45833, 0, 0, 0.56111],
              "113": [0.19444, 0.45833, 0, 0, 0.56111],
              "114": [0, 0.45833, 0.01528, 0, 0.37222],
              "115": [0, 0.45833, 0, 0, 0.42167],
              "116": [0, 0.58929, 0, 0, 0.40417],
              "117": [0, 0.45833, 0, 0, 0.56111],
              "118": [0, 0.45833, 0.01528, 0, 0.5],
              "119": [0, 0.45833, 0.01528, 0, 0.74445],
              "120": [0, 0.45833, 0, 0, 0.5],
              "121": [0.19444, 0.45833, 0.01528, 0, 0.5],
              "122": [0, 0.45833, 0, 0, 0.47639],
              "126": [0.35, 0.34444, 0, 0, 0.55],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.69444, 0, 0, 0.55],
              "176": [0, 0.69444, 0, 0, 0.73334],
              "180": [0, 0.69444, 0, 0, 0.55],
              "184": [0.17014, 0, 0, 0, 0.48889],
              "305": [0, 0.45833, 0, 0, 0.25556],
              "567": [0.19444, 0.45833, 0, 0, 0.28611],
              "710": [0, 0.69444, 0, 0, 0.55],
              "711": [0, 0.63542, 0, 0, 0.55],
              "713": [0, 0.63778, 0, 0, 0.55],
              "728": [0, 0.69444, 0, 0, 0.55],
              "729": [0, 0.69444, 0, 0, 0.30556],
              "730": [0, 0.69444, 0, 0, 0.73334],
              "732": [0, 0.69444, 0, 0, 0.55],
              "733": [0, 0.69444, 0, 0, 0.55],
              "915": [0, 0.69444, 0, 0, 0.58056],
              "916": [0, 0.69444, 0, 0, 0.91667],
              "920": [0, 0.69444, 0, 0, 0.85556],
              "923": [0, 0.69444, 0, 0, 0.67223],
              "926": [0, 0.69444, 0, 0, 0.73334],
              "928": [0, 0.69444, 0, 0, 0.79445],
              "931": [0, 0.69444, 0, 0, 0.79445],
              "933": [0, 0.69444, 0, 0, 0.85556],
              "934": [0, 0.69444, 0, 0, 0.79445],
              "936": [0, 0.69444, 0, 0, 0.85556],
              "937": [0, 0.69444, 0, 0, 0.79445],
              "8211": [0, 0.45833, 0.03056, 0, 0.55],
              "8212": [0, 0.45833, 0.03056, 0, 1.10001],
              "8216": [0, 0.69444, 0, 0, 0.30556],
              "8217": [0, 0.69444, 0, 0, 0.30556],
              "8220": [0, 0.69444, 0, 0, 0.55834],
              "8221": [0, 0.69444, 0, 0, 0.55834]
            },
            "SansSerif-Italic": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0.05733, 0, 0.31945],
              "34": [0, 0.69444, 316e-5, 0, 0.5],
              "35": [0.19444, 0.69444, 0.05087, 0, 0.83334],
              "36": [0.05556, 0.75, 0.11156, 0, 0.5],
              "37": [0.05556, 0.75, 0.03126, 0, 0.83334],
              "38": [0, 0.69444, 0.03058, 0, 0.75834],
              "39": [0, 0.69444, 0.07816, 0, 0.27778],
              "40": [0.25, 0.75, 0.13164, 0, 0.38889],
              "41": [0.25, 0.75, 0.02536, 0, 0.38889],
              "42": [0, 0.75, 0.11775, 0, 0.5],
              "43": [0.08333, 0.58333, 0.02536, 0, 0.77778],
              "44": [0.125, 0.08333, 0, 0, 0.27778],
              "45": [0, 0.44444, 0.01946, 0, 0.33333],
              "46": [0, 0.08333, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0.13164, 0, 0.5],
              "48": [0, 0.65556, 0.11156, 0, 0.5],
              "49": [0, 0.65556, 0.11156, 0, 0.5],
              "50": [0, 0.65556, 0.11156, 0, 0.5],
              "51": [0, 0.65556, 0.11156, 0, 0.5],
              "52": [0, 0.65556, 0.11156, 0, 0.5],
              "53": [0, 0.65556, 0.11156, 0, 0.5],
              "54": [0, 0.65556, 0.11156, 0, 0.5],
              "55": [0, 0.65556, 0.11156, 0, 0.5],
              "56": [0, 0.65556, 0.11156, 0, 0.5],
              "57": [0, 0.65556, 0.11156, 0, 0.5],
              "58": [0, 0.44444, 0.02502, 0, 0.27778],
              "59": [0.125, 0.44444, 0.02502, 0, 0.27778],
              "61": [-0.13, 0.37, 0.05087, 0, 0.77778],
              "63": [0, 0.69444, 0.11809, 0, 0.47222],
              "64": [0, 0.69444, 0.07555, 0, 0.66667],
              "65": [0, 0.69444, 0, 0, 0.66667],
              "66": [0, 0.69444, 0.08293, 0, 0.66667],
              "67": [0, 0.69444, 0.11983, 0, 0.63889],
              "68": [0, 0.69444, 0.07555, 0, 0.72223],
              "69": [0, 0.69444, 0.11983, 0, 0.59722],
              "70": [0, 0.69444, 0.13372, 0, 0.56945],
              "71": [0, 0.69444, 0.11983, 0, 0.66667],
              "72": [0, 0.69444, 0.08094, 0, 0.70834],
              "73": [0, 0.69444, 0.13372, 0, 0.27778],
              "74": [0, 0.69444, 0.08094, 0, 0.47222],
              "75": [0, 0.69444, 0.11983, 0, 0.69445],
              "76": [0, 0.69444, 0, 0, 0.54167],
              "77": [0, 0.69444, 0.08094, 0, 0.875],
              "78": [0, 0.69444, 0.08094, 0, 0.70834],
              "79": [0, 0.69444, 0.07555, 0, 0.73611],
              "80": [0, 0.69444, 0.08293, 0, 0.63889],
              "81": [0.125, 0.69444, 0.07555, 0, 0.73611],
              "82": [0, 0.69444, 0.08293, 0, 0.64584],
              "83": [0, 0.69444, 0.09205, 0, 0.55556],
              "84": [0, 0.69444, 0.13372, 0, 0.68056],
              "85": [0, 0.69444, 0.08094, 0, 0.6875],
              "86": [0, 0.69444, 0.1615, 0, 0.66667],
              "87": [0, 0.69444, 0.1615, 0, 0.94445],
              "88": [0, 0.69444, 0.13372, 0, 0.66667],
              "89": [0, 0.69444, 0.17261, 0, 0.66667],
              "90": [0, 0.69444, 0.11983, 0, 0.61111],
              "91": [0.25, 0.75, 0.15942, 0, 0.28889],
              "93": [0.25, 0.75, 0.08719, 0, 0.28889],
              "94": [0, 0.69444, 0.0799, 0, 0.5],
              "95": [0.35, 0.09444, 0.08616, 0, 0.5],
              "97": [0, 0.44444, 981e-5, 0, 0.48056],
              "98": [0, 0.69444, 0.03057, 0, 0.51667],
              "99": [0, 0.44444, 0.08336, 0, 0.44445],
              "100": [0, 0.69444, 0.09483, 0, 0.51667],
              "101": [0, 0.44444, 0.06778, 0, 0.44445],
              "102": [0, 0.69444, 0.21705, 0, 0.30556],
              "103": [0.19444, 0.44444, 0.10836, 0, 0.5],
              "104": [0, 0.69444, 0.01778, 0, 0.51667],
              "105": [0, 0.67937, 0.09718, 0, 0.23889],
              "106": [0.19444, 0.67937, 0.09162, 0, 0.26667],
              "107": [0, 0.69444, 0.08336, 0, 0.48889],
              "108": [0, 0.69444, 0.09483, 0, 0.23889],
              "109": [0, 0.44444, 0.01778, 0, 0.79445],
              "110": [0, 0.44444, 0.01778, 0, 0.51667],
              "111": [0, 0.44444, 0.06613, 0, 0.5],
              "112": [0.19444, 0.44444, 0.0389, 0, 0.51667],
              "113": [0.19444, 0.44444, 0.04169, 0, 0.51667],
              "114": [0, 0.44444, 0.10836, 0, 0.34167],
              "115": [0, 0.44444, 0.0778, 0, 0.38333],
              "116": [0, 0.57143, 0.07225, 0, 0.36111],
              "117": [0, 0.44444, 0.04169, 0, 0.51667],
              "118": [0, 0.44444, 0.10836, 0, 0.46111],
              "119": [0, 0.44444, 0.10836, 0, 0.68334],
              "120": [0, 0.44444, 0.09169, 0, 0.46111],
              "121": [0.19444, 0.44444, 0.10836, 0, 0.46111],
              "122": [0, 0.44444, 0.08752, 0, 0.43472],
              "126": [0.35, 0.32659, 0.08826, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.67937, 0.06385, 0, 0.5],
              "176": [0, 0.69444, 0, 0, 0.73752],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "305": [0, 0.44444, 0.04169, 0, 0.23889],
              "567": [0.19444, 0.44444, 0.04169, 0, 0.26667],
              "710": [0, 0.69444, 0.0799, 0, 0.5],
              "711": [0, 0.63194, 0.08432, 0, 0.5],
              "713": [0, 0.60889, 0.08776, 0, 0.5],
              "714": [0, 0.69444, 0.09205, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0.09483, 0, 0.5],
              "729": [0, 0.67937, 0.07774, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.73752],
              "732": [0, 0.67659, 0.08826, 0, 0.5],
              "733": [0, 0.69444, 0.09205, 0, 0.5],
              "915": [0, 0.69444, 0.13372, 0, 0.54167],
              "916": [0, 0.69444, 0, 0, 0.83334],
              "920": [0, 0.69444, 0.07555, 0, 0.77778],
              "923": [0, 0.69444, 0, 0, 0.61111],
              "926": [0, 0.69444, 0.12816, 0, 0.66667],
              "928": [0, 0.69444, 0.08094, 0, 0.70834],
              "931": [0, 0.69444, 0.11983, 0, 0.72222],
              "933": [0, 0.69444, 0.09031, 0, 0.77778],
              "934": [0, 0.69444, 0.04603, 0, 0.72222],
              "936": [0, 0.69444, 0.09031, 0, 0.77778],
              "937": [0, 0.69444, 0.08293, 0, 0.72222],
              "8211": [0, 0.44444, 0.08616, 0, 0.5],
              "8212": [0, 0.44444, 0.08616, 0, 1],
              "8216": [0, 0.69444, 0.07816, 0, 0.27778],
              "8217": [0, 0.69444, 0.07816, 0, 0.27778],
              "8220": [0, 0.69444, 0.14205, 0, 0.5],
              "8221": [0, 0.69444, 316e-5, 0, 0.5]
            },
            "SansSerif-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "33": [0, 0.69444, 0, 0, 0.31945],
              "34": [0, 0.69444, 0, 0, 0.5],
              "35": [0.19444, 0.69444, 0, 0, 0.83334],
              "36": [0.05556, 0.75, 0, 0, 0.5],
              "37": [0.05556, 0.75, 0, 0, 0.83334],
              "38": [0, 0.69444, 0, 0, 0.75834],
              "39": [0, 0.69444, 0, 0, 0.27778],
              "40": [0.25, 0.75, 0, 0, 0.38889],
              "41": [0.25, 0.75, 0, 0, 0.38889],
              "42": [0, 0.75, 0, 0, 0.5],
              "43": [0.08333, 0.58333, 0, 0, 0.77778],
              "44": [0.125, 0.08333, 0, 0, 0.27778],
              "45": [0, 0.44444, 0, 0, 0.33333],
              "46": [0, 0.08333, 0, 0, 0.27778],
              "47": [0.25, 0.75, 0, 0, 0.5],
              "48": [0, 0.65556, 0, 0, 0.5],
              "49": [0, 0.65556, 0, 0, 0.5],
              "50": [0, 0.65556, 0, 0, 0.5],
              "51": [0, 0.65556, 0, 0, 0.5],
              "52": [0, 0.65556, 0, 0, 0.5],
              "53": [0, 0.65556, 0, 0, 0.5],
              "54": [0, 0.65556, 0, 0, 0.5],
              "55": [0, 0.65556, 0, 0, 0.5],
              "56": [0, 0.65556, 0, 0, 0.5],
              "57": [0, 0.65556, 0, 0, 0.5],
              "58": [0, 0.44444, 0, 0, 0.27778],
              "59": [0.125, 0.44444, 0, 0, 0.27778],
              "61": [-0.13, 0.37, 0, 0, 0.77778],
              "63": [0, 0.69444, 0, 0, 0.47222],
              "64": [0, 0.69444, 0, 0, 0.66667],
              "65": [0, 0.69444, 0, 0, 0.66667],
              "66": [0, 0.69444, 0, 0, 0.66667],
              "67": [0, 0.69444, 0, 0, 0.63889],
              "68": [0, 0.69444, 0, 0, 0.72223],
              "69": [0, 0.69444, 0, 0, 0.59722],
              "70": [0, 0.69444, 0, 0, 0.56945],
              "71": [0, 0.69444, 0, 0, 0.66667],
              "72": [0, 0.69444, 0, 0, 0.70834],
              "73": [0, 0.69444, 0, 0, 0.27778],
              "74": [0, 0.69444, 0, 0, 0.47222],
              "75": [0, 0.69444, 0, 0, 0.69445],
              "76": [0, 0.69444, 0, 0, 0.54167],
              "77": [0, 0.69444, 0, 0, 0.875],
              "78": [0, 0.69444, 0, 0, 0.70834],
              "79": [0, 0.69444, 0, 0, 0.73611],
              "80": [0, 0.69444, 0, 0, 0.63889],
              "81": [0.125, 0.69444, 0, 0, 0.73611],
              "82": [0, 0.69444, 0, 0, 0.64584],
              "83": [0, 0.69444, 0, 0, 0.55556],
              "84": [0, 0.69444, 0, 0, 0.68056],
              "85": [0, 0.69444, 0, 0, 0.6875],
              "86": [0, 0.69444, 0.01389, 0, 0.66667],
              "87": [0, 0.69444, 0.01389, 0, 0.94445],
              "88": [0, 0.69444, 0, 0, 0.66667],
              "89": [0, 0.69444, 0.025, 0, 0.66667],
              "90": [0, 0.69444, 0, 0, 0.61111],
              "91": [0.25, 0.75, 0, 0, 0.28889],
              "93": [0.25, 0.75, 0, 0, 0.28889],
              "94": [0, 0.69444, 0, 0, 0.5],
              "95": [0.35, 0.09444, 0.02778, 0, 0.5],
              "97": [0, 0.44444, 0, 0, 0.48056],
              "98": [0, 0.69444, 0, 0, 0.51667],
              "99": [0, 0.44444, 0, 0, 0.44445],
              "100": [0, 0.69444, 0, 0, 0.51667],
              "101": [0, 0.44444, 0, 0, 0.44445],
              "102": [0, 0.69444, 0.06944, 0, 0.30556],
              "103": [0.19444, 0.44444, 0.01389, 0, 0.5],
              "104": [0, 0.69444, 0, 0, 0.51667],
              "105": [0, 0.67937, 0, 0, 0.23889],
              "106": [0.19444, 0.67937, 0, 0, 0.26667],
              "107": [0, 0.69444, 0, 0, 0.48889],
              "108": [0, 0.69444, 0, 0, 0.23889],
              "109": [0, 0.44444, 0, 0, 0.79445],
              "110": [0, 0.44444, 0, 0, 0.51667],
              "111": [0, 0.44444, 0, 0, 0.5],
              "112": [0.19444, 0.44444, 0, 0, 0.51667],
              "113": [0.19444, 0.44444, 0, 0, 0.51667],
              "114": [0, 0.44444, 0.01389, 0, 0.34167],
              "115": [0, 0.44444, 0, 0, 0.38333],
              "116": [0, 0.57143, 0, 0, 0.36111],
              "117": [0, 0.44444, 0, 0, 0.51667],
              "118": [0, 0.44444, 0.01389, 0, 0.46111],
              "119": [0, 0.44444, 0.01389, 0, 0.68334],
              "120": [0, 0.44444, 0, 0, 0.46111],
              "121": [0.19444, 0.44444, 0.01389, 0, 0.46111],
              "122": [0, 0.44444, 0, 0, 0.43472],
              "126": [0.35, 0.32659, 0, 0, 0.5],
              "160": [0, 0, 0, 0, 0.25],
              "168": [0, 0.67937, 0, 0, 0.5],
              "176": [0, 0.69444, 0, 0, 0.66667],
              "184": [0.17014, 0, 0, 0, 0.44445],
              "305": [0, 0.44444, 0, 0, 0.23889],
              "567": [0.19444, 0.44444, 0, 0, 0.26667],
              "710": [0, 0.69444, 0, 0, 0.5],
              "711": [0, 0.63194, 0, 0, 0.5],
              "713": [0, 0.60889, 0, 0, 0.5],
              "714": [0, 0.69444, 0, 0, 0.5],
              "715": [0, 0.69444, 0, 0, 0.5],
              "728": [0, 0.69444, 0, 0, 0.5],
              "729": [0, 0.67937, 0, 0, 0.27778],
              "730": [0, 0.69444, 0, 0, 0.66667],
              "732": [0, 0.67659, 0, 0, 0.5],
              "733": [0, 0.69444, 0, 0, 0.5],
              "915": [0, 0.69444, 0, 0, 0.54167],
              "916": [0, 0.69444, 0, 0, 0.83334],
              "920": [0, 0.69444, 0, 0, 0.77778],
              "923": [0, 0.69444, 0, 0, 0.61111],
              "926": [0, 0.69444, 0, 0, 0.66667],
              "928": [0, 0.69444, 0, 0, 0.70834],
              "931": [0, 0.69444, 0, 0, 0.72222],
              "933": [0, 0.69444, 0, 0, 0.77778],
              "934": [0, 0.69444, 0, 0, 0.72222],
              "936": [0, 0.69444, 0, 0, 0.77778],
              "937": [0, 0.69444, 0, 0, 0.72222],
              "8211": [0, 0.44444, 0.02778, 0, 0.5],
              "8212": [0, 0.44444, 0.02778, 0, 1],
              "8216": [0, 0.69444, 0, 0, 0.27778],
              "8217": [0, 0.69444, 0, 0, 0.27778],
              "8220": [0, 0.69444, 0, 0, 0.5],
              "8221": [0, 0.69444, 0, 0, 0.5]
            },
            "Script-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "65": [0, 0.7, 0.22925, 0, 0.80253],
              "66": [0, 0.7, 0.04087, 0, 0.90757],
              "67": [0, 0.7, 0.1689, 0, 0.66619],
              "68": [0, 0.7, 0.09371, 0, 0.77443],
              "69": [0, 0.7, 0.18583, 0, 0.56162],
              "70": [0, 0.7, 0.13634, 0, 0.89544],
              "71": [0, 0.7, 0.17322, 0, 0.60961],
              "72": [0, 0.7, 0.29694, 0, 0.96919],
              "73": [0, 0.7, 0.19189, 0, 0.80907],
              "74": [0.27778, 0.7, 0.19189, 0, 1.05159],
              "75": [0, 0.7, 0.31259, 0, 0.91364],
              "76": [0, 0.7, 0.19189, 0, 0.87373],
              "77": [0, 0.7, 0.15981, 0, 1.08031],
              "78": [0, 0.7, 0.3525, 0, 0.9015],
              "79": [0, 0.7, 0.08078, 0, 0.73787],
              "80": [0, 0.7, 0.08078, 0, 1.01262],
              "81": [0, 0.7, 0.03305, 0, 0.88282],
              "82": [0, 0.7, 0.06259, 0, 0.85],
              "83": [0, 0.7, 0.19189, 0, 0.86767],
              "84": [0, 0.7, 0.29087, 0, 0.74697],
              "85": [0, 0.7, 0.25815, 0, 0.79996],
              "86": [0, 0.7, 0.27523, 0, 0.62204],
              "87": [0, 0.7, 0.27523, 0, 0.80532],
              "88": [0, 0.7, 0.26006, 0, 0.94445],
              "89": [0, 0.7, 0.2939, 0, 0.70961],
              "90": [0, 0.7, 0.24037, 0, 0.8212],
              "160": [0, 0, 0, 0, 0.25]
            },
            "Size1-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.35001, 0.85, 0, 0, 0.45834],
              "41": [0.35001, 0.85, 0, 0, 0.45834],
              "47": [0.35001, 0.85, 0, 0, 0.57778],
              "91": [0.35001, 0.85, 0, 0, 0.41667],
              "92": [0.35001, 0.85, 0, 0, 0.57778],
              "93": [0.35001, 0.85, 0, 0, 0.41667],
              "123": [0.35001, 0.85, 0, 0, 0.58334],
              "125": [0.35001, 0.85, 0, 0, 0.58334],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.72222, 0, 0, 0.55556],
              "732": [0, 0.72222, 0, 0, 0.55556],
              "770": [0, 0.72222, 0, 0, 0.55556],
              "771": [0, 0.72222, 0, 0, 0.55556],
              "8214": [-99e-5, 0.601, 0, 0, 0.77778],
              "8593": [1e-5, 0.6, 0, 0, 0.66667],
              "8595": [1e-5, 0.6, 0, 0, 0.66667],
              "8657": [1e-5, 0.6, 0, 0, 0.77778],
              "8659": [1e-5, 0.6, 0, 0, 0.77778],
              "8719": [0.25001, 0.75, 0, 0, 0.94445],
              "8720": [0.25001, 0.75, 0, 0, 0.94445],
              "8721": [0.25001, 0.75, 0, 0, 1.05556],
              "8730": [0.35001, 0.85, 0, 0, 1],
              "8739": [-599e-5, 0.606, 0, 0, 0.33333],
              "8741": [-599e-5, 0.606, 0, 0, 0.55556],
              "8747": [0.30612, 0.805, 0.19445, 0, 0.47222],
              "8748": [0.306, 0.805, 0.19445, 0, 0.47222],
              "8749": [0.306, 0.805, 0.19445, 0, 0.47222],
              "8750": [0.30612, 0.805, 0.19445, 0, 0.47222],
              "8896": [0.25001, 0.75, 0, 0, 0.83334],
              "8897": [0.25001, 0.75, 0, 0, 0.83334],
              "8898": [0.25001, 0.75, 0, 0, 0.83334],
              "8899": [0.25001, 0.75, 0, 0, 0.83334],
              "8968": [0.35001, 0.85, 0, 0, 0.47222],
              "8969": [0.35001, 0.85, 0, 0, 0.47222],
              "8970": [0.35001, 0.85, 0, 0, 0.47222],
              "8971": [0.35001, 0.85, 0, 0, 0.47222],
              "9168": [-99e-5, 0.601, 0, 0, 0.66667],
              "10216": [0.35001, 0.85, 0, 0, 0.47222],
              "10217": [0.35001, 0.85, 0, 0, 0.47222],
              "10752": [0.25001, 0.75, 0, 0, 1.11111],
              "10753": [0.25001, 0.75, 0, 0, 1.11111],
              "10754": [0.25001, 0.75, 0, 0, 1.11111],
              "10756": [0.25001, 0.75, 0, 0, 0.83334],
              "10758": [0.25001, 0.75, 0, 0, 0.83334]
            },
            "Size2-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.65002, 1.15, 0, 0, 0.59722],
              "41": [0.65002, 1.15, 0, 0, 0.59722],
              "47": [0.65002, 1.15, 0, 0, 0.81111],
              "91": [0.65002, 1.15, 0, 0, 0.47222],
              "92": [0.65002, 1.15, 0, 0, 0.81111],
              "93": [0.65002, 1.15, 0, 0, 0.47222],
              "123": [0.65002, 1.15, 0, 0, 0.66667],
              "125": [0.65002, 1.15, 0, 0, 0.66667],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.75, 0, 0, 1],
              "732": [0, 0.75, 0, 0, 1],
              "770": [0, 0.75, 0, 0, 1],
              "771": [0, 0.75, 0, 0, 1],
              "8719": [0.55001, 1.05, 0, 0, 1.27778],
              "8720": [0.55001, 1.05, 0, 0, 1.27778],
              "8721": [0.55001, 1.05, 0, 0, 1.44445],
              "8730": [0.65002, 1.15, 0, 0, 1],
              "8747": [0.86225, 1.36, 0.44445, 0, 0.55556],
              "8748": [0.862, 1.36, 0.44445, 0, 0.55556],
              "8749": [0.862, 1.36, 0.44445, 0, 0.55556],
              "8750": [0.86225, 1.36, 0.44445, 0, 0.55556],
              "8896": [0.55001, 1.05, 0, 0, 1.11111],
              "8897": [0.55001, 1.05, 0, 0, 1.11111],
              "8898": [0.55001, 1.05, 0, 0, 1.11111],
              "8899": [0.55001, 1.05, 0, 0, 1.11111],
              "8968": [0.65002, 1.15, 0, 0, 0.52778],
              "8969": [0.65002, 1.15, 0, 0, 0.52778],
              "8970": [0.65002, 1.15, 0, 0, 0.52778],
              "8971": [0.65002, 1.15, 0, 0, 0.52778],
              "10216": [0.65002, 1.15, 0, 0, 0.61111],
              "10217": [0.65002, 1.15, 0, 0, 0.61111],
              "10752": [0.55001, 1.05, 0, 0, 1.51112],
              "10753": [0.55001, 1.05, 0, 0, 1.51112],
              "10754": [0.55001, 1.05, 0, 0, 1.51112],
              "10756": [0.55001, 1.05, 0, 0, 1.11111],
              "10758": [0.55001, 1.05, 0, 0, 1.11111]
            },
            "Size3-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [0.95003, 1.45, 0, 0, 0.73611],
              "41": [0.95003, 1.45, 0, 0, 0.73611],
              "47": [0.95003, 1.45, 0, 0, 1.04445],
              "91": [0.95003, 1.45, 0, 0, 0.52778],
              "92": [0.95003, 1.45, 0, 0, 1.04445],
              "93": [0.95003, 1.45, 0, 0, 0.52778],
              "123": [0.95003, 1.45, 0, 0, 0.75],
              "125": [0.95003, 1.45, 0, 0, 0.75],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.75, 0, 0, 1.44445],
              "732": [0, 0.75, 0, 0, 1.44445],
              "770": [0, 0.75, 0, 0, 1.44445],
              "771": [0, 0.75, 0, 0, 1.44445],
              "8730": [0.95003, 1.45, 0, 0, 1],
              "8968": [0.95003, 1.45, 0, 0, 0.58334],
              "8969": [0.95003, 1.45, 0, 0, 0.58334],
              "8970": [0.95003, 1.45, 0, 0, 0.58334],
              "8971": [0.95003, 1.45, 0, 0, 0.58334],
              "10216": [0.95003, 1.45, 0, 0, 0.75],
              "10217": [0.95003, 1.45, 0, 0, 0.75]
            },
            "Size4-Regular": {
              "32": [0, 0, 0, 0, 0.25],
              "40": [1.25003, 1.75, 0, 0, 0.79167],
              "41": [1.25003, 1.75, 0, 0, 0.79167],
              "47": [1.25003, 1.75, 0, 0, 1.27778],
              "91": [1.25003, 1.75, 0, 0, 0.58334],
              "92": [1.25003, 1.75, 0, 0, 1.27778],
              "93": [1.25003, 1.75, 0, 0, 0.58334],
              "123": [1.25003, 1.75, 0, 0, 0.80556],
              "125": [1.25003, 1.75, 0, 0, 0.80556],
              "160": [0, 0, 0, 0, 0.25],
              "710": [0, 0.825, 0, 0, 1.8889],
              "732": [0, 0.825, 0, 0, 1.8889],
              "770": [0, 0.825, 0, 0, 1.8889],
              "771": [0, 0.825, 0, 0, 1.8889],
              "8730": [1.25003, 1.75, 0, 0, 1],
              "8968": [1.25003, 1.75, 0, 0, 0.63889],
              "8969": [1.25003, 1.75, 0, 0, 0.63889],
              "8970": [1.25003, 1.75, 0, 0, 0.63889],
              "8971": [1.25003, 1.75, 0, 0, 0.63889],
              "9115": [0.64502, 1.155, 0, 0, 0.875],
              "9116": [1e-5, 0.6, 0, 0, 0.875],
              "9117": [0.64502, 1.155, 0, 0, 0.875],
              "9118": [0.64502, 1.155, 0, 0, 0.875],
              "9119": [1e-5, 0.6, 0, 0, 0.875],
              "9120": [0.64502, 1.155, 0, 0, 0.875],
              "9121": [0.64502, 1.155, 0, 0, 0.66667],
              "9122": [-99e-5, 0.601, 0, 0, 0.66667],
              "9123": [0.64502, 1.155, 0, 0, 0.66667],
              "9124": [0.64502, 1.155, 0, 0, 0.66667],
              "9125": [-99e-5, 0.601, 0, 0, 0.66667],
              "9126": [0.64502, 1.155, 0, 0, 0.66667],
              "9127": [1e-5, 0.9, 0, 0, 0.88889],
              "9128": [0.65002, 1.15, 0, 0, 0.88889],
              "9129": [0.90001, 0, 0, 0, 0.88889],
              "9130": [0, 0.3, 0, 0, 0.88889],
              "9131": [1e-5, 0.9, 0, 0, 0.88889],
              "9132": [0.65002, 1.15, 0, 0, 0.88889],
              "9133": [0.90001, 0, 0, 0, 0.88889],
              "9143": [0.88502, 0.915, 0, 0, 1.05556],
              "10216": [1.25003, 1.75, 0, 0, 0.80556],
              "10217": [1.25003, 1.75, 0, 0, 0.80556],
              "57344": [-499e-5, 0.605, 0, 0, 1.05556],
              "57345": [-499e-5, 0.605, 0, 0, 1.05556],
              "57680": [0, 0.12, 0, 0, 0.45],
              "57681": [0, 0.12, 0, 0, 0.45],
              "57682": [0, 0.12, 0, 0, 0.45],
              "57683": [0, 0.12, 0, 0, 0.45]
            },
            "Typewriter-Regular": {
              "32": [0, 0, 0, 0, 0.525],
              "33": [0, 0.61111, 0, 0, 0.525],
              "34": [0, 0.61111, 0, 0, 0.525],
              "35": [0, 0.61111, 0, 0, 0.525],
              "36": [0.08333, 0.69444, 0, 0, 0.525],
              "37": [0.08333, 0.69444, 0, 0, 0.525],
              "38": [0, 0.61111, 0, 0, 0.525],
              "39": [0, 0.61111, 0, 0, 0.525],
              "40": [0.08333, 0.69444, 0, 0, 0.525],
              "41": [0.08333, 0.69444, 0, 0, 0.525],
              "42": [0, 0.52083, 0, 0, 0.525],
              "43": [-0.08056, 0.53055, 0, 0, 0.525],
              "44": [0.13889, 0.125, 0, 0, 0.525],
              "45": [-0.08056, 0.53055, 0, 0, 0.525],
              "46": [0, 0.125, 0, 0, 0.525],
              "47": [0.08333, 0.69444, 0, 0, 0.525],
              "48": [0, 0.61111, 0, 0, 0.525],
              "49": [0, 0.61111, 0, 0, 0.525],
              "50": [0, 0.61111, 0, 0, 0.525],
              "51": [0, 0.61111, 0, 0, 0.525],
              "52": [0, 0.61111, 0, 0, 0.525],
              "53": [0, 0.61111, 0, 0, 0.525],
              "54": [0, 0.61111, 0, 0, 0.525],
              "55": [0, 0.61111, 0, 0, 0.525],
              "56": [0, 0.61111, 0, 0, 0.525],
              "57": [0, 0.61111, 0, 0, 0.525],
              "58": [0, 0.43056, 0, 0, 0.525],
              "59": [0.13889, 0.43056, 0, 0, 0.525],
              "60": [-0.05556, 0.55556, 0, 0, 0.525],
              "61": [-0.19549, 0.41562, 0, 0, 0.525],
              "62": [-0.05556, 0.55556, 0, 0, 0.525],
              "63": [0, 0.61111, 0, 0, 0.525],
              "64": [0, 0.61111, 0, 0, 0.525],
              "65": [0, 0.61111, 0, 0, 0.525],
              "66": [0, 0.61111, 0, 0, 0.525],
              "67": [0, 0.61111, 0, 0, 0.525],
              "68": [0, 0.61111, 0, 0, 0.525],
              "69": [0, 0.61111, 0, 0, 0.525],
              "70": [0, 0.61111, 0, 0, 0.525],
              "71": [0, 0.61111, 0, 0, 0.525],
              "72": [0, 0.61111, 0, 0, 0.525],
              "73": [0, 0.61111, 0, 0, 0.525],
              "74": [0, 0.61111, 0, 0, 0.525],
              "75": [0, 0.61111, 0, 0, 0.525],
              "76": [0, 0.61111, 0, 0, 0.525],
              "77": [0, 0.61111, 0, 0, 0.525],
              "78": [0, 0.61111, 0, 0, 0.525],
              "79": [0, 0.61111, 0, 0, 0.525],
              "80": [0, 0.61111, 0, 0, 0.525],
              "81": [0.13889, 0.61111, 0, 0, 0.525],
              "82": [0, 0.61111, 0, 0, 0.525],
              "83": [0, 0.61111, 0, 0, 0.525],
              "84": [0, 0.61111, 0, 0, 0.525],
              "85": [0, 0.61111, 0, 0, 0.525],
              "86": [0, 0.61111, 0, 0, 0.525],
              "87": [0, 0.61111, 0, 0, 0.525],
              "88": [0, 0.61111, 0, 0, 0.525],
              "89": [0, 0.61111, 0, 0, 0.525],
              "90": [0, 0.61111, 0, 0, 0.525],
              "91": [0.08333, 0.69444, 0, 0, 0.525],
              "92": [0.08333, 0.69444, 0, 0, 0.525],
              "93": [0.08333, 0.69444, 0, 0, 0.525],
              "94": [0, 0.61111, 0, 0, 0.525],
              "95": [0.09514, 0, 0, 0, 0.525],
              "96": [0, 0.61111, 0, 0, 0.525],
              "97": [0, 0.43056, 0, 0, 0.525],
              "98": [0, 0.61111, 0, 0, 0.525],
              "99": [0, 0.43056, 0, 0, 0.525],
              "100": [0, 0.61111, 0, 0, 0.525],
              "101": [0, 0.43056, 0, 0, 0.525],
              "102": [0, 0.61111, 0, 0, 0.525],
              "103": [0.22222, 0.43056, 0, 0, 0.525],
              "104": [0, 0.61111, 0, 0, 0.525],
              "105": [0, 0.61111, 0, 0, 0.525],
              "106": [0.22222, 0.61111, 0, 0, 0.525],
              "107": [0, 0.61111, 0, 0, 0.525],
              "108": [0, 0.61111, 0, 0, 0.525],
              "109": [0, 0.43056, 0, 0, 0.525],
              "110": [0, 0.43056, 0, 0, 0.525],
              "111": [0, 0.43056, 0, 0, 0.525],
              "112": [0.22222, 0.43056, 0, 0, 0.525],
              "113": [0.22222, 0.43056, 0, 0, 0.525],
              "114": [0, 0.43056, 0, 0, 0.525],
              "115": [0, 0.43056, 0, 0, 0.525],
              "116": [0, 0.55358, 0, 0, 0.525],
              "117": [0, 0.43056, 0, 0, 0.525],
              "118": [0, 0.43056, 0, 0, 0.525],
              "119": [0, 0.43056, 0, 0, 0.525],
              "120": [0, 0.43056, 0, 0, 0.525],
              "121": [0.22222, 0.43056, 0, 0, 0.525],
              "122": [0, 0.43056, 0, 0, 0.525],
              "123": [0.08333, 0.69444, 0, 0, 0.525],
              "124": [0.08333, 0.69444, 0, 0, 0.525],
              "125": [0.08333, 0.69444, 0, 0, 0.525],
              "126": [0, 0.61111, 0, 0, 0.525],
              "127": [0, 0.61111, 0, 0, 0.525],
              "160": [0, 0, 0, 0, 0.525],
              "176": [0, 0.61111, 0, 0, 0.525],
              "184": [0.19445, 0, 0, 0, 0.525],
              "305": [0, 0.43056, 0, 0, 0.525],
              "567": [0.22222, 0.43056, 0, 0, 0.525],
              "711": [0, 0.56597, 0, 0, 0.525],
              "713": [0, 0.56555, 0, 0, 0.525],
              "714": [0, 0.61111, 0, 0, 0.525],
              "715": [0, 0.61111, 0, 0, 0.525],
              "728": [0, 0.61111, 0, 0, 0.525],
              "730": [0, 0.61111, 0, 0, 0.525],
              "770": [0, 0.61111, 0, 0, 0.525],
              "771": [0, 0.61111, 0, 0, 0.525],
              "776": [0, 0.61111, 0, 0, 0.525],
              "915": [0, 0.61111, 0, 0, 0.525],
              "916": [0, 0.61111, 0, 0, 0.525],
              "920": [0, 0.61111, 0, 0, 0.525],
              "923": [0, 0.61111, 0, 0, 0.525],
              "926": [0, 0.61111, 0, 0, 0.525],
              "928": [0, 0.61111, 0, 0, 0.525],
              "931": [0, 0.61111, 0, 0, 0.525],
              "933": [0, 0.61111, 0, 0, 0.525],
              "934": [0, 0.61111, 0, 0, 0.525],
              "936": [0, 0.61111, 0, 0, 0.525],
              "937": [0, 0.61111, 0, 0, 0.525],
              "8216": [0, 0.61111, 0, 0, 0.525],
              "8217": [0, 0.61111, 0, 0, 0.525],
              "8242": [0, 0.61111, 0, 0, 0.525],
              "9251": [0.11111, 0.21944, 0, 0, 0.525]
            }
          };
          const sigmasAndXis = {
            slant: [0.25, 0.25, 0.25],
            // sigma1
            space: [0, 0, 0],
            // sigma2
            stretch: [0, 0, 0],
            // sigma3
            shrink: [0, 0, 0],
            // sigma4
            xHeight: [0.431, 0.431, 0.431],
            // sigma5
            quad: [1, 1.171, 1.472],
            // sigma6
            extraSpace: [0, 0, 0],
            // sigma7
            num1: [0.677, 0.732, 0.925],
            // sigma8
            num2: [0.394, 0.384, 0.387],
            // sigma9
            num3: [0.444, 0.471, 0.504],
            // sigma10
            denom1: [0.686, 0.752, 1.025],
            // sigma11
            denom2: [0.345, 0.344, 0.532],
            // sigma12
            sup1: [0.413, 0.503, 0.504],
            // sigma13
            sup2: [0.363, 0.431, 0.404],
            // sigma14
            sup3: [0.289, 0.286, 0.294],
            // sigma15
            sub1: [0.15, 0.143, 0.2],
            // sigma16
            sub2: [0.247, 0.286, 0.4],
            // sigma17
            supDrop: [0.386, 0.353, 0.494],
            // sigma18
            subDrop: [0.05, 0.071, 0.1],
            // sigma19
            delim1: [2.39, 1.7, 1.98],
            // sigma20
            delim2: [1.01, 1.157, 1.42],
            // sigma21
            axisHeight: [0.25, 0.25, 0.25],
            // sigma22
            // These font metrics are extracted from TeX by using tftopl on cmex10.tfm;
            // they correspond to the font parameters of the extension fonts (family 3).
            // See the TeXbook, page 441. In AMSTeX, the extension fonts scale; to
            // match cmex7, we'd use cmex7.tfm values for script and scriptscript
            // values.
            defaultRuleThickness: [0.04, 0.049, 0.049],
            // xi8; cmex7: 0.049
            bigOpSpacing1: [0.111, 0.111, 0.111],
            // xi9
            bigOpSpacing2: [0.166, 0.166, 0.166],
            // xi10
            bigOpSpacing3: [0.2, 0.2, 0.2],
            // xi11
            bigOpSpacing4: [0.6, 0.611, 0.611],
            // xi12; cmex7: 0.611
            bigOpSpacing5: [0.1, 0.143, 0.143],
            // xi13; cmex7: 0.143
            // The \sqrt rule width is taken from the height of the surd character.
            // Since we use the same font at all sizes, this thickness doesn't scale.
            sqrtRuleThickness: [0.04, 0.04, 0.04],
            // This value determines how large a pt is, for metrics which are defined
            // in terms of pts.
            // This value is also used in katex.scss; if you change it make sure the
            // values match.
            ptPerEm: [10, 10, 10],
            // The space between adjacent `|` columns in an array definition. From
            // `\showthe\doublerulesep` in LaTeX. Equals 2.0 / ptPerEm.
            doubleRuleSep: [0.2, 0.2, 0.2],
            // The width of separator lines in {array} environments. From
            // `\showthe\arrayrulewidth` in LaTeX. Equals 0.4 / ptPerEm.
            arrayRuleWidth: [0.04, 0.04, 0.04],
            // Two values from LaTeX source2e:
            fboxsep: [0.3, 0.3, 0.3],
            //        3 pt / ptPerEm
            fboxrule: [0.04, 0.04, 0.04]
            // 0.4 pt / ptPerEm
          };
          const extraCharacterMap = {
            // Latin-1
            "Å": "A",
            "Ð": "D",
            "Þ": "o",
            "å": "a",
            "ð": "d",
            "þ": "o",
            // Cyrillic
            "А": "A",
            "Б": "B",
            "В": "B",
            "Г": "F",
            "Д": "A",
            "Е": "E",
            "Ж": "K",
            "З": "3",
            "И": "N",
            "Й": "N",
            "К": "K",
            "Л": "N",
            "М": "M",
            "Н": "H",
            "О": "O",
            "П": "N",
            "Р": "P",
            "С": "C",
            "Т": "T",
            "У": "y",
            "Ф": "O",
            "Х": "X",
            "Ц": "U",
            "Ч": "h",
            "Ш": "W",
            "Щ": "W",
            "Ъ": "B",
            "Ы": "X",
            "Ь": "B",
            "Э": "3",
            "Ю": "X",
            "Я": "R",
            "а": "a",
            "б": "b",
            "в": "a",
            "г": "r",
            "д": "y",
            "е": "e",
            "ж": "m",
            "з": "e",
            "и": "n",
            "й": "n",
            "к": "n",
            "л": "n",
            "м": "m",
            "н": "n",
            "о": "o",
            "п": "n",
            "р": "p",
            "с": "c",
            "т": "o",
            "у": "y",
            "ф": "b",
            "х": "x",
            "ц": "n",
            "ч": "n",
            "ш": "w",
            "щ": "w",
            "ъ": "a",
            "ы": "m",
            "ь": "a",
            "э": "e",
            "ю": "m",
            "я": "r"
          };
          function setFontMetrics(fontName, metrics) {
            fontMetricsData[fontName] = metrics;
          }
          function getCharacterMetrics(character, font, mode) {
            if (!fontMetricsData[font]) {
              throw new Error("Font metrics not found for font: " + font + ".");
            }
            let ch2 = character.charCodeAt(0);
            let metrics = fontMetricsData[font][ch2];
            if (!metrics && character[0] in extraCharacterMap) {
              ch2 = extraCharacterMap[character[0]].charCodeAt(0);
              metrics = fontMetricsData[font][ch2];
            }
            if (!metrics && mode === "text") {
              if (supportedCodepoint(ch2)) {
                metrics = fontMetricsData[font][77];
              }
            }
            if (metrics) {
              return {
                depth: metrics[0],
                height: metrics[1],
                italic: metrics[2],
                skew: metrics[3],
                width: metrics[4]
              };
            }
          }
          const fontMetricsBySizeIndex = {};
          function getGlobalMetrics(size2) {
            let sizeIndex;
            if (size2 >= 5) {
              sizeIndex = 0;
            } else if (size2 >= 3) {
              sizeIndex = 1;
            } else {
              sizeIndex = 2;
            }
            if (!fontMetricsBySizeIndex[sizeIndex]) {
              const metrics = fontMetricsBySizeIndex[sizeIndex] = {
                cssEmPerMu: sigmasAndXis.quad[sizeIndex] / 18
              };
              for (const key in sigmasAndXis) {
                if (sigmasAndXis.hasOwnProperty(key)) {
                  metrics[key] = sigmasAndXis[key][sizeIndex];
                }
              }
            }
            return fontMetricsBySizeIndex[sizeIndex];
          }
          const sizeStyleMap = [
            // Each element contains [textsize, scriptsize, scriptscriptsize].
            // The size mappings are taken from TeX with \normalsize=10pt.
            [1, 1, 1],
            // size1: [5, 5, 5]              \tiny
            [2, 1, 1],
            // size2: [6, 5, 5]
            [3, 1, 1],
            // size3: [7, 5, 5]              \scriptsize
            [4, 2, 1],
            // size4: [8, 6, 5]              \footnotesize
            [5, 2, 1],
            // size5: [9, 6, 5]              \small
            [6, 3, 1],
            // size6: [10, 7, 5]             \normalsize
            [7, 4, 2],
            // size7: [12, 8, 6]             \large
            [8, 6, 3],
            // size8: [14.4, 10, 7]          \Large
            [9, 7, 6],
            // size9: [17.28, 12, 10]        \LARGE
            [10, 8, 7],
            // size10: [20.74, 14.4, 12]     \huge
            [11, 10, 9]
            // size11: [24.88, 20.74, 17.28] \HUGE
          ];
          const sizeMultipliers = [
            // fontMetrics.js:getGlobalMetrics also uses size indexes, so if
            // you change size indexes, change that function.
            0.5,
            0.6,
            0.7,
            0.8,
            0.9,
            1,
            1.2,
            1.44,
            1.728,
            2.074,
            2.488
          ];
          const sizeAtStyle = function(size2, style) {
            return style.size < 2 ? size2 : sizeStyleMap[size2 - 1][style.size - 1];
          };
          class Options {
            // A font family applies to a group of fonts (i.e. SansSerif), while a font
            // represents a specific font (i.e. SansSerif Bold).
            // See: https://tex.stackexchange.com/questions/22350/difference-between-textrm-and-mathrm
            /**
             * The base size index.
             */
            constructor(data) {
              this.style = void 0;
              this.color = void 0;
              this.size = void 0;
              this.textSize = void 0;
              this.phantom = void 0;
              this.font = void 0;
              this.fontFamily = void 0;
              this.fontWeight = void 0;
              this.fontShape = void 0;
              this.sizeMultiplier = void 0;
              this.maxSize = void 0;
              this.minRuleThickness = void 0;
              this._fontMetrics = void 0;
              this.style = data.style;
              this.color = data.color;
              this.size = data.size || Options.BASESIZE;
              this.textSize = data.textSize || this.size;
              this.phantom = !!data.phantom;
              this.font = data.font || "";
              this.fontFamily = data.fontFamily || "";
              this.fontWeight = data.fontWeight || "";
              this.fontShape = data.fontShape || "";
              this.sizeMultiplier = sizeMultipliers[this.size - 1];
              this.maxSize = data.maxSize;
              this.minRuleThickness = data.minRuleThickness;
              this._fontMetrics = void 0;
            }
            /**
             * Returns a new options object with the same properties as "this".  Properties
             * from "extension" will be copied to the new options object.
             */
            extend(extension) {
              const data = {
                style: this.style,
                size: this.size,
                textSize: this.textSize,
                color: this.color,
                phantom: this.phantom,
                font: this.font,
                fontFamily: this.fontFamily,
                fontWeight: this.fontWeight,
                fontShape: this.fontShape,
                maxSize: this.maxSize,
                minRuleThickness: this.minRuleThickness
              };
              for (const key in extension) {
                if (extension.hasOwnProperty(key)) {
                  data[key] = extension[key];
                }
              }
              return new Options(data);
            }
            /**
             * Return an options object with the given style. If `this.style === style`,
             * returns `this`.
             */
            havingStyle(style) {
              if (this.style === style) {
                return this;
              } else {
                return this.extend({
                  style,
                  size: sizeAtStyle(this.textSize, style)
                });
              }
            }
            /**
             * Return an options object with a cramped version of the current style. If
             * the current style is cramped, returns `this`.
             */
            havingCrampedStyle() {
              return this.havingStyle(this.style.cramp());
            }
            /**
             * Return an options object with the given size and in at least `\textstyle`.
             * Returns `this` if appropriate.
             */
            havingSize(size2) {
              if (this.size === size2 && this.textSize === size2) {
                return this;
              } else {
                return this.extend({
                  style: this.style.text(),
                  size: size2,
                  textSize: size2,
                  sizeMultiplier: sizeMultipliers[size2 - 1]
                });
              }
            }
            /**
             * Like `this.havingSize(BASESIZE).havingStyle(style)`. If `style` is omitted,
             * changes to at least `\textstyle`.
             */
            havingBaseStyle(style) {
              style = style || this.style.text();
              const wantSize = sizeAtStyle(Options.BASESIZE, style);
              if (this.size === wantSize && this.textSize === Options.BASESIZE && this.style === style) {
                return this;
              } else {
                return this.extend({
                  style,
                  size: wantSize
                });
              }
            }
            /**
             * Remove the effect of sizing changes such as \Huge.
             * Keep the effect of the current style, such as \scriptstyle.
             */
            havingBaseSizing() {
              let size2;
              switch (this.style.id) {
                case 4:
                case 5:
                  size2 = 3;
                  break;
                case 6:
                case 7:
                  size2 = 1;
                  break;
                default:
                  size2 = 6;
              }
              return this.extend({
                style: this.style.text(),
                size: size2
              });
            }
            /**
             * Create a new options object with the given color.
             */
            withColor(color) {
              return this.extend({
                color
              });
            }
            /**
             * Create a new options object with "phantom" set to true.
             */
            withPhantom() {
              return this.extend({
                phantom: true
              });
            }
            /**
             * Creates a new options object with the given math font or old text font.
             * @type {[type]}
             */
            withFont(font) {
              return this.extend({
                font
              });
            }
            /**
             * Create a new options objects with the given fontFamily.
             */
            withTextFontFamily(fontFamily) {
              return this.extend({
                fontFamily,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontWeight(fontWeight) {
              return this.extend({
                fontWeight,
                font: ""
              });
            }
            /**
             * Creates a new options object with the given font weight
             */
            withTextFontShape(fontShape) {
              return this.extend({
                fontShape,
                font: ""
              });
            }
            /**
             * Return the CSS sizing classes required to switch from enclosing options
             * `oldOptions` to `this`. Returns an array of classes.
             */
            sizingClasses(oldOptions) {
              if (oldOptions.size !== this.size) {
                return ["sizing", "reset-size" + oldOptions.size, "size" + this.size];
              } else {
                return [];
              }
            }
            /**
             * Return the CSS sizing classes required to switch to the base size. Like
             * `this.havingSize(BASESIZE).sizingClasses(this)`.
             */
            baseSizingClasses() {
              if (this.size !== Options.BASESIZE) {
                return ["sizing", "reset-size" + this.size, "size" + Options.BASESIZE];
              } else {
                return [];
              }
            }
            /**
             * Return the font metrics for this size.
             */
            fontMetrics() {
              if (!this._fontMetrics) {
                this._fontMetrics = getGlobalMetrics(this.size);
              }
              return this._fontMetrics;
            }
            /**
             * Gets the CSS color of the current options object
             */
            getColor() {
              if (this.phantom) {
                return "transparent";
              } else {
                return this.color;
              }
            }
          }
          Options.BASESIZE = 6;
          var src_Options = Options;
          const ptPerUnit = {
            // https://en.wikibooks.org/wiki/LaTeX/Lengths and
            // https://tex.stackexchange.com/a/8263
            "pt": 1,
            // TeX point
            "mm": 7227 / 2540,
            // millimeter
            "cm": 7227 / 254,
            // centimeter
            "in": 72.27,
            // inch
            "bp": 803 / 800,
            // big (PostScript) points
            "pc": 12,
            // pica
            "dd": 1238 / 1157,
            // didot
            "cc": 14856 / 1157,
            // cicero (12 didot)
            "nd": 685 / 642,
            // new didot
            "nc": 1370 / 107,
            // new cicero (12 new didot)
            "sp": 1 / 65536,
            // scaled point (TeX's internal smallest unit)
            // https://tex.stackexchange.com/a/41371
            "px": 803 / 800
            // \pdfpxdimen defaults to 1 bp in pdfTeX and LuaTeX
          };
          const relativeUnit = {
            "ex": true,
            "em": true,
            "mu": true
          };
          const validUnit = function(unit) {
            if (typeof unit !== "string") {
              unit = unit.unit;
            }
            return unit in ptPerUnit || unit in relativeUnit || unit === "ex";
          };
          const calculateSize = function(sizeValue, options) {
            let scale;
            if (sizeValue.unit in ptPerUnit) {
              scale = ptPerUnit[sizeValue.unit] / options.fontMetrics().ptPerEm / options.sizeMultiplier;
            } else if (sizeValue.unit === "mu") {
              scale = options.fontMetrics().cssEmPerMu;
            } else {
              let unitOptions;
              if (options.style.isTight()) {
                unitOptions = options.havingStyle(options.style.text());
              } else {
                unitOptions = options;
              }
              if (sizeValue.unit === "ex") {
                scale = unitOptions.fontMetrics().xHeight;
              } else if (sizeValue.unit === "em") {
                scale = unitOptions.fontMetrics().quad;
              } else {
                throw new src_ParseError("Invalid unit: '" + sizeValue.unit + "'");
              }
              if (unitOptions !== options) {
                scale *= unitOptions.sizeMultiplier / options.sizeMultiplier;
              }
            }
            return Math.min(sizeValue.number * scale, options.maxSize);
          };
          const makeEm = function(n2) {
            return +n2.toFixed(4) + "em";
          };
          const createClass = function(classes) {
            return classes.filter((cls) => cls).join(" ");
          };
          const initNode = function(classes, options, style) {
            this.classes = classes || [];
            this.attributes = {};
            this.height = 0;
            this.depth = 0;
            this.maxFontSize = 0;
            this.style = style || {};
            if (options) {
              if (options.style.isTight()) {
                this.classes.push("mtight");
              }
              const color = options.getColor();
              if (color) {
                this.style.color = color;
              }
            }
          };
          const toNode = function(tagName) {
            const node = document.createElement(tagName);
            node.className = createClass(this.classes);
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                node.style[style] = this.style[style];
              }
            }
            for (const attr in this.attributes) {
              if (this.attributes.hasOwnProperty(attr)) {
                node.setAttribute(attr, this.attributes[attr]);
              }
            }
            for (let i2 = 0; i2 < this.children.length; i2++) {
              node.appendChild(this.children[i2].toNode());
            }
            return node;
          };
          const toMarkup = function(tagName) {
            let markup = "<" + tagName;
            if (this.classes.length) {
              markup += ' class="' + utils.escape(createClass(this.classes)) + '"';
            }
            let styles2 = "";
            for (const style in this.style) {
              if (this.style.hasOwnProperty(style)) {
                styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
              }
            }
            if (styles2) {
              markup += ' style="' + utils.escape(styles2) + '"';
            }
            for (const attr in this.attributes) {
              if (this.attributes.hasOwnProperty(attr)) {
                markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
              }
            }
            markup += ">";
            for (let i2 = 0; i2 < this.children.length; i2++) {
              markup += this.children[i2].toMarkup();
            }
            markup += "</" + tagName + ">";
            return markup;
          };
          class Span {
            constructor(classes, children, options, style) {
              this.children = void 0;
              this.attributes = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.width = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              initNode.call(this, classes, options, style);
              this.children = children || [];
            }
            /**
             * Sets an arbitrary attribute on the span. Warning: use this wisely. Not
             * all browsers support attributes the same, and having too many custom
             * attributes is probably bad.
             */
            setAttribute(attribute, value) {
              this.attributes[attribute] = value;
            }
            hasClass(className) {
              return utils.contains(this.classes, className);
            }
            toNode() {
              return toNode.call(this, "span");
            }
            toMarkup() {
              return toMarkup.call(this, "span");
            }
          }
          class Anchor2 {
            constructor(href, classes, children, options) {
              this.children = void 0;
              this.attributes = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              initNode.call(this, classes, options);
              this.children = children || [];
              this.setAttribute("href", href);
            }
            setAttribute(attribute, value) {
              this.attributes[attribute] = value;
            }
            hasClass(className) {
              return utils.contains(this.classes, className);
            }
            toNode() {
              return toNode.call(this, "a");
            }
            toMarkup() {
              return toMarkup.call(this, "a");
            }
          }
          class Img {
            constructor(src, alt, style) {
              this.src = void 0;
              this.alt = void 0;
              this.classes = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.maxFontSize = void 0;
              this.style = void 0;
              this.alt = alt;
              this.src = src;
              this.classes = ["mord"];
              this.style = style;
            }
            hasClass(className) {
              return utils.contains(this.classes, className);
            }
            toNode() {
              const node = document.createElement("img");
              node.src = this.src;
              node.alt = this.alt;
              node.className = "mord";
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  node.style[style] = this.style[style];
                }
              }
              return node;
            }
            toMarkup() {
              let markup = '<img src="' + utils.escape(this.src) + '"' + (' alt="' + utils.escape(this.alt) + '"');
              let styles2 = "";
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles2) {
                markup += ' style="' + utils.escape(styles2) + '"';
              }
              markup += "'/>";
              return markup;
            }
          }
          const iCombinations = {
            "î": "ı̂",
            "ï": "ı̈",
            "í": "ı́",
            // 'ī': '\u0131\u0304', // enable when we add Extended Latin
            "ì": "ı̀"
          };
          class SymbolNode {
            constructor(text, height, depth, italic, skew, width, classes, style) {
              this.text = void 0;
              this.height = void 0;
              this.depth = void 0;
              this.italic = void 0;
              this.skew = void 0;
              this.width = void 0;
              this.maxFontSize = void 0;
              this.classes = void 0;
              this.style = void 0;
              this.text = text;
              this.height = height || 0;
              this.depth = depth || 0;
              this.italic = italic || 0;
              this.skew = skew || 0;
              this.width = width || 0;
              this.classes = classes || [];
              this.style = style || {};
              this.maxFontSize = 0;
              const script = scriptFromCodepoint(this.text.charCodeAt(0));
              if (script) {
                this.classes.push(script + "_fallback");
              }
              if (/[îïíì]/.test(this.text)) {
                this.text = iCombinations[this.text];
              }
            }
            hasClass(className) {
              return utils.contains(this.classes, className);
            }
            /**
             * Creates a text node or span from a symbol node. Note that a span is only
             * created if it is needed.
             */
            toNode() {
              const node = document.createTextNode(this.text);
              let span = null;
              if (this.italic > 0) {
                span = document.createElement("span");
                span.style.marginRight = makeEm(this.italic);
              }
              if (this.classes.length > 0) {
                span = span || document.createElement("span");
                span.className = createClass(this.classes);
              }
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  span = span || document.createElement("span");
                  span.style[style] = this.style[style];
                }
              }
              if (span) {
                span.appendChild(node);
                return span;
              } else {
                return node;
              }
            }
            /**
             * Creates markup for a symbol node.
             */
            toMarkup() {
              let needsSpan = false;
              let markup = "<span";
              if (this.classes.length) {
                needsSpan = true;
                markup += ' class="';
                markup += utils.escape(createClass(this.classes));
                markup += '"';
              }
              let styles2 = "";
              if (this.italic > 0) {
                styles2 += "margin-right:" + this.italic + "em;";
              }
              for (const style in this.style) {
                if (this.style.hasOwnProperty(style)) {
                  styles2 += utils.hyphenate(style) + ":" + this.style[style] + ";";
                }
              }
              if (styles2) {
                needsSpan = true;
                markup += ' style="' + utils.escape(styles2) + '"';
              }
              const escaped = utils.escape(this.text);
              if (needsSpan) {
                markup += ">";
                markup += escaped;
                markup += "</span>";
                return markup;
              } else {
                return escaped;
              }
            }
          }
          class SvgNode {
            constructor(children, attributes) {
              this.children = void 0;
              this.attributes = void 0;
              this.children = children || [];
              this.attributes = attributes || {};
            }
            toNode() {
              const svgNS = "http://www.w3.org/2000/svg";
              const node = document.createElementNS(svgNS, "svg");
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  node.setAttribute(attr, this.attributes[attr]);
                }
              }
              for (let i2 = 0; i2 < this.children.length; i2++) {
                node.appendChild(this.children[i2].toNode());
              }
              return node;
            }
            toMarkup() {
              let markup = '<svg xmlns="http://www.w3.org/2000/svg"';
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
                }
              }
              markup += ">";
              for (let i2 = 0; i2 < this.children.length; i2++) {
                markup += this.children[i2].toMarkup();
              }
              markup += "</svg>";
              return markup;
            }
          }
          class PathNode {
            constructor(pathName, alternate) {
              this.pathName = void 0;
              this.alternate = void 0;
              this.pathName = pathName;
              this.alternate = alternate;
            }
            toNode() {
              const svgNS = "http://www.w3.org/2000/svg";
              const node = document.createElementNS(svgNS, "path");
              if (this.alternate) {
                node.setAttribute("d", this.alternate);
              } else {
                node.setAttribute("d", path2[this.pathName]);
              }
              return node;
            }
            toMarkup() {
              if (this.alternate) {
                return '<path d="' + utils.escape(this.alternate) + '"/>';
              } else {
                return '<path d="' + utils.escape(path2[this.pathName]) + '"/>';
              }
            }
          }
          class LineNode {
            constructor(attributes) {
              this.attributes = void 0;
              this.attributes = attributes || {};
            }
            toNode() {
              const svgNS = "http://www.w3.org/2000/svg";
              const node = document.createElementNS(svgNS, "line");
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  node.setAttribute(attr, this.attributes[attr]);
                }
              }
              return node;
            }
            toMarkup() {
              let markup = "<line";
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  markup += " " + attr + '="' + utils.escape(this.attributes[attr]) + '"';
                }
              }
              markup += "/>";
              return markup;
            }
          }
          function assertSymbolDomNode(group) {
            if (group instanceof SymbolNode) {
              return group;
            } else {
              throw new Error("Expected symbolNode but got " + String(group) + ".");
            }
          }
          function assertSpan(group) {
            if (group instanceof Span) {
              return group;
            } else {
              throw new Error("Expected span<HtmlDomNode> but got " + String(group) + ".");
            }
          }
          const ATOMS = {
            "bin": 1,
            "close": 1,
            "inner": 1,
            "open": 1,
            "punct": 1,
            "rel": 1
          };
          const NON_ATOMS = {
            "accent-token": 1,
            "mathord": 1,
            "op-token": 1,
            "spacing": 1,
            "textord": 1
          };
          const symbols = {
            "math": {},
            "text": {}
          };
          var src_symbols = symbols;
          function defineSymbol(mode, font, group, replace, name, acceptUnicodeChar) {
            symbols[mode][name] = {
              font,
              group,
              replace
            };
            if (acceptUnicodeChar && replace) {
              symbols[mode][replace] = symbols[mode][name];
            }
          }
          const math = "math";
          const symbols_text = "text";
          const main = "main";
          const ams = "ams";
          const accent = "accent-token";
          const bin = "bin";
          const symbols_close = "close";
          const inner = "inner";
          const mathord = "mathord";
          const op = "op-token";
          const symbols_open = "open";
          const punct = "punct";
          const rel = "rel";
          const spacing = "spacing";
          const textord = "textord";
          defineSymbol(math, main, rel, "≡", "\\equiv", true);
          defineSymbol(math, main, rel, "≺", "\\prec", true);
          defineSymbol(math, main, rel, "≻", "\\succ", true);
          defineSymbol(math, main, rel, "∼", "\\sim", true);
          defineSymbol(math, main, rel, "⊥", "\\perp");
          defineSymbol(math, main, rel, "⪯", "\\preceq", true);
          defineSymbol(math, main, rel, "⪰", "\\succeq", true);
          defineSymbol(math, main, rel, "≃", "\\simeq", true);
          defineSymbol(math, main, rel, "∣", "\\mid", true);
          defineSymbol(math, main, rel, "≪", "\\ll", true);
          defineSymbol(math, main, rel, "≫", "\\gg", true);
          defineSymbol(math, main, rel, "≍", "\\asymp", true);
          defineSymbol(math, main, rel, "∥", "\\parallel");
          defineSymbol(math, main, rel, "⋈", "\\bowtie", true);
          defineSymbol(math, main, rel, "⌣", "\\smile", true);
          defineSymbol(math, main, rel, "⊑", "\\sqsubseteq", true);
          defineSymbol(math, main, rel, "⊒", "\\sqsupseteq", true);
          defineSymbol(math, main, rel, "≐", "\\doteq", true);
          defineSymbol(math, main, rel, "⌢", "\\frown", true);
          defineSymbol(math, main, rel, "∋", "\\ni", true);
          defineSymbol(math, main, rel, "∝", "\\propto", true);
          defineSymbol(math, main, rel, "⊢", "\\vdash", true);
          defineSymbol(math, main, rel, "⊣", "\\dashv", true);
          defineSymbol(math, main, rel, "∋", "\\owns");
          defineSymbol(math, main, punct, ".", "\\ldotp");
          defineSymbol(math, main, punct, "⋅", "\\cdotp");
          defineSymbol(math, main, textord, "#", "\\#");
          defineSymbol(symbols_text, main, textord, "#", "\\#");
          defineSymbol(math, main, textord, "&", "\\&");
          defineSymbol(symbols_text, main, textord, "&", "\\&");
          defineSymbol(math, main, textord, "ℵ", "\\aleph", true);
          defineSymbol(math, main, textord, "∀", "\\forall", true);
          defineSymbol(math, main, textord, "ℏ", "\\hbar", true);
          defineSymbol(math, main, textord, "∃", "\\exists", true);
          defineSymbol(math, main, textord, "∇", "\\nabla", true);
          defineSymbol(math, main, textord, "♭", "\\flat", true);
          defineSymbol(math, main, textord, "ℓ", "\\ell", true);
          defineSymbol(math, main, textord, "♮", "\\natural", true);
          defineSymbol(math, main, textord, "♣", "\\clubsuit", true);
          defineSymbol(math, main, textord, "℘", "\\wp", true);
          defineSymbol(math, main, textord, "♯", "\\sharp", true);
          defineSymbol(math, main, textord, "♢", "\\diamondsuit", true);
          defineSymbol(math, main, textord, "ℜ", "\\Re", true);
          defineSymbol(math, main, textord, "♡", "\\heartsuit", true);
          defineSymbol(math, main, textord, "ℑ", "\\Im", true);
          defineSymbol(math, main, textord, "♠", "\\spadesuit", true);
          defineSymbol(math, main, textord, "§", "\\S", true);
          defineSymbol(symbols_text, main, textord, "§", "\\S");
          defineSymbol(math, main, textord, "¶", "\\P", true);
          defineSymbol(symbols_text, main, textord, "¶", "\\P");
          defineSymbol(math, main, textord, "†", "\\dag");
          defineSymbol(symbols_text, main, textord, "†", "\\dag");
          defineSymbol(symbols_text, main, textord, "†", "\\textdagger");
          defineSymbol(math, main, textord, "‡", "\\ddag");
          defineSymbol(symbols_text, main, textord, "‡", "\\ddag");
          defineSymbol(symbols_text, main, textord, "‡", "\\textdaggerdbl");
          defineSymbol(math, main, symbols_close, "⎱", "\\rmoustache", true);
          defineSymbol(math, main, symbols_open, "⎰", "\\lmoustache", true);
          defineSymbol(math, main, symbols_close, "⟯", "\\rgroup", true);
          defineSymbol(math, main, symbols_open, "⟮", "\\lgroup", true);
          defineSymbol(math, main, bin, "∓", "\\mp", true);
          defineSymbol(math, main, bin, "⊖", "\\ominus", true);
          defineSymbol(math, main, bin, "⊎", "\\uplus", true);
          defineSymbol(math, main, bin, "⊓", "\\sqcap", true);
          defineSymbol(math, main, bin, "∗", "\\ast");
          defineSymbol(math, main, bin, "⊔", "\\sqcup", true);
          defineSymbol(math, main, bin, "◯", "\\bigcirc", true);
          defineSymbol(math, main, bin, "∙", "\\bullet", true);
          defineSymbol(math, main, bin, "‡", "\\ddagger");
          defineSymbol(math, main, bin, "≀", "\\wr", true);
          defineSymbol(math, main, bin, "⨿", "\\amalg");
          defineSymbol(math, main, bin, "&", "\\And");
          defineSymbol(math, main, rel, "⟵", "\\longleftarrow", true);
          defineSymbol(math, main, rel, "⇐", "\\Leftarrow", true);
          defineSymbol(math, main, rel, "⟸", "\\Longleftarrow", true);
          defineSymbol(math, main, rel, "⟶", "\\longrightarrow", true);
          defineSymbol(math, main, rel, "⇒", "\\Rightarrow", true);
          defineSymbol(math, main, rel, "⟹", "\\Longrightarrow", true);
          defineSymbol(math, main, rel, "↔", "\\leftrightarrow", true);
          defineSymbol(math, main, rel, "⟷", "\\longleftrightarrow", true);
          defineSymbol(math, main, rel, "⇔", "\\Leftrightarrow", true);
          defineSymbol(math, main, rel, "⟺", "\\Longleftrightarrow", true);
          defineSymbol(math, main, rel, "↦", "\\mapsto", true);
          defineSymbol(math, main, rel, "⟼", "\\longmapsto", true);
          defineSymbol(math, main, rel, "↗", "\\nearrow", true);
          defineSymbol(math, main, rel, "↩", "\\hookleftarrow", true);
          defineSymbol(math, main, rel, "↪", "\\hookrightarrow", true);
          defineSymbol(math, main, rel, "↘", "\\searrow", true);
          defineSymbol(math, main, rel, "↼", "\\leftharpoonup", true);
          defineSymbol(math, main, rel, "⇀", "\\rightharpoonup", true);
          defineSymbol(math, main, rel, "↙", "\\swarrow", true);
          defineSymbol(math, main, rel, "↽", "\\leftharpoondown", true);
          defineSymbol(math, main, rel, "⇁", "\\rightharpoondown", true);
          defineSymbol(math, main, rel, "↖", "\\nwarrow", true);
          defineSymbol(math, main, rel, "⇌", "\\rightleftharpoons", true);
          defineSymbol(math, ams, rel, "≮", "\\nless", true);
          defineSymbol(math, ams, rel, "", "\\@nleqslant");
          defineSymbol(math, ams, rel, "", "\\@nleqq");
          defineSymbol(math, ams, rel, "⪇", "\\lneq", true);
          defineSymbol(math, ams, rel, "≨", "\\lneqq", true);
          defineSymbol(math, ams, rel, "", "\\@lvertneqq");
          defineSymbol(math, ams, rel, "⋦", "\\lnsim", true);
          defineSymbol(math, ams, rel, "⪉", "\\lnapprox", true);
          defineSymbol(math, ams, rel, "⊀", "\\nprec", true);
          defineSymbol(math, ams, rel, "⋠", "\\npreceq", true);
          defineSymbol(math, ams, rel, "⋨", "\\precnsim", true);
          defineSymbol(math, ams, rel, "⪹", "\\precnapprox", true);
          defineSymbol(math, ams, rel, "≁", "\\nsim", true);
          defineSymbol(math, ams, rel, "", "\\@nshortmid");
          defineSymbol(math, ams, rel, "∤", "\\nmid", true);
          defineSymbol(math, ams, rel, "⊬", "\\nvdash", true);
          defineSymbol(math, ams, rel, "⊭", "\\nvDash", true);
          defineSymbol(math, ams, rel, "⋪", "\\ntriangleleft");
          defineSymbol(math, ams, rel, "⋬", "\\ntrianglelefteq", true);
          defineSymbol(math, ams, rel, "⊊", "\\subsetneq", true);
          defineSymbol(math, ams, rel, "", "\\@varsubsetneq");
          defineSymbol(math, ams, rel, "⫋", "\\subsetneqq", true);
          defineSymbol(math, ams, rel, "", "\\@varsubsetneqq");
          defineSymbol(math, ams, rel, "≯", "\\ngtr", true);
          defineSymbol(math, ams, rel, "", "\\@ngeqslant");
          defineSymbol(math, ams, rel, "", "\\@ngeqq");
          defineSymbol(math, ams, rel, "⪈", "\\gneq", true);
          defineSymbol(math, ams, rel, "≩", "\\gneqq", true);
          defineSymbol(math, ams, rel, "", "\\@gvertneqq");
          defineSymbol(math, ams, rel, "⋧", "\\gnsim", true);
          defineSymbol(math, ams, rel, "⪊", "\\gnapprox", true);
          defineSymbol(math, ams, rel, "⊁", "\\nsucc", true);
          defineSymbol(math, ams, rel, "⋡", "\\nsucceq", true);
          defineSymbol(math, ams, rel, "⋩", "\\succnsim", true);
          defineSymbol(math, ams, rel, "⪺", "\\succnapprox", true);
          defineSymbol(math, ams, rel, "≆", "\\ncong", true);
          defineSymbol(math, ams, rel, "", "\\@nshortparallel");
          defineSymbol(math, ams, rel, "∦", "\\nparallel", true);
          defineSymbol(math, ams, rel, "⊯", "\\nVDash", true);
          defineSymbol(math, ams, rel, "⋫", "\\ntriangleright");
          defineSymbol(math, ams, rel, "⋭", "\\ntrianglerighteq", true);
          defineSymbol(math, ams, rel, "", "\\@nsupseteqq");
          defineSymbol(math, ams, rel, "⊋", "\\supsetneq", true);
          defineSymbol(math, ams, rel, "", "\\@varsupsetneq");
          defineSymbol(math, ams, rel, "⫌", "\\supsetneqq", true);
          defineSymbol(math, ams, rel, "", "\\@varsupsetneqq");
          defineSymbol(math, ams, rel, "⊮", "\\nVdash", true);
          defineSymbol(math, ams, rel, "⪵", "\\precneqq", true);
          defineSymbol(math, ams, rel, "⪶", "\\succneqq", true);
          defineSymbol(math, ams, rel, "", "\\@nsubseteqq");
          defineSymbol(math, ams, bin, "⊴", "\\unlhd");
          defineSymbol(math, ams, bin, "⊵", "\\unrhd");
          defineSymbol(math, ams, rel, "↚", "\\nleftarrow", true);
          defineSymbol(math, ams, rel, "↛", "\\nrightarrow", true);
          defineSymbol(math, ams, rel, "⇍", "\\nLeftarrow", true);
          defineSymbol(math, ams, rel, "⇏", "\\nRightarrow", true);
          defineSymbol(math, ams, rel, "↮", "\\nleftrightarrow", true);
          defineSymbol(math, ams, rel, "⇎", "\\nLeftrightarrow", true);
          defineSymbol(math, ams, rel, "△", "\\vartriangle");
          defineSymbol(math, ams, textord, "ℏ", "\\hslash");
          defineSymbol(math, ams, textord, "▽", "\\triangledown");
          defineSymbol(math, ams, textord, "◊", "\\lozenge");
          defineSymbol(math, ams, textord, "Ⓢ", "\\circledS");
          defineSymbol(math, ams, textord, "®", "\\circledR");
          defineSymbol(symbols_text, ams, textord, "®", "\\circledR");
          defineSymbol(math, ams, textord, "∡", "\\measuredangle", true);
          defineSymbol(math, ams, textord, "∄", "\\nexists");
          defineSymbol(math, ams, textord, "℧", "\\mho");
          defineSymbol(math, ams, textord, "Ⅎ", "\\Finv", true);
          defineSymbol(math, ams, textord, "⅁", "\\Game", true);
          defineSymbol(math, ams, textord, "‵", "\\backprime");
          defineSymbol(math, ams, textord, "▲", "\\blacktriangle");
          defineSymbol(math, ams, textord, "▼", "\\blacktriangledown");
          defineSymbol(math, ams, textord, "■", "\\blacksquare");
          defineSymbol(math, ams, textord, "⧫", "\\blacklozenge");
          defineSymbol(math, ams, textord, "★", "\\bigstar");
          defineSymbol(math, ams, textord, "∢", "\\sphericalangle", true);
          defineSymbol(math, ams, textord, "∁", "\\complement", true);
          defineSymbol(math, ams, textord, "ð", "\\eth", true);
          defineSymbol(symbols_text, main, textord, "ð", "ð");
          defineSymbol(math, ams, textord, "╱", "\\diagup");
          defineSymbol(math, ams, textord, "╲", "\\diagdown");
          defineSymbol(math, ams, textord, "□", "\\square");
          defineSymbol(math, ams, textord, "□", "\\Box");
          defineSymbol(math, ams, textord, "◊", "\\Diamond");
          defineSymbol(math, ams, textord, "¥", "\\yen", true);
          defineSymbol(symbols_text, ams, textord, "¥", "\\yen", true);
          defineSymbol(math, ams, textord, "✓", "\\checkmark", true);
          defineSymbol(symbols_text, ams, textord, "✓", "\\checkmark");
          defineSymbol(math, ams, textord, "ℶ", "\\beth", true);
          defineSymbol(math, ams, textord, "ℸ", "\\daleth", true);
          defineSymbol(math, ams, textord, "ℷ", "\\gimel", true);
          defineSymbol(math, ams, textord, "ϝ", "\\digamma", true);
          defineSymbol(math, ams, textord, "ϰ", "\\varkappa");
          defineSymbol(math, ams, symbols_open, "┌", "\\@ulcorner", true);
          defineSymbol(math, ams, symbols_close, "┐", "\\@urcorner", true);
          defineSymbol(math, ams, symbols_open, "└", "\\@llcorner", true);
          defineSymbol(math, ams, symbols_close, "┘", "\\@lrcorner", true);
          defineSymbol(math, ams, rel, "≦", "\\leqq", true);
          defineSymbol(math, ams, rel, "⩽", "\\leqslant", true);
          defineSymbol(math, ams, rel, "⪕", "\\eqslantless", true);
          defineSymbol(math, ams, rel, "≲", "\\lesssim", true);
          defineSymbol(math, ams, rel, "⪅", "\\lessapprox", true);
          defineSymbol(math, ams, rel, "≊", "\\approxeq", true);
          defineSymbol(math, ams, bin, "⋖", "\\lessdot");
          defineSymbol(math, ams, rel, "⋘", "\\lll", true);
          defineSymbol(math, ams, rel, "≶", "\\lessgtr", true);
          defineSymbol(math, ams, rel, "⋚", "\\lesseqgtr", true);
          defineSymbol(math, ams, rel, "⪋", "\\lesseqqgtr", true);
          defineSymbol(math, ams, rel, "≑", "\\doteqdot");
          defineSymbol(math, ams, rel, "≓", "\\risingdotseq", true);
          defineSymbol(math, ams, rel, "≒", "\\fallingdotseq", true);
          defineSymbol(math, ams, rel, "∽", "\\backsim", true);
          defineSymbol(math, ams, rel, "⋍", "\\backsimeq", true);
          defineSymbol(math, ams, rel, "⫅", "\\subseteqq", true);
          defineSymbol(math, ams, rel, "⋐", "\\Subset", true);
          defineSymbol(math, ams, rel, "⊏", "\\sqsubset", true);
          defineSymbol(math, ams, rel, "≼", "\\preccurlyeq", true);
          defineSymbol(math, ams, rel, "⋞", "\\curlyeqprec", true);
          defineSymbol(math, ams, rel, "≾", "\\precsim", true);
          defineSymbol(math, ams, rel, "⪷", "\\precapprox", true);
          defineSymbol(math, ams, rel, "⊲", "\\vartriangleleft");
          defineSymbol(math, ams, rel, "⊴", "\\trianglelefteq");
          defineSymbol(math, ams, rel, "⊨", "\\vDash", true);
          defineSymbol(math, ams, rel, "⊪", "\\Vvdash", true);
          defineSymbol(math, ams, rel, "⌣", "\\smallsmile");
          defineSymbol(math, ams, rel, "⌢", "\\smallfrown");
          defineSymbol(math, ams, rel, "≏", "\\bumpeq", true);
          defineSymbol(math, ams, rel, "≎", "\\Bumpeq", true);
          defineSymbol(math, ams, rel, "≧", "\\geqq", true);
          defineSymbol(math, ams, rel, "⩾", "\\geqslant", true);
          defineSymbol(math, ams, rel, "⪖", "\\eqslantgtr", true);
          defineSymbol(math, ams, rel, "≳", "\\gtrsim", true);
          defineSymbol(math, ams, rel, "⪆", "\\gtrapprox", true);
          defineSymbol(math, ams, bin, "⋗", "\\gtrdot");
          defineSymbol(math, ams, rel, "⋙", "\\ggg", true);
          defineSymbol(math, ams, rel, "≷", "\\gtrless", true);
          defineSymbol(math, ams, rel, "⋛", "\\gtreqless", true);
          defineSymbol(math, ams, rel, "⪌", "\\gtreqqless", true);
          defineSymbol(math, ams, rel, "≖", "\\eqcirc", true);
          defineSymbol(math, ams, rel, "≗", "\\circeq", true);
          defineSymbol(math, ams, rel, "≜", "\\triangleq", true);
          defineSymbol(math, ams, rel, "∼", "\\thicksim");
          defineSymbol(math, ams, rel, "≈", "\\thickapprox");
          defineSymbol(math, ams, rel, "⫆", "\\supseteqq", true);
          defineSymbol(math, ams, rel, "⋑", "\\Supset", true);
          defineSymbol(math, ams, rel, "⊐", "\\sqsupset", true);
          defineSymbol(math, ams, rel, "≽", "\\succcurlyeq", true);
          defineSymbol(math, ams, rel, "⋟", "\\curlyeqsucc", true);
          defineSymbol(math, ams, rel, "≿", "\\succsim", true);
          defineSymbol(math, ams, rel, "⪸", "\\succapprox", true);
          defineSymbol(math, ams, rel, "⊳", "\\vartriangleright");
          defineSymbol(math, ams, rel, "⊵", "\\trianglerighteq");
          defineSymbol(math, ams, rel, "⊩", "\\Vdash", true);
          defineSymbol(math, ams, rel, "∣", "\\shortmid");
          defineSymbol(math, ams, rel, "∥", "\\shortparallel");
          defineSymbol(math, ams, rel, "≬", "\\between", true);
          defineSymbol(math, ams, rel, "⋔", "\\pitchfork", true);
          defineSymbol(math, ams, rel, "∝", "\\varpropto");
          defineSymbol(math, ams, rel, "◀", "\\blacktriangleleft");
          defineSymbol(math, ams, rel, "∴", "\\therefore", true);
          defineSymbol(math, ams, rel, "∍", "\\backepsilon");
          defineSymbol(math, ams, rel, "▶", "\\blacktriangleright");
          defineSymbol(math, ams, rel, "∵", "\\because", true);
          defineSymbol(math, ams, rel, "⋘", "\\llless");
          defineSymbol(math, ams, rel, "⋙", "\\gggtr");
          defineSymbol(math, ams, bin, "⊲", "\\lhd");
          defineSymbol(math, ams, bin, "⊳", "\\rhd");
          defineSymbol(math, ams, rel, "≂", "\\eqsim", true);
          defineSymbol(math, main, rel, "⋈", "\\Join");
          defineSymbol(math, ams, rel, "≑", "\\Doteq", true);
          defineSymbol(math, ams, bin, "∔", "\\dotplus", true);
          defineSymbol(math, ams, bin, "∖", "\\smallsetminus");
          defineSymbol(math, ams, bin, "⋒", "\\Cap", true);
          defineSymbol(math, ams, bin, "⋓", "\\Cup", true);
          defineSymbol(math, ams, bin, "⩞", "\\doublebarwedge", true);
          defineSymbol(math, ams, bin, "⊟", "\\boxminus", true);
          defineSymbol(math, ams, bin, "⊞", "\\boxplus", true);
          defineSymbol(math, ams, bin, "⋇", "\\divideontimes", true);
          defineSymbol(math, ams, bin, "⋉", "\\ltimes", true);
          defineSymbol(math, ams, bin, "⋊", "\\rtimes", true);
          defineSymbol(math, ams, bin, "⋋", "\\leftthreetimes", true);
          defineSymbol(math, ams, bin, "⋌", "\\rightthreetimes", true);
          defineSymbol(math, ams, bin, "⋏", "\\curlywedge", true);
          defineSymbol(math, ams, bin, "⋎", "\\curlyvee", true);
          defineSymbol(math, ams, bin, "⊝", "\\circleddash", true);
          defineSymbol(math, ams, bin, "⊛", "\\circledast", true);
          defineSymbol(math, ams, bin, "⋅", "\\centerdot");
          defineSymbol(math, ams, bin, "⊺", "\\intercal", true);
          defineSymbol(math, ams, bin, "⋒", "\\doublecap");
          defineSymbol(math, ams, bin, "⋓", "\\doublecup");
          defineSymbol(math, ams, bin, "⊠", "\\boxtimes", true);
          defineSymbol(math, ams, rel, "⇢", "\\dashrightarrow", true);
          defineSymbol(math, ams, rel, "⇠", "\\dashleftarrow", true);
          defineSymbol(math, ams, rel, "⇇", "\\leftleftarrows", true);
          defineSymbol(math, ams, rel, "⇆", "\\leftrightarrows", true);
          defineSymbol(math, ams, rel, "⇚", "\\Lleftarrow", true);
          defineSymbol(math, ams, rel, "↞", "\\twoheadleftarrow", true);
          defineSymbol(math, ams, rel, "↢", "\\leftarrowtail", true);
          defineSymbol(math, ams, rel, "↫", "\\looparrowleft", true);
          defineSymbol(math, ams, rel, "⇋", "\\leftrightharpoons", true);
          defineSymbol(math, ams, rel, "↶", "\\curvearrowleft", true);
          defineSymbol(math, ams, rel, "↺", "\\circlearrowleft", true);
          defineSymbol(math, ams, rel, "↰", "\\Lsh", true);
          defineSymbol(math, ams, rel, "⇈", "\\upuparrows", true);
          defineSymbol(math, ams, rel, "↿", "\\upharpoonleft", true);
          defineSymbol(math, ams, rel, "⇃", "\\downharpoonleft", true);
          defineSymbol(math, main, rel, "⊶", "\\origof", true);
          defineSymbol(math, main, rel, "⊷", "\\imageof", true);
          defineSymbol(math, ams, rel, "⊸", "\\multimap", true);
          defineSymbol(math, ams, rel, "↭", "\\leftrightsquigarrow", true);
          defineSymbol(math, ams, rel, "⇉", "\\rightrightarrows", true);
          defineSymbol(math, ams, rel, "⇄", "\\rightleftarrows", true);
          defineSymbol(math, ams, rel, "↠", "\\twoheadrightarrow", true);
          defineSymbol(math, ams, rel, "↣", "\\rightarrowtail", true);
          defineSymbol(math, ams, rel, "↬", "\\looparrowright", true);
          defineSymbol(math, ams, rel, "↷", "\\curvearrowright", true);
          defineSymbol(math, ams, rel, "↻", "\\circlearrowright", true);
          defineSymbol(math, ams, rel, "↱", "\\Rsh", true);
          defineSymbol(math, ams, rel, "⇊", "\\downdownarrows", true);
          defineSymbol(math, ams, rel, "↾", "\\upharpoonright", true);
          defineSymbol(math, ams, rel, "⇂", "\\downharpoonright", true);
          defineSymbol(math, ams, rel, "⇝", "\\rightsquigarrow", true);
          defineSymbol(math, ams, rel, "⇝", "\\leadsto");
          defineSymbol(math, ams, rel, "⇛", "\\Rrightarrow", true);
          defineSymbol(math, ams, rel, "↾", "\\restriction");
          defineSymbol(math, main, textord, "‘", "`");
          defineSymbol(math, main, textord, "$", "\\$");
          defineSymbol(symbols_text, main, textord, "$", "\\$");
          defineSymbol(symbols_text, main, textord, "$", "\\textdollar");
          defineSymbol(math, main, textord, "%", "\\%");
          defineSymbol(symbols_text, main, textord, "%", "\\%");
          defineSymbol(math, main, textord, "_", "\\_");
          defineSymbol(symbols_text, main, textord, "_", "\\_");
          defineSymbol(symbols_text, main, textord, "_", "\\textunderscore");
          defineSymbol(math, main, textord, "∠", "\\angle", true);
          defineSymbol(math, main, textord, "∞", "\\infty", true);
          defineSymbol(math, main, textord, "′", "\\prime");
          defineSymbol(math, main, textord, "△", "\\triangle");
          defineSymbol(math, main, textord, "Γ", "\\Gamma", true);
          defineSymbol(math, main, textord, "Δ", "\\Delta", true);
          defineSymbol(math, main, textord, "Θ", "\\Theta", true);
          defineSymbol(math, main, textord, "Λ", "\\Lambda", true);
          defineSymbol(math, main, textord, "Ξ", "\\Xi", true);
          defineSymbol(math, main, textord, "Π", "\\Pi", true);
          defineSymbol(math, main, textord, "Σ", "\\Sigma", true);
          defineSymbol(math, main, textord, "Υ", "\\Upsilon", true);
          defineSymbol(math, main, textord, "Φ", "\\Phi", true);
          defineSymbol(math, main, textord, "Ψ", "\\Psi", true);
          defineSymbol(math, main, textord, "Ω", "\\Omega", true);
          defineSymbol(math, main, textord, "A", "Α");
          defineSymbol(math, main, textord, "B", "Β");
          defineSymbol(math, main, textord, "E", "Ε");
          defineSymbol(math, main, textord, "Z", "Ζ");
          defineSymbol(math, main, textord, "H", "Η");
          defineSymbol(math, main, textord, "I", "Ι");
          defineSymbol(math, main, textord, "K", "Κ");
          defineSymbol(math, main, textord, "M", "Μ");
          defineSymbol(math, main, textord, "N", "Ν");
          defineSymbol(math, main, textord, "O", "Ο");
          defineSymbol(math, main, textord, "P", "Ρ");
          defineSymbol(math, main, textord, "T", "Τ");
          defineSymbol(math, main, textord, "X", "Χ");
          defineSymbol(math, main, textord, "¬", "\\neg", true);
          defineSymbol(math, main, textord, "¬", "\\lnot");
          defineSymbol(math, main, textord, "⊤", "\\top");
          defineSymbol(math, main, textord, "⊥", "\\bot");
          defineSymbol(math, main, textord, "∅", "\\emptyset");
          defineSymbol(math, ams, textord, "∅", "\\varnothing");
          defineSymbol(math, main, mathord, "α", "\\alpha", true);
          defineSymbol(math, main, mathord, "β", "\\beta", true);
          defineSymbol(math, main, mathord, "γ", "\\gamma", true);
          defineSymbol(math, main, mathord, "δ", "\\delta", true);
          defineSymbol(math, main, mathord, "ϵ", "\\epsilon", true);
          defineSymbol(math, main, mathord, "ζ", "\\zeta", true);
          defineSymbol(math, main, mathord, "η", "\\eta", true);
          defineSymbol(math, main, mathord, "θ", "\\theta", true);
          defineSymbol(math, main, mathord, "ι", "\\iota", true);
          defineSymbol(math, main, mathord, "κ", "\\kappa", true);
          defineSymbol(math, main, mathord, "λ", "\\lambda", true);
          defineSymbol(math, main, mathord, "μ", "\\mu", true);
          defineSymbol(math, main, mathord, "ν", "\\nu", true);
          defineSymbol(math, main, mathord, "ξ", "\\xi", true);
          defineSymbol(math, main, mathord, "ο", "\\omicron", true);
          defineSymbol(math, main, mathord, "π", "\\pi", true);
          defineSymbol(math, main, mathord, "ρ", "\\rho", true);
          defineSymbol(math, main, mathord, "σ", "\\sigma", true);
          defineSymbol(math, main, mathord, "τ", "\\tau", true);
          defineSymbol(math, main, mathord, "υ", "\\upsilon", true);
          defineSymbol(math, main, mathord, "ϕ", "\\phi", true);
          defineSymbol(math, main, mathord, "χ", "\\chi", true);
          defineSymbol(math, main, mathord, "ψ", "\\psi", true);
          defineSymbol(math, main, mathord, "ω", "\\omega", true);
          defineSymbol(math, main, mathord, "ε", "\\varepsilon", true);
          defineSymbol(math, main, mathord, "ϑ", "\\vartheta", true);
          defineSymbol(math, main, mathord, "ϖ", "\\varpi", true);
          defineSymbol(math, main, mathord, "ϱ", "\\varrho", true);
          defineSymbol(math, main, mathord, "ς", "\\varsigma", true);
          defineSymbol(math, main, mathord, "φ", "\\varphi", true);
          defineSymbol(math, main, bin, "∗", "*", true);
          defineSymbol(math, main, bin, "+", "+");
          defineSymbol(math, main, bin, "−", "-", true);
          defineSymbol(math, main, bin, "⋅", "\\cdot", true);
          defineSymbol(math, main, bin, "∘", "\\circ", true);
          defineSymbol(math, main, bin, "÷", "\\div", true);
          defineSymbol(math, main, bin, "±", "\\pm", true);
          defineSymbol(math, main, bin, "×", "\\times", true);
          defineSymbol(math, main, bin, "∩", "\\cap", true);
          defineSymbol(math, main, bin, "∪", "\\cup", true);
          defineSymbol(math, main, bin, "∖", "\\setminus", true);
          defineSymbol(math, main, bin, "∧", "\\land");
          defineSymbol(math, main, bin, "∨", "\\lor");
          defineSymbol(math, main, bin, "∧", "\\wedge", true);
          defineSymbol(math, main, bin, "∨", "\\vee", true);
          defineSymbol(math, main, textord, "√", "\\surd");
          defineSymbol(math, main, symbols_open, "⟨", "\\langle", true);
          defineSymbol(math, main, symbols_open, "∣", "\\lvert");
          defineSymbol(math, main, symbols_open, "∥", "\\lVert");
          defineSymbol(math, main, symbols_close, "?", "?");
          defineSymbol(math, main, symbols_close, "!", "!");
          defineSymbol(math, main, symbols_close, "⟩", "\\rangle", true);
          defineSymbol(math, main, symbols_close, "∣", "\\rvert");
          defineSymbol(math, main, symbols_close, "∥", "\\rVert");
          defineSymbol(math, main, rel, "=", "=");
          defineSymbol(math, main, rel, ":", ":");
          defineSymbol(math, main, rel, "≈", "\\approx", true);
          defineSymbol(math, main, rel, "≅", "\\cong", true);
          defineSymbol(math, main, rel, "≥", "\\ge");
          defineSymbol(math, main, rel, "≥", "\\geq", true);
          defineSymbol(math, main, rel, "←", "\\gets");
          defineSymbol(math, main, rel, ">", "\\gt", true);
          defineSymbol(math, main, rel, "∈", "\\in", true);
          defineSymbol(math, main, rel, "", "\\@not");
          defineSymbol(math, main, rel, "⊂", "\\subset", true);
          defineSymbol(math, main, rel, "⊃", "\\supset", true);
          defineSymbol(math, main, rel, "⊆", "\\subseteq", true);
          defineSymbol(math, main, rel, "⊇", "\\supseteq", true);
          defineSymbol(math, ams, rel, "⊈", "\\nsubseteq", true);
          defineSymbol(math, ams, rel, "⊉", "\\nsupseteq", true);
          defineSymbol(math, main, rel, "⊨", "\\models");
          defineSymbol(math, main, rel, "←", "\\leftarrow", true);
          defineSymbol(math, main, rel, "≤", "\\le");
          defineSymbol(math, main, rel, "≤", "\\leq", true);
          defineSymbol(math, main, rel, "<", "\\lt", true);
          defineSymbol(math, main, rel, "→", "\\rightarrow", true);
          defineSymbol(math, main, rel, "→", "\\to");
          defineSymbol(math, ams, rel, "≱", "\\ngeq", true);
          defineSymbol(math, ams, rel, "≰", "\\nleq", true);
          defineSymbol(math, main, spacing, " ", "\\ ");
          defineSymbol(math, main, spacing, " ", "\\space");
          defineSymbol(math, main, spacing, " ", "\\nobreakspace");
          defineSymbol(symbols_text, main, spacing, " ", "\\ ");
          defineSymbol(symbols_text, main, spacing, " ", " ");
          defineSymbol(symbols_text, main, spacing, " ", "\\space");
          defineSymbol(symbols_text, main, spacing, " ", "\\nobreakspace");
          defineSymbol(math, main, spacing, null, "\\nobreak");
          defineSymbol(math, main, spacing, null, "\\allowbreak");
          defineSymbol(math, main, punct, ",", ",");
          defineSymbol(math, main, punct, ";", ";");
          defineSymbol(math, ams, bin, "⊼", "\\barwedge", true);
          defineSymbol(math, ams, bin, "⊻", "\\veebar", true);
          defineSymbol(math, main, bin, "⊙", "\\odot", true);
          defineSymbol(math, main, bin, "⊕", "\\oplus", true);
          defineSymbol(math, main, bin, "⊗", "\\otimes", true);
          defineSymbol(math, main, textord, "∂", "\\partial", true);
          defineSymbol(math, main, bin, "⊘", "\\oslash", true);
          defineSymbol(math, ams, bin, "⊚", "\\circledcirc", true);
          defineSymbol(math, ams, bin, "⊡", "\\boxdot", true);
          defineSymbol(math, main, bin, "△", "\\bigtriangleup");
          defineSymbol(math, main, bin, "▽", "\\bigtriangledown");
          defineSymbol(math, main, bin, "†", "\\dagger");
          defineSymbol(math, main, bin, "⋄", "\\diamond");
          defineSymbol(math, main, bin, "⋆", "\\star");
          defineSymbol(math, main, bin, "◃", "\\triangleleft");
          defineSymbol(math, main, bin, "▹", "\\triangleright");
          defineSymbol(math, main, symbols_open, "{", "\\{");
          defineSymbol(symbols_text, main, textord, "{", "\\{");
          defineSymbol(symbols_text, main, textord, "{", "\\textbraceleft");
          defineSymbol(math, main, symbols_close, "}", "\\}");
          defineSymbol(symbols_text, main, textord, "}", "\\}");
          defineSymbol(symbols_text, main, textord, "}", "\\textbraceright");
          defineSymbol(math, main, symbols_open, "{", "\\lbrace");
          defineSymbol(math, main, symbols_close, "}", "\\rbrace");
          defineSymbol(math, main, symbols_open, "[", "\\lbrack", true);
          defineSymbol(symbols_text, main, textord, "[", "\\lbrack", true);
          defineSymbol(math, main, symbols_close, "]", "\\rbrack", true);
          defineSymbol(symbols_text, main, textord, "]", "\\rbrack", true);
          defineSymbol(math, main, symbols_open, "(", "\\lparen", true);
          defineSymbol(math, main, symbols_close, ")", "\\rparen", true);
          defineSymbol(symbols_text, main, textord, "<", "\\textless", true);
          defineSymbol(symbols_text, main, textord, ">", "\\textgreater", true);
          defineSymbol(math, main, symbols_open, "⌊", "\\lfloor", true);
          defineSymbol(math, main, symbols_close, "⌋", "\\rfloor", true);
          defineSymbol(math, main, symbols_open, "⌈", "\\lceil", true);
          defineSymbol(math, main, symbols_close, "⌉", "\\rceil", true);
          defineSymbol(math, main, textord, "\\", "\\backslash");
          defineSymbol(math, main, textord, "∣", "|");
          defineSymbol(math, main, textord, "∣", "\\vert");
          defineSymbol(symbols_text, main, textord, "|", "\\textbar", true);
          defineSymbol(math, main, textord, "∥", "\\|");
          defineSymbol(math, main, textord, "∥", "\\Vert");
          defineSymbol(symbols_text, main, textord, "∥", "\\textbardbl");
          defineSymbol(symbols_text, main, textord, "~", "\\textasciitilde");
          defineSymbol(symbols_text, main, textord, "\\", "\\textbackslash");
          defineSymbol(symbols_text, main, textord, "^", "\\textasciicircum");
          defineSymbol(math, main, rel, "↑", "\\uparrow", true);
          defineSymbol(math, main, rel, "⇑", "\\Uparrow", true);
          defineSymbol(math, main, rel, "↓", "\\downarrow", true);
          defineSymbol(math, main, rel, "⇓", "\\Downarrow", true);
          defineSymbol(math, main, rel, "↕", "\\updownarrow", true);
          defineSymbol(math, main, rel, "⇕", "\\Updownarrow", true);
          defineSymbol(math, main, op, "∐", "\\coprod");
          defineSymbol(math, main, op, "⋁", "\\bigvee");
          defineSymbol(math, main, op, "⋀", "\\bigwedge");
          defineSymbol(math, main, op, "⨄", "\\biguplus");
          defineSymbol(math, main, op, "⋂", "\\bigcap");
          defineSymbol(math, main, op, "⋃", "\\bigcup");
          defineSymbol(math, main, op, "∫", "\\int");
          defineSymbol(math, main, op, "∫", "\\intop");
          defineSymbol(math, main, op, "∬", "\\iint");
          defineSymbol(math, main, op, "∭", "\\iiint");
          defineSymbol(math, main, op, "∏", "\\prod");
          defineSymbol(math, main, op, "∑", "\\sum");
          defineSymbol(math, main, op, "⨂", "\\bigotimes");
          defineSymbol(math, main, op, "⨁", "\\bigoplus");
          defineSymbol(math, main, op, "⨀", "\\bigodot");
          defineSymbol(math, main, op, "∮", "\\oint");
          defineSymbol(math, main, op, "∯", "\\oiint");
          defineSymbol(math, main, op, "∰", "\\oiiint");
          defineSymbol(math, main, op, "⨆", "\\bigsqcup");
          defineSymbol(math, main, op, "∫", "\\smallint");
          defineSymbol(symbols_text, main, inner, "…", "\\textellipsis");
          defineSymbol(math, main, inner, "…", "\\mathellipsis");
          defineSymbol(symbols_text, main, inner, "…", "\\ldots", true);
          defineSymbol(math, main, inner, "…", "\\ldots", true);
          defineSymbol(math, main, inner, "⋯", "\\@cdots", true);
          defineSymbol(math, main, inner, "⋱", "\\ddots", true);
          defineSymbol(math, main, textord, "⋮", "\\varvdots");
          defineSymbol(symbols_text, main, textord, "⋮", "\\varvdots");
          defineSymbol(math, main, accent, "ˊ", "\\acute");
          defineSymbol(math, main, accent, "ˋ", "\\grave");
          defineSymbol(math, main, accent, "¨", "\\ddot");
          defineSymbol(math, main, accent, "~", "\\tilde");
          defineSymbol(math, main, accent, "ˉ", "\\bar");
          defineSymbol(math, main, accent, "˘", "\\breve");
          defineSymbol(math, main, accent, "ˇ", "\\check");
          defineSymbol(math, main, accent, "^", "\\hat");
          defineSymbol(math, main, accent, "⃗", "\\vec");
          defineSymbol(math, main, accent, "˙", "\\dot");
          defineSymbol(math, main, accent, "˚", "\\mathring");
          defineSymbol(math, main, mathord, "", "\\@imath");
          defineSymbol(math, main, mathord, "", "\\@jmath");
          defineSymbol(math, main, textord, "ı", "ı");
          defineSymbol(math, main, textord, "ȷ", "ȷ");
          defineSymbol(symbols_text, main, textord, "ı", "\\i", true);
          defineSymbol(symbols_text, main, textord, "ȷ", "\\j", true);
          defineSymbol(symbols_text, main, textord, "ß", "\\ss", true);
          defineSymbol(symbols_text, main, textord, "æ", "\\ae", true);
          defineSymbol(symbols_text, main, textord, "œ", "\\oe", true);
          defineSymbol(symbols_text, main, textord, "ø", "\\o", true);
          defineSymbol(symbols_text, main, textord, "Æ", "\\AE", true);
          defineSymbol(symbols_text, main, textord, "Œ", "\\OE", true);
          defineSymbol(symbols_text, main, textord, "Ø", "\\O", true);
          defineSymbol(symbols_text, main, accent, "ˊ", "\\'");
          defineSymbol(symbols_text, main, accent, "ˋ", "\\`");
          defineSymbol(symbols_text, main, accent, "ˆ", "\\^");
          defineSymbol(symbols_text, main, accent, "˜", "\\~");
          defineSymbol(symbols_text, main, accent, "ˉ", "\\=");
          defineSymbol(symbols_text, main, accent, "˘", "\\u");
          defineSymbol(symbols_text, main, accent, "˙", "\\.");
          defineSymbol(symbols_text, main, accent, "¸", "\\c");
          defineSymbol(symbols_text, main, accent, "˚", "\\r");
          defineSymbol(symbols_text, main, accent, "ˇ", "\\v");
          defineSymbol(symbols_text, main, accent, "¨", '\\"');
          defineSymbol(symbols_text, main, accent, "˝", "\\H");
          defineSymbol(symbols_text, main, accent, "◯", "\\textcircled");
          const ligatures = {
            "--": true,
            "---": true,
            "``": true,
            "''": true
          };
          defineSymbol(symbols_text, main, textord, "–", "--", true);
          defineSymbol(symbols_text, main, textord, "–", "\\textendash");
          defineSymbol(symbols_text, main, textord, "—", "---", true);
          defineSymbol(symbols_text, main, textord, "—", "\\textemdash");
          defineSymbol(symbols_text, main, textord, "‘", "`", true);
          defineSymbol(symbols_text, main, textord, "‘", "\\textquoteleft");
          defineSymbol(symbols_text, main, textord, "’", "'", true);
          defineSymbol(symbols_text, main, textord, "’", "\\textquoteright");
          defineSymbol(symbols_text, main, textord, "“", "``", true);
          defineSymbol(symbols_text, main, textord, "“", "\\textquotedblleft");
          defineSymbol(symbols_text, main, textord, "”", "''", true);
          defineSymbol(symbols_text, main, textord, "”", "\\textquotedblright");
          defineSymbol(math, main, textord, "°", "\\degree", true);
          defineSymbol(symbols_text, main, textord, "°", "\\degree");
          defineSymbol(symbols_text, main, textord, "°", "\\textdegree", true);
          defineSymbol(math, main, textord, "£", "\\pounds");
          defineSymbol(math, main, textord, "£", "\\mathsterling", true);
          defineSymbol(symbols_text, main, textord, "£", "\\pounds");
          defineSymbol(symbols_text, main, textord, "£", "\\textsterling", true);
          defineSymbol(math, ams, textord, "✠", "\\maltese");
          defineSymbol(symbols_text, ams, textord, "✠", "\\maltese");
          const mathTextSymbols = '0123456789/@."';
          for (let i2 = 0; i2 < mathTextSymbols.length; i2++) {
            const ch2 = mathTextSymbols.charAt(i2);
            defineSymbol(math, main, textord, ch2, ch2);
          }
          const textSymbols = '0123456789!@*()-=+";:?/.,';
          for (let i2 = 0; i2 < textSymbols.length; i2++) {
            const ch2 = textSymbols.charAt(i2);
            defineSymbol(symbols_text, main, textord, ch2, ch2);
          }
          const letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
          for (let i2 = 0; i2 < letters.length; i2++) {
            const ch2 = letters.charAt(i2);
            defineSymbol(math, main, mathord, ch2, ch2);
            defineSymbol(symbols_text, main, textord, ch2, ch2);
          }
          defineSymbol(math, ams, textord, "C", "ℂ");
          defineSymbol(symbols_text, ams, textord, "C", "ℂ");
          defineSymbol(math, ams, textord, "H", "ℍ");
          defineSymbol(symbols_text, ams, textord, "H", "ℍ");
          defineSymbol(math, ams, textord, "N", "ℕ");
          defineSymbol(symbols_text, ams, textord, "N", "ℕ");
          defineSymbol(math, ams, textord, "P", "ℙ");
          defineSymbol(symbols_text, ams, textord, "P", "ℙ");
          defineSymbol(math, ams, textord, "Q", "ℚ");
          defineSymbol(symbols_text, ams, textord, "Q", "ℚ");
          defineSymbol(math, ams, textord, "R", "ℝ");
          defineSymbol(symbols_text, ams, textord, "R", "ℝ");
          defineSymbol(math, ams, textord, "Z", "ℤ");
          defineSymbol(symbols_text, ams, textord, "Z", "ℤ");
          defineSymbol(math, main, mathord, "h", "ℎ");
          defineSymbol(symbols_text, main, mathord, "h", "ℎ");
          let wideChar = "";
          for (let i2 = 0; i2 < letters.length; i2++) {
            const ch2 = letters.charAt(i2);
            wideChar = String.fromCharCode(55349, 56320 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 56372 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 56424 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 56580 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 56684 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 56736 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 56788 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 56840 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 56944 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            if (i2 < 26) {
              wideChar = String.fromCharCode(55349, 56632 + i2);
              defineSymbol(math, main, mathord, ch2, wideChar);
              defineSymbol(symbols_text, main, textord, ch2, wideChar);
              wideChar = String.fromCharCode(55349, 56476 + i2);
              defineSymbol(math, main, mathord, ch2, wideChar);
              defineSymbol(symbols_text, main, textord, ch2, wideChar);
            }
          }
          wideChar = String.fromCharCode(55349, 56668);
          defineSymbol(math, main, mathord, "k", wideChar);
          defineSymbol(symbols_text, main, textord, "k", wideChar);
          for (let i2 = 0; i2 < 10; i2++) {
            const ch2 = i2.toString();
            wideChar = String.fromCharCode(55349, 57294 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 57314 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 57324 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
            wideChar = String.fromCharCode(55349, 57334 + i2);
            defineSymbol(math, main, mathord, ch2, wideChar);
            defineSymbol(symbols_text, main, textord, ch2, wideChar);
          }
          const extraLatin = "ÐÞþ";
          for (let i2 = 0; i2 < extraLatin.length; i2++) {
            const ch2 = extraLatin.charAt(i2);
            defineSymbol(math, main, mathord, ch2, ch2);
            defineSymbol(symbols_text, main, textord, ch2, ch2);
          }
          const wideLatinLetterData = [
            ["mathbf", "textbf", "Main-Bold"],
            // A-Z bold upright
            ["mathbf", "textbf", "Main-Bold"],
            // a-z bold upright
            ["mathnormal", "textit", "Math-Italic"],
            // A-Z italic
            ["mathnormal", "textit", "Math-Italic"],
            // a-z italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // A-Z bold italic
            ["boldsymbol", "boldsymbol", "Main-BoldItalic"],
            // a-z bold italic
            // Map fancy A-Z letters to script, not calligraphic.
            // This aligns with unicode-math and math fonts (except Cambria Math).
            ["mathscr", "textscr", "Script-Regular"],
            // A-Z script
            ["", "", ""],
            // a-z script.  No font
            ["", "", ""],
            // A-Z bold script. No font
            ["", "", ""],
            // a-z bold script. No font
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // A-Z Fraktur
            ["mathfrak", "textfrak", "Fraktur-Regular"],
            // a-z Fraktur
            ["mathbb", "textbb", "AMS-Regular"],
            // A-Z double-struck
            ["mathbb", "textbb", "AMS-Regular"],
            // k double-struck
            // Note that we are using a bold font, but font metrics for regular Fraktur.
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // A-Z bold Fraktur
            ["mathboldfrak", "textboldfrak", "Fraktur-Regular"],
            // a-z bold Fraktur
            ["mathsf", "textsf", "SansSerif-Regular"],
            // A-Z sans-serif
            ["mathsf", "textsf", "SansSerif-Regular"],
            // a-z sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // A-Z bold sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // a-z bold sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // A-Z italic sans-serif
            ["mathitsf", "textitsf", "SansSerif-Italic"],
            // a-z italic sans-serif
            ["", "", ""],
            // A-Z bold italic sans. No font
            ["", "", ""],
            // a-z bold italic sans. No font
            ["mathtt", "texttt", "Typewriter-Regular"],
            // A-Z monospace
            ["mathtt", "texttt", "Typewriter-Regular"]
            // a-z monospace
          ];
          const wideNumeralData = [
            ["mathbf", "textbf", "Main-Bold"],
            // 0-9 bold
            ["", "", ""],
            // 0-9 double-struck. No KaTeX font.
            ["mathsf", "textsf", "SansSerif-Regular"],
            // 0-9 sans-serif
            ["mathboldsf", "textboldsf", "SansSerif-Bold"],
            // 0-9 bold sans-serif
            ["mathtt", "texttt", "Typewriter-Regular"]
            // 0-9 monospace
          ];
          const wideCharacterFont = function(wideChar2, mode) {
            const H2 = wideChar2.charCodeAt(0);
            const L2 = wideChar2.charCodeAt(1);
            const codePoint = (H2 - 55296) * 1024 + (L2 - 56320) + 65536;
            const j = mode === "math" ? 0 : 1;
            if (119808 <= codePoint && codePoint < 120484) {
              const i2 = Math.floor((codePoint - 119808) / 26);
              return [wideLatinLetterData[i2][2], wideLatinLetterData[i2][j]];
            } else if (120782 <= codePoint && codePoint <= 120831) {
              const i2 = Math.floor((codePoint - 120782) / 10);
              return [wideNumeralData[i2][2], wideNumeralData[i2][j]];
            } else if (codePoint === 120485 || codePoint === 120486) {
              return [wideLatinLetterData[0][2], wideLatinLetterData[0][j]];
            } else if (120486 < codePoint && codePoint < 120782) {
              return ["", ""];
            } else {
              throw new src_ParseError("Unsupported character: " + wideChar2);
            }
          };
          const lookupSymbol = function(value, fontName, mode) {
            if (src_symbols[mode][value] && src_symbols[mode][value].replace) {
              value = src_symbols[mode][value].replace;
            }
            return {
              value,
              metrics: getCharacterMetrics(value, fontName, mode)
            };
          };
          const makeSymbol = function(value, fontName, mode, options, classes) {
            const lookup = lookupSymbol(value, fontName, mode);
            const metrics = lookup.metrics;
            value = lookup.value;
            let symbolNode;
            if (metrics) {
              let italic = metrics.italic;
              if (mode === "text" || options && options.font === "mathit") {
                italic = 0;
              }
              symbolNode = new SymbolNode(value, metrics.height, metrics.depth, italic, metrics.skew, metrics.width, classes);
            } else {
              typeof console !== "undefined" && console.warn("No character metrics " + ("for '" + value + "' in style '" + fontName + "' and mode '" + mode + "'"));
              symbolNode = new SymbolNode(value, 0, 0, 0, 0, 0, classes);
            }
            if (options) {
              symbolNode.maxFontSize = options.sizeMultiplier;
              if (options.style.isTight()) {
                symbolNode.classes.push("mtight");
              }
              const color = options.getColor();
              if (color) {
                symbolNode.style.color = color;
              }
            }
            return symbolNode;
          };
          const mathsym = function(value, mode, options, classes) {
            if (classes === void 0) {
              classes = [];
            }
            if (options.font === "boldsymbol" && lookupSymbol(value, "Main-Bold", mode).metrics) {
              return makeSymbol(value, "Main-Bold", mode, options, classes.concat(["mathbf"]));
            } else if (value === "\\" || src_symbols[mode][value].font === "main") {
              return makeSymbol(value, "Main-Regular", mode, options, classes);
            } else {
              return makeSymbol(value, "AMS-Regular", mode, options, classes.concat(["amsrm"]));
            }
          };
          const boldsymbol = function(value, mode, options, classes, type) {
            if (type !== "textord" && lookupSymbol(value, "Math-BoldItalic", mode).metrics) {
              return {
                fontName: "Math-BoldItalic",
                fontClass: "boldsymbol"
              };
            } else {
              return {
                fontName: "Main-Bold",
                fontClass: "mathbf"
              };
            }
          };
          const makeOrd = function(group, options, type) {
            const mode = group.mode;
            const text = group.text;
            const classes = ["mord"];
            const isFont = mode === "math" || mode === "text" && options.font;
            const fontOrFamily = isFont ? options.font : options.fontFamily;
            let wideFontName = "";
            let wideFontClass = "";
            if (text.charCodeAt(0) === 55349) {
              [wideFontName, wideFontClass] = wideCharacterFont(text, mode);
            }
            if (wideFontName.length > 0) {
              return makeSymbol(text, wideFontName, mode, options, classes.concat(wideFontClass));
            } else if (fontOrFamily) {
              let fontName;
              let fontClasses;
              if (fontOrFamily === "boldsymbol") {
                const fontData = boldsymbol(text, mode, options, classes, type);
                fontName = fontData.fontName;
                fontClasses = [fontData.fontClass];
              } else if (isFont) {
                fontName = fontMap[fontOrFamily].fontName;
                fontClasses = [fontOrFamily];
              } else {
                fontName = retrieveTextFontName(fontOrFamily, options.fontWeight, options.fontShape);
                fontClasses = [fontOrFamily, options.fontWeight, options.fontShape];
              }
              if (lookupSymbol(text, fontName, mode).metrics) {
                return makeSymbol(text, fontName, mode, options, classes.concat(fontClasses));
              } else if (ligatures.hasOwnProperty(text) && fontName.slice(0, 10) === "Typewriter") {
                const parts = [];
                for (let i2 = 0; i2 < text.length; i2++) {
                  parts.push(makeSymbol(text[i2], fontName, mode, options, classes.concat(fontClasses)));
                }
                return makeFragment(parts);
              }
            }
            if (type === "mathord") {
              return makeSymbol(text, "Math-Italic", mode, options, classes.concat(["mathnormal"]));
            } else if (type === "textord") {
              const font = src_symbols[mode][text] && src_symbols[mode][text].font;
              if (font === "ams") {
                const fontName = retrieveTextFontName("amsrm", options.fontWeight, options.fontShape);
                return makeSymbol(text, fontName, mode, options, classes.concat("amsrm", options.fontWeight, options.fontShape));
              } else if (font === "main" || !font) {
                const fontName = retrieveTextFontName("textrm", options.fontWeight, options.fontShape);
                return makeSymbol(text, fontName, mode, options, classes.concat(options.fontWeight, options.fontShape));
              } else {
                const fontName = retrieveTextFontName(font, options.fontWeight, options.fontShape);
                return makeSymbol(text, fontName, mode, options, classes.concat(fontName, options.fontWeight, options.fontShape));
              }
            } else {
              throw new Error("unexpected type: " + type + " in makeOrd");
            }
          };
          const canCombine = (prev, next) => {
            if (createClass(prev.classes) !== createClass(next.classes) || prev.skew !== next.skew || prev.maxFontSize !== next.maxFontSize) {
              return false;
            }
            if (prev.classes.length === 1) {
              const cls = prev.classes[0];
              if (cls === "mbin" || cls === "mord") {
                return false;
              }
            }
            for (const style in prev.style) {
              if (prev.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
                return false;
              }
            }
            for (const style in next.style) {
              if (next.style.hasOwnProperty(style) && prev.style[style] !== next.style[style]) {
                return false;
              }
            }
            return true;
          };
          const tryCombineChars = (chars2) => {
            for (let i2 = 0; i2 < chars2.length - 1; i2++) {
              const prev = chars2[i2];
              const next = chars2[i2 + 1];
              if (prev instanceof SymbolNode && next instanceof SymbolNode && canCombine(prev, next)) {
                prev.text += next.text;
                prev.height = Math.max(prev.height, next.height);
                prev.depth = Math.max(prev.depth, next.depth);
                prev.italic = next.italic;
                chars2.splice(i2 + 1, 1);
                i2--;
              }
            }
            return chars2;
          };
          const sizeElementFromChildren = function(elem) {
            let height = 0;
            let depth = 0;
            let maxFontSize = 0;
            for (let i2 = 0; i2 < elem.children.length; i2++) {
              const child = elem.children[i2];
              if (child.height > height) {
                height = child.height;
              }
              if (child.depth > depth) {
                depth = child.depth;
              }
              if (child.maxFontSize > maxFontSize) {
                maxFontSize = child.maxFontSize;
              }
            }
            elem.height = height;
            elem.depth = depth;
            elem.maxFontSize = maxFontSize;
          };
          const makeSpan = function(classes, children, options, style) {
            const span = new Span(classes, children, options, style);
            sizeElementFromChildren(span);
            return span;
          };
          const makeSvgSpan = (classes, children, options, style) => new Span(classes, children, options, style);
          const makeLineSpan = function(className, options, thickness) {
            const line = makeSpan([className], [], options);
            line.height = Math.max(thickness || options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
            line.style.borderBottomWidth = makeEm(line.height);
            line.maxFontSize = 1;
            return line;
          };
          const makeAnchor = function(href, classes, children, options) {
            const anchor = new Anchor2(href, classes, children, options);
            sizeElementFromChildren(anchor);
            return anchor;
          };
          const makeFragment = function(children) {
            const fragment = new DocumentFragment2(children);
            sizeElementFromChildren(fragment);
            return fragment;
          };
          const wrapFragment = function(group, options) {
            if (group instanceof DocumentFragment2) {
              return makeSpan([], [group], options);
            }
            return group;
          };
          const getVListChildrenAndDepth = function(params) {
            if (params.positionType === "individualShift") {
              const oldChildren = params.children;
              const children = [oldChildren[0]];
              const depth2 = -oldChildren[0].shift - oldChildren[0].elem.depth;
              let currPos = depth2;
              for (let i2 = 1; i2 < oldChildren.length; i2++) {
                const diff = -oldChildren[i2].shift - currPos - oldChildren[i2].elem.depth;
                const size2 = diff - (oldChildren[i2 - 1].elem.height + oldChildren[i2 - 1].elem.depth);
                currPos = currPos + diff;
                children.push({
                  type: "kern",
                  size: size2
                });
                children.push(oldChildren[i2]);
              }
              return {
                children,
                depth: depth2
              };
            }
            let depth;
            if (params.positionType === "top") {
              let bottom = params.positionData;
              for (let i2 = 0; i2 < params.children.length; i2++) {
                const child = params.children[i2];
                bottom -= child.type === "kern" ? child.size : child.elem.height + child.elem.depth;
              }
              depth = bottom;
            } else if (params.positionType === "bottom") {
              depth = -params.positionData;
            } else {
              const firstChild = params.children[0];
              if (firstChild.type !== "elem") {
                throw new Error('First child must have type "elem".');
              }
              if (params.positionType === "shift") {
                depth = -firstChild.elem.depth - params.positionData;
              } else if (params.positionType === "firstBaseline") {
                depth = -firstChild.elem.depth;
              } else {
                throw new Error("Invalid positionType " + params.positionType + ".");
              }
            }
            return {
              children: params.children,
              depth
            };
          };
          const makeVList = function(params, options) {
            const {
              children,
              depth
            } = getVListChildrenAndDepth(params);
            let pstrutSize = 0;
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              if (child.type === "elem") {
                const elem = child.elem;
                pstrutSize = Math.max(pstrutSize, elem.maxFontSize, elem.height);
              }
            }
            pstrutSize += 2;
            const pstrut = makeSpan(["pstrut"], []);
            pstrut.style.height = makeEm(pstrutSize);
            const realChildren = [];
            let minPos = depth;
            let maxPos = depth;
            let currPos = depth;
            for (let i2 = 0; i2 < children.length; i2++) {
              const child = children[i2];
              if (child.type === "kern") {
                currPos += child.size;
              } else {
                const elem = child.elem;
                const classes = child.wrapperClasses || [];
                const style = child.wrapperStyle || {};
                const childWrap = makeSpan(classes, [pstrut, elem], void 0, style);
                childWrap.style.top = makeEm(-pstrutSize - currPos - elem.depth);
                if (child.marginLeft) {
                  childWrap.style.marginLeft = child.marginLeft;
                }
                if (child.marginRight) {
                  childWrap.style.marginRight = child.marginRight;
                }
                realChildren.push(childWrap);
                currPos += elem.height + elem.depth;
              }
              minPos = Math.min(minPos, currPos);
              maxPos = Math.max(maxPos, currPos);
            }
            const vlist = makeSpan(["vlist"], realChildren);
            vlist.style.height = makeEm(maxPos);
            let rows;
            if (minPos < 0) {
              const emptySpan = makeSpan([], []);
              const depthStrut = makeSpan(["vlist"], [emptySpan]);
              depthStrut.style.height = makeEm(-minPos);
              const topStrut = makeSpan(["vlist-s"], [new SymbolNode("​")]);
              rows = [makeSpan(["vlist-r"], [vlist, topStrut]), makeSpan(["vlist-r"], [depthStrut])];
            } else {
              rows = [makeSpan(["vlist-r"], [vlist])];
            }
            const vtable = makeSpan(["vlist-t"], rows);
            if (rows.length === 2) {
              vtable.classes.push("vlist-t2");
            }
            vtable.height = maxPos;
            vtable.depth = -minPos;
            return vtable;
          };
          const makeGlue = (measurement, options) => {
            const rule = makeSpan(["mspace"], [], options);
            const size2 = calculateSize(measurement, options);
            rule.style.marginRight = makeEm(size2);
            return rule;
          };
          const retrieveTextFontName = function(fontFamily, fontWeight, fontShape) {
            let baseFontName = "";
            switch (fontFamily) {
              case "amsrm":
                baseFontName = "AMS";
                break;
              case "textrm":
                baseFontName = "Main";
                break;
              case "textsf":
                baseFontName = "SansSerif";
                break;
              case "texttt":
                baseFontName = "Typewriter";
                break;
              default:
                baseFontName = fontFamily;
            }
            let fontStylesName;
            if (fontWeight === "textbf" && fontShape === "textit") {
              fontStylesName = "BoldItalic";
            } else if (fontWeight === "textbf") {
              fontStylesName = "Bold";
            } else if (fontWeight === "textit") {
              fontStylesName = "Italic";
            } else {
              fontStylesName = "Regular";
            }
            return baseFontName + "-" + fontStylesName;
          };
          const fontMap = {
            // styles
            "mathbf": {
              variant: "bold",
              fontName: "Main-Bold"
            },
            "mathrm": {
              variant: "normal",
              fontName: "Main-Regular"
            },
            "textit": {
              variant: "italic",
              fontName: "Main-Italic"
            },
            "mathit": {
              variant: "italic",
              fontName: "Main-Italic"
            },
            "mathnormal": {
              variant: "italic",
              fontName: "Math-Italic"
            },
            "mathsfit": {
              variant: "sans-serif-italic",
              fontName: "SansSerif-Italic"
            },
            // "boldsymbol" is missing because they require the use of multiple fonts:
            // Math-BoldItalic and Main-Bold.  This is handled by a special case in
            // makeOrd which ends up calling boldsymbol.
            // families
            "mathbb": {
              variant: "double-struck",
              fontName: "AMS-Regular"
            },
            "mathcal": {
              variant: "script",
              fontName: "Caligraphic-Regular"
            },
            "mathfrak": {
              variant: "fraktur",
              fontName: "Fraktur-Regular"
            },
            "mathscr": {
              variant: "script",
              fontName: "Script-Regular"
            },
            "mathsf": {
              variant: "sans-serif",
              fontName: "SansSerif-Regular"
            },
            "mathtt": {
              variant: "monospace",
              fontName: "Typewriter-Regular"
            }
          };
          const svgData = {
            //   path, width, height
            vec: ["vec", 0.471, 0.714],
            // values from the font glyph
            oiintSize1: ["oiintSize1", 0.957, 0.499],
            // oval to overlay the integrand
            oiintSize2: ["oiintSize2", 1.472, 0.659],
            oiiintSize1: ["oiiintSize1", 1.304, 0.499],
            oiiintSize2: ["oiiintSize2", 1.98, 0.659]
          };
          const staticSvg = function(value, options) {
            const [pathName, width, height] = svgData[value];
            const path3 = new PathNode(pathName);
            const svgNode = new SvgNode([path3], {
              "width": makeEm(width),
              "height": makeEm(height),
              // Override CSS rule `.katex svg { width: 100% }`
              "style": "width:" + makeEm(width),
              "viewBox": "0 0 " + 1e3 * width + " " + 1e3 * height,
              "preserveAspectRatio": "xMinYMin"
            });
            const span = makeSvgSpan(["overlay"], [svgNode], options);
            span.height = height;
            span.style.height = makeEm(height);
            span.style.width = makeEm(width);
            return span;
          };
          var buildCommon = {
            fontMap,
            makeSymbol,
            mathsym,
            makeSpan,
            makeSvgSpan,
            makeLineSpan,
            makeAnchor,
            makeFragment,
            wrapFragment,
            makeVList,
            makeOrd,
            makeGlue,
            staticSvg,
            svgData,
            tryCombineChars
          };
          const thinspace = {
            number: 3,
            unit: "mu"
          };
          const mediumspace = {
            number: 4,
            unit: "mu"
          };
          const thickspace = {
            number: 5,
            unit: "mu"
          };
          const spacings = {
            mord: {
              mop: thinspace,
              mbin: mediumspace,
              mrel: thickspace,
              minner: thinspace
            },
            mop: {
              mord: thinspace,
              mop: thinspace,
              mrel: thickspace,
              minner: thinspace
            },
            mbin: {
              mord: mediumspace,
              mop: mediumspace,
              mopen: mediumspace,
              minner: mediumspace
            },
            mrel: {
              mord: thickspace,
              mop: thickspace,
              mopen: thickspace,
              minner: thickspace
            },
            mopen: {},
            mclose: {
              mop: thinspace,
              mbin: mediumspace,
              mrel: thickspace,
              minner: thinspace
            },
            mpunct: {
              mord: thinspace,
              mop: thinspace,
              mrel: thickspace,
              mopen: thinspace,
              mclose: thinspace,
              mpunct: thinspace,
              minner: thinspace
            },
            minner: {
              mord: thinspace,
              mop: thinspace,
              mbin: mediumspace,
              mrel: thickspace,
              mopen: thinspace,
              mpunct: thinspace,
              minner: thinspace
            }
          };
          const tightSpacings = {
            mord: {
              mop: thinspace
            },
            mop: {
              mord: thinspace,
              mop: thinspace
            },
            mbin: {},
            mrel: {},
            mopen: {},
            mclose: {
              mop: thinspace
            },
            mpunct: {},
            minner: {
              mop: thinspace
            }
          };
          const _functions = {};
          const _htmlGroupBuilders = {};
          const _mathmlGroupBuilders = {};
          function defineFunction(_ref) {
            let {
              type,
              names,
              props,
              handler,
              htmlBuilder: htmlBuilder2,
              mathmlBuilder: mathmlBuilder2
            } = _ref;
            const data = {
              type,
              numArgs: props.numArgs,
              argTypes: props.argTypes,
              allowedInArgument: !!props.allowedInArgument,
              allowedInText: !!props.allowedInText,
              allowedInMath: props.allowedInMath === void 0 ? true : props.allowedInMath,
              numOptionalArgs: props.numOptionalArgs || 0,
              infix: !!props.infix,
              primitive: !!props.primitive,
              handler
            };
            for (let i2 = 0; i2 < names.length; ++i2) {
              _functions[names[i2]] = data;
            }
            if (type) {
              if (htmlBuilder2) {
                _htmlGroupBuilders[type] = htmlBuilder2;
              }
              if (mathmlBuilder2) {
                _mathmlGroupBuilders[type] = mathmlBuilder2;
              }
            }
          }
          function defineFunctionBuilders(_ref2) {
            let {
              type,
              htmlBuilder: htmlBuilder2,
              mathmlBuilder: mathmlBuilder2
            } = _ref2;
            defineFunction({
              type,
              names: [],
              props: {
                numArgs: 0
              },
              handler() {
                throw new Error("Should never be called.");
              },
              htmlBuilder: htmlBuilder2,
              mathmlBuilder: mathmlBuilder2
            });
          }
          const normalizeArgument = function(arg) {
            return arg.type === "ordgroup" && arg.body.length === 1 ? arg.body[0] : arg;
          };
          const ordargument = function(arg) {
            return arg.type === "ordgroup" ? arg.body : [arg];
          };
          const buildHTML_makeSpan = buildCommon.makeSpan;
          const binLeftCanceller = ["leftmost", "mbin", "mopen", "mrel", "mop", "mpunct"];
          const binRightCanceller = ["rightmost", "mrel", "mclose", "mpunct"];
          const styleMap = {
            "display": src_Style.DISPLAY,
            "text": src_Style.TEXT,
            "script": src_Style.SCRIPT,
            "scriptscript": src_Style.SCRIPTSCRIPT
          };
          const DomEnum = {
            mord: "mord",
            mop: "mop",
            mbin: "mbin",
            mrel: "mrel",
            mopen: "mopen",
            mclose: "mclose",
            mpunct: "mpunct",
            minner: "minner"
          };
          const buildExpression = function(expression, options, isRealGroup, surrounding) {
            if (surrounding === void 0) {
              surrounding = [null, null];
            }
            const groups = [];
            for (let i2 = 0; i2 < expression.length; i2++) {
              const output = buildGroup(expression[i2], options);
              if (output instanceof DocumentFragment2) {
                const children = output.children;
                groups.push(...children);
              } else {
                groups.push(output);
              }
            }
            buildCommon.tryCombineChars(groups);
            if (!isRealGroup) {
              return groups;
            }
            let glueOptions = options;
            if (expression.length === 1) {
              const node = expression[0];
              if (node.type === "sizing") {
                glueOptions = options.havingSize(node.size);
              } else if (node.type === "styling") {
                glueOptions = options.havingStyle(styleMap[node.style]);
              }
            }
            const dummyPrev = buildHTML_makeSpan([surrounding[0] || "leftmost"], [], options);
            const dummyNext = buildHTML_makeSpan([surrounding[1] || "rightmost"], [], options);
            const isRoot = isRealGroup === "root";
            traverseNonSpaceNodes(groups, (node, prev) => {
              const prevType = prev.classes[0];
              const type = node.classes[0];
              if (prevType === "mbin" && utils.contains(binRightCanceller, type)) {
                prev.classes[0] = "mord";
              } else if (type === "mbin" && utils.contains(binLeftCanceller, prevType)) {
                node.classes[0] = "mord";
              }
            }, {
              node: dummyPrev
            }, dummyNext, isRoot);
            traverseNonSpaceNodes(groups, (node, prev) => {
              const prevType = getTypeOfDomTree(prev);
              const type = getTypeOfDomTree(node);
              const space = prevType && type ? node.hasClass("mtight") ? tightSpacings[prevType][type] : spacings[prevType][type] : null;
              if (space) {
                return buildCommon.makeGlue(space, glueOptions);
              }
            }, {
              node: dummyPrev
            }, dummyNext, isRoot);
            return groups;
          };
          const traverseNonSpaceNodes = function(nodes, callback, prev, next, isRoot) {
            if (next) {
              nodes.push(next);
            }
            let i2 = 0;
            for (; i2 < nodes.length; i2++) {
              const node = nodes[i2];
              const partialGroup = checkPartialGroup(node);
              if (partialGroup) {
                traverseNonSpaceNodes(partialGroup.children, callback, prev, null, isRoot);
                continue;
              }
              const nonspace = !node.hasClass("mspace");
              if (nonspace) {
                const result = callback(node, prev.node);
                if (result) {
                  if (prev.insertAfter) {
                    prev.insertAfter(result);
                  } else {
                    nodes.unshift(result);
                    i2++;
                  }
                }
              }
              if (nonspace) {
                prev.node = node;
              } else if (isRoot && node.hasClass("newline")) {
                prev.node = buildHTML_makeSpan(["leftmost"]);
              }
              prev.insertAfter = /* @__PURE__ */ ((index2) => (n2) => {
                nodes.splice(index2 + 1, 0, n2);
                i2++;
              })(i2);
            }
            if (next) {
              nodes.pop();
            }
          };
          const checkPartialGroup = function(node) {
            if (node instanceof DocumentFragment2 || node instanceof Anchor2 || node instanceof Span && node.hasClass("enclosing")) {
              return node;
            }
            return null;
          };
          const getOutermostNode = function(node, side) {
            const partialGroup = checkPartialGroup(node);
            if (partialGroup) {
              const children = partialGroup.children;
              if (children.length) {
                if (side === "right") {
                  return getOutermostNode(children[children.length - 1], "right");
                } else if (side === "left") {
                  return getOutermostNode(children[0], "left");
                }
              }
            }
            return node;
          };
          const getTypeOfDomTree = function(node, side) {
            if (!node) {
              return null;
            }
            if (side) {
              node = getOutermostNode(node, side);
            }
            return DomEnum[node.classes[0]] || null;
          };
          const makeNullDelimiter = function(options, classes) {
            const moreClasses = ["nulldelimiter"].concat(options.baseSizingClasses());
            return buildHTML_makeSpan(classes.concat(moreClasses));
          };
          const buildGroup = function(group, options, baseOptions) {
            if (!group) {
              return buildHTML_makeSpan();
            }
            if (_htmlGroupBuilders[group.type]) {
              let groupNode = _htmlGroupBuilders[group.type](group, options);
              if (baseOptions && options.size !== baseOptions.size) {
                groupNode = buildHTML_makeSpan(options.sizingClasses(baseOptions), [groupNode], options);
                const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
                groupNode.height *= multiplier;
                groupNode.depth *= multiplier;
              }
              return groupNode;
            } else {
              throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
            }
          };
          function buildHTMLUnbreakable(children, options) {
            const body = buildHTML_makeSpan(["base"], children, options);
            const strut = buildHTML_makeSpan(["strut"]);
            strut.style.height = makeEm(body.height + body.depth);
            if (body.depth) {
              strut.style.verticalAlign = makeEm(-body.depth);
            }
            body.children.unshift(strut);
            return body;
          }
          function buildHTML(tree, options) {
            let tag = null;
            if (tree.length === 1 && tree[0].type === "tag") {
              tag = tree[0].tag;
              tree = tree[0].body;
            }
            const expression = buildExpression(tree, options, "root");
            let eqnNum;
            if (expression.length === 2 && expression[1].hasClass("tag")) {
              eqnNum = expression.pop();
            }
            const children = [];
            let parts = [];
            for (let i2 = 0; i2 < expression.length; i2++) {
              parts.push(expression[i2]);
              if (expression[i2].hasClass("mbin") || expression[i2].hasClass("mrel") || expression[i2].hasClass("allowbreak")) {
                let nobreak = false;
                while (i2 < expression.length - 1 && expression[i2 + 1].hasClass("mspace") && !expression[i2 + 1].hasClass("newline")) {
                  i2++;
                  parts.push(expression[i2]);
                  if (expression[i2].hasClass("nobreak")) {
                    nobreak = true;
                  }
                }
                if (!nobreak) {
                  children.push(buildHTMLUnbreakable(parts, options));
                  parts = [];
                }
              } else if (expression[i2].hasClass("newline")) {
                parts.pop();
                if (parts.length > 0) {
                  children.push(buildHTMLUnbreakable(parts, options));
                  parts = [];
                }
                children.push(expression[i2]);
              }
            }
            if (parts.length > 0) {
              children.push(buildHTMLUnbreakable(parts, options));
            }
            let tagChild;
            if (tag) {
              tagChild = buildHTMLUnbreakable(buildExpression(tag, options, true));
              tagChild.classes = ["tag"];
              children.push(tagChild);
            } else if (eqnNum) {
              children.push(eqnNum);
            }
            const htmlNode = buildHTML_makeSpan(["katex-html"], children);
            htmlNode.setAttribute("aria-hidden", "true");
            if (tagChild) {
              const strut = tagChild.children[0];
              strut.style.height = makeEm(htmlNode.height + htmlNode.depth);
              if (htmlNode.depth) {
                strut.style.verticalAlign = makeEm(-htmlNode.depth);
              }
            }
            return htmlNode;
          }
          function newDocumentFragment(children) {
            return new DocumentFragment2(children);
          }
          class MathNode {
            constructor(type, children, classes) {
              this.type = void 0;
              this.attributes = void 0;
              this.children = void 0;
              this.classes = void 0;
              this.type = type;
              this.attributes = {};
              this.children = children || [];
              this.classes = classes || [];
            }
            /**
             * Sets an attribute on a MathML node. MathML depends on attributes to convey a
             * semantic content, so this is used heavily.
             */
            setAttribute(name, value) {
              this.attributes[name] = value;
            }
            /**
             * Gets an attribute on a MathML node.
             */
            getAttribute(name) {
              return this.attributes[name];
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", this.type);
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  node.setAttribute(attr, this.attributes[attr]);
                }
              }
              if (this.classes.length > 0) {
                node.className = createClass(this.classes);
              }
              for (let i2 = 0; i2 < this.children.length; i2++) {
                if (this.children[i2] instanceof TextNode && this.children[i2 + 1] instanceof TextNode) {
                  let text = this.children[i2].toText() + this.children[++i2].toText();
                  while (this.children[i2 + 1] instanceof TextNode) {
                    text += this.children[++i2].toText();
                  }
                  node.appendChild(new TextNode(text).toNode());
                } else {
                  node.appendChild(this.children[i2].toNode());
                }
              }
              return node;
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              let markup = "<" + this.type;
              for (const attr in this.attributes) {
                if (Object.prototype.hasOwnProperty.call(this.attributes, attr)) {
                  markup += " " + attr + '="';
                  markup += utils.escape(this.attributes[attr]);
                  markup += '"';
                }
              }
              if (this.classes.length > 0) {
                markup += ' class ="' + utils.escape(createClass(this.classes)) + '"';
              }
              markup += ">";
              for (let i2 = 0; i2 < this.children.length; i2++) {
                markup += this.children[i2].toMarkup();
              }
              markup += "</" + this.type + ">";
              return markup;
            }
            /**
             * Converts the math node into a string, similar to innerText, but escaped.
             */
            toText() {
              return this.children.map((child) => child.toText()).join("");
            }
          }
          class TextNode {
            constructor(text) {
              this.text = void 0;
              this.text = text;
            }
            /**
             * Converts the text node into a DOM text node.
             */
            toNode() {
              return document.createTextNode(this.text);
            }
            /**
             * Converts the text node into escaped HTML markup
             * (representing the text itself).
             */
            toMarkup() {
              return utils.escape(this.toText());
            }
            /**
             * Converts the text node into a string
             * (representing the text itself).
             */
            toText() {
              return this.text;
            }
          }
          class SpaceNode {
            /**
             * Create a Space node with width given in CSS ems.
             */
            constructor(width) {
              this.width = void 0;
              this.character = void 0;
              this.width = width;
              if (width >= 0.05555 && width <= 0.05556) {
                this.character = " ";
              } else if (width >= 0.1666 && width <= 0.1667) {
                this.character = " ";
              } else if (width >= 0.2222 && width <= 0.2223) {
                this.character = " ";
              } else if (width >= 0.2777 && width <= 0.2778) {
                this.character = "  ";
              } else if (width >= -0.05556 && width <= -0.05555) {
                this.character = " ⁣";
              } else if (width >= -0.1667 && width <= -0.1666) {
                this.character = " ⁣";
              } else if (width >= -0.2223 && width <= -0.2222) {
                this.character = " ⁣";
              } else if (width >= -0.2778 && width <= -0.2777) {
                this.character = " ⁣";
              } else {
                this.character = null;
              }
            }
            /**
             * Converts the math node into a MathML-namespaced DOM element.
             */
            toNode() {
              if (this.character) {
                return document.createTextNode(this.character);
              } else {
                const node = document.createElementNS("http://www.w3.org/1998/Math/MathML", "mspace");
                node.setAttribute("width", makeEm(this.width));
                return node;
              }
            }
            /**
             * Converts the math node into an HTML markup string.
             */
            toMarkup() {
              if (this.character) {
                return "<mtext>" + this.character + "</mtext>";
              } else {
                return '<mspace width="' + makeEm(this.width) + '"/>';
              }
            }
            /**
             * Converts the math node into a string, similar to innerText.
             */
            toText() {
              if (this.character) {
                return this.character;
              } else {
                return " ";
              }
            }
          }
          var mathMLTree = {
            MathNode,
            TextNode,
            SpaceNode,
            newDocumentFragment
          };
          const makeText = function(text, mode, options) {
            if (src_symbols[mode][text] && src_symbols[mode][text].replace && text.charCodeAt(0) !== 55349 && !(ligatures.hasOwnProperty(text) && options && (options.fontFamily && options.fontFamily.slice(4, 6) === "tt" || options.font && options.font.slice(4, 6) === "tt"))) {
              text = src_symbols[mode][text].replace;
            }
            return new mathMLTree.TextNode(text);
          };
          const makeRow = function(body) {
            if (body.length === 1) {
              return body[0];
            } else {
              return new mathMLTree.MathNode("mrow", body);
            }
          };
          const getVariant = function(group, options) {
            if (options.fontFamily === "texttt") {
              return "monospace";
            } else if (options.fontFamily === "textsf") {
              if (options.fontShape === "textit" && options.fontWeight === "textbf") {
                return "sans-serif-bold-italic";
              } else if (options.fontShape === "textit") {
                return "sans-serif-italic";
              } else if (options.fontWeight === "textbf") {
                return "bold-sans-serif";
              } else {
                return "sans-serif";
              }
            } else if (options.fontShape === "textit" && options.fontWeight === "textbf") {
              return "bold-italic";
            } else if (options.fontShape === "textit") {
              return "italic";
            } else if (options.fontWeight === "textbf") {
              return "bold";
            }
            const font = options.font;
            if (!font || font === "mathnormal") {
              return null;
            }
            const mode = group.mode;
            if (font === "mathit") {
              return "italic";
            } else if (font === "boldsymbol") {
              return group.type === "textord" ? "bold" : "bold-italic";
            } else if (font === "mathbf") {
              return "bold";
            } else if (font === "mathbb") {
              return "double-struck";
            } else if (font === "mathsfit") {
              return "sans-serif-italic";
            } else if (font === "mathfrak") {
              return "fraktur";
            } else if (font === "mathscr" || font === "mathcal") {
              return "script";
            } else if (font === "mathsf") {
              return "sans-serif";
            } else if (font === "mathtt") {
              return "monospace";
            }
            let text = group.text;
            if (utils.contains(["\\imath", "\\jmath"], text)) {
              return null;
            }
            if (src_symbols[mode][text] && src_symbols[mode][text].replace) {
              text = src_symbols[mode][text].replace;
            }
            const fontName = buildCommon.fontMap[font].fontName;
            if (getCharacterMetrics(text, fontName, mode)) {
              return buildCommon.fontMap[font].variant;
            }
            return null;
          };
          function isNumberPunctuation(group) {
            if (!group) {
              return false;
            }
            if (group.type === "mi" && group.children.length === 1) {
              const child = group.children[0];
              return child instanceof TextNode && child.text === ".";
            } else if (group.type === "mo" && group.children.length === 1 && group.getAttribute("separator") === "true" && group.getAttribute("lspace") === "0em" && group.getAttribute("rspace") === "0em") {
              const child = group.children[0];
              return child instanceof TextNode && child.text === ",";
            } else {
              return false;
            }
          }
          const buildMathML_buildExpression = function(expression, options, isOrdgroup) {
            if (expression.length === 1) {
              const group = buildMathML_buildGroup(expression[0], options);
              if (isOrdgroup && group instanceof MathNode && group.type === "mo") {
                group.setAttribute("lspace", "0em");
                group.setAttribute("rspace", "0em");
              }
              return [group];
            }
            const groups = [];
            let lastGroup;
            for (let i2 = 0; i2 < expression.length; i2++) {
              const group = buildMathML_buildGroup(expression[i2], options);
              if (group instanceof MathNode && lastGroup instanceof MathNode) {
                if (group.type === "mtext" && lastGroup.type === "mtext" && group.getAttribute("mathvariant") === lastGroup.getAttribute("mathvariant")) {
                  lastGroup.children.push(...group.children);
                  continue;
                } else if (group.type === "mn" && lastGroup.type === "mn") {
                  lastGroup.children.push(...group.children);
                  continue;
                } else if (isNumberPunctuation(group) && lastGroup.type === "mn") {
                  lastGroup.children.push(...group.children);
                  continue;
                } else if (group.type === "mn" && isNumberPunctuation(lastGroup)) {
                  group.children = [...lastGroup.children, ...group.children];
                  groups.pop();
                } else if ((group.type === "msup" || group.type === "msub") && group.children.length >= 1 && (lastGroup.type === "mn" || isNumberPunctuation(lastGroup))) {
                  const base = group.children[0];
                  if (base instanceof MathNode && base.type === "mn") {
                    base.children = [...lastGroup.children, ...base.children];
                    groups.pop();
                  }
                } else if (lastGroup.type === "mi" && lastGroup.children.length === 1) {
                  const lastChild = lastGroup.children[0];
                  if (lastChild instanceof TextNode && lastChild.text === "̸" && (group.type === "mo" || group.type === "mi" || group.type === "mn")) {
                    const child = group.children[0];
                    if (child instanceof TextNode && child.text.length > 0) {
                      child.text = child.text.slice(0, 1) + "̸" + child.text.slice(1);
                      groups.pop();
                    }
                  }
                }
              }
              groups.push(group);
              lastGroup = group;
            }
            return groups;
          };
          const buildExpressionRow = function(expression, options, isOrdgroup) {
            return makeRow(buildMathML_buildExpression(expression, options, isOrdgroup));
          };
          const buildMathML_buildGroup = function(group, options) {
            if (!group) {
              return new mathMLTree.MathNode("mrow");
            }
            if (_mathmlGroupBuilders[group.type]) {
              const result = _mathmlGroupBuilders[group.type](group, options);
              return result;
            } else {
              throw new src_ParseError("Got group of unknown type: '" + group.type + "'");
            }
          };
          function buildMathML(tree, texExpression, options, isDisplayMode, forMathmlOnly) {
            const expression = buildMathML_buildExpression(tree, options);
            let wrapper;
            if (expression.length === 1 && expression[0] instanceof MathNode && utils.contains(["mrow", "mtable"], expression[0].type)) {
              wrapper = expression[0];
            } else {
              wrapper = new mathMLTree.MathNode("mrow", expression);
            }
            const annotation = new mathMLTree.MathNode("annotation", [new mathMLTree.TextNode(texExpression)]);
            annotation.setAttribute("encoding", "application/x-tex");
            const semantics = new mathMLTree.MathNode("semantics", [wrapper, annotation]);
            const math2 = new mathMLTree.MathNode("math", [semantics]);
            math2.setAttribute("xmlns", "http://www.w3.org/1998/Math/MathML");
            if (isDisplayMode) {
              math2.setAttribute("display", "block");
            }
            const wrapperClass = forMathmlOnly ? "katex" : "katex-mathml";
            return buildCommon.makeSpan([wrapperClass], [math2]);
          }
          const optionsFromSettings = function(settings) {
            return new src_Options({
              style: settings.displayMode ? src_Style.DISPLAY : src_Style.TEXT,
              maxSize: settings.maxSize,
              minRuleThickness: settings.minRuleThickness
            });
          };
          const displayWrap = function(node, settings) {
            if (settings.displayMode) {
              const classes = ["katex-display"];
              if (settings.leqno) {
                classes.push("leqno");
              }
              if (settings.fleqn) {
                classes.push("fleqn");
              }
              node = buildCommon.makeSpan(classes, [node]);
            }
            return node;
          };
          const buildTree = function(tree, expression, settings) {
            const options = optionsFromSettings(settings);
            let katexNode;
            if (settings.output === "mathml") {
              return buildMathML(tree, expression, options, settings.displayMode, true);
            } else if (settings.output === "html") {
              const htmlNode = buildHTML(tree, options);
              katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
            } else {
              const mathMLNode = buildMathML(tree, expression, options, settings.displayMode, false);
              const htmlNode = buildHTML(tree, options);
              katexNode = buildCommon.makeSpan(["katex"], [mathMLNode, htmlNode]);
            }
            return displayWrap(katexNode, settings);
          };
          const buildHTMLTree = function(tree, expression, settings) {
            const options = optionsFromSettings(settings);
            const htmlNode = buildHTML(tree, options);
            const katexNode = buildCommon.makeSpan(["katex"], [htmlNode]);
            return displayWrap(katexNode, settings);
          };
          const stretchyCodePoint = {
            widehat: "^",
            widecheck: "ˇ",
            widetilde: "~",
            utilde: "~",
            overleftarrow: "←",
            underleftarrow: "←",
            xleftarrow: "←",
            overrightarrow: "→",
            underrightarrow: "→",
            xrightarrow: "→",
            underbrace: "⏟",
            overbrace: "⏞",
            overgroup: "⏠",
            undergroup: "⏡",
            overleftrightarrow: "↔",
            underleftrightarrow: "↔",
            xleftrightarrow: "↔",
            Overrightarrow: "⇒",
            xRightarrow: "⇒",
            overleftharpoon: "↼",
            xleftharpoonup: "↼",
            overrightharpoon: "⇀",
            xrightharpoonup: "⇀",
            xLeftarrow: "⇐",
            xLeftrightarrow: "⇔",
            xhookleftarrow: "↩",
            xhookrightarrow: "↪",
            xmapsto: "↦",
            xrightharpoondown: "⇁",
            xleftharpoondown: "↽",
            xrightleftharpoons: "⇌",
            xleftrightharpoons: "⇋",
            xtwoheadleftarrow: "↞",
            xtwoheadrightarrow: "↠",
            xlongequal: "=",
            xtofrom: "⇄",
            xrightleftarrows: "⇄",
            xrightequilibrium: "⇌",
            // Not a perfect match.
            xleftequilibrium: "⇋",
            // None better available.
            "\\cdrightarrow": "→",
            "\\cdleftarrow": "←",
            "\\cdlongequal": "="
          };
          const mathMLnode = function(label) {
            const node = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(stretchyCodePoint[label.replace(/^\\/, "")])]);
            node.setAttribute("stretchy", "true");
            return node;
          };
          const katexImagesData = {
            //   path(s), minWidth, height, align
            overrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            overleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            underrightarrow: [["rightarrow"], 0.888, 522, "xMaxYMin"],
            underleftarrow: [["leftarrow"], 0.888, 522, "xMinYMin"],
            xrightarrow: [["rightarrow"], 1.469, 522, "xMaxYMin"],
            "\\cdrightarrow": [["rightarrow"], 3, 522, "xMaxYMin"],
            // CD minwwidth2.5pc
            xleftarrow: [["leftarrow"], 1.469, 522, "xMinYMin"],
            "\\cdleftarrow": [["leftarrow"], 3, 522, "xMinYMin"],
            Overrightarrow: [["doublerightarrow"], 0.888, 560, "xMaxYMin"],
            xRightarrow: [["doublerightarrow"], 1.526, 560, "xMaxYMin"],
            xLeftarrow: [["doubleleftarrow"], 1.526, 560, "xMinYMin"],
            overleftharpoon: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoonup: [["leftharpoon"], 0.888, 522, "xMinYMin"],
            xleftharpoondown: [["leftharpoondown"], 0.888, 522, "xMinYMin"],
            overrightharpoon: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoonup: [["rightharpoon"], 0.888, 522, "xMaxYMin"],
            xrightharpoondown: [["rightharpoondown"], 0.888, 522, "xMaxYMin"],
            xlongequal: [["longequal"], 0.888, 334, "xMinYMin"],
            "\\cdlongequal": [["longequal"], 3, 334, "xMinYMin"],
            xtwoheadleftarrow: [["twoheadleftarrow"], 0.888, 334, "xMinYMin"],
            xtwoheadrightarrow: [["twoheadrightarrow"], 0.888, 334, "xMaxYMin"],
            overleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            overbrace: [["leftbrace", "midbrace", "rightbrace"], 1.6, 548],
            underbrace: [["leftbraceunder", "midbraceunder", "rightbraceunder"], 1.6, 548],
            underleftrightarrow: [["leftarrow", "rightarrow"], 0.888, 522],
            xleftrightarrow: [["leftarrow", "rightarrow"], 1.75, 522],
            xLeftrightarrow: [["doubleleftarrow", "doublerightarrow"], 1.75, 560],
            xrightleftharpoons: [["leftharpoondownplus", "rightharpoonplus"], 1.75, 716],
            xleftrightharpoons: [["leftharpoonplus", "rightharpoondownplus"], 1.75, 716],
            xhookleftarrow: [["leftarrow", "righthook"], 1.08, 522],
            xhookrightarrow: [["lefthook", "rightarrow"], 1.08, 522],
            overlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            underlinesegment: [["leftlinesegment", "rightlinesegment"], 0.888, 522],
            overgroup: [["leftgroup", "rightgroup"], 0.888, 342],
            undergroup: [["leftgroupunder", "rightgroupunder"], 0.888, 342],
            xmapsto: [["leftmapsto", "rightarrow"], 1.5, 522],
            xtofrom: [["leftToFrom", "rightToFrom"], 1.75, 528],
            // The next three arrows are from the mhchem package.
            // In mhchem.sty, min-length is 2.0em. But these arrows might appear in the
            // document as \xrightarrow or \xrightleftharpoons. Those have
            // min-length = 1.75em, so we set min-length on these next three to match.
            xrightleftarrows: [["baraboveleftarrow", "rightarrowabovebar"], 1.75, 901],
            xrightequilibrium: [["baraboveshortleftharpoon", "rightharpoonaboveshortbar"], 1.75, 716],
            xleftequilibrium: [["shortbaraboveleftharpoon", "shortrightharpoonabovebar"], 1.75, 716]
          };
          const groupLength = function(arg) {
            if (arg.type === "ordgroup") {
              return arg.body.length;
            } else {
              return 1;
            }
          };
          const svgSpan = function(group, options) {
            function buildSvgSpan_() {
              let viewBoxWidth = 4e5;
              const label = group.label.slice(1);
              if (utils.contains(["widehat", "widecheck", "widetilde", "utilde"], label)) {
                const grp = group;
                const numChars = groupLength(grp.base);
                let viewBoxHeight;
                let pathName;
                let height2;
                if (numChars > 5) {
                  if (label === "widehat" || label === "widecheck") {
                    viewBoxHeight = 420;
                    viewBoxWidth = 2364;
                    height2 = 0.42;
                    pathName = label + "4";
                  } else {
                    viewBoxHeight = 312;
                    viewBoxWidth = 2340;
                    height2 = 0.34;
                    pathName = "tilde4";
                  }
                } else {
                  const imgIndex = [1, 1, 2, 2, 3, 3][numChars];
                  if (label === "widehat" || label === "widecheck") {
                    viewBoxWidth = [0, 1062, 2364, 2364, 2364][imgIndex];
                    viewBoxHeight = [0, 239, 300, 360, 420][imgIndex];
                    height2 = [0, 0.24, 0.3, 0.3, 0.36, 0.42][imgIndex];
                    pathName = label + imgIndex;
                  } else {
                    viewBoxWidth = [0, 600, 1033, 2339, 2340][imgIndex];
                    viewBoxHeight = [0, 260, 286, 306, 312][imgIndex];
                    height2 = [0, 0.26, 0.286, 0.3, 0.306, 0.34][imgIndex];
                    pathName = "tilde" + imgIndex;
                  }
                }
                const path3 = new PathNode(pathName);
                const svgNode = new SvgNode([path3], {
                  "width": "100%",
                  "height": makeEm(height2),
                  "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                  "preserveAspectRatio": "none"
                });
                return {
                  span: buildCommon.makeSvgSpan([], [svgNode], options),
                  minWidth: 0,
                  height: height2
                };
              } else {
                const spans = [];
                const data = katexImagesData[label];
                const [paths, minWidth2, viewBoxHeight] = data;
                const height2 = viewBoxHeight / 1e3;
                const numSvgChildren = paths.length;
                let widthClasses;
                let aligns;
                if (numSvgChildren === 1) {
                  const align1 = data[3];
                  widthClasses = ["hide-tail"];
                  aligns = [align1];
                } else if (numSvgChildren === 2) {
                  widthClasses = ["halfarrow-left", "halfarrow-right"];
                  aligns = ["xMinYMin", "xMaxYMin"];
                } else if (numSvgChildren === 3) {
                  widthClasses = ["brace-left", "brace-center", "brace-right"];
                  aligns = ["xMinYMin", "xMidYMin", "xMaxYMin"];
                } else {
                  throw new Error("Correct katexImagesData or update code here to support\n                    " + numSvgChildren + " children.");
                }
                for (let i2 = 0; i2 < numSvgChildren; i2++) {
                  const path3 = new PathNode(paths[i2]);
                  const svgNode = new SvgNode([path3], {
                    "width": "400em",
                    "height": makeEm(height2),
                    "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight,
                    "preserveAspectRatio": aligns[i2] + " slice"
                  });
                  const span2 = buildCommon.makeSvgSpan([widthClasses[i2]], [svgNode], options);
                  if (numSvgChildren === 1) {
                    return {
                      span: span2,
                      minWidth: minWidth2,
                      height: height2
                    };
                  } else {
                    span2.style.height = makeEm(height2);
                    spans.push(span2);
                  }
                }
                return {
                  span: buildCommon.makeSpan(["stretchy"], spans, options),
                  minWidth: minWidth2,
                  height: height2
                };
              }
            }
            const {
              span,
              minWidth,
              height
            } = buildSvgSpan_();
            span.height = height;
            span.style.height = makeEm(height);
            if (minWidth > 0) {
              span.style.minWidth = makeEm(minWidth);
            }
            return span;
          };
          const encloseSpan = function(inner2, label, topPad, bottomPad, options) {
            let img;
            const totalHeight = inner2.height + inner2.depth + topPad + bottomPad;
            if (/fbox|color|angl/.test(label)) {
              img = buildCommon.makeSpan(["stretchy", label], [], options);
              if (label === "fbox") {
                const color = options.color && options.getColor();
                if (color) {
                  img.style.borderColor = color;
                }
              }
            } else {
              const lines = [];
              if (/^[bx]cancel$/.test(label)) {
                lines.push(new LineNode({
                  "x1": "0",
                  "y1": "0",
                  "x2": "100%",
                  "y2": "100%",
                  "stroke-width": "0.046em"
                }));
              }
              if (/^x?cancel$/.test(label)) {
                lines.push(new LineNode({
                  "x1": "0",
                  "y1": "100%",
                  "x2": "100%",
                  "y2": "0",
                  "stroke-width": "0.046em"
                }));
              }
              const svgNode = new SvgNode(lines, {
                "width": "100%",
                "height": makeEm(totalHeight)
              });
              img = buildCommon.makeSvgSpan([], [svgNode], options);
            }
            img.height = totalHeight;
            img.style.height = makeEm(totalHeight);
            return img;
          };
          var stretchy = {
            encloseSpan,
            mathMLnode,
            svgSpan
          };
          function assertNodeType(node, type) {
            if (!node || node.type !== type) {
              throw new Error("Expected node of type " + type + ", but got " + (node ? "node of type " + node.type : String(node)));
            }
            return node;
          }
          function assertSymbolNodeType(node) {
            const typedNode = checkSymbolNodeType(node);
            if (!typedNode) {
              throw new Error("Expected node of symbol group type, but got " + (node ? "node of type " + node.type : String(node)));
            }
            return typedNode;
          }
          function checkSymbolNodeType(node) {
            if (node && (node.type === "atom" || NON_ATOMS.hasOwnProperty(node.type))) {
              return node;
            }
            return null;
          }
          const htmlBuilder = (grp, options) => {
            let base;
            let group;
            let supSubGroup;
            if (grp && grp.type === "supsub") {
              group = assertNodeType(grp.base, "accent");
              base = group.base;
              grp.base = base;
              supSubGroup = assertSpan(buildGroup(grp, options));
              grp.base = group;
            } else {
              group = assertNodeType(grp, "accent");
              base = group.base;
            }
            const body = buildGroup(base, options.havingCrampedStyle());
            const mustShift = group.isShifty && utils.isCharacterBox(base);
            let skew = 0;
            if (mustShift) {
              const baseChar = utils.getBaseElem(base);
              const baseGroup = buildGroup(baseChar, options.havingCrampedStyle());
              skew = assertSymbolDomNode(baseGroup).skew;
            }
            const accentBelow = group.label === "\\c";
            let clearance = accentBelow ? body.height + body.depth : Math.min(body.height, options.fontMetrics().xHeight);
            let accentBody;
            if (!group.isStretchy) {
              let accent2;
              let width;
              if (group.label === "\\vec") {
                accent2 = buildCommon.staticSvg("vec", options);
                width = buildCommon.svgData.vec[1];
              } else {
                accent2 = buildCommon.makeOrd({
                  mode: group.mode,
                  text: group.label
                }, options, "textord");
                accent2 = assertSymbolDomNode(accent2);
                accent2.italic = 0;
                width = accent2.width;
                if (accentBelow) {
                  clearance += accent2.depth;
                }
              }
              accentBody = buildCommon.makeSpan(["accent-body"], [accent2]);
              const accentFull = group.label === "\\textcircled";
              if (accentFull) {
                accentBody.classes.push("accent-full");
                clearance = body.height;
              }
              let left = skew;
              if (!accentFull) {
                left -= width / 2;
              }
              accentBody.style.left = makeEm(left);
              if (group.label === "\\textcircled") {
                accentBody.style.top = ".2em";
              }
              accentBody = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "kern",
                  size: -clearance
                }, {
                  type: "elem",
                  elem: accentBody
                }]
              }, options);
            } else {
              accentBody = stretchy.svgSpan(group, options);
              accentBody = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "elem",
                  elem: accentBody,
                  wrapperClasses: ["svg-align"],
                  wrapperStyle: skew > 0 ? {
                    width: "calc(100% - " + makeEm(2 * skew) + ")",
                    marginLeft: makeEm(2 * skew)
                  } : void 0
                }]
              }, options);
            }
            const accentWrap = buildCommon.makeSpan(["mord", "accent"], [accentBody], options);
            if (supSubGroup) {
              supSubGroup.children[0] = accentWrap;
              supSubGroup.height = Math.max(accentWrap.height, supSubGroup.height);
              supSubGroup.classes[0] = "mord";
              return supSubGroup;
            } else {
              return accentWrap;
            }
          };
          const mathmlBuilder = (group, options) => {
            const accentNode = group.isStretchy ? stretchy.mathMLnode(group.label) : new mathMLTree.MathNode("mo", [makeText(group.label, group.mode)]);
            const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.base, options), accentNode]);
            node.setAttribute("accent", "true");
            return node;
          };
          const NON_STRETCHY_ACCENT_REGEX = new RegExp(["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring"].map((accent2) => "\\" + accent2).join("|"));
          defineFunction({
            type: "accent",
            names: ["\\acute", "\\grave", "\\ddot", "\\tilde", "\\bar", "\\breve", "\\check", "\\hat", "\\vec", "\\dot", "\\mathring", "\\widecheck", "\\widehat", "\\widetilde", "\\overrightarrow", "\\overleftarrow", "\\Overrightarrow", "\\overleftrightarrow", "\\overgroup", "\\overlinesegment", "\\overleftharpoon", "\\overrightharpoon"],
            props: {
              numArgs: 1
            },
            handler: (context, args) => {
              const base = normalizeArgument(args[0]);
              const isStretchy = !NON_STRETCHY_ACCENT_REGEX.test(context.funcName);
              const isShifty = !isStretchy || context.funcName === "\\widehat" || context.funcName === "\\widetilde" || context.funcName === "\\widecheck";
              return {
                type: "accent",
                mode: context.parser.mode,
                label: context.funcName,
                isStretchy,
                isShifty,
                base
              };
            },
            htmlBuilder,
            mathmlBuilder
          });
          defineFunction({
            type: "accent",
            names: ["\\'", "\\`", "\\^", "\\~", "\\=", "\\u", "\\.", '\\"', "\\c", "\\r", "\\H", "\\v", "\\textcircled"],
            props: {
              numArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              // unless in strict mode
              argTypes: ["primitive"]
            },
            handler: (context, args) => {
              const base = args[0];
              let mode = context.parser.mode;
              if (mode === "math") {
                context.parser.settings.reportNonstrict("mathVsTextAccents", "LaTeX's accent " + context.funcName + " works only in text mode");
                mode = "text";
              }
              return {
                type: "accent",
                mode,
                label: context.funcName,
                isStretchy: false,
                isShifty: true,
                base
              };
            },
            htmlBuilder,
            mathmlBuilder
          });
          defineFunction({
            type: "accentUnder",
            names: ["\\underleftarrow", "\\underrightarrow", "\\underleftrightarrow", "\\undergroup", "\\underlinesegment", "\\utilde"],
            props: {
              numArgs: 1
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const base = args[0];
              return {
                type: "accentUnder",
                mode: parser.mode,
                label: funcName,
                base
              };
            },
            htmlBuilder: (group, options) => {
              const innerGroup = buildGroup(group.base, options);
              const accentBody = stretchy.svgSpan(group, options);
              const kern = group.label === "\\utilde" ? 0.12 : 0;
              const vlist = buildCommon.makeVList({
                positionType: "top",
                positionData: innerGroup.height,
                children: [{
                  type: "elem",
                  elem: accentBody,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: kern
                }, {
                  type: "elem",
                  elem: innerGroup
                }]
              }, options);
              return buildCommon.makeSpan(["mord", "accentunder"], [vlist], options);
            },
            mathmlBuilder: (group, options) => {
              const accentNode = stretchy.mathMLnode(group.label);
              const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.base, options), accentNode]);
              node.setAttribute("accentunder", "true");
              return node;
            }
          });
          const paddedNode = (group) => {
            const node = new mathMLTree.MathNode("mpadded", group ? [group] : []);
            node.setAttribute("width", "+0.6em");
            node.setAttribute("lspace", "0.3em");
            return node;
          };
          defineFunction({
            type: "xArrow",
            names: [
              "\\xleftarrow",
              "\\xrightarrow",
              "\\xLeftarrow",
              "\\xRightarrow",
              "\\xleftrightarrow",
              "\\xLeftrightarrow",
              "\\xhookleftarrow",
              "\\xhookrightarrow",
              "\\xmapsto",
              "\\xrightharpoondown",
              "\\xrightharpoonup",
              "\\xleftharpoondown",
              "\\xleftharpoonup",
              "\\xrightleftharpoons",
              "\\xleftrightharpoons",
              "\\xlongequal",
              "\\xtwoheadrightarrow",
              "\\xtwoheadleftarrow",
              "\\xtofrom",
              // The next 3 functions are here to support the mhchem extension.
              // Direct use of these functions is discouraged and may break someday.
              "\\xrightleftarrows",
              "\\xrightequilibrium",
              "\\xleftequilibrium",
              // The next 3 functions are here only to support the {CD} environment.
              "\\\\cdrightarrow",
              "\\\\cdleftarrow",
              "\\\\cdlongequal"
            ],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(_ref, args, optArgs) {
              let {
                parser,
                funcName
              } = _ref;
              return {
                type: "xArrow",
                mode: parser.mode,
                label: funcName,
                body: args[0],
                below: optArgs[0]
              };
            },
            // Flow is unable to correctly infer the type of `group`, even though it's
            // unambiguously determined from the passed-in `type` above.
            htmlBuilder(group, options) {
              const style = options.style;
              let newOptions = options.havingStyle(style.sup());
              const upperGroup = buildCommon.wrapFragment(buildGroup(group.body, newOptions, options), options);
              const arrowPrefix = group.label.slice(0, 2) === "\\x" ? "x" : "cd";
              upperGroup.classes.push(arrowPrefix + "-arrow-pad");
              let lowerGroup;
              if (group.below) {
                newOptions = options.havingStyle(style.sub());
                lowerGroup = buildCommon.wrapFragment(buildGroup(group.below, newOptions, options), options);
                lowerGroup.classes.push(arrowPrefix + "-arrow-pad");
              }
              const arrowBody = stretchy.svgSpan(group, options);
              const arrowShift = -options.fontMetrics().axisHeight + 0.5 * arrowBody.height;
              let upperShift = -options.fontMetrics().axisHeight - 0.5 * arrowBody.height - 0.111;
              if (upperGroup.depth > 0.25 || group.label === "\\xleftequilibrium") {
                upperShift -= upperGroup.depth;
              }
              let vlist;
              if (lowerGroup) {
                const lowerShift = -options.fontMetrics().axisHeight + lowerGroup.height + 0.5 * arrowBody.height + 0.111;
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: upperGroup,
                    shift: upperShift
                  }, {
                    type: "elem",
                    elem: arrowBody,
                    shift: arrowShift
                  }, {
                    type: "elem",
                    elem: lowerGroup,
                    shift: lowerShift
                  }]
                }, options);
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: upperGroup,
                    shift: upperShift
                  }, {
                    type: "elem",
                    elem: arrowBody,
                    shift: arrowShift
                  }]
                }, options);
              }
              vlist.children[0].children[0].children[1].classes.push("svg-align");
              return buildCommon.makeSpan(["mrel", "x-arrow"], [vlist], options);
            },
            mathmlBuilder(group, options) {
              const arrowNode = stretchy.mathMLnode(group.label);
              arrowNode.setAttribute("minsize", group.label.charAt(0) === "x" ? "1.75em" : "3.0em");
              let node;
              if (group.body) {
                const upperNode = paddedNode(buildMathML_buildGroup(group.body, options));
                if (group.below) {
                  const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
                  node = new mathMLTree.MathNode("munderover", [arrowNode, lowerNode, upperNode]);
                } else {
                  node = new mathMLTree.MathNode("mover", [arrowNode, upperNode]);
                }
              } else if (group.below) {
                const lowerNode = paddedNode(buildMathML_buildGroup(group.below, options));
                node = new mathMLTree.MathNode("munder", [arrowNode, lowerNode]);
              } else {
                node = paddedNode();
                node = new mathMLTree.MathNode("mover", [arrowNode, node]);
              }
              return node;
            }
          });
          const mclass_makeSpan = buildCommon.makeSpan;
          function mclass_htmlBuilder(group, options) {
            const elements = buildExpression(group.body, options, true);
            return mclass_makeSpan([group.mclass], elements, options);
          }
          function mclass_mathmlBuilder(group, options) {
            let node;
            const inner2 = buildMathML_buildExpression(group.body, options);
            if (group.mclass === "minner") {
              node = new mathMLTree.MathNode("mpadded", inner2);
            } else if (group.mclass === "mord") {
              if (group.isCharacterBox) {
                node = inner2[0];
                node.type = "mi";
              } else {
                node = new mathMLTree.MathNode("mi", inner2);
              }
            } else {
              if (group.isCharacterBox) {
                node = inner2[0];
                node.type = "mo";
              } else {
                node = new mathMLTree.MathNode("mo", inner2);
              }
              if (group.mclass === "mbin") {
                node.attributes.lspace = "0.22em";
                node.attributes.rspace = "0.22em";
              } else if (group.mclass === "mpunct") {
                node.attributes.lspace = "0em";
                node.attributes.rspace = "0.17em";
              } else if (group.mclass === "mopen" || group.mclass === "mclose") {
                node.attributes.lspace = "0em";
                node.attributes.rspace = "0em";
              } else if (group.mclass === "minner") {
                node.attributes.lspace = "0.0556em";
                node.attributes.width = "+0.1111em";
              }
            }
            return node;
          }
          defineFunction({
            type: "mclass",
            names: ["\\mathord", "\\mathbin", "\\mathrel", "\\mathopen", "\\mathclose", "\\mathpunct", "\\mathinner"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              const body = args[0];
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: "m" + funcName.slice(5),
                // TODO(kevinb): don't prefix with 'm'
                body: ordargument(body),
                isCharacterBox: utils.isCharacterBox(body)
              };
            },
            htmlBuilder: mclass_htmlBuilder,
            mathmlBuilder: mclass_mathmlBuilder
          });
          const binrelClass = (arg) => {
            const atom = arg.type === "ordgroup" && arg.body.length ? arg.body[0] : arg;
            if (atom.type === "atom" && (atom.family === "bin" || atom.family === "rel")) {
              return "m" + atom.family;
            } else {
              return "mord";
            }
          };
          defineFunction({
            type: "mclass",
            names: ["\\@binrel"],
            props: {
              numArgs: 2
            },
            handler(_ref2, args) {
              let {
                parser
              } = _ref2;
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: binrelClass(args[0]),
                body: ordargument(args[1]),
                isCharacterBox: utils.isCharacterBox(args[1])
              };
            }
          });
          defineFunction({
            type: "mclass",
            names: ["\\stackrel", "\\overset", "\\underset"],
            props: {
              numArgs: 2
            },
            handler(_ref3, args) {
              let {
                parser,
                funcName
              } = _ref3;
              const baseArg = args[1];
              const shiftedArg = args[0];
              let mclass;
              if (funcName !== "\\stackrel") {
                mclass = binrelClass(baseArg);
              } else {
                mclass = "mrel";
              }
              const baseOp = {
                type: "op",
                mode: baseArg.mode,
                limits: true,
                alwaysHandleSupSub: true,
                parentIsSupSub: false,
                symbol: false,
                suppressBaseShift: funcName !== "\\stackrel",
                body: ordargument(baseArg)
              };
              const supsub = {
                type: "supsub",
                mode: shiftedArg.mode,
                base: baseOp,
                sup: funcName === "\\underset" ? null : shiftedArg,
                sub: funcName === "\\underset" ? shiftedArg : null
              };
              return {
                type: "mclass",
                mode: parser.mode,
                mclass,
                body: [supsub],
                isCharacterBox: utils.isCharacterBox(supsub)
              };
            },
            htmlBuilder: mclass_htmlBuilder,
            mathmlBuilder: mclass_mathmlBuilder
          });
          defineFunction({
            type: "pmb",
            names: ["\\pmb"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              return {
                type: "pmb",
                mode: parser.mode,
                mclass: binrelClass(args[0]),
                body: ordargument(args[0])
              };
            },
            htmlBuilder(group, options) {
              const elements = buildExpression(group.body, options, true);
              const node = buildCommon.makeSpan([group.mclass], elements, options);
              node.style.textShadow = "0.02em 0.01em 0.04px";
              return node;
            },
            mathmlBuilder(group, style) {
              const inner2 = buildMathML_buildExpression(group.body, style);
              const node = new mathMLTree.MathNode("mstyle", inner2);
              node.setAttribute("style", "text-shadow: 0.02em 0.01em 0.04px");
              return node;
            }
          });
          const cdArrowFunctionName = {
            ">": "\\\\cdrightarrow",
            "<": "\\\\cdleftarrow",
            "=": "\\\\cdlongequal",
            "A": "\\uparrow",
            "V": "\\downarrow",
            "|": "\\Vert",
            ".": "no arrow"
          };
          const newCell = () => {
            return {
              type: "styling",
              body: [],
              mode: "math",
              style: "display"
            };
          };
          const isStartOfArrow = (node) => {
            return node.type === "textord" && node.text === "@";
          };
          const isLabelEnd = (node, endChar) => {
            return (node.type === "mathord" || node.type === "atom") && node.text === endChar;
          };
          function cdArrow(arrowChar, labels, parser) {
            const funcName = cdArrowFunctionName[arrowChar];
            switch (funcName) {
              case "\\\\cdrightarrow":
              case "\\\\cdleftarrow":
                return parser.callFunction(funcName, [labels[0]], [labels[1]]);
              case "\\uparrow":
              case "\\downarrow": {
                const leftLabel = parser.callFunction("\\\\cdleft", [labels[0]], []);
                const bareArrow = {
                  type: "atom",
                  text: funcName,
                  mode: "math",
                  family: "rel"
                };
                const sizedArrow = parser.callFunction("\\Big", [bareArrow], []);
                const rightLabel = parser.callFunction("\\\\cdright", [labels[1]], []);
                const arrowGroup = {
                  type: "ordgroup",
                  mode: "math",
                  body: [leftLabel, sizedArrow, rightLabel]
                };
                return parser.callFunction("\\\\cdparent", [arrowGroup], []);
              }
              case "\\\\cdlongequal":
                return parser.callFunction("\\\\cdlongequal", [], []);
              case "\\Vert": {
                const arrow2 = {
                  type: "textord",
                  text: "\\Vert",
                  mode: "math"
                };
                return parser.callFunction("\\Big", [arrow2], []);
              }
              default:
                return {
                  type: "textord",
                  text: " ",
                  mode: "math"
                };
            }
          }
          function parseCD(parser) {
            const parsedRows = [];
            parser.gullet.beginGroup();
            parser.gullet.macros.set("\\cr", "\\\\\\relax");
            parser.gullet.beginGroup();
            while (true) {
              parsedRows.push(parser.parseExpression(false, "\\\\"));
              parser.gullet.endGroup();
              parser.gullet.beginGroup();
              const next = parser.fetch().text;
              if (next === "&" || next === "\\\\") {
                parser.consume();
              } else if (next === "\\end") {
                if (parsedRows[parsedRows.length - 1].length === 0) {
                  parsedRows.pop();
                }
                break;
              } else {
                throw new src_ParseError("Expected \\\\ or \\cr or \\end", parser.nextToken);
              }
            }
            let row = [];
            const body = [row];
            for (let i2 = 0; i2 < parsedRows.length; i2++) {
              const rowNodes = parsedRows[i2];
              let cell = newCell();
              for (let j = 0; j < rowNodes.length; j++) {
                if (!isStartOfArrow(rowNodes[j])) {
                  cell.body.push(rowNodes[j]);
                } else {
                  row.push(cell);
                  j += 1;
                  const arrowChar = assertSymbolNodeType(rowNodes[j]).text;
                  const labels = new Array(2);
                  labels[0] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  };
                  labels[1] = {
                    type: "ordgroup",
                    mode: "math",
                    body: []
                  };
                  if ("=|.".indexOf(arrowChar) > -1) ;
                  else if ("<>AV".indexOf(arrowChar) > -1) {
                    for (let labelNum = 0; labelNum < 2; labelNum++) {
                      let inLabel = true;
                      for (let k2 = j + 1; k2 < rowNodes.length; k2++) {
                        if (isLabelEnd(rowNodes[k2], arrowChar)) {
                          inLabel = false;
                          j = k2;
                          break;
                        }
                        if (isStartOfArrow(rowNodes[k2])) {
                          throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[k2]);
                        }
                        labels[labelNum].body.push(rowNodes[k2]);
                      }
                      if (inLabel) {
                        throw new src_ParseError("Missing a " + arrowChar + " character to complete a CD arrow.", rowNodes[j]);
                      }
                    }
                  } else {
                    throw new src_ParseError('Expected one of "<>AV=|." after @', rowNodes[j]);
                  }
                  const arrow2 = cdArrow(arrowChar, labels, parser);
                  const wrappedArrow = {
                    type: "styling",
                    body: [arrow2],
                    mode: "math",
                    style: "display"
                    // CD is always displaystyle.
                  };
                  row.push(wrappedArrow);
                  cell = newCell();
                }
              }
              if (i2 % 2 === 0) {
                row.push(cell);
              } else {
                row.shift();
              }
              row = [];
              body.push(row);
            }
            parser.gullet.endGroup();
            parser.gullet.endGroup();
            const cols = new Array(body[0].length).fill({
              type: "align",
              align: "c",
              pregap: 0.25,
              // CD package sets \enskip between columns.
              postgap: 0.25
              // So pre and post each get half an \enskip, i.e. 0.25em.
            });
            return {
              type: "array",
              mode: "math",
              body,
              arraystretch: 1,
              addJot: true,
              rowGaps: [null],
              cols,
              colSeparationType: "CD",
              hLinesBeforeRow: new Array(body.length + 1).fill([])
            };
          }
          defineFunction({
            type: "cdlabel",
            names: ["\\\\cdleft", "\\\\cdright"],
            props: {
              numArgs: 1
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              return {
                type: "cdlabel",
                mode: parser.mode,
                side: funcName.slice(4),
                label: args[0]
              };
            },
            htmlBuilder(group, options) {
              const newOptions = options.havingStyle(options.style.sup());
              const label = buildCommon.wrapFragment(buildGroup(group.label, newOptions, options), options);
              label.classes.push("cd-label-" + group.side);
              label.style.bottom = makeEm(0.8 - label.depth);
              label.height = 0;
              label.depth = 0;
              return label;
            },
            mathmlBuilder(group, options) {
              let label = new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.label, options)]);
              label = new mathMLTree.MathNode("mpadded", [label]);
              label.setAttribute("width", "0");
              if (group.side === "left") {
                label.setAttribute("lspace", "-1width");
              }
              label.setAttribute("voffset", "0.7em");
              label = new mathMLTree.MathNode("mstyle", [label]);
              label.setAttribute("displaystyle", "false");
              label.setAttribute("scriptlevel", "1");
              return label;
            }
          });
          defineFunction({
            type: "cdlabelparent",
            names: ["\\\\cdparent"],
            props: {
              numArgs: 1
            },
            handler(_ref2, args) {
              let {
                parser
              } = _ref2;
              return {
                type: "cdlabelparent",
                mode: parser.mode,
                fragment: args[0]
              };
            },
            htmlBuilder(group, options) {
              const parent = buildCommon.wrapFragment(buildGroup(group.fragment, options), options);
              parent.classes.push("cd-vert-arrow");
              return parent;
            },
            mathmlBuilder(group, options) {
              return new mathMLTree.MathNode("mrow", [buildMathML_buildGroup(group.fragment, options)]);
            }
          });
          defineFunction({
            type: "textord",
            names: ["\\@char"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              const arg = assertNodeType(args[0], "ordgroup");
              const group = arg.body;
              let number = "";
              for (let i2 = 0; i2 < group.length; i2++) {
                const node = assertNodeType(group[i2], "textord");
                number += node.text;
              }
              let code = parseInt(number);
              let text;
              if (isNaN(code)) {
                throw new src_ParseError("\\@char has non-numeric argument " + number);
              } else if (code < 0 || code >= 1114111) {
                throw new src_ParseError("\\@char with invalid code point " + number);
              } else if (code <= 65535) {
                text = String.fromCharCode(code);
              } else {
                code -= 65536;
                text = String.fromCharCode((code >> 10) + 55296, (code & 1023) + 56320);
              }
              return {
                type: "textord",
                mode: parser.mode,
                text
              };
            }
          });
          const color_htmlBuilder = (group, options) => {
            const elements = buildExpression(group.body, options.withColor(group.color), false);
            return buildCommon.makeFragment(elements);
          };
          const color_mathmlBuilder = (group, options) => {
            const inner2 = buildMathML_buildExpression(group.body, options.withColor(group.color));
            const node = new mathMLTree.MathNode("mstyle", inner2);
            node.setAttribute("mathcolor", group.color);
            return node;
          };
          defineFunction({
            type: "color",
            names: ["\\textcolor"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "original"]
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              const color = assertNodeType(args[0], "color-token").color;
              const body = args[1];
              return {
                type: "color",
                mode: parser.mode,
                color,
                body: ordargument(body)
              };
            },
            htmlBuilder: color_htmlBuilder,
            mathmlBuilder: color_mathmlBuilder
          });
          defineFunction({
            type: "color",
            names: ["\\color"],
            props: {
              numArgs: 1,
              allowedInText: true,
              argTypes: ["color"]
            },
            handler(_ref2, args) {
              let {
                parser,
                breakOnTokenText
              } = _ref2;
              const color = assertNodeType(args[0], "color-token").color;
              parser.gullet.macros.set("\\current@color", color);
              const body = parser.parseExpression(true, breakOnTokenText);
              return {
                type: "color",
                mode: parser.mode,
                color,
                body
              };
            },
            htmlBuilder: color_htmlBuilder,
            mathmlBuilder: color_mathmlBuilder
          });
          defineFunction({
            type: "cr",
            names: ["\\\\"],
            props: {
              numArgs: 0,
              numOptionalArgs: 0,
              allowedInText: true
            },
            handler(_ref, args, optArgs) {
              let {
                parser
              } = _ref;
              const size2 = parser.gullet.future().text === "[" ? parser.parseSizeGroup(true) : null;
              const newLine = !parser.settings.displayMode || !parser.settings.useStrictBehavior("newLineInDisplayMode", "In LaTeX, \\\\ or \\newline does nothing in display mode");
              return {
                type: "cr",
                mode: parser.mode,
                newLine,
                size: size2 && assertNodeType(size2, "size").value
              };
            },
            // The following builders are called only at the top level,
            // not within tabular/array environments.
            htmlBuilder(group, options) {
              const span = buildCommon.makeSpan(["mspace"], [], options);
              if (group.newLine) {
                span.classes.push("newline");
                if (group.size) {
                  span.style.marginTop = makeEm(calculateSize(group.size, options));
                }
              }
              return span;
            },
            mathmlBuilder(group, options) {
              const node = new mathMLTree.MathNode("mspace");
              if (group.newLine) {
                node.setAttribute("linebreak", "newline");
                if (group.size) {
                  node.setAttribute("height", makeEm(calculateSize(group.size, options)));
                }
              }
              return node;
            }
          });
          const globalMap = {
            "\\global": "\\global",
            "\\long": "\\\\globallong",
            "\\\\globallong": "\\\\globallong",
            "\\def": "\\gdef",
            "\\gdef": "\\gdef",
            "\\edef": "\\xdef",
            "\\xdef": "\\xdef",
            "\\let": "\\\\globallet",
            "\\futurelet": "\\\\globalfuture"
          };
          const checkControlSequence = (tok) => {
            const name = tok.text;
            if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
              throw new src_ParseError("Expected a control sequence", tok);
            }
            return name;
          };
          const getRHS = (parser) => {
            let tok = parser.gullet.popToken();
            if (tok.text === "=") {
              tok = parser.gullet.popToken();
              if (tok.text === " ") {
                tok = parser.gullet.popToken();
              }
            }
            return tok;
          };
          const letCommand = (parser, name, tok, global2) => {
            let macro = parser.gullet.macros.get(tok.text);
            if (macro == null) {
              tok.noexpand = true;
              macro = {
                tokens: [tok],
                numArgs: 0,
                // reproduce the same behavior in expansion
                unexpandable: !parser.gullet.isExpandable(tok.text)
              };
            }
            parser.gullet.macros.set(name, macro, global2);
          };
          defineFunction({
            type: "internal",
            names: [
              "\\global",
              "\\long",
              "\\\\globallong"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(_ref) {
              let {
                parser,
                funcName
              } = _ref;
              parser.consumeSpaces();
              const token = parser.fetch();
              if (globalMap[token.text]) {
                if (funcName === "\\global" || funcName === "\\\\globallong") {
                  token.text = globalMap[token.text];
                }
                return assertNodeType(parser.parseFunction(), "internal");
              }
              throw new src_ParseError("Invalid token after macro prefix", token);
            }
          });
          defineFunction({
            type: "internal",
            names: ["\\def", "\\gdef", "\\edef", "\\xdef"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(_ref2) {
              let {
                parser,
                funcName
              } = _ref2;
              let tok = parser.gullet.popToken();
              const name = tok.text;
              if (/^(?:[\\{}$&#^_]|EOF)$/.test(name)) {
                throw new src_ParseError("Expected a control sequence", tok);
              }
              let numArgs = 0;
              let insert2;
              const delimiters2 = [[]];
              while (parser.gullet.future().text !== "{") {
                tok = parser.gullet.popToken();
                if (tok.text === "#") {
                  if (parser.gullet.future().text === "{") {
                    insert2 = parser.gullet.future();
                    delimiters2[numArgs].push("{");
                    break;
                  }
                  tok = parser.gullet.popToken();
                  if (!/^[1-9]$/.test(tok.text)) {
                    throw new src_ParseError('Invalid argument number "' + tok.text + '"');
                  }
                  if (parseInt(tok.text) !== numArgs + 1) {
                    throw new src_ParseError('Argument number "' + tok.text + '" out of order');
                  }
                  numArgs++;
                  delimiters2.push([]);
                } else if (tok.text === "EOF") {
                  throw new src_ParseError("Expected a macro definition");
                } else {
                  delimiters2[numArgs].push(tok.text);
                }
              }
              let {
                tokens
              } = parser.gullet.consumeArg();
              if (insert2) {
                tokens.unshift(insert2);
              }
              if (funcName === "\\edef" || funcName === "\\xdef") {
                tokens = parser.gullet.expandTokens(tokens);
                tokens.reverse();
              }
              parser.gullet.macros.set(name, {
                tokens,
                numArgs,
                delimiters: delimiters2
              }, funcName === globalMap[funcName]);
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          defineFunction({
            type: "internal",
            names: [
              "\\let",
              "\\\\globallet"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(_ref3) {
              let {
                parser,
                funcName
              } = _ref3;
              const name = checkControlSequence(parser.gullet.popToken());
              parser.gullet.consumeSpaces();
              const tok = getRHS(parser);
              letCommand(parser, name, tok, funcName === "\\\\globallet");
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          defineFunction({
            type: "internal",
            names: [
              "\\futurelet",
              "\\\\globalfuture"
              // can’t be entered directly
            ],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(_ref4) {
              let {
                parser,
                funcName
              } = _ref4;
              const name = checkControlSequence(parser.gullet.popToken());
              const middle = parser.gullet.popToken();
              const tok = parser.gullet.popToken();
              letCommand(parser, name, tok, funcName === "\\\\globalfuture");
              parser.gullet.pushToken(tok);
              parser.gullet.pushToken(middle);
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          const getMetrics = function(symbol, font, mode) {
            const replace = src_symbols.math[symbol] && src_symbols.math[symbol].replace;
            const metrics = getCharacterMetrics(replace || symbol, font, mode);
            if (!metrics) {
              throw new Error("Unsupported symbol " + symbol + " and font size " + font + ".");
            }
            return metrics;
          };
          const styleWrap = function(delim, toStyle, options, classes) {
            const newOptions = options.havingBaseStyle(toStyle);
            const span = buildCommon.makeSpan(classes.concat(newOptions.sizingClasses(options)), [delim], options);
            const delimSizeMultiplier = newOptions.sizeMultiplier / options.sizeMultiplier;
            span.height *= delimSizeMultiplier;
            span.depth *= delimSizeMultiplier;
            span.maxFontSize = newOptions.sizeMultiplier;
            return span;
          };
          const centerSpan = function(span, options, style) {
            const newOptions = options.havingBaseStyle(style);
            const shift2 = (1 - options.sizeMultiplier / newOptions.sizeMultiplier) * options.fontMetrics().axisHeight;
            span.classes.push("delimcenter");
            span.style.top = makeEm(shift2);
            span.height -= shift2;
            span.depth += shift2;
          };
          const makeSmallDelim = function(delim, style, center, options, mode, classes) {
            const text = buildCommon.makeSymbol(delim, "Main-Regular", mode, options);
            const span = styleWrap(text, style, options, classes);
            if (center) {
              centerSpan(span, options, style);
            }
            return span;
          };
          const mathrmSize = function(value, size2, mode, options) {
            return buildCommon.makeSymbol(value, "Size" + size2 + "-Regular", mode, options);
          };
          const makeLargeDelim = function(delim, size2, center, options, mode, classes) {
            const inner2 = mathrmSize(delim, size2, mode, options);
            const span = styleWrap(buildCommon.makeSpan(["delimsizing", "size" + size2], [inner2], options), src_Style.TEXT, options, classes);
            if (center) {
              centerSpan(span, options, src_Style.TEXT);
            }
            return span;
          };
          const makeGlyphSpan = function(symbol, font, mode) {
            let sizeClass;
            if (font === "Size1-Regular") {
              sizeClass = "delim-size1";
            } else {
              sizeClass = "delim-size4";
            }
            const corner = buildCommon.makeSpan(["delimsizinginner", sizeClass], [buildCommon.makeSpan([], [buildCommon.makeSymbol(symbol, font, mode)])]);
            return {
              type: "elem",
              elem: corner
            };
          };
          const makeInner = function(ch2, height, options) {
            const width = fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)] ? fontMetricsData["Size4-Regular"][ch2.charCodeAt(0)][4] : fontMetricsData["Size1-Regular"][ch2.charCodeAt(0)][4];
            const path3 = new PathNode("inner", innerPath(ch2, Math.round(1e3 * height)));
            const svgNode = new SvgNode([path3], {
              "width": makeEm(width),
              "height": makeEm(height),
              // Override CSS rule `.katex svg { width: 100% }`
              "style": "width:" + makeEm(width),
              "viewBox": "0 0 " + 1e3 * width + " " + Math.round(1e3 * height),
              "preserveAspectRatio": "xMinYMin"
            });
            const span = buildCommon.makeSvgSpan([], [svgNode], options);
            span.height = height;
            span.style.height = makeEm(height);
            span.style.width = makeEm(width);
            return {
              type: "elem",
              elem: span
            };
          };
          const lapInEms = 8e-3;
          const lap = {
            type: "kern",
            size: -1 * lapInEms
          };
          const verts = ["|", "\\lvert", "\\rvert", "\\vert"];
          const doubleVerts = ["\\|", "\\lVert", "\\rVert", "\\Vert"];
          const makeStackedDelim = function(delim, heightTotal, center, options, mode, classes) {
            let top;
            let middle;
            let repeat;
            let bottom;
            let svgLabel = "";
            let viewBoxWidth = 0;
            top = repeat = bottom = delim;
            middle = null;
            let font = "Size1-Regular";
            if (delim === "\\uparrow") {
              repeat = bottom = "⏐";
            } else if (delim === "\\Uparrow") {
              repeat = bottom = "‖";
            } else if (delim === "\\downarrow") {
              top = repeat = "⏐";
            } else if (delim === "\\Downarrow") {
              top = repeat = "‖";
            } else if (delim === "\\updownarrow") {
              top = "\\uparrow";
              repeat = "⏐";
              bottom = "\\downarrow";
            } else if (delim === "\\Updownarrow") {
              top = "\\Uparrow";
              repeat = "‖";
              bottom = "\\Downarrow";
            } else if (utils.contains(verts, delim)) {
              repeat = "∣";
              svgLabel = "vert";
              viewBoxWidth = 333;
            } else if (utils.contains(doubleVerts, delim)) {
              repeat = "∥";
              svgLabel = "doublevert";
              viewBoxWidth = 556;
            } else if (delim === "[" || delim === "\\lbrack") {
              top = "⎡";
              repeat = "⎢";
              bottom = "⎣";
              font = "Size4-Regular";
              svgLabel = "lbrack";
              viewBoxWidth = 667;
            } else if (delim === "]" || delim === "\\rbrack") {
              top = "⎤";
              repeat = "⎥";
              bottom = "⎦";
              font = "Size4-Regular";
              svgLabel = "rbrack";
              viewBoxWidth = 667;
            } else if (delim === "\\lfloor" || delim === "⌊") {
              repeat = top = "⎢";
              bottom = "⎣";
              font = "Size4-Regular";
              svgLabel = "lfloor";
              viewBoxWidth = 667;
            } else if (delim === "\\lceil" || delim === "⌈") {
              top = "⎡";
              repeat = bottom = "⎢";
              font = "Size4-Regular";
              svgLabel = "lceil";
              viewBoxWidth = 667;
            } else if (delim === "\\rfloor" || delim === "⌋") {
              repeat = top = "⎥";
              bottom = "⎦";
              font = "Size4-Regular";
              svgLabel = "rfloor";
              viewBoxWidth = 667;
            } else if (delim === "\\rceil" || delim === "⌉") {
              top = "⎤";
              repeat = bottom = "⎥";
              font = "Size4-Regular";
              svgLabel = "rceil";
              viewBoxWidth = 667;
            } else if (delim === "(" || delim === "\\lparen") {
              top = "⎛";
              repeat = "⎜";
              bottom = "⎝";
              font = "Size4-Regular";
              svgLabel = "lparen";
              viewBoxWidth = 875;
            } else if (delim === ")" || delim === "\\rparen") {
              top = "⎞";
              repeat = "⎟";
              bottom = "⎠";
              font = "Size4-Regular";
              svgLabel = "rparen";
              viewBoxWidth = 875;
            } else if (delim === "\\{" || delim === "\\lbrace") {
              top = "⎧";
              middle = "⎨";
              bottom = "⎩";
              repeat = "⎪";
              font = "Size4-Regular";
            } else if (delim === "\\}" || delim === "\\rbrace") {
              top = "⎫";
              middle = "⎬";
              bottom = "⎭";
              repeat = "⎪";
              font = "Size4-Regular";
            } else if (delim === "\\lgroup" || delim === "⟮") {
              top = "⎧";
              bottom = "⎩";
              repeat = "⎪";
              font = "Size4-Regular";
            } else if (delim === "\\rgroup" || delim === "⟯") {
              top = "⎫";
              bottom = "⎭";
              repeat = "⎪";
              font = "Size4-Regular";
            } else if (delim === "\\lmoustache" || delim === "⎰") {
              top = "⎧";
              bottom = "⎭";
              repeat = "⎪";
              font = "Size4-Regular";
            } else if (delim === "\\rmoustache" || delim === "⎱") {
              top = "⎫";
              bottom = "⎩";
              repeat = "⎪";
              font = "Size4-Regular";
            }
            const topMetrics = getMetrics(top, font, mode);
            const topHeightTotal = topMetrics.height + topMetrics.depth;
            const repeatMetrics = getMetrics(repeat, font, mode);
            const repeatHeightTotal = repeatMetrics.height + repeatMetrics.depth;
            const bottomMetrics = getMetrics(bottom, font, mode);
            const bottomHeightTotal = bottomMetrics.height + bottomMetrics.depth;
            let middleHeightTotal = 0;
            let middleFactor = 1;
            if (middle !== null) {
              const middleMetrics = getMetrics(middle, font, mode);
              middleHeightTotal = middleMetrics.height + middleMetrics.depth;
              middleFactor = 2;
            }
            const minHeight = topHeightTotal + bottomHeightTotal + middleHeightTotal;
            const repeatCount = Math.max(0, Math.ceil((heightTotal - minHeight) / (middleFactor * repeatHeightTotal)));
            const realHeightTotal = minHeight + repeatCount * middleFactor * repeatHeightTotal;
            let axisHeight = options.fontMetrics().axisHeight;
            if (center) {
              axisHeight *= options.sizeMultiplier;
            }
            const depth = realHeightTotal / 2 - axisHeight;
            const stack = [];
            if (svgLabel.length > 0) {
              const midHeight = realHeightTotal - topHeightTotal - bottomHeightTotal;
              const viewBoxHeight = Math.round(realHeightTotal * 1e3);
              const pathStr = tallDelim(svgLabel, Math.round(midHeight * 1e3));
              const path3 = new PathNode(svgLabel, pathStr);
              const width = (viewBoxWidth / 1e3).toFixed(3) + "em";
              const height = (viewBoxHeight / 1e3).toFixed(3) + "em";
              const svg = new SvgNode([path3], {
                "width": width,
                "height": height,
                "viewBox": "0 0 " + viewBoxWidth + " " + viewBoxHeight
              });
              const wrapper = buildCommon.makeSvgSpan([], [svg], options);
              wrapper.height = viewBoxHeight / 1e3;
              wrapper.style.width = width;
              wrapper.style.height = height;
              stack.push({
                type: "elem",
                elem: wrapper
              });
            } else {
              stack.push(makeGlyphSpan(bottom, font, mode));
              stack.push(lap);
              if (middle === null) {
                const innerHeight = realHeightTotal - topHeightTotal - bottomHeightTotal + 2 * lapInEms;
                stack.push(makeInner(repeat, innerHeight, options));
              } else {
                const innerHeight = (realHeightTotal - topHeightTotal - bottomHeightTotal - middleHeightTotal) / 2 + 2 * lapInEms;
                stack.push(makeInner(repeat, innerHeight, options));
                stack.push(lap);
                stack.push(makeGlyphSpan(middle, font, mode));
                stack.push(lap);
                stack.push(makeInner(repeat, innerHeight, options));
              }
              stack.push(lap);
              stack.push(makeGlyphSpan(top, font, mode));
            }
            const newOptions = options.havingBaseStyle(src_Style.TEXT);
            const inner2 = buildCommon.makeVList({
              positionType: "bottom",
              positionData: depth,
              children: stack
            }, newOptions);
            return styleWrap(buildCommon.makeSpan(["delimsizing", "mult"], [inner2], newOptions), src_Style.TEXT, options, classes);
          };
          const vbPad = 80;
          const emPad = 0.08;
          const sqrtSvg = function(sqrtName, height, viewBoxHeight, extraVinculum, options) {
            const path3 = sqrtPath(sqrtName, extraVinculum, viewBoxHeight);
            const pathNode = new PathNode(sqrtName, path3);
            const svg = new SvgNode([pathNode], {
              // Note: 1000:1 ratio of viewBox to document em width.
              "width": "400em",
              "height": makeEm(height),
              "viewBox": "0 0 400000 " + viewBoxHeight,
              "preserveAspectRatio": "xMinYMin slice"
            });
            return buildCommon.makeSvgSpan(["hide-tail"], [svg], options);
          };
          const makeSqrtImage = function(height, options) {
            const newOptions = options.havingBaseSizing();
            const delim = traverseSequence("\\surd", height * newOptions.sizeMultiplier, stackLargeDelimiterSequence, newOptions);
            let sizeMultiplier = newOptions.sizeMultiplier;
            const extraVinculum = Math.max(0, options.minRuleThickness - options.fontMetrics().sqrtRuleThickness);
            let span;
            let spanHeight = 0;
            let texHeight = 0;
            let viewBoxHeight = 0;
            let advanceWidth;
            if (delim.type === "small") {
              viewBoxHeight = 1e3 + 1e3 * extraVinculum + vbPad;
              if (height < 1) {
                sizeMultiplier = 1;
              } else if (height < 1.4) {
                sizeMultiplier = 0.7;
              }
              spanHeight = (1 + extraVinculum + emPad) / sizeMultiplier;
              texHeight = (1 + extraVinculum) / sizeMultiplier;
              span = sqrtSvg("sqrtMain", spanHeight, viewBoxHeight, extraVinculum, options);
              span.style.minWidth = "0.853em";
              advanceWidth = 0.833 / sizeMultiplier;
            } else if (delim.type === "large") {
              viewBoxHeight = (1e3 + vbPad) * sizeToMaxHeight[delim.size];
              texHeight = (sizeToMaxHeight[delim.size] + extraVinculum) / sizeMultiplier;
              spanHeight = (sizeToMaxHeight[delim.size] + extraVinculum + emPad) / sizeMultiplier;
              span = sqrtSvg("sqrtSize" + delim.size, spanHeight, viewBoxHeight, extraVinculum, options);
              span.style.minWidth = "1.02em";
              advanceWidth = 1 / sizeMultiplier;
            } else {
              spanHeight = height + extraVinculum + emPad;
              texHeight = height + extraVinculum;
              viewBoxHeight = Math.floor(1e3 * height + extraVinculum) + vbPad;
              span = sqrtSvg("sqrtTall", spanHeight, viewBoxHeight, extraVinculum, options);
              span.style.minWidth = "0.742em";
              advanceWidth = 1.056;
            }
            span.height = texHeight;
            span.style.height = makeEm(spanHeight);
            return {
              span,
              advanceWidth,
              // Calculate the actual line width.
              // This actually should depend on the chosen font -- e.g. \boldmath
              // should use the thicker surd symbols from e.g. KaTeX_Main-Bold, and
              // have thicker rules.
              ruleWidth: (options.fontMetrics().sqrtRuleThickness + extraVinculum) * sizeMultiplier
            };
          };
          const stackLargeDelimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "\\surd"];
          const stackAlwaysDelimiters = ["\\uparrow", "\\downarrow", "\\updownarrow", "\\Uparrow", "\\Downarrow", "\\Updownarrow", "|", "\\|", "\\vert", "\\Vert", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱"];
          const stackNeverDelimiters = ["<", ">", "\\langle", "\\rangle", "/", "\\backslash", "\\lt", "\\gt"];
          const sizeToMaxHeight = [0, 1.2, 1.8, 2.4, 3];
          const makeSizedDelim = function(delim, size2, options, mode, classes) {
            if (delim === "<" || delim === "\\lt" || delim === "⟨") {
              delim = "\\langle";
            } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
              delim = "\\rangle";
            }
            if (utils.contains(stackLargeDelimiters, delim) || utils.contains(stackNeverDelimiters, delim)) {
              return makeLargeDelim(delim, size2, false, options, mode, classes);
            } else if (utils.contains(stackAlwaysDelimiters, delim)) {
              return makeStackedDelim(delim, sizeToMaxHeight[size2], false, options, mode, classes);
            } else {
              throw new src_ParseError("Illegal delimiter: '" + delim + "'");
            }
          };
          const stackNeverDelimiterSequence = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }];
          const stackAlwaysDelimiterSequence = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "stack"
          }];
          const stackLargeDelimiterSequence = [{
            type: "small",
            style: src_Style.SCRIPTSCRIPT
          }, {
            type: "small",
            style: src_Style.SCRIPT
          }, {
            type: "small",
            style: src_Style.TEXT
          }, {
            type: "large",
            size: 1
          }, {
            type: "large",
            size: 2
          }, {
            type: "large",
            size: 3
          }, {
            type: "large",
            size: 4
          }, {
            type: "stack"
          }];
          const delimTypeToFont = function(type) {
            if (type.type === "small") {
              return "Main-Regular";
            } else if (type.type === "large") {
              return "Size" + type.size + "-Regular";
            } else if (type.type === "stack") {
              return "Size4-Regular";
            } else {
              throw new Error("Add support for delim type '" + type.type + "' here.");
            }
          };
          const traverseSequence = function(delim, height, sequence, options) {
            const start = Math.min(2, 3 - options.style.size);
            for (let i2 = start; i2 < sequence.length; i2++) {
              if (sequence[i2].type === "stack") {
                break;
              }
              const metrics = getMetrics(delim, delimTypeToFont(sequence[i2]), "math");
              let heightDepth = metrics.height + metrics.depth;
              if (sequence[i2].type === "small") {
                const newOptions = options.havingBaseStyle(sequence[i2].style);
                heightDepth *= newOptions.sizeMultiplier;
              }
              if (heightDepth > height) {
                return sequence[i2];
              }
            }
            return sequence[sequence.length - 1];
          };
          const makeCustomSizedDelim = function(delim, height, center, options, mode, classes) {
            if (delim === "<" || delim === "\\lt" || delim === "⟨") {
              delim = "\\langle";
            } else if (delim === ">" || delim === "\\gt" || delim === "⟩") {
              delim = "\\rangle";
            }
            let sequence;
            if (utils.contains(stackNeverDelimiters, delim)) {
              sequence = stackNeverDelimiterSequence;
            } else if (utils.contains(stackLargeDelimiters, delim)) {
              sequence = stackLargeDelimiterSequence;
            } else {
              sequence = stackAlwaysDelimiterSequence;
            }
            const delimType = traverseSequence(delim, height, sequence, options);
            if (delimType.type === "small") {
              return makeSmallDelim(delim, delimType.style, center, options, mode, classes);
            } else if (delimType.type === "large") {
              return makeLargeDelim(delim, delimType.size, center, options, mode, classes);
            } else {
              return makeStackedDelim(delim, height, center, options, mode, classes);
            }
          };
          const makeLeftRightDelim = function(delim, height, depth, options, mode, classes) {
            const axisHeight = options.fontMetrics().axisHeight * options.sizeMultiplier;
            const delimiterFactor = 901;
            const delimiterExtend = 5 / options.fontMetrics().ptPerEm;
            const maxDistFromAxis = Math.max(height - axisHeight, depth + axisHeight);
            const totalHeight = Math.max(
              // In real TeX, calculations are done using integral values which are
              // 65536 per pt, or 655360 per em. So, the division here truncates in
              // TeX but doesn't here, producing different results. If we wanted to
              // exactly match TeX's calculation, we could do
              //   Math.floor(655360 * maxDistFromAxis / 500) *
              //    delimiterFactor / 655360
              // (To see the difference, compare
              //    x^{x^{\left(\rule{0.1em}{0.68em}\right)}}
              // in TeX and KaTeX)
              maxDistFromAxis / 500 * delimiterFactor,
              2 * maxDistFromAxis - delimiterExtend
            );
            return makeCustomSizedDelim(delim, totalHeight, true, options, mode, classes);
          };
          var delimiter = {
            sqrtImage: makeSqrtImage,
            sizedDelim: makeSizedDelim,
            sizeToMaxHeight,
            customSizedDelim: makeCustomSizedDelim,
            leftRightDelim: makeLeftRightDelim
          };
          const delimiterSizes = {
            "\\bigl": {
              mclass: "mopen",
              size: 1
            },
            "\\Bigl": {
              mclass: "mopen",
              size: 2
            },
            "\\biggl": {
              mclass: "mopen",
              size: 3
            },
            "\\Biggl": {
              mclass: "mopen",
              size: 4
            },
            "\\bigr": {
              mclass: "mclose",
              size: 1
            },
            "\\Bigr": {
              mclass: "mclose",
              size: 2
            },
            "\\biggr": {
              mclass: "mclose",
              size: 3
            },
            "\\Biggr": {
              mclass: "mclose",
              size: 4
            },
            "\\bigm": {
              mclass: "mrel",
              size: 1
            },
            "\\Bigm": {
              mclass: "mrel",
              size: 2
            },
            "\\biggm": {
              mclass: "mrel",
              size: 3
            },
            "\\Biggm": {
              mclass: "mrel",
              size: 4
            },
            "\\big": {
              mclass: "mord",
              size: 1
            },
            "\\Big": {
              mclass: "mord",
              size: 2
            },
            "\\bigg": {
              mclass: "mord",
              size: 3
            },
            "\\Bigg": {
              mclass: "mord",
              size: 4
            }
          };
          const delimiters = ["(", "\\lparen", ")", "\\rparen", "[", "\\lbrack", "]", "\\rbrack", "\\{", "\\lbrace", "\\}", "\\rbrace", "\\lfloor", "\\rfloor", "⌊", "⌋", "\\lceil", "\\rceil", "⌈", "⌉", "<", ">", "\\langle", "⟨", "\\rangle", "⟩", "\\lt", "\\gt", "\\lvert", "\\rvert", "\\lVert", "\\rVert", "\\lgroup", "\\rgroup", "⟮", "⟯", "\\lmoustache", "\\rmoustache", "⎰", "⎱", "/", "\\backslash", "|", "\\vert", "\\|", "\\Vert", "\\uparrow", "\\Uparrow", "\\downarrow", "\\Downarrow", "\\updownarrow", "\\Updownarrow", "."];
          function checkDelimiter(delim, context) {
            const symDelim = checkSymbolNodeType(delim);
            if (symDelim && utils.contains(delimiters, symDelim.text)) {
              return symDelim;
            } else if (symDelim) {
              throw new src_ParseError("Invalid delimiter '" + symDelim.text + "' after '" + context.funcName + "'", delim);
            } else {
              throw new src_ParseError("Invalid delimiter type '" + delim.type + "'", delim);
            }
          }
          defineFunction({
            type: "delimsizing",
            names: ["\\bigl", "\\Bigl", "\\biggl", "\\Biggl", "\\bigr", "\\Bigr", "\\biggr", "\\Biggr", "\\bigm", "\\Bigm", "\\biggm", "\\Biggm", "\\big", "\\Big", "\\bigg", "\\Bigg"],
            props: {
              numArgs: 1,
              argTypes: ["primitive"]
            },
            handler: (context, args) => {
              const delim = checkDelimiter(args[0], context);
              return {
                type: "delimsizing",
                mode: context.parser.mode,
                size: delimiterSizes[context.funcName].size,
                mclass: delimiterSizes[context.funcName].mclass,
                delim: delim.text
              };
            },
            htmlBuilder: (group, options) => {
              if (group.delim === ".") {
                return buildCommon.makeSpan([group.mclass]);
              }
              return delimiter.sizedDelim(group.delim, group.size, options, group.mode, [group.mclass]);
            },
            mathmlBuilder: (group) => {
              const children = [];
              if (group.delim !== ".") {
                children.push(makeText(group.delim, group.mode));
              }
              const node = new mathMLTree.MathNode("mo", children);
              if (group.mclass === "mopen" || group.mclass === "mclose") {
                node.setAttribute("fence", "true");
              } else {
                node.setAttribute("fence", "false");
              }
              node.setAttribute("stretchy", "true");
              const size2 = makeEm(delimiter.sizeToMaxHeight[group.size]);
              node.setAttribute("minsize", size2);
              node.setAttribute("maxsize", size2);
              return node;
            }
          });
          function assertParsed(group) {
            if (!group.body) {
              throw new Error("Bug: The leftright ParseNode wasn't fully parsed.");
            }
          }
          defineFunction({
            type: "leftright-right",
            names: ["\\right"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (context, args) => {
              const color = context.parser.gullet.macros.get("\\current@color");
              if (color && typeof color !== "string") {
                throw new src_ParseError("\\current@color set to non-string in \\right");
              }
              return {
                type: "leftright-right",
                mode: context.parser.mode,
                delim: checkDelimiter(args[0], context).text,
                color
                // undefined if not set via \color
              };
            }
          });
          defineFunction({
            type: "leftright",
            names: ["\\left"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (context, args) => {
              const delim = checkDelimiter(args[0], context);
              const parser = context.parser;
              ++parser.leftrightDepth;
              const body = parser.parseExpression(false);
              --parser.leftrightDepth;
              parser.expect("\\right", false);
              const right = assertNodeType(parser.parseFunction(), "leftright-right");
              return {
                type: "leftright",
                mode: parser.mode,
                body,
                left: delim.text,
                right: right.delim,
                rightColor: right.color
              };
            },
            htmlBuilder: (group, options) => {
              assertParsed(group);
              const inner2 = buildExpression(group.body, options, true, ["mopen", "mclose"]);
              let innerHeight = 0;
              let innerDepth = 0;
              let hadMiddle = false;
              for (let i2 = 0; i2 < inner2.length; i2++) {
                if (inner2[i2].isMiddle) {
                  hadMiddle = true;
                } else {
                  innerHeight = Math.max(inner2[i2].height, innerHeight);
                  innerDepth = Math.max(inner2[i2].depth, innerDepth);
                }
              }
              innerHeight *= options.sizeMultiplier;
              innerDepth *= options.sizeMultiplier;
              let leftDelim;
              if (group.left === ".") {
                leftDelim = makeNullDelimiter(options, ["mopen"]);
              } else {
                leftDelim = delimiter.leftRightDelim(group.left, innerHeight, innerDepth, options, group.mode, ["mopen"]);
              }
              inner2.unshift(leftDelim);
              if (hadMiddle) {
                for (let i2 = 1; i2 < inner2.length; i2++) {
                  const middleDelim = inner2[i2];
                  const isMiddle = middleDelim.isMiddle;
                  if (isMiddle) {
                    inner2[i2] = delimiter.leftRightDelim(isMiddle.delim, innerHeight, innerDepth, isMiddle.options, group.mode, []);
                  }
                }
              }
              let rightDelim;
              if (group.right === ".") {
                rightDelim = makeNullDelimiter(options, ["mclose"]);
              } else {
                const colorOptions = group.rightColor ? options.withColor(group.rightColor) : options;
                rightDelim = delimiter.leftRightDelim(group.right, innerHeight, innerDepth, colorOptions, group.mode, ["mclose"]);
              }
              inner2.push(rightDelim);
              return buildCommon.makeSpan(["minner"], inner2, options);
            },
            mathmlBuilder: (group, options) => {
              assertParsed(group);
              const inner2 = buildMathML_buildExpression(group.body, options);
              if (group.left !== ".") {
                const leftNode = new mathMLTree.MathNode("mo", [makeText(group.left, group.mode)]);
                leftNode.setAttribute("fence", "true");
                inner2.unshift(leftNode);
              }
              if (group.right !== ".") {
                const rightNode = new mathMLTree.MathNode("mo", [makeText(group.right, group.mode)]);
                rightNode.setAttribute("fence", "true");
                if (group.rightColor) {
                  rightNode.setAttribute("mathcolor", group.rightColor);
                }
                inner2.push(rightNode);
              }
              return makeRow(inner2);
            }
          });
          defineFunction({
            type: "middle",
            names: ["\\middle"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (context, args) => {
              const delim = checkDelimiter(args[0], context);
              if (!context.parser.leftrightDepth) {
                throw new src_ParseError("\\middle without preceding \\left", delim);
              }
              return {
                type: "middle",
                mode: context.parser.mode,
                delim: delim.text
              };
            },
            htmlBuilder: (group, options) => {
              let middleDelim;
              if (group.delim === ".") {
                middleDelim = makeNullDelimiter(options, []);
              } else {
                middleDelim = delimiter.sizedDelim(group.delim, 1, options, group.mode, []);
                const isMiddle = {
                  delim: group.delim,
                  options
                };
                middleDelim.isMiddle = isMiddle;
              }
              return middleDelim;
            },
            mathmlBuilder: (group, options) => {
              const textNode = group.delim === "\\vert" || group.delim === "|" ? makeText("|", "text") : makeText(group.delim, group.mode);
              const middleNode = new mathMLTree.MathNode("mo", [textNode]);
              middleNode.setAttribute("fence", "true");
              middleNode.setAttribute("lspace", "0.05em");
              middleNode.setAttribute("rspace", "0.05em");
              return middleNode;
            }
          });
          const enclose_htmlBuilder = (group, options) => {
            const inner2 = buildCommon.wrapFragment(buildGroup(group.body, options), options);
            const label = group.label.slice(1);
            let scale = options.sizeMultiplier;
            let img;
            let imgShift = 0;
            const isSingleChar = utils.isCharacterBox(group.body);
            if (label === "sout") {
              img = buildCommon.makeSpan(["stretchy", "sout"]);
              img.height = options.fontMetrics().defaultRuleThickness / scale;
              imgShift = -0.5 * options.fontMetrics().xHeight;
            } else if (label === "phase") {
              const lineWeight = calculateSize({
                number: 0.6,
                unit: "pt"
              }, options);
              const clearance = calculateSize({
                number: 0.35,
                unit: "ex"
              }, options);
              const newOptions = options.havingBaseSizing();
              scale = scale / newOptions.sizeMultiplier;
              const angleHeight = inner2.height + inner2.depth + lineWeight + clearance;
              inner2.style.paddingLeft = makeEm(angleHeight / 2 + lineWeight);
              const viewBoxHeight = Math.floor(1e3 * angleHeight * scale);
              const path3 = phasePath(viewBoxHeight);
              const svgNode = new SvgNode([new PathNode("phase", path3)], {
                "width": "400em",
                "height": makeEm(viewBoxHeight / 1e3),
                "viewBox": "0 0 400000 " + viewBoxHeight,
                "preserveAspectRatio": "xMinYMin slice"
              });
              img = buildCommon.makeSvgSpan(["hide-tail"], [svgNode], options);
              img.style.height = makeEm(angleHeight);
              imgShift = inner2.depth + lineWeight + clearance;
            } else {
              if (/cancel/.test(label)) {
                if (!isSingleChar) {
                  inner2.classes.push("cancel-pad");
                }
              } else if (label === "angl") {
                inner2.classes.push("anglpad");
              } else {
                inner2.classes.push("boxpad");
              }
              let topPad = 0;
              let bottomPad = 0;
              let ruleThickness = 0;
              if (/box/.test(label)) {
                ruleThickness = Math.max(
                  options.fontMetrics().fboxrule,
                  // default
                  options.minRuleThickness
                  // User override.
                );
                topPad = options.fontMetrics().fboxsep + (label === "colorbox" ? 0 : ruleThickness);
                bottomPad = topPad;
              } else if (label === "angl") {
                ruleThickness = Math.max(options.fontMetrics().defaultRuleThickness, options.minRuleThickness);
                topPad = 4 * ruleThickness;
                bottomPad = Math.max(0, 0.25 - inner2.depth);
              } else {
                topPad = isSingleChar ? 0.2 : 0;
                bottomPad = topPad;
              }
              img = stretchy.encloseSpan(inner2, label, topPad, bottomPad, options);
              if (/fbox|boxed|fcolorbox/.test(label)) {
                img.style.borderStyle = "solid";
                img.style.borderWidth = makeEm(ruleThickness);
              } else if (label === "angl" && ruleThickness !== 0.049) {
                img.style.borderTopWidth = makeEm(ruleThickness);
                img.style.borderRightWidth = makeEm(ruleThickness);
              }
              imgShift = inner2.depth + bottomPad;
              if (group.backgroundColor) {
                img.style.backgroundColor = group.backgroundColor;
                if (group.borderColor) {
                  img.style.borderColor = group.borderColor;
                }
              }
            }
            let vlist;
            if (group.backgroundColor) {
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [
                  // Put the color background behind inner;
                  {
                    type: "elem",
                    elem: img,
                    shift: imgShift
                  },
                  {
                    type: "elem",
                    elem: inner2,
                    shift: 0
                  }
                ]
              }, options);
            } else {
              const classes = /cancel|phase/.test(label) ? ["svg-align"] : [];
              vlist = buildCommon.makeVList({
                positionType: "individualShift",
                children: [
                  // Write the \cancel stroke on top of inner.
                  {
                    type: "elem",
                    elem: inner2,
                    shift: 0
                  },
                  {
                    type: "elem",
                    elem: img,
                    shift: imgShift,
                    wrapperClasses: classes
                  }
                ]
              }, options);
            }
            if (/cancel/.test(label)) {
              vlist.height = inner2.height;
              vlist.depth = inner2.depth;
            }
            if (/cancel/.test(label) && !isSingleChar) {
              return buildCommon.makeSpan(["mord", "cancel-lap"], [vlist], options);
            } else {
              return buildCommon.makeSpan(["mord"], [vlist], options);
            }
          };
          const enclose_mathmlBuilder = (group, options) => {
            let fboxsep = 0;
            const node = new mathMLTree.MathNode(group.label.indexOf("colorbox") > -1 ? "mpadded" : "menclose", [buildMathML_buildGroup(group.body, options)]);
            switch (group.label) {
              case "\\cancel":
                node.setAttribute("notation", "updiagonalstrike");
                break;
              case "\\bcancel":
                node.setAttribute("notation", "downdiagonalstrike");
                break;
              case "\\phase":
                node.setAttribute("notation", "phasorangle");
                break;
              case "\\sout":
                node.setAttribute("notation", "horizontalstrike");
                break;
              case "\\fbox":
                node.setAttribute("notation", "box");
                break;
              case "\\angl":
                node.setAttribute("notation", "actuarial");
                break;
              case "\\fcolorbox":
              case "\\colorbox":
                fboxsep = options.fontMetrics().fboxsep * options.fontMetrics().ptPerEm;
                node.setAttribute("width", "+" + 2 * fboxsep + "pt");
                node.setAttribute("height", "+" + 2 * fboxsep + "pt");
                node.setAttribute("lspace", fboxsep + "pt");
                node.setAttribute("voffset", fboxsep + "pt");
                if (group.label === "\\fcolorbox") {
                  const thk = Math.max(
                    options.fontMetrics().fboxrule,
                    // default
                    options.minRuleThickness
                    // user override
                  );
                  node.setAttribute("style", "border: " + thk + "em solid " + String(group.borderColor));
                }
                break;
              case "\\xcancel":
                node.setAttribute("notation", "updiagonalstrike downdiagonalstrike");
                break;
            }
            if (group.backgroundColor) {
              node.setAttribute("mathbackground", group.backgroundColor);
            }
            return node;
          };
          defineFunction({
            type: "enclose",
            names: ["\\colorbox"],
            props: {
              numArgs: 2,
              allowedInText: true,
              argTypes: ["color", "text"]
            },
            handler(_ref, args, optArgs) {
              let {
                parser,
                funcName
              } = _ref;
              const color = assertNodeType(args[0], "color-token").color;
              const body = args[1];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                backgroundColor: color,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          defineFunction({
            type: "enclose",
            names: ["\\fcolorbox"],
            props: {
              numArgs: 3,
              allowedInText: true,
              argTypes: ["color", "color", "text"]
            },
            handler(_ref2, args, optArgs) {
              let {
                parser,
                funcName
              } = _ref2;
              const borderColor = assertNodeType(args[0], "color-token").color;
              const backgroundColor = assertNodeType(args[1], "color-token").color;
              const body = args[2];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                backgroundColor,
                borderColor,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          defineFunction({
            type: "enclose",
            names: ["\\fbox"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: true
            },
            handler(_ref3, args) {
              let {
                parser
              } = _ref3;
              return {
                type: "enclose",
                mode: parser.mode,
                label: "\\fbox",
                body: args[0]
              };
            }
          });
          defineFunction({
            type: "enclose",
            names: ["\\cancel", "\\bcancel", "\\xcancel", "\\sout", "\\phase"],
            props: {
              numArgs: 1
            },
            handler(_ref4, args) {
              let {
                parser,
                funcName
              } = _ref4;
              const body = args[0];
              return {
                type: "enclose",
                mode: parser.mode,
                label: funcName,
                body
              };
            },
            htmlBuilder: enclose_htmlBuilder,
            mathmlBuilder: enclose_mathmlBuilder
          });
          defineFunction({
            type: "enclose",
            names: ["\\angl"],
            props: {
              numArgs: 1,
              argTypes: ["hbox"],
              allowedInText: false
            },
            handler(_ref5, args) {
              let {
                parser
              } = _ref5;
              return {
                type: "enclose",
                mode: parser.mode,
                label: "\\angl",
                body: args[0]
              };
            }
          });
          const _environments = {};
          function defineEnvironment(_ref) {
            let {
              type,
              names,
              props,
              handler,
              htmlBuilder: htmlBuilder2,
              mathmlBuilder: mathmlBuilder2
            } = _ref;
            const data = {
              type,
              numArgs: props.numArgs || 0,
              allowedInText: false,
              numOptionalArgs: 0,
              handler
            };
            for (let i2 = 0; i2 < names.length; ++i2) {
              _environments[names[i2]] = data;
            }
            if (htmlBuilder2) {
              _htmlGroupBuilders[type] = htmlBuilder2;
            }
            if (mathmlBuilder2) {
              _mathmlGroupBuilders[type] = mathmlBuilder2;
            }
          }
          const _macros = {};
          function defineMacro(name, body) {
            _macros[name] = body;
          }
          class SourceLocation {
            // The + prefix indicates that these fields aren't writeable
            // Lexer holding the input string.
            // Start offset, zero-based inclusive.
            // End offset, zero-based exclusive.
            constructor(lexer, start, end) {
              this.lexer = void 0;
              this.start = void 0;
              this.end = void 0;
              this.lexer = lexer;
              this.start = start;
              this.end = end;
            }
            /**
             * Merges two `SourceLocation`s from location providers, given they are
             * provided in order of appearance.
             * - Returns the first one's location if only the first is provided.
             * - Returns a merged range of the first and the last if both are provided
             *   and their lexers match.
             * - Otherwise, returns null.
             */
            static range(first, second) {
              if (!second) {
                return first && first.loc;
              } else if (!first || !first.loc || !second.loc || first.loc.lexer !== second.loc.lexer) {
                return null;
              } else {
                return new SourceLocation(first.loc.lexer, first.loc.start, second.loc.end);
              }
            }
          }
          class Token {
            // don't expand the token
            // used in \noexpand
            constructor(text, loc) {
              this.text = void 0;
              this.loc = void 0;
              this.noexpand = void 0;
              this.treatAsRelax = void 0;
              this.text = text;
              this.loc = loc;
            }
            /**
             * Given a pair of tokens (this and endToken), compute a `Token` encompassing
             * the whole input range enclosed by these two.
             */
            range(endToken, text) {
              return new Token(text, SourceLocation.range(this, endToken));
            }
          }
          function getHLines(parser) {
            const hlineInfo = [];
            parser.consumeSpaces();
            let nxt = parser.fetch().text;
            if (nxt === "\\relax") {
              parser.consume();
              parser.consumeSpaces();
              nxt = parser.fetch().text;
            }
            while (nxt === "\\hline" || nxt === "\\hdashline") {
              parser.consume();
              hlineInfo.push(nxt === "\\hdashline");
              parser.consumeSpaces();
              nxt = parser.fetch().text;
            }
            return hlineInfo;
          }
          const validateAmsEnvironmentContext = (context) => {
            const settings = context.parser.settings;
            if (!settings.displayMode) {
              throw new src_ParseError("{" + context.envName + "} can be used only in display mode.");
            }
          };
          function getAutoTag(name) {
            if (name.indexOf("ed") === -1) {
              return name.indexOf("*") === -1;
            }
          }
          function parseArray(parser, _ref, style) {
            let {
              hskipBeforeAndAfter,
              addJot,
              cols,
              arraystretch,
              colSeparationType,
              autoTag,
              singleRow,
              emptySingleRow,
              maxNumCols,
              leqno
            } = _ref;
            parser.gullet.beginGroup();
            if (!singleRow) {
              parser.gullet.macros.set("\\cr", "\\\\\\relax");
            }
            if (!arraystretch) {
              const stretch = parser.gullet.expandMacroAsText("\\arraystretch");
              if (stretch == null) {
                arraystretch = 1;
              } else {
                arraystretch = parseFloat(stretch);
                if (!arraystretch || arraystretch < 0) {
                  throw new src_ParseError("Invalid \\arraystretch: " + stretch);
                }
              }
            }
            parser.gullet.beginGroup();
            let row = [];
            const body = [row];
            const rowGaps = [];
            const hLinesBeforeRow = [];
            const tags = autoTag != null ? [] : void 0;
            function beginRow() {
              if (autoTag) {
                parser.gullet.macros.set("\\@eqnsw", "1", true);
              }
            }
            function endRow() {
              if (tags) {
                if (parser.gullet.macros.get("\\df@tag")) {
                  tags.push(parser.subparse([new Token("\\df@tag")]));
                  parser.gullet.macros.set("\\df@tag", void 0, true);
                } else {
                  tags.push(Boolean(autoTag) && parser.gullet.macros.get("\\@eqnsw") === "1");
                }
              }
            }
            beginRow();
            hLinesBeforeRow.push(getHLines(parser));
            while (true) {
              let cell = parser.parseExpression(false, singleRow ? "\\end" : "\\\\");
              parser.gullet.endGroup();
              parser.gullet.beginGroup();
              cell = {
                type: "ordgroup",
                mode: parser.mode,
                body: cell
              };
              if (style) {
                cell = {
                  type: "styling",
                  mode: parser.mode,
                  style,
                  body: [cell]
                };
              }
              row.push(cell);
              const next = parser.fetch().text;
              if (next === "&") {
                if (maxNumCols && row.length === maxNumCols) {
                  if (singleRow || colSeparationType) {
                    throw new src_ParseError("Too many tab characters: &", parser.nextToken);
                  } else {
                    parser.settings.reportNonstrict("textEnv", "Too few columns specified in the {array} column argument.");
                  }
                }
                parser.consume();
              } else if (next === "\\end") {
                endRow();
                if (row.length === 1 && cell.type === "styling" && cell.body[0].body.length === 0 && (body.length > 1 || !emptySingleRow)) {
                  body.pop();
                }
                if (hLinesBeforeRow.length < body.length + 1) {
                  hLinesBeforeRow.push([]);
                }
                break;
              } else if (next === "\\\\") {
                parser.consume();
                let size2;
                if (parser.gullet.future().text !== " ") {
                  size2 = parser.parseSizeGroup(true);
                }
                rowGaps.push(size2 ? size2.value : null);
                endRow();
                hLinesBeforeRow.push(getHLines(parser));
                row = [];
                body.push(row);
                beginRow();
              } else {
                throw new src_ParseError("Expected & or \\\\ or \\cr or \\end", parser.nextToken);
              }
            }
            parser.gullet.endGroup();
            parser.gullet.endGroup();
            return {
              type: "array",
              mode: parser.mode,
              addJot,
              arraystretch,
              body,
              cols,
              rowGaps,
              hskipBeforeAndAfter,
              hLinesBeforeRow,
              colSeparationType,
              tags,
              leqno
            };
          }
          function dCellStyle(envName) {
            if (envName.slice(0, 1) === "d") {
              return "display";
            } else {
              return "text";
            }
          }
          const array_htmlBuilder = function(group, options) {
            let r2;
            let c2;
            const nr = group.body.length;
            const hLinesBeforeRow = group.hLinesBeforeRow;
            let nc2 = 0;
            let body = new Array(nr);
            const hlines = [];
            const ruleThickness = Math.max(
              // From LaTeX \showthe\arrayrulewidth. Equals 0.04 em.
              options.fontMetrics().arrayRuleWidth,
              options.minRuleThickness
              // User override.
            );
            const pt = 1 / options.fontMetrics().ptPerEm;
            let arraycolsep = 5 * pt;
            if (group.colSeparationType && group.colSeparationType === "small") {
              const localMultiplier = options.havingStyle(src_Style.SCRIPT).sizeMultiplier;
              arraycolsep = 0.2778 * (localMultiplier / options.sizeMultiplier);
            }
            const baselineskip = group.colSeparationType === "CD" ? calculateSize({
              number: 3,
              unit: "ex"
            }, options) : 12 * pt;
            const jot = 3 * pt;
            const arrayskip = group.arraystretch * baselineskip;
            const arstrutHeight = 0.7 * arrayskip;
            const arstrutDepth = 0.3 * arrayskip;
            let totalHeight = 0;
            function setHLinePos(hlinesInGap) {
              for (let i2 = 0; i2 < hlinesInGap.length; ++i2) {
                if (i2 > 0) {
                  totalHeight += 0.25;
                }
                hlines.push({
                  pos: totalHeight,
                  isDashed: hlinesInGap[i2]
                });
              }
            }
            setHLinePos(hLinesBeforeRow[0]);
            for (r2 = 0; r2 < group.body.length; ++r2) {
              const inrow = group.body[r2];
              let height = arstrutHeight;
              let depth = arstrutDepth;
              if (nc2 < inrow.length) {
                nc2 = inrow.length;
              }
              const outrow = new Array(inrow.length);
              for (c2 = 0; c2 < inrow.length; ++c2) {
                const elt = buildGroup(inrow[c2], options);
                if (depth < elt.depth) {
                  depth = elt.depth;
                }
                if (height < elt.height) {
                  height = elt.height;
                }
                outrow[c2] = elt;
              }
              const rowGap = group.rowGaps[r2];
              let gap = 0;
              if (rowGap) {
                gap = calculateSize(rowGap, options);
                if (gap > 0) {
                  gap += arstrutDepth;
                  if (depth < gap) {
                    depth = gap;
                  }
                  gap = 0;
                }
              }
              if (group.addJot) {
                depth += jot;
              }
              outrow.height = height;
              outrow.depth = depth;
              totalHeight += height;
              outrow.pos = totalHeight;
              totalHeight += depth + gap;
              body[r2] = outrow;
              setHLinePos(hLinesBeforeRow[r2 + 1]);
            }
            const offset2 = totalHeight / 2 + options.fontMetrics().axisHeight;
            const colDescriptions = group.cols || [];
            const cols = [];
            let colSep;
            let colDescrNum;
            const tagSpans = [];
            if (group.tags && group.tags.some((tag) => tag)) {
              for (r2 = 0; r2 < nr; ++r2) {
                const rw = body[r2];
                const shift2 = rw.pos - offset2;
                const tag = group.tags[r2];
                let tagSpan;
                if (tag === true) {
                  tagSpan = buildCommon.makeSpan(["eqn-num"], [], options);
                } else if (tag === false) {
                  tagSpan = buildCommon.makeSpan([], [], options);
                } else {
                  tagSpan = buildCommon.makeSpan([], buildExpression(tag, options, true), options);
                }
                tagSpan.depth = rw.depth;
                tagSpan.height = rw.height;
                tagSpans.push({
                  type: "elem",
                  elem: tagSpan,
                  shift: shift2
                });
              }
            }
            for (
              c2 = 0, colDescrNum = 0;
              // Continue while either there are more columns or more column
              // descriptions, so trailing separators don't get lost.
              c2 < nc2 || colDescrNum < colDescriptions.length;
              ++c2, ++colDescrNum
            ) {
              let colDescr = colDescriptions[colDescrNum] || {};
              let firstSeparator = true;
              while (colDescr.type === "separator") {
                if (!firstSeparator) {
                  colSep = buildCommon.makeSpan(["arraycolsep"], []);
                  colSep.style.width = makeEm(options.fontMetrics().doubleRuleSep);
                  cols.push(colSep);
                }
                if (colDescr.separator === "|" || colDescr.separator === ":") {
                  const lineType = colDescr.separator === "|" ? "solid" : "dashed";
                  const separator = buildCommon.makeSpan(["vertical-separator"], [], options);
                  separator.style.height = makeEm(totalHeight);
                  separator.style.borderRightWidth = makeEm(ruleThickness);
                  separator.style.borderRightStyle = lineType;
                  separator.style.margin = "0 " + makeEm(-ruleThickness / 2);
                  const shift2 = totalHeight - offset2;
                  if (shift2) {
                    separator.style.verticalAlign = makeEm(-shift2);
                  }
                  cols.push(separator);
                } else {
                  throw new src_ParseError("Invalid separator type: " + colDescr.separator);
                }
                colDescrNum++;
                colDescr = colDescriptions[colDescrNum] || {};
                firstSeparator = false;
              }
              if (c2 >= nc2) {
                continue;
              }
              let sepwidth;
              if (c2 > 0 || group.hskipBeforeAndAfter) {
                sepwidth = utils.deflt(colDescr.pregap, arraycolsep);
                if (sepwidth !== 0) {
                  colSep = buildCommon.makeSpan(["arraycolsep"], []);
                  colSep.style.width = makeEm(sepwidth);
                  cols.push(colSep);
                }
              }
              let col = [];
              for (r2 = 0; r2 < nr; ++r2) {
                const row = body[r2];
                const elem = row[c2];
                if (!elem) {
                  continue;
                }
                const shift2 = row.pos - offset2;
                elem.depth = row.depth;
                elem.height = row.height;
                col.push({
                  type: "elem",
                  elem,
                  shift: shift2
                });
              }
              col = buildCommon.makeVList({
                positionType: "individualShift",
                children: col
              }, options);
              col = buildCommon.makeSpan(["col-align-" + (colDescr.align || "c")], [col]);
              cols.push(col);
              if (c2 < nc2 - 1 || group.hskipBeforeAndAfter) {
                sepwidth = utils.deflt(colDescr.postgap, arraycolsep);
                if (sepwidth !== 0) {
                  colSep = buildCommon.makeSpan(["arraycolsep"], []);
                  colSep.style.width = makeEm(sepwidth);
                  cols.push(colSep);
                }
              }
            }
            body = buildCommon.makeSpan(["mtable"], cols);
            if (hlines.length > 0) {
              const line = buildCommon.makeLineSpan("hline", options, ruleThickness);
              const dashes = buildCommon.makeLineSpan("hdashline", options, ruleThickness);
              const vListElems = [{
                type: "elem",
                elem: body,
                shift: 0
              }];
              while (hlines.length > 0) {
                const hline = hlines.pop();
                const lineShift = hline.pos - offset2;
                if (hline.isDashed) {
                  vListElems.push({
                    type: "elem",
                    elem: dashes,
                    shift: lineShift
                  });
                } else {
                  vListElems.push({
                    type: "elem",
                    elem: line,
                    shift: lineShift
                  });
                }
              }
              body = buildCommon.makeVList({
                positionType: "individualShift",
                children: vListElems
              }, options);
            }
            if (tagSpans.length === 0) {
              return buildCommon.makeSpan(["mord"], [body], options);
            } else {
              let eqnNumCol = buildCommon.makeVList({
                positionType: "individualShift",
                children: tagSpans
              }, options);
              eqnNumCol = buildCommon.makeSpan(["tag"], [eqnNumCol], options);
              return buildCommon.makeFragment([body, eqnNumCol]);
            }
          };
          const alignMap = {
            c: "center ",
            l: "left ",
            r: "right "
          };
          const array_mathmlBuilder = function(group, options) {
            const tbl = [];
            const glue = new mathMLTree.MathNode("mtd", [], ["mtr-glue"]);
            const tag = new mathMLTree.MathNode("mtd", [], ["mml-eqn-num"]);
            for (let i2 = 0; i2 < group.body.length; i2++) {
              const rw = group.body[i2];
              const row = [];
              for (let j = 0; j < rw.length; j++) {
                row.push(new mathMLTree.MathNode("mtd", [buildMathML_buildGroup(rw[j], options)]));
              }
              if (group.tags && group.tags[i2]) {
                row.unshift(glue);
                row.push(glue);
                if (group.leqno) {
                  row.unshift(tag);
                } else {
                  row.push(tag);
                }
              }
              tbl.push(new mathMLTree.MathNode("mtr", row));
            }
            let table = new mathMLTree.MathNode("mtable", tbl);
            const gap = group.arraystretch === 0.5 ? 0.1 : 0.16 + group.arraystretch - 1 + (group.addJot ? 0.09 : 0);
            table.setAttribute("rowspacing", makeEm(gap));
            let menclose = "";
            let align = "";
            if (group.cols && group.cols.length > 0) {
              const cols = group.cols;
              let columnLines = "";
              let prevTypeWasAlign = false;
              let iStart = 0;
              let iEnd = cols.length;
              if (cols[0].type === "separator") {
                menclose += "top ";
                iStart = 1;
              }
              if (cols[cols.length - 1].type === "separator") {
                menclose += "bottom ";
                iEnd -= 1;
              }
              for (let i2 = iStart; i2 < iEnd; i2++) {
                if (cols[i2].type === "align") {
                  align += alignMap[cols[i2].align];
                  if (prevTypeWasAlign) {
                    columnLines += "none ";
                  }
                  prevTypeWasAlign = true;
                } else if (cols[i2].type === "separator") {
                  if (prevTypeWasAlign) {
                    columnLines += cols[i2].separator === "|" ? "solid " : "dashed ";
                    prevTypeWasAlign = false;
                  }
                }
              }
              table.setAttribute("columnalign", align.trim());
              if (/[sd]/.test(columnLines)) {
                table.setAttribute("columnlines", columnLines.trim());
              }
            }
            if (group.colSeparationType === "align") {
              const cols = group.cols || [];
              let spacing2 = "";
              for (let i2 = 1; i2 < cols.length; i2++) {
                spacing2 += i2 % 2 ? "0em " : "1em ";
              }
              table.setAttribute("columnspacing", spacing2.trim());
            } else if (group.colSeparationType === "alignat" || group.colSeparationType === "gather") {
              table.setAttribute("columnspacing", "0em");
            } else if (group.colSeparationType === "small") {
              table.setAttribute("columnspacing", "0.2778em");
            } else if (group.colSeparationType === "CD") {
              table.setAttribute("columnspacing", "0.5em");
            } else {
              table.setAttribute("columnspacing", "1em");
            }
            let rowLines = "";
            const hlines = group.hLinesBeforeRow;
            menclose += hlines[0].length > 0 ? "left " : "";
            menclose += hlines[hlines.length - 1].length > 0 ? "right " : "";
            for (let i2 = 1; i2 < hlines.length - 1; i2++) {
              rowLines += hlines[i2].length === 0 ? "none " : hlines[i2][0] ? "dashed " : "solid ";
            }
            if (/[sd]/.test(rowLines)) {
              table.setAttribute("rowlines", rowLines.trim());
            }
            if (menclose !== "") {
              table = new mathMLTree.MathNode("menclose", [table]);
              table.setAttribute("notation", menclose.trim());
            }
            if (group.arraystretch && group.arraystretch < 1) {
              table = new mathMLTree.MathNode("mstyle", [table]);
              table.setAttribute("scriptlevel", "1");
            }
            return table;
          };
          const alignedHandler = function(context, args) {
            if (context.envName.indexOf("ed") === -1) {
              validateAmsEnvironmentContext(context);
            }
            const cols = [];
            const separationType = context.envName.indexOf("at") > -1 ? "alignat" : "align";
            const isSplit = context.envName === "split";
            const res = parseArray(context.parser, {
              cols,
              addJot: true,
              autoTag: isSplit ? void 0 : getAutoTag(context.envName),
              emptySingleRow: true,
              colSeparationType: separationType,
              maxNumCols: isSplit ? 2 : void 0,
              leqno: context.parser.settings.leqno
            }, "display");
            let numMaths;
            let numCols = 0;
            const emptyGroup = {
              type: "ordgroup",
              mode: context.mode,
              body: []
            };
            if (args[0] && args[0].type === "ordgroup") {
              let arg0 = "";
              for (let i2 = 0; i2 < args[0].body.length; i2++) {
                const textord2 = assertNodeType(args[0].body[i2], "textord");
                arg0 += textord2.text;
              }
              numMaths = Number(arg0);
              numCols = numMaths * 2;
            }
            const isAligned = !numCols;
            res.body.forEach(function(row) {
              for (let i2 = 1; i2 < row.length; i2 += 2) {
                const styling = assertNodeType(row[i2], "styling");
                const ordgroup = assertNodeType(styling.body[0], "ordgroup");
                ordgroup.body.unshift(emptyGroup);
              }
              if (!isAligned) {
                const curMaths = row.length / 2;
                if (numMaths < curMaths) {
                  throw new src_ParseError("Too many math in a row: " + ("expected " + numMaths + ", but got " + curMaths), row[0]);
                }
              } else if (numCols < row.length) {
                numCols = row.length;
              }
            });
            for (let i2 = 0; i2 < numCols; ++i2) {
              let align = "r";
              let pregap = 0;
              if (i2 % 2 === 1) {
                align = "l";
              } else if (i2 > 0 && isAligned) {
                pregap = 1;
              }
              cols[i2] = {
                type: "align",
                align,
                pregap,
                postgap: 0
              };
            }
            res.colSeparationType = isAligned ? "align" : "alignat";
            return res;
          };
          defineEnvironment({
            type: "array",
            names: ["array", "darray"],
            props: {
              numArgs: 1
            },
            handler(context, args) {
              const symNode = checkSymbolNodeType(args[0]);
              const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
              const cols = colalign.map(function(nde) {
                const node = assertSymbolNodeType(nde);
                const ca2 = node.text;
                if ("lcr".indexOf(ca2) !== -1) {
                  return {
                    type: "align",
                    align: ca2
                  };
                } else if (ca2 === "|") {
                  return {
                    type: "separator",
                    separator: "|"
                  };
                } else if (ca2 === ":") {
                  return {
                    type: "separator",
                    separator: ":"
                  };
                }
                throw new src_ParseError("Unknown column alignment: " + ca2, nde);
              });
              const res = {
                cols,
                hskipBeforeAndAfter: true,
                // \@preamble in lttab.dtx
                maxNumCols: cols.length
              };
              return parseArray(context.parser, res, dCellStyle(context.envName));
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["matrix", "pmatrix", "bmatrix", "Bmatrix", "vmatrix", "Vmatrix", "matrix*", "pmatrix*", "bmatrix*", "Bmatrix*", "vmatrix*", "Vmatrix*"],
            props: {
              numArgs: 0
            },
            handler(context) {
              const delimiters2 = {
                "matrix": null,
                "pmatrix": ["(", ")"],
                "bmatrix": ["[", "]"],
                "Bmatrix": ["\\{", "\\}"],
                "vmatrix": ["|", "|"],
                "Vmatrix": ["\\Vert", "\\Vert"]
              }[context.envName.replace("*", "")];
              let colAlign = "c";
              const payload = {
                hskipBeforeAndAfter: false,
                cols: [{
                  type: "align",
                  align: colAlign
                }]
              };
              if (context.envName.charAt(context.envName.length - 1) === "*") {
                const parser = context.parser;
                parser.consumeSpaces();
                if (parser.fetch().text === "[") {
                  parser.consume();
                  parser.consumeSpaces();
                  colAlign = parser.fetch().text;
                  if ("lcr".indexOf(colAlign) === -1) {
                    throw new src_ParseError("Expected l or c or r", parser.nextToken);
                  }
                  parser.consume();
                  parser.consumeSpaces();
                  parser.expect("]");
                  parser.consume();
                  payload.cols = [{
                    type: "align",
                    align: colAlign
                  }];
                }
              }
              const res = parseArray(context.parser, payload, dCellStyle(context.envName));
              const numCols = Math.max(0, ...res.body.map((row) => row.length));
              res.cols = new Array(numCols).fill({
                type: "align",
                align: colAlign
              });
              return delimiters2 ? {
                type: "leftright",
                mode: context.mode,
                body: [res],
                left: delimiters2[0],
                right: delimiters2[1],
                rightColor: void 0
                // \right uninfluenced by \color in array
              } : res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["smallmatrix"],
            props: {
              numArgs: 0
            },
            handler(context) {
              const payload = {
                arraystretch: 0.5
              };
              const res = parseArray(context.parser, payload, "script");
              res.colSeparationType = "small";
              return res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["subarray"],
            props: {
              numArgs: 1
            },
            handler(context, args) {
              const symNode = checkSymbolNodeType(args[0]);
              const colalign = symNode ? [args[0]] : assertNodeType(args[0], "ordgroup").body;
              const cols = colalign.map(function(nde) {
                const node = assertSymbolNodeType(nde);
                const ca2 = node.text;
                if ("lc".indexOf(ca2) !== -1) {
                  return {
                    type: "align",
                    align: ca2
                  };
                }
                throw new src_ParseError("Unknown column alignment: " + ca2, nde);
              });
              if (cols.length > 1) {
                throw new src_ParseError("{subarray} can contain only one column");
              }
              let res = {
                cols,
                hskipBeforeAndAfter: false,
                arraystretch: 0.5
              };
              res = parseArray(context.parser, res, "script");
              if (res.body.length > 0 && res.body[0].length > 1) {
                throw new src_ParseError("{subarray} can contain only one column");
              }
              return res;
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["cases", "dcases", "rcases", "drcases"],
            props: {
              numArgs: 0
            },
            handler(context) {
              const payload = {
                arraystretch: 1.2,
                cols: [{
                  type: "align",
                  align: "l",
                  pregap: 0,
                  // TODO(kevinb) get the current style.
                  // For now we use the metrics for TEXT style which is what we were
                  // doing before.  Before attempting to get the current style we
                  // should look at TeX's behavior especially for \over and matrices.
                  postgap: 1
                  /* 1em quad */
                }, {
                  type: "align",
                  align: "l",
                  pregap: 0,
                  postgap: 0
                }]
              };
              const res = parseArray(context.parser, payload, dCellStyle(context.envName));
              return {
                type: "leftright",
                mode: context.mode,
                body: [res],
                left: context.envName.indexOf("r") > -1 ? "." : "\\{",
                right: context.envName.indexOf("r") > -1 ? "\\}" : ".",
                rightColor: void 0
              };
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["align", "align*", "aligned", "split"],
            props: {
              numArgs: 0
            },
            handler: alignedHandler,
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["gathered", "gather", "gather*"],
            props: {
              numArgs: 0
            },
            handler(context) {
              if (utils.contains(["gather", "gather*"], context.envName)) {
                validateAmsEnvironmentContext(context);
              }
              const res = {
                cols: [{
                  type: "align",
                  align: "c"
                }],
                addJot: true,
                colSeparationType: "gather",
                autoTag: getAutoTag(context.envName),
                emptySingleRow: true,
                leqno: context.parser.settings.leqno
              };
              return parseArray(context.parser, res, "display");
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["alignat", "alignat*", "alignedat"],
            props: {
              numArgs: 1
            },
            handler: alignedHandler,
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["equation", "equation*"],
            props: {
              numArgs: 0
            },
            handler(context) {
              validateAmsEnvironmentContext(context);
              const res = {
                autoTag: getAutoTag(context.envName),
                emptySingleRow: true,
                singleRow: true,
                maxNumCols: 1,
                leqno: context.parser.settings.leqno
              };
              return parseArray(context.parser, res, "display");
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineEnvironment({
            type: "array",
            names: ["CD"],
            props: {
              numArgs: 0
            },
            handler(context) {
              validateAmsEnvironmentContext(context);
              return parseCD(context.parser);
            },
            htmlBuilder: array_htmlBuilder,
            mathmlBuilder: array_mathmlBuilder
          });
          defineMacro("\\nonumber", "\\gdef\\@eqnsw{0}");
          defineMacro("\\notag", "\\nonumber");
          defineFunction({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\hline", "\\hdashline"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: true
            },
            handler(context, args) {
              throw new src_ParseError(context.funcName + " valid only within array environment");
            }
          });
          const environments = _environments;
          var src_environments = environments;
          defineFunction({
            type: "environment",
            names: ["\\begin", "\\end"],
            props: {
              numArgs: 1,
              argTypes: ["text"]
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              const nameGroup = args[0];
              if (nameGroup.type !== "ordgroup") {
                throw new src_ParseError("Invalid environment name", nameGroup);
              }
              let envName = "";
              for (let i2 = 0; i2 < nameGroup.body.length; ++i2) {
                envName += assertNodeType(nameGroup.body[i2], "textord").text;
              }
              if (funcName === "\\begin") {
                if (!src_environments.hasOwnProperty(envName)) {
                  throw new src_ParseError("No such environment: " + envName, nameGroup);
                }
                const env = src_environments[envName];
                const {
                  args: args2,
                  optArgs
                } = parser.parseArguments("\\begin{" + envName + "}", env);
                const context = {
                  mode: parser.mode,
                  envName,
                  parser
                };
                const result = env.handler(context, args2, optArgs);
                parser.expect("\\end", false);
                const endNameToken = parser.nextToken;
                const end = assertNodeType(parser.parseFunction(), "environment");
                if (end.name !== envName) {
                  throw new src_ParseError("Mismatch: \\begin{" + envName + "} matched by \\end{" + end.name + "}", endNameToken);
                }
                return result;
              }
              return {
                type: "environment",
                mode: parser.mode,
                name: envName,
                nameGroup
              };
            }
          });
          const font_htmlBuilder = (group, options) => {
            const font = group.font;
            const newOptions = options.withFont(font);
            return buildGroup(group.body, newOptions);
          };
          const font_mathmlBuilder = (group, options) => {
            const font = group.font;
            const newOptions = options.withFont(font);
            return buildMathML_buildGroup(group.body, newOptions);
          };
          const fontAliases = {
            "\\Bbb": "\\mathbb",
            "\\bold": "\\mathbf",
            "\\frak": "\\mathfrak",
            "\\bm": "\\boldsymbol"
          };
          defineFunction({
            type: "font",
            names: [
              // styles, except \boldsymbol defined below
              "\\mathrm",
              "\\mathit",
              "\\mathbf",
              "\\mathnormal",
              "\\mathsfit",
              // families
              "\\mathbb",
              "\\mathcal",
              "\\mathfrak",
              "\\mathscr",
              "\\mathsf",
              "\\mathtt",
              // aliases, except \bm defined below
              "\\Bbb",
              "\\bold",
              "\\frak"
            ],
            props: {
              numArgs: 1,
              allowedInArgument: true
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const body = normalizeArgument(args[0]);
              let func = funcName;
              if (func in fontAliases) {
                func = fontAliases[func];
              }
              return {
                type: "font",
                mode: parser.mode,
                font: func.slice(1),
                body
              };
            },
            htmlBuilder: font_htmlBuilder,
            mathmlBuilder: font_mathmlBuilder
          });
          defineFunction({
            type: "mclass",
            names: ["\\boldsymbol", "\\bm"],
            props: {
              numArgs: 1
            },
            handler: (_ref2, args) => {
              let {
                parser
              } = _ref2;
              const body = args[0];
              const isCharacterBox2 = utils.isCharacterBox(body);
              return {
                type: "mclass",
                mode: parser.mode,
                mclass: binrelClass(body),
                body: [{
                  type: "font",
                  mode: parser.mode,
                  font: "boldsymbol",
                  body
                }],
                isCharacterBox: isCharacterBox2
              };
            }
          });
          defineFunction({
            type: "font",
            names: ["\\rm", "\\sf", "\\tt", "\\bf", "\\it", "\\cal"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (_ref3, args) => {
              let {
                parser,
                funcName,
                breakOnTokenText
              } = _ref3;
              const {
                mode
              } = parser;
              const body = parser.parseExpression(true, breakOnTokenText);
              const style = "math" + funcName.slice(1);
              return {
                type: "font",
                mode,
                font: style,
                body: {
                  type: "ordgroup",
                  mode: parser.mode,
                  body
                }
              };
            },
            htmlBuilder: font_htmlBuilder,
            mathmlBuilder: font_mathmlBuilder
          });
          const adjustStyle = (size2, originalStyle) => {
            let style = originalStyle;
            if (size2 === "display") {
              style = style.id >= src_Style.SCRIPT.id ? style.text() : src_Style.DISPLAY;
            } else if (size2 === "text" && style.size === src_Style.DISPLAY.size) {
              style = src_Style.TEXT;
            } else if (size2 === "script") {
              style = src_Style.SCRIPT;
            } else if (size2 === "scriptscript") {
              style = src_Style.SCRIPTSCRIPT;
            }
            return style;
          };
          const genfrac_htmlBuilder = (group, options) => {
            const style = adjustStyle(group.size, options.style);
            const nstyle = style.fracNum();
            const dstyle = style.fracDen();
            let newOptions;
            newOptions = options.havingStyle(nstyle);
            const numerm = buildGroup(group.numer, newOptions, options);
            if (group.continued) {
              const hStrut = 8.5 / options.fontMetrics().ptPerEm;
              const dStrut = 3.5 / options.fontMetrics().ptPerEm;
              numerm.height = numerm.height < hStrut ? hStrut : numerm.height;
              numerm.depth = numerm.depth < dStrut ? dStrut : numerm.depth;
            }
            newOptions = options.havingStyle(dstyle);
            const denomm = buildGroup(group.denom, newOptions, options);
            let rule;
            let ruleWidth;
            let ruleSpacing;
            if (group.hasBarLine) {
              if (group.barSize) {
                ruleWidth = calculateSize(group.barSize, options);
                rule = buildCommon.makeLineSpan("frac-line", options, ruleWidth);
              } else {
                rule = buildCommon.makeLineSpan("frac-line", options);
              }
              ruleWidth = rule.height;
              ruleSpacing = rule.height;
            } else {
              rule = null;
              ruleWidth = 0;
              ruleSpacing = options.fontMetrics().defaultRuleThickness;
            }
            let numShift;
            let clearance;
            let denomShift;
            if (style.size === src_Style.DISPLAY.size || group.size === "display") {
              numShift = options.fontMetrics().num1;
              if (ruleWidth > 0) {
                clearance = 3 * ruleSpacing;
              } else {
                clearance = 7 * ruleSpacing;
              }
              denomShift = options.fontMetrics().denom1;
            } else {
              if (ruleWidth > 0) {
                numShift = options.fontMetrics().num2;
                clearance = ruleSpacing;
              } else {
                numShift = options.fontMetrics().num3;
                clearance = 3 * ruleSpacing;
              }
              denomShift = options.fontMetrics().denom2;
            }
            let frac;
            if (!rule) {
              const candidateClearance = numShift - numerm.depth - (denomm.height - denomShift);
              if (candidateClearance < clearance) {
                numShift += 0.5 * (clearance - candidateClearance);
                denomShift += 0.5 * (clearance - candidateClearance);
              }
              frac = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: denomm,
                  shift: denomShift
                }, {
                  type: "elem",
                  elem: numerm,
                  shift: -numShift
                }]
              }, options);
            } else {
              const axisHeight = options.fontMetrics().axisHeight;
              if (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth) < clearance) {
                numShift += clearance - (numShift - numerm.depth - (axisHeight + 0.5 * ruleWidth));
              }
              if (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift) < clearance) {
                denomShift += clearance - (axisHeight - 0.5 * ruleWidth - (denomm.height - denomShift));
              }
              const midShift = -(axisHeight - 0.5 * ruleWidth);
              frac = buildCommon.makeVList({
                positionType: "individualShift",
                children: [{
                  type: "elem",
                  elem: denomm,
                  shift: denomShift
                }, {
                  type: "elem",
                  elem: rule,
                  shift: midShift
                }, {
                  type: "elem",
                  elem: numerm,
                  shift: -numShift
                }]
              }, options);
            }
            newOptions = options.havingStyle(style);
            frac.height *= newOptions.sizeMultiplier / options.sizeMultiplier;
            frac.depth *= newOptions.sizeMultiplier / options.sizeMultiplier;
            let delimSize;
            if (style.size === src_Style.DISPLAY.size) {
              delimSize = options.fontMetrics().delim1;
            } else if (style.size === src_Style.SCRIPTSCRIPT.size) {
              delimSize = options.havingStyle(src_Style.SCRIPT).fontMetrics().delim2;
            } else {
              delimSize = options.fontMetrics().delim2;
            }
            let leftDelim;
            let rightDelim;
            if (group.leftDelim == null) {
              leftDelim = makeNullDelimiter(options, ["mopen"]);
            } else {
              leftDelim = delimiter.customSizedDelim(group.leftDelim, delimSize, true, options.havingStyle(style), group.mode, ["mopen"]);
            }
            if (group.continued) {
              rightDelim = buildCommon.makeSpan([]);
            } else if (group.rightDelim == null) {
              rightDelim = makeNullDelimiter(options, ["mclose"]);
            } else {
              rightDelim = delimiter.customSizedDelim(group.rightDelim, delimSize, true, options.havingStyle(style), group.mode, ["mclose"]);
            }
            return buildCommon.makeSpan(["mord"].concat(newOptions.sizingClasses(options)), [leftDelim, buildCommon.makeSpan(["mfrac"], [frac]), rightDelim], options);
          };
          const genfrac_mathmlBuilder = (group, options) => {
            let node = new mathMLTree.MathNode("mfrac", [buildMathML_buildGroup(group.numer, options), buildMathML_buildGroup(group.denom, options)]);
            if (!group.hasBarLine) {
              node.setAttribute("linethickness", "0px");
            } else if (group.barSize) {
              const ruleWidth = calculateSize(group.barSize, options);
              node.setAttribute("linethickness", makeEm(ruleWidth));
            }
            const style = adjustStyle(group.size, options.style);
            if (style.size !== options.style.size) {
              node = new mathMLTree.MathNode("mstyle", [node]);
              const isDisplay = style.size === src_Style.DISPLAY.size ? "true" : "false";
              node.setAttribute("displaystyle", isDisplay);
              node.setAttribute("scriptlevel", "0");
            }
            if (group.leftDelim != null || group.rightDelim != null) {
              const withDelims = [];
              if (group.leftDelim != null) {
                const leftOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.leftDelim.replace("\\", ""))]);
                leftOp.setAttribute("fence", "true");
                withDelims.push(leftOp);
              }
              withDelims.push(node);
              if (group.rightDelim != null) {
                const rightOp = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode(group.rightDelim.replace("\\", ""))]);
                rightOp.setAttribute("fence", "true");
                withDelims.push(rightOp);
              }
              return makeRow(withDelims);
            }
            return node;
          };
          defineFunction({
            type: "genfrac",
            names: [
              "\\dfrac",
              "\\frac",
              "\\tfrac",
              "\\dbinom",
              "\\binom",
              "\\tbinom",
              "\\\\atopfrac",
              // can’t be entered directly
              "\\\\bracefrac",
              "\\\\brackfrac"
              // ditto
            ],
            props: {
              numArgs: 2,
              allowedInArgument: true
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const numer = args[0];
              const denom = args[1];
              let hasBarLine;
              let leftDelim = null;
              let rightDelim = null;
              let size2 = "auto";
              switch (funcName) {
                case "\\dfrac":
                case "\\frac":
                case "\\tfrac":
                  hasBarLine = true;
                  break;
                case "\\\\atopfrac":
                  hasBarLine = false;
                  break;
                case "\\dbinom":
                case "\\binom":
                case "\\tbinom":
                  hasBarLine = false;
                  leftDelim = "(";
                  rightDelim = ")";
                  break;
                case "\\\\bracefrac":
                  hasBarLine = false;
                  leftDelim = "\\{";
                  rightDelim = "\\}";
                  break;
                case "\\\\brackfrac":
                  hasBarLine = false;
                  leftDelim = "[";
                  rightDelim = "]";
                  break;
                default:
                  throw new Error("Unrecognized genfrac command");
              }
              switch (funcName) {
                case "\\dfrac":
                case "\\dbinom":
                  size2 = "display";
                  break;
                case "\\tfrac":
                case "\\tbinom":
                  size2 = "text";
                  break;
              }
              return {
                type: "genfrac",
                mode: parser.mode,
                continued: false,
                numer,
                denom,
                hasBarLine,
                leftDelim,
                rightDelim,
                size: size2,
                barSize: null
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          defineFunction({
            type: "genfrac",
            names: ["\\cfrac"],
            props: {
              numArgs: 2
            },
            handler: (_ref2, args) => {
              let {
                parser,
                funcName
              } = _ref2;
              const numer = args[0];
              const denom = args[1];
              return {
                type: "genfrac",
                mode: parser.mode,
                continued: true,
                numer,
                denom,
                hasBarLine: true,
                leftDelim: null,
                rightDelim: null,
                size: "display",
                barSize: null
              };
            }
          });
          defineFunction({
            type: "infix",
            names: ["\\over", "\\choose", "\\atop", "\\brace", "\\brack"],
            props: {
              numArgs: 0,
              infix: true
            },
            handler(_ref3) {
              let {
                parser,
                funcName,
                token
              } = _ref3;
              let replaceWith;
              switch (funcName) {
                case "\\over":
                  replaceWith = "\\frac";
                  break;
                case "\\choose":
                  replaceWith = "\\binom";
                  break;
                case "\\atop":
                  replaceWith = "\\\\atopfrac";
                  break;
                case "\\brace":
                  replaceWith = "\\\\bracefrac";
                  break;
                case "\\brack":
                  replaceWith = "\\\\brackfrac";
                  break;
                default:
                  throw new Error("Unrecognized infix genfrac command");
              }
              return {
                type: "infix",
                mode: parser.mode,
                replaceWith,
                token
              };
            }
          });
          const stylArray = ["display", "text", "script", "scriptscript"];
          const delimFromValue = function(delimString) {
            let delim = null;
            if (delimString.length > 0) {
              delim = delimString;
              delim = delim === "." ? null : delim;
            }
            return delim;
          };
          defineFunction({
            type: "genfrac",
            names: ["\\genfrac"],
            props: {
              numArgs: 6,
              allowedInArgument: true,
              argTypes: ["math", "math", "size", "text", "math", "math"]
            },
            handler(_ref4, args) {
              let {
                parser
              } = _ref4;
              const numer = args[4];
              const denom = args[5];
              const leftNode = normalizeArgument(args[0]);
              const leftDelim = leftNode.type === "atom" && leftNode.family === "open" ? delimFromValue(leftNode.text) : null;
              const rightNode = normalizeArgument(args[1]);
              const rightDelim = rightNode.type === "atom" && rightNode.family === "close" ? delimFromValue(rightNode.text) : null;
              const barNode = assertNodeType(args[2], "size");
              let hasBarLine;
              let barSize = null;
              if (barNode.isBlank) {
                hasBarLine = true;
              } else {
                barSize = barNode.value;
                hasBarLine = barSize.number > 0;
              }
              let size2 = "auto";
              let styl = args[3];
              if (styl.type === "ordgroup") {
                if (styl.body.length > 0) {
                  const textOrd = assertNodeType(styl.body[0], "textord");
                  size2 = stylArray[Number(textOrd.text)];
                }
              } else {
                styl = assertNodeType(styl, "textord");
                size2 = stylArray[Number(styl.text)];
              }
              return {
                type: "genfrac",
                mode: parser.mode,
                numer,
                denom,
                continued: false,
                hasBarLine,
                barSize,
                leftDelim,
                rightDelim,
                size: size2
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          defineFunction({
            type: "infix",
            names: ["\\above"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              infix: true
            },
            handler(_ref5, args) {
              let {
                parser,
                funcName,
                token
              } = _ref5;
              return {
                type: "infix",
                mode: parser.mode,
                replaceWith: "\\\\abovefrac",
                size: assertNodeType(args[0], "size").value,
                token
              };
            }
          });
          defineFunction({
            type: "genfrac",
            names: ["\\\\abovefrac"],
            props: {
              numArgs: 3,
              argTypes: ["math", "size", "math"]
            },
            handler: (_ref6, args) => {
              let {
                parser,
                funcName
              } = _ref6;
              const numer = args[0];
              const barSize = assert(assertNodeType(args[1], "infix").size);
              const denom = args[2];
              const hasBarLine = barSize.number > 0;
              return {
                type: "genfrac",
                mode: parser.mode,
                numer,
                denom,
                continued: false,
                hasBarLine,
                barSize,
                leftDelim: null,
                rightDelim: null,
                size: "auto"
              };
            },
            htmlBuilder: genfrac_htmlBuilder,
            mathmlBuilder: genfrac_mathmlBuilder
          });
          const horizBrace_htmlBuilder = (grp, options) => {
            const style = options.style;
            let supSubGroup;
            let group;
            if (grp.type === "supsub") {
              supSubGroup = grp.sup ? buildGroup(grp.sup, options.havingStyle(style.sup()), options) : buildGroup(grp.sub, options.havingStyle(style.sub()), options);
              group = assertNodeType(grp.base, "horizBrace");
            } else {
              group = assertNodeType(grp, "horizBrace");
            }
            const body = buildGroup(group.base, options.havingBaseStyle(src_Style.DISPLAY));
            const braceBody = stretchy.svgSpan(group, options);
            let vlist;
            if (group.isOver) {
              vlist = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: body
                }, {
                  type: "kern",
                  size: 0.1
                }, {
                  type: "elem",
                  elem: braceBody
                }]
              }, options);
              vlist.children[0].children[0].children[1].classes.push("svg-align");
            } else {
              vlist = buildCommon.makeVList({
                positionType: "bottom",
                positionData: body.depth + 0.1 + braceBody.height,
                children: [{
                  type: "elem",
                  elem: braceBody
                }, {
                  type: "kern",
                  size: 0.1
                }, {
                  type: "elem",
                  elem: body
                }]
              }, options);
              vlist.children[0].children[0].children[0].classes.push("svg-align");
            }
            if (supSubGroup) {
              const vSpan = buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
              if (group.isOver) {
                vlist = buildCommon.makeVList({
                  positionType: "firstBaseline",
                  children: [{
                    type: "elem",
                    elem: vSpan
                  }, {
                    type: "kern",
                    size: 0.2
                  }, {
                    type: "elem",
                    elem: supSubGroup
                  }]
                }, options);
              } else {
                vlist = buildCommon.makeVList({
                  positionType: "bottom",
                  positionData: vSpan.depth + 0.2 + supSubGroup.height + supSubGroup.depth,
                  children: [{
                    type: "elem",
                    elem: supSubGroup
                  }, {
                    type: "kern",
                    size: 0.2
                  }, {
                    type: "elem",
                    elem: vSpan
                  }]
                }, options);
              }
            }
            return buildCommon.makeSpan(["mord", group.isOver ? "mover" : "munder"], [vlist], options);
          };
          const horizBrace_mathmlBuilder = (group, options) => {
            const accentNode = stretchy.mathMLnode(group.label);
            return new mathMLTree.MathNode(group.isOver ? "mover" : "munder", [buildMathML_buildGroup(group.base, options), accentNode]);
          };
          defineFunction({
            type: "horizBrace",
            names: ["\\overbrace", "\\underbrace"],
            props: {
              numArgs: 1
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              return {
                type: "horizBrace",
                mode: parser.mode,
                label: funcName,
                isOver: /^\\over/.test(funcName),
                base: args[0]
              };
            },
            htmlBuilder: horizBrace_htmlBuilder,
            mathmlBuilder: horizBrace_mathmlBuilder
          });
          defineFunction({
            type: "href",
            names: ["\\href"],
            props: {
              numArgs: 2,
              argTypes: ["url", "original"],
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser
              } = _ref;
              const body = args[1];
              const href = assertNodeType(args[0], "url").url;
              if (!parser.settings.isTrusted({
                command: "\\href",
                url: href
              })) {
                return parser.formatUnsupportedCmd("\\href");
              }
              return {
                type: "href",
                mode: parser.mode,
                href,
                body: ordargument(body)
              };
            },
            htmlBuilder: (group, options) => {
              const elements = buildExpression(group.body, options, false);
              return buildCommon.makeAnchor(group.href, [], elements, options);
            },
            mathmlBuilder: (group, options) => {
              let math2 = buildExpressionRow(group.body, options);
              if (!(math2 instanceof MathNode)) {
                math2 = new MathNode("mrow", [math2]);
              }
              math2.setAttribute("href", group.href);
              return math2;
            }
          });
          defineFunction({
            type: "href",
            names: ["\\url"],
            props: {
              numArgs: 1,
              argTypes: ["url"],
              allowedInText: true
            },
            handler: (_ref2, args) => {
              let {
                parser
              } = _ref2;
              const href = assertNodeType(args[0], "url").url;
              if (!parser.settings.isTrusted({
                command: "\\url",
                url: href
              })) {
                return parser.formatUnsupportedCmd("\\url");
              }
              const chars2 = [];
              for (let i2 = 0; i2 < href.length; i2++) {
                let c2 = href[i2];
                if (c2 === "~") {
                  c2 = "\\textasciitilde";
                }
                chars2.push({
                  type: "textord",
                  mode: "text",
                  text: c2
                });
              }
              const body = {
                type: "text",
                mode: parser.mode,
                font: "\\texttt",
                body: chars2
              };
              return {
                type: "href",
                mode: parser.mode,
                href,
                body: ordargument(body)
              };
            }
          });
          defineFunction({
            type: "hbox",
            names: ["\\hbox"],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInText: true,
              primitive: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              return {
                type: "hbox",
                mode: parser.mode,
                body: ordargument(args[0])
              };
            },
            htmlBuilder(group, options) {
              const elements = buildExpression(group.body, options, false);
              return buildCommon.makeFragment(elements);
            },
            mathmlBuilder(group, options) {
              return new mathMLTree.MathNode("mrow", buildMathML_buildExpression(group.body, options));
            }
          });
          defineFunction({
            type: "html",
            names: ["\\htmlClass", "\\htmlId", "\\htmlStyle", "\\htmlData"],
            props: {
              numArgs: 2,
              argTypes: ["raw", "original"],
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName,
                token
              } = _ref;
              const value = assertNodeType(args[0], "raw").string;
              const body = args[1];
              if (parser.settings.strict) {
                parser.settings.reportNonstrict("htmlExtension", "HTML extension is disabled on strict mode");
              }
              let trustContext;
              const attributes = {};
              switch (funcName) {
                case "\\htmlClass":
                  attributes.class = value;
                  trustContext = {
                    command: "\\htmlClass",
                    class: value
                  };
                  break;
                case "\\htmlId":
                  attributes.id = value;
                  trustContext = {
                    command: "\\htmlId",
                    id: value
                  };
                  break;
                case "\\htmlStyle":
                  attributes.style = value;
                  trustContext = {
                    command: "\\htmlStyle",
                    style: value
                  };
                  break;
                case "\\htmlData": {
                  const data = value.split(",");
                  for (let i2 = 0; i2 < data.length; i2++) {
                    const keyVal = data[i2].split("=");
                    if (keyVal.length !== 2) {
                      throw new src_ParseError("Error parsing key-value for \\htmlData");
                    }
                    attributes["data-" + keyVal[0].trim()] = keyVal[1].trim();
                  }
                  trustContext = {
                    command: "\\htmlData",
                    attributes
                  };
                  break;
                }
                default:
                  throw new Error("Unrecognized html command");
              }
              if (!parser.settings.isTrusted(trustContext)) {
                return parser.formatUnsupportedCmd(funcName);
              }
              return {
                type: "html",
                mode: parser.mode,
                attributes,
                body: ordargument(body)
              };
            },
            htmlBuilder: (group, options) => {
              const elements = buildExpression(group.body, options, false);
              const classes = ["enclosing"];
              if (group.attributes.class) {
                classes.push(...group.attributes.class.trim().split(/\s+/));
              }
              const span = buildCommon.makeSpan(classes, elements, options);
              for (const attr in group.attributes) {
                if (attr !== "class" && group.attributes.hasOwnProperty(attr)) {
                  span.setAttribute(attr, group.attributes[attr]);
                }
              }
              return span;
            },
            mathmlBuilder: (group, options) => {
              return buildExpressionRow(group.body, options);
            }
          });
          defineFunction({
            type: "htmlmathml",
            names: ["\\html@mathml"],
            props: {
              numArgs: 2,
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser
              } = _ref;
              return {
                type: "htmlmathml",
                mode: parser.mode,
                html: ordargument(args[0]),
                mathml: ordargument(args[1])
              };
            },
            htmlBuilder: (group, options) => {
              const elements = buildExpression(group.html, options, false);
              return buildCommon.makeFragment(elements);
            },
            mathmlBuilder: (group, options) => {
              return buildExpressionRow(group.mathml, options);
            }
          });
          const sizeData = function(str) {
            if (/^[-+]? *(\d+(\.\d*)?|\.\d+)$/.test(str)) {
              return {
                number: +str,
                unit: "bp"
              };
            } else {
              const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(str);
              if (!match) {
                throw new src_ParseError("Invalid size: '" + str + "' in \\includegraphics");
              }
              const data = {
                number: +(match[1] + match[2]),
                // sign + magnitude, cast to number
                unit: match[3]
              };
              if (!validUnit(data)) {
                throw new src_ParseError("Invalid unit: '" + data.unit + "' in \\includegraphics.");
              }
              return data;
            }
          };
          defineFunction({
            type: "includegraphics",
            names: ["\\includegraphics"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              argTypes: ["raw", "url"],
              allowedInText: false
            },
            handler: (_ref, args, optArgs) => {
              let {
                parser
              } = _ref;
              let width = {
                number: 0,
                unit: "em"
              };
              let height = {
                number: 0.9,
                unit: "em"
              };
              let totalheight = {
                number: 0,
                unit: "em"
              };
              let alt = "";
              if (optArgs[0]) {
                const attributeStr = assertNodeType(optArgs[0], "raw").string;
                const attributes = attributeStr.split(",");
                for (let i2 = 0; i2 < attributes.length; i2++) {
                  const keyVal = attributes[i2].split("=");
                  if (keyVal.length === 2) {
                    const str = keyVal[1].trim();
                    switch (keyVal[0].trim()) {
                      case "alt":
                        alt = str;
                        break;
                      case "width":
                        width = sizeData(str);
                        break;
                      case "height":
                        height = sizeData(str);
                        break;
                      case "totalheight":
                        totalheight = sizeData(str);
                        break;
                      default:
                        throw new src_ParseError("Invalid key: '" + keyVal[0] + "' in \\includegraphics.");
                    }
                  }
                }
              }
              const src = assertNodeType(args[0], "url").url;
              if (alt === "") {
                alt = src;
                alt = alt.replace(/^.*[\\/]/, "");
                alt = alt.substring(0, alt.lastIndexOf("."));
              }
              if (!parser.settings.isTrusted({
                command: "\\includegraphics",
                url: src
              })) {
                return parser.formatUnsupportedCmd("\\includegraphics");
              }
              return {
                type: "includegraphics",
                mode: parser.mode,
                alt,
                width,
                height,
                totalheight,
                src
              };
            },
            htmlBuilder: (group, options) => {
              const height = calculateSize(group.height, options);
              let depth = 0;
              if (group.totalheight.number > 0) {
                depth = calculateSize(group.totalheight, options) - height;
              }
              let width = 0;
              if (group.width.number > 0) {
                width = calculateSize(group.width, options);
              }
              const style = {
                height: makeEm(height + depth)
              };
              if (width > 0) {
                style.width = makeEm(width);
              }
              if (depth > 0) {
                style.verticalAlign = makeEm(-depth);
              }
              const node = new Img(group.src, group.alt, style);
              node.height = height;
              node.depth = depth;
              return node;
            },
            mathmlBuilder: (group, options) => {
              const node = new mathMLTree.MathNode("mglyph", []);
              node.setAttribute("alt", group.alt);
              const height = calculateSize(group.height, options);
              let depth = 0;
              if (group.totalheight.number > 0) {
                depth = calculateSize(group.totalheight, options) - height;
                node.setAttribute("valign", makeEm(-depth));
              }
              node.setAttribute("height", makeEm(height + depth));
              if (group.width.number > 0) {
                const width = calculateSize(group.width, options);
                node.setAttribute("width", makeEm(width));
              }
              node.setAttribute("src", group.src);
              return node;
            }
          });
          defineFunction({
            type: "kern",
            names: ["\\kern", "\\mkern", "\\hskip", "\\mskip"],
            props: {
              numArgs: 1,
              argTypes: ["size"],
              primitive: true,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              const size2 = assertNodeType(args[0], "size");
              if (parser.settings.strict) {
                const mathFunction = funcName[1] === "m";
                const muUnit = size2.value.unit === "mu";
                if (mathFunction) {
                  if (!muUnit) {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " supports only mu units, " + ("not " + size2.value.unit + " units"));
                  }
                  if (parser.mode !== "math") {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " works only in math mode");
                  }
                } else {
                  if (muUnit) {
                    parser.settings.reportNonstrict("mathVsTextUnits", "LaTeX's " + funcName + " doesn't support mu units");
                  }
                }
              }
              return {
                type: "kern",
                mode: parser.mode,
                dimension: size2.value
              };
            },
            htmlBuilder(group, options) {
              return buildCommon.makeGlue(group.dimension, options);
            },
            mathmlBuilder(group, options) {
              const dimension = calculateSize(group.dimension, options);
              return new mathMLTree.SpaceNode(dimension);
            }
          });
          defineFunction({
            type: "lap",
            names: ["\\mathllap", "\\mathrlap", "\\mathclap"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const body = args[0];
              return {
                type: "lap",
                mode: parser.mode,
                alignment: funcName.slice(5),
                body
              };
            },
            htmlBuilder: (group, options) => {
              let inner2;
              if (group.alignment === "clap") {
                inner2 = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
                inner2 = buildCommon.makeSpan(["inner"], [inner2], options);
              } else {
                inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options)]);
              }
              const fix = buildCommon.makeSpan(["fix"], []);
              let node = buildCommon.makeSpan([group.alignment], [inner2, fix], options);
              const strut = buildCommon.makeSpan(["strut"]);
              strut.style.height = makeEm(node.height + node.depth);
              if (node.depth) {
                strut.style.verticalAlign = makeEm(-node.depth);
              }
              node.children.unshift(strut);
              node = buildCommon.makeSpan(["thinbox"], [node], options);
              return buildCommon.makeSpan(["mord", "vbox"], [node], options);
            },
            mathmlBuilder: (group, options) => {
              const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              if (group.alignment !== "rlap") {
                const offset2 = group.alignment === "llap" ? "-1" : "-0.5";
                node.setAttribute("lspace", offset2 + "width");
              }
              node.setAttribute("width", "0px");
              return node;
            }
          });
          defineFunction({
            type: "styling",
            names: ["\\(", "$"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(_ref, args) {
              let {
                funcName,
                parser
              } = _ref;
              const outerMode = parser.mode;
              parser.switchMode("math");
              const close = funcName === "\\(" ? "\\)" : "$";
              const body = parser.parseExpression(false, close);
              parser.expect(close);
              parser.switchMode(outerMode);
              return {
                type: "styling",
                mode: parser.mode,
                style: "text",
                body
              };
            }
          });
          defineFunction({
            type: "text",
            // Doesn't matter what this is.
            names: ["\\)", "\\]"],
            props: {
              numArgs: 0,
              allowedInText: true,
              allowedInMath: false
            },
            handler(context, args) {
              throw new src_ParseError("Mismatched " + context.funcName);
            }
          });
          const chooseMathStyle = (group, options) => {
            switch (options.style.size) {
              case src_Style.DISPLAY.size:
                return group.display;
              case src_Style.TEXT.size:
                return group.text;
              case src_Style.SCRIPT.size:
                return group.script;
              case src_Style.SCRIPTSCRIPT.size:
                return group.scriptscript;
              default:
                return group.text;
            }
          };
          defineFunction({
            type: "mathchoice",
            names: ["\\mathchoice"],
            props: {
              numArgs: 4,
              primitive: true
            },
            handler: (_ref, args) => {
              let {
                parser
              } = _ref;
              return {
                type: "mathchoice",
                mode: parser.mode,
                display: ordargument(args[0]),
                text: ordargument(args[1]),
                script: ordargument(args[2]),
                scriptscript: ordargument(args[3])
              };
            },
            htmlBuilder: (group, options) => {
              const body = chooseMathStyle(group, options);
              const elements = buildExpression(body, options, false);
              return buildCommon.makeFragment(elements);
            },
            mathmlBuilder: (group, options) => {
              const body = chooseMathStyle(group, options);
              return buildExpressionRow(body, options);
            }
          });
          const assembleSupSub = (base, supGroup, subGroup, options, style, slant, baseShift) => {
            base = buildCommon.makeSpan([], [base]);
            const subIsSingleCharacter = subGroup && utils.isCharacterBox(subGroup);
            let sub2;
            let sup2;
            if (supGroup) {
              const elem = buildGroup(supGroup, options.havingStyle(style.sup()), options);
              sup2 = {
                elem,
                kern: Math.max(options.fontMetrics().bigOpSpacing1, options.fontMetrics().bigOpSpacing3 - elem.depth)
              };
            }
            if (subGroup) {
              const elem = buildGroup(subGroup, options.havingStyle(style.sub()), options);
              sub2 = {
                elem,
                kern: Math.max(options.fontMetrics().bigOpSpacing2, options.fontMetrics().bigOpSpacing4 - elem.height)
              };
            }
            let finalGroup;
            if (sup2 && sub2) {
              const bottom = options.fontMetrics().bigOpSpacing5 + sub2.elem.height + sub2.elem.depth + sub2.kern + base.depth + baseShift;
              finalGroup = buildCommon.makeVList({
                positionType: "bottom",
                positionData: bottom,
                children: [{
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: sub2.elem,
                  marginLeft: makeEm(-slant)
                }, {
                  type: "kern",
                  size: sub2.kern
                }, {
                  type: "elem",
                  elem: base
                }, {
                  type: "kern",
                  size: sup2.kern
                }, {
                  type: "elem",
                  elem: sup2.elem,
                  marginLeft: makeEm(slant)
                }, {
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }]
              }, options);
            } else if (sub2) {
              const top = base.height - baseShift;
              finalGroup = buildCommon.makeVList({
                positionType: "top",
                positionData: top,
                children: [{
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }, {
                  type: "elem",
                  elem: sub2.elem,
                  marginLeft: makeEm(-slant)
                }, {
                  type: "kern",
                  size: sub2.kern
                }, {
                  type: "elem",
                  elem: base
                }]
              }, options);
            } else if (sup2) {
              const bottom = base.depth + baseShift;
              finalGroup = buildCommon.makeVList({
                positionType: "bottom",
                positionData: bottom,
                children: [{
                  type: "elem",
                  elem: base
                }, {
                  type: "kern",
                  size: sup2.kern
                }, {
                  type: "elem",
                  elem: sup2.elem,
                  marginLeft: makeEm(slant)
                }, {
                  type: "kern",
                  size: options.fontMetrics().bigOpSpacing5
                }]
              }, options);
            } else {
              return base;
            }
            const parts = [finalGroup];
            if (sub2 && slant !== 0 && !subIsSingleCharacter) {
              const spacer = buildCommon.makeSpan(["mspace"], [], options);
              spacer.style.marginRight = makeEm(slant);
              parts.unshift(spacer);
            }
            return buildCommon.makeSpan(["mop", "op-limits"], parts, options);
          };
          const noSuccessor = ["\\smallint"];
          const op_htmlBuilder = (grp, options) => {
            let supGroup;
            let subGroup;
            let hasLimits = false;
            let group;
            if (grp.type === "supsub") {
              supGroup = grp.sup;
              subGroup = grp.sub;
              group = assertNodeType(grp.base, "op");
              hasLimits = true;
            } else {
              group = assertNodeType(grp, "op");
            }
            const style = options.style;
            let large = false;
            if (style.size === src_Style.DISPLAY.size && group.symbol && !utils.contains(noSuccessor, group.name)) {
              large = true;
            }
            let base;
            if (group.symbol) {
              const fontName = large ? "Size2-Regular" : "Size1-Regular";
              let stash = "";
              if (group.name === "\\oiint" || group.name === "\\oiiint") {
                stash = group.name.slice(1);
                group.name = stash === "oiint" ? "\\iint" : "\\iiint";
              }
              base = buildCommon.makeSymbol(group.name, fontName, "math", options, ["mop", "op-symbol", large ? "large-op" : "small-op"]);
              if (stash.length > 0) {
                const italic = base.italic;
                const oval = buildCommon.staticSvg(stash + "Size" + (large ? "2" : "1"), options);
                base = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: [{
                    type: "elem",
                    elem: base,
                    shift: 0
                  }, {
                    type: "elem",
                    elem: oval,
                    shift: large ? 0.08 : 0
                  }]
                }, options);
                group.name = "\\" + stash;
                base.classes.unshift("mop");
                base.italic = italic;
              }
            } else if (group.body) {
              const inner2 = buildExpression(group.body, options, true);
              if (inner2.length === 1 && inner2[0] instanceof SymbolNode) {
                base = inner2[0];
                base.classes[0] = "mop";
              } else {
                base = buildCommon.makeSpan(["mop"], inner2, options);
              }
            } else {
              const output = [];
              for (let i2 = 1; i2 < group.name.length; i2++) {
                output.push(buildCommon.mathsym(group.name[i2], group.mode, options));
              }
              base = buildCommon.makeSpan(["mop"], output, options);
            }
            let baseShift = 0;
            let slant = 0;
            if ((base instanceof SymbolNode || group.name === "\\oiint" || group.name === "\\oiiint") && !group.suppressBaseShift) {
              baseShift = (base.height - base.depth) / 2 - options.fontMetrics().axisHeight;
              slant = base.italic;
            }
            if (hasLimits) {
              return assembleSupSub(base, supGroup, subGroup, options, style, slant, baseShift);
            } else {
              if (baseShift) {
                base.style.position = "relative";
                base.style.top = makeEm(baseShift);
              }
              return base;
            }
          };
          const op_mathmlBuilder = (group, options) => {
            let node;
            if (group.symbol) {
              node = new MathNode("mo", [makeText(group.name, group.mode)]);
              if (utils.contains(noSuccessor, group.name)) {
                node.setAttribute("largeop", "false");
              }
            } else if (group.body) {
              node = new MathNode("mo", buildMathML_buildExpression(group.body, options));
            } else {
              node = new MathNode("mi", [new TextNode(group.name.slice(1))]);
              const operator = new MathNode("mo", [makeText("⁡", "text")]);
              if (group.parentIsSupSub) {
                node = new MathNode("mrow", [node, operator]);
              } else {
                node = newDocumentFragment([node, operator]);
              }
            }
            return node;
          };
          const singleCharBigOps = {
            "∏": "\\prod",
            "∐": "\\coprod",
            "∑": "\\sum",
            "⋀": "\\bigwedge",
            "⋁": "\\bigvee",
            "⋂": "\\bigcap",
            "⋃": "\\bigcup",
            "⨀": "\\bigodot",
            "⨁": "\\bigoplus",
            "⨂": "\\bigotimes",
            "⨄": "\\biguplus",
            "⨆": "\\bigsqcup"
          };
          defineFunction({
            type: "op",
            names: ["\\coprod", "\\bigvee", "\\bigwedge", "\\biguplus", "\\bigcap", "\\bigcup", "\\intop", "\\prod", "\\sum", "\\bigotimes", "\\bigoplus", "\\bigodot", "\\bigsqcup", "\\smallint", "∏", "∐", "∑", "⋀", "⋁", "⋂", "⋃", "⨀", "⨁", "⨂", "⨄", "⨆"],
            props: {
              numArgs: 0
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              let fName = funcName;
              if (fName.length === 1) {
                fName = singleCharBigOps[fName];
              }
              return {
                type: "op",
                mode: parser.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: true,
                name: fName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction({
            type: "op",
            names: ["\\mathop"],
            props: {
              numArgs: 1,
              primitive: true
            },
            handler: (_ref2, args) => {
              let {
                parser
              } = _ref2;
              const body = args[0];
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                body: ordargument(body)
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          const singleCharIntegrals = {
            "∫": "\\int",
            "∬": "\\iint",
            "∭": "\\iiint",
            "∮": "\\oint",
            "∯": "\\oiint",
            "∰": "\\oiiint"
          };
          defineFunction({
            type: "op",
            names: ["\\arcsin", "\\arccos", "\\arctan", "\\arctg", "\\arcctg", "\\arg", "\\ch", "\\cos", "\\cosec", "\\cosh", "\\cot", "\\cotg", "\\coth", "\\csc", "\\ctg", "\\cth", "\\deg", "\\dim", "\\exp", "\\hom", "\\ker", "\\lg", "\\ln", "\\log", "\\sec", "\\sin", "\\sinh", "\\sh", "\\tan", "\\tanh", "\\tg", "\\th"],
            props: {
              numArgs: 0
            },
            handler(_ref3) {
              let {
                parser,
                funcName
              } = _ref3;
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: false,
                name: funcName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction({
            type: "op",
            names: ["\\det", "\\gcd", "\\inf", "\\lim", "\\max", "\\min", "\\Pr", "\\sup"],
            props: {
              numArgs: 0
            },
            handler(_ref4) {
              let {
                parser,
                funcName
              } = _ref4;
              return {
                type: "op",
                mode: parser.mode,
                limits: true,
                parentIsSupSub: false,
                symbol: false,
                name: funcName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          defineFunction({
            type: "op",
            names: ["\\int", "\\iint", "\\iiint", "\\oint", "\\oiint", "\\oiiint", "∫", "∬", "∭", "∮", "∯", "∰"],
            props: {
              numArgs: 0
            },
            handler(_ref5) {
              let {
                parser,
                funcName
              } = _ref5;
              let fName = funcName;
              if (fName.length === 1) {
                fName = singleCharIntegrals[fName];
              }
              return {
                type: "op",
                mode: parser.mode,
                limits: false,
                parentIsSupSub: false,
                symbol: true,
                name: fName
              };
            },
            htmlBuilder: op_htmlBuilder,
            mathmlBuilder: op_mathmlBuilder
          });
          const operatorname_htmlBuilder = (grp, options) => {
            let supGroup;
            let subGroup;
            let hasLimits = false;
            let group;
            if (grp.type === "supsub") {
              supGroup = grp.sup;
              subGroup = grp.sub;
              group = assertNodeType(grp.base, "operatorname");
              hasLimits = true;
            } else {
              group = assertNodeType(grp, "operatorname");
            }
            let base;
            if (group.body.length > 0) {
              const body = group.body.map((child) => {
                const childText = child.text;
                if (typeof childText === "string") {
                  return {
                    type: "textord",
                    mode: child.mode,
                    text: childText
                  };
                } else {
                  return child;
                }
              });
              const expression = buildExpression(body, options.withFont("mathrm"), true);
              for (let i2 = 0; i2 < expression.length; i2++) {
                const child = expression[i2];
                if (child instanceof SymbolNode) {
                  child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                }
              }
              base = buildCommon.makeSpan(["mop"], expression, options);
            } else {
              base = buildCommon.makeSpan(["mop"], [], options);
            }
            if (hasLimits) {
              return assembleSupSub(base, supGroup, subGroup, options, options.style, 0, 0);
            } else {
              return base;
            }
          };
          const operatorname_mathmlBuilder = (group, options) => {
            let expression = buildMathML_buildExpression(group.body, options.withFont("mathrm"));
            let isAllString = true;
            for (let i2 = 0; i2 < expression.length; i2++) {
              const node = expression[i2];
              if (node instanceof mathMLTree.SpaceNode) ;
              else if (node instanceof mathMLTree.MathNode) {
                switch (node.type) {
                  case "mi":
                  case "mn":
                  case "ms":
                  case "mspace":
                  case "mtext":
                    break;
                  case "mo": {
                    const child = node.children[0];
                    if (node.children.length === 1 && child instanceof mathMLTree.TextNode) {
                      child.text = child.text.replace(/\u2212/, "-").replace(/\u2217/, "*");
                    } else {
                      isAllString = false;
                    }
                    break;
                  }
                  default:
                    isAllString = false;
                }
              } else {
                isAllString = false;
              }
            }
            if (isAllString) {
              const word = expression.map((node) => node.toText()).join("");
              expression = [new mathMLTree.TextNode(word)];
            }
            const identifier = new mathMLTree.MathNode("mi", expression);
            identifier.setAttribute("mathvariant", "normal");
            const operator = new mathMLTree.MathNode("mo", [makeText("⁡", "text")]);
            if (group.parentIsSupSub) {
              return new mathMLTree.MathNode("mrow", [identifier, operator]);
            } else {
              return mathMLTree.newDocumentFragment([identifier, operator]);
            }
          };
          defineFunction({
            type: "operatorname",
            names: ["\\operatorname@", "\\operatornamewithlimits"],
            props: {
              numArgs: 1
            },
            handler: (_ref, args) => {
              let {
                parser,
                funcName
              } = _ref;
              const body = args[0];
              return {
                type: "operatorname",
                mode: parser.mode,
                body: ordargument(body),
                alwaysHandleSupSub: funcName === "\\operatornamewithlimits",
                limits: false,
                parentIsSupSub: false
              };
            },
            htmlBuilder: operatorname_htmlBuilder,
            mathmlBuilder: operatorname_mathmlBuilder
          });
          defineMacro("\\operatorname", "\\@ifstar\\operatornamewithlimits\\operatorname@");
          defineFunctionBuilders({
            type: "ordgroup",
            htmlBuilder(group, options) {
              if (group.semisimple) {
                return buildCommon.makeFragment(buildExpression(group.body, options, false));
              }
              return buildCommon.makeSpan(["mord"], buildExpression(group.body, options, true), options);
            },
            mathmlBuilder(group, options) {
              return buildExpressionRow(group.body, options, true);
            }
          });
          defineFunction({
            type: "overline",
            names: ["\\overline"],
            props: {
              numArgs: 1
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              const body = args[0];
              return {
                type: "overline",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder(group, options) {
              const innerGroup = buildGroup(group.body, options.havingCrampedStyle());
              const line = buildCommon.makeLineSpan("overline-line", options);
              const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
              const vlist = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: innerGroup
                }, {
                  type: "kern",
                  size: 3 * defaultRuleThickness
                }, {
                  type: "elem",
                  elem: line
                }, {
                  type: "kern",
                  size: defaultRuleThickness
                }]
              }, options);
              return buildCommon.makeSpan(["mord", "overline"], [vlist], options);
            },
            mathmlBuilder(group, options) {
              const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
              operator.setAttribute("stretchy", "true");
              const node = new mathMLTree.MathNode("mover", [buildMathML_buildGroup(group.body, options), operator]);
              node.setAttribute("accent", "true");
              return node;
            }
          });
          defineFunction({
            type: "phantom",
            names: ["\\phantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                parser
              } = _ref;
              const body = args[0];
              return {
                type: "phantom",
                mode: parser.mode,
                body: ordargument(body)
              };
            },
            htmlBuilder: (group, options) => {
              const elements = buildExpression(group.body, options.withPhantom(), false);
              return buildCommon.makeFragment(elements);
            },
            mathmlBuilder: (group, options) => {
              const inner2 = buildMathML_buildExpression(group.body, options);
              return new mathMLTree.MathNode("mphantom", inner2);
            }
          });
          defineFunction({
            type: "hphantom",
            names: ["\\hphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (_ref2, args) => {
              let {
                parser
              } = _ref2;
              const body = args[0];
              return {
                type: "hphantom",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder: (group, options) => {
              let node = buildCommon.makeSpan([], [buildGroup(group.body, options.withPhantom())]);
              node.height = 0;
              node.depth = 0;
              if (node.children) {
                for (let i2 = 0; i2 < node.children.length; i2++) {
                  node.children[i2].height = 0;
                  node.children[i2].depth = 0;
                }
              }
              node = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: node
                }]
              }, options);
              return buildCommon.makeSpan(["mord"], [node], options);
            },
            mathmlBuilder: (group, options) => {
              const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
              const phantom = new mathMLTree.MathNode("mphantom", inner2);
              const node = new mathMLTree.MathNode("mpadded", [phantom]);
              node.setAttribute("height", "0px");
              node.setAttribute("depth", "0px");
              return node;
            }
          });
          defineFunction({
            type: "vphantom",
            names: ["\\vphantom"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler: (_ref3, args) => {
              let {
                parser
              } = _ref3;
              const body = args[0];
              return {
                type: "vphantom",
                mode: parser.mode,
                body
              };
            },
            htmlBuilder: (group, options) => {
              const inner2 = buildCommon.makeSpan(["inner"], [buildGroup(group.body, options.withPhantom())]);
              const fix = buildCommon.makeSpan(["fix"], []);
              return buildCommon.makeSpan(["mord", "rlap"], [inner2, fix], options);
            },
            mathmlBuilder: (group, options) => {
              const inner2 = buildMathML_buildExpression(ordargument(group.body), options);
              const phantom = new mathMLTree.MathNode("mphantom", inner2);
              const node = new mathMLTree.MathNode("mpadded", [phantom]);
              node.setAttribute("width", "0px");
              return node;
            }
          });
          defineFunction({
            type: "raisebox",
            names: ["\\raisebox"],
            props: {
              numArgs: 2,
              argTypes: ["size", "hbox"],
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              const amount = assertNodeType(args[0], "size").value;
              const body = args[1];
              return {
                type: "raisebox",
                mode: parser.mode,
                dy: amount,
                body
              };
            },
            htmlBuilder(group, options) {
              const body = buildGroup(group.body, options);
              const dy = calculateSize(group.dy, options);
              return buildCommon.makeVList({
                positionType: "shift",
                positionData: -dy,
                children: [{
                  type: "elem",
                  elem: body
                }]
              }, options);
            },
            mathmlBuilder(group, options) {
              const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              const dy = group.dy.number + group.dy.unit;
              node.setAttribute("voffset", dy);
              return node;
            }
          });
          defineFunction({
            type: "internal",
            names: ["\\relax"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(_ref) {
              let {
                parser
              } = _ref;
              return {
                type: "internal",
                mode: parser.mode
              };
            }
          });
          defineFunction({
            type: "rule",
            names: ["\\rule"],
            props: {
              numArgs: 2,
              numOptionalArgs: 1,
              allowedInText: true,
              allowedInMath: true,
              argTypes: ["size", "size", "size"]
            },
            handler(_ref, args, optArgs) {
              let {
                parser
              } = _ref;
              const shift2 = optArgs[0];
              const width = assertNodeType(args[0], "size");
              const height = assertNodeType(args[1], "size");
              return {
                type: "rule",
                mode: parser.mode,
                shift: shift2 && assertNodeType(shift2, "size").value,
                width: width.value,
                height: height.value
              };
            },
            htmlBuilder(group, options) {
              const rule = buildCommon.makeSpan(["mord", "rule"], [], options);
              const width = calculateSize(group.width, options);
              const height = calculateSize(group.height, options);
              const shift2 = group.shift ? calculateSize(group.shift, options) : 0;
              rule.style.borderRightWidth = makeEm(width);
              rule.style.borderTopWidth = makeEm(height);
              rule.style.bottom = makeEm(shift2);
              rule.width = width;
              rule.height = height + shift2;
              rule.depth = -shift2;
              rule.maxFontSize = height * 1.125 * options.sizeMultiplier;
              return rule;
            },
            mathmlBuilder(group, options) {
              const width = calculateSize(group.width, options);
              const height = calculateSize(group.height, options);
              const shift2 = group.shift ? calculateSize(group.shift, options) : 0;
              const color = options.color && options.getColor() || "black";
              const rule = new mathMLTree.MathNode("mspace");
              rule.setAttribute("mathbackground", color);
              rule.setAttribute("width", makeEm(width));
              rule.setAttribute("height", makeEm(height));
              const wrapper = new mathMLTree.MathNode("mpadded", [rule]);
              if (shift2 >= 0) {
                wrapper.setAttribute("height", makeEm(shift2));
              } else {
                wrapper.setAttribute("height", makeEm(shift2));
                wrapper.setAttribute("depth", makeEm(-shift2));
              }
              wrapper.setAttribute("voffset", makeEm(shift2));
              return wrapper;
            }
          });
          function sizingGroup(value, options, baseOptions) {
            const inner2 = buildExpression(value, options, false);
            const multiplier = options.sizeMultiplier / baseOptions.sizeMultiplier;
            for (let i2 = 0; i2 < inner2.length; i2++) {
              const pos = inner2[i2].classes.indexOf("sizing");
              if (pos < 0) {
                Array.prototype.push.apply(inner2[i2].classes, options.sizingClasses(baseOptions));
              } else if (inner2[i2].classes[pos + 1] === "reset-size" + options.size) {
                inner2[i2].classes[pos + 1] = "reset-size" + baseOptions.size;
              }
              inner2[i2].height *= multiplier;
              inner2[i2].depth *= multiplier;
            }
            return buildCommon.makeFragment(inner2);
          }
          const sizeFuncs = ["\\tiny", "\\sixptsize", "\\scriptsize", "\\footnotesize", "\\small", "\\normalsize", "\\large", "\\Large", "\\LARGE", "\\huge", "\\Huge"];
          const sizing_htmlBuilder = (group, options) => {
            const newOptions = options.havingSize(group.size);
            return sizingGroup(group.body, newOptions, options);
          };
          defineFunction({
            type: "sizing",
            names: sizeFuncs,
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler: (_ref, args) => {
              let {
                breakOnTokenText,
                funcName,
                parser
              } = _ref;
              const body = parser.parseExpression(false, breakOnTokenText);
              return {
                type: "sizing",
                mode: parser.mode,
                // Figure out what size to use based on the list of functions above
                size: sizeFuncs.indexOf(funcName) + 1,
                body
              };
            },
            htmlBuilder: sizing_htmlBuilder,
            mathmlBuilder: (group, options) => {
              const newOptions = options.havingSize(group.size);
              const inner2 = buildMathML_buildExpression(group.body, newOptions);
              const node = new mathMLTree.MathNode("mstyle", inner2);
              node.setAttribute("mathsize", makeEm(newOptions.sizeMultiplier));
              return node;
            }
          });
          defineFunction({
            type: "smash",
            names: ["\\smash"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1,
              allowedInText: true
            },
            handler: (_ref, args, optArgs) => {
              let {
                parser
              } = _ref;
              let smashHeight = false;
              let smashDepth = false;
              const tbArg = optArgs[0] && assertNodeType(optArgs[0], "ordgroup");
              if (tbArg) {
                let letter = "";
                for (let i2 = 0; i2 < tbArg.body.length; ++i2) {
                  const node = tbArg.body[i2];
                  letter = node.text;
                  if (letter === "t") {
                    smashHeight = true;
                  } else if (letter === "b") {
                    smashDepth = true;
                  } else {
                    smashHeight = false;
                    smashDepth = false;
                    break;
                  }
                }
              } else {
                smashHeight = true;
                smashDepth = true;
              }
              const body = args[0];
              return {
                type: "smash",
                mode: parser.mode,
                body,
                smashHeight,
                smashDepth
              };
            },
            htmlBuilder: (group, options) => {
              const node = buildCommon.makeSpan([], [buildGroup(group.body, options)]);
              if (!group.smashHeight && !group.smashDepth) {
                return node;
              }
              if (group.smashHeight) {
                node.height = 0;
                if (node.children) {
                  for (let i2 = 0; i2 < node.children.length; i2++) {
                    node.children[i2].height = 0;
                  }
                }
              }
              if (group.smashDepth) {
                node.depth = 0;
                if (node.children) {
                  for (let i2 = 0; i2 < node.children.length; i2++) {
                    node.children[i2].depth = 0;
                  }
                }
              }
              const smashedNode = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: node
                }]
              }, options);
              return buildCommon.makeSpan(["mord"], [smashedNode], options);
            },
            mathmlBuilder: (group, options) => {
              const node = new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)]);
              if (group.smashHeight) {
                node.setAttribute("height", "0px");
              }
              if (group.smashDepth) {
                node.setAttribute("depth", "0px");
              }
              return node;
            }
          });
          defineFunction({
            type: "sqrt",
            names: ["\\sqrt"],
            props: {
              numArgs: 1,
              numOptionalArgs: 1
            },
            handler(_ref, args, optArgs) {
              let {
                parser
              } = _ref;
              const index2 = optArgs[0];
              const body = args[0];
              return {
                type: "sqrt",
                mode: parser.mode,
                body,
                index: index2
              };
            },
            htmlBuilder(group, options) {
              let inner2 = buildGroup(group.body, options.havingCrampedStyle());
              if (inner2.height === 0) {
                inner2.height = options.fontMetrics().xHeight;
              }
              inner2 = buildCommon.wrapFragment(inner2, options);
              const metrics = options.fontMetrics();
              const theta = metrics.defaultRuleThickness;
              let phi = theta;
              if (options.style.id < src_Style.TEXT.id) {
                phi = options.fontMetrics().xHeight;
              }
              let lineClearance = theta + phi / 4;
              const minDelimiterHeight = inner2.height + inner2.depth + lineClearance + theta;
              const {
                span: img,
                ruleWidth,
                advanceWidth
              } = delimiter.sqrtImage(minDelimiterHeight, options);
              const delimDepth = img.height - ruleWidth;
              if (delimDepth > inner2.height + inner2.depth + lineClearance) {
                lineClearance = (lineClearance + delimDepth - inner2.height - inner2.depth) / 2;
              }
              const imgShift = img.height - inner2.height - lineClearance - ruleWidth;
              inner2.style.paddingLeft = makeEm(advanceWidth);
              const body = buildCommon.makeVList({
                positionType: "firstBaseline",
                children: [{
                  type: "elem",
                  elem: inner2,
                  wrapperClasses: ["svg-align"]
                }, {
                  type: "kern",
                  size: -(inner2.height + imgShift)
                }, {
                  type: "elem",
                  elem: img
                }, {
                  type: "kern",
                  size: ruleWidth
                }]
              }, options);
              if (!group.index) {
                return buildCommon.makeSpan(["mord", "sqrt"], [body], options);
              } else {
                const newOptions = options.havingStyle(src_Style.SCRIPTSCRIPT);
                const rootm = buildGroup(group.index, newOptions, options);
                const toShift = 0.6 * (body.height - body.depth);
                const rootVList = buildCommon.makeVList({
                  positionType: "shift",
                  positionData: -toShift,
                  children: [{
                    type: "elem",
                    elem: rootm
                  }]
                }, options);
                const rootVListWrap = buildCommon.makeSpan(["root"], [rootVList]);
                return buildCommon.makeSpan(["mord", "sqrt"], [rootVListWrap, body], options);
              }
            },
            mathmlBuilder(group, options) {
              const {
                body,
                index: index2
              } = group;
              return index2 ? new mathMLTree.MathNode("mroot", [buildMathML_buildGroup(body, options), buildMathML_buildGroup(index2, options)]) : new mathMLTree.MathNode("msqrt", [buildMathML_buildGroup(body, options)]);
            }
          });
          const styling_styleMap = {
            "display": src_Style.DISPLAY,
            "text": src_Style.TEXT,
            "script": src_Style.SCRIPT,
            "scriptscript": src_Style.SCRIPTSCRIPT
          };
          defineFunction({
            type: "styling",
            names: ["\\displaystyle", "\\textstyle", "\\scriptstyle", "\\scriptscriptstyle"],
            props: {
              numArgs: 0,
              allowedInText: true,
              primitive: true
            },
            handler(_ref, args) {
              let {
                breakOnTokenText,
                funcName,
                parser
              } = _ref;
              const body = parser.parseExpression(true, breakOnTokenText);
              const style = funcName.slice(1, funcName.length - 5);
              return {
                type: "styling",
                mode: parser.mode,
                // Figure out what style to use by pulling out the style from
                // the function name
                style,
                body
              };
            },
            htmlBuilder(group, options) {
              const newStyle = styling_styleMap[group.style];
              const newOptions = options.havingStyle(newStyle).withFont("");
              return sizingGroup(group.body, newOptions, options);
            },
            mathmlBuilder(group, options) {
              const newStyle = styling_styleMap[group.style];
              const newOptions = options.havingStyle(newStyle);
              const inner2 = buildMathML_buildExpression(group.body, newOptions);
              const node = new mathMLTree.MathNode("mstyle", inner2);
              const styleAttributes = {
                "display": ["0", "true"],
                "text": ["0", "false"],
                "script": ["1", "false"],
                "scriptscript": ["2", "false"]
              };
              const attr = styleAttributes[group.style];
              node.setAttribute("scriptlevel", attr[0]);
              node.setAttribute("displaystyle", attr[1]);
              return node;
            }
          });
          const htmlBuilderDelegate = function(group, options) {
            const base = group.base;
            if (!base) {
              return null;
            } else if (base.type === "op") {
              const delegate = base.limits && (options.style.size === src_Style.DISPLAY.size || base.alwaysHandleSupSub);
              return delegate ? op_htmlBuilder : null;
            } else if (base.type === "operatorname") {
              const delegate = base.alwaysHandleSupSub && (options.style.size === src_Style.DISPLAY.size || base.limits);
              return delegate ? operatorname_htmlBuilder : null;
            } else if (base.type === "accent") {
              return utils.isCharacterBox(base.base) ? htmlBuilder : null;
            } else if (base.type === "horizBrace") {
              const isSup = !group.sub;
              return isSup === base.isOver ? horizBrace_htmlBuilder : null;
            } else {
              return null;
            }
          };
          defineFunctionBuilders({
            type: "supsub",
            htmlBuilder(group, options) {
              const builderDelegate = htmlBuilderDelegate(group, options);
              if (builderDelegate) {
                return builderDelegate(group, options);
              }
              const {
                base: valueBase,
                sup: valueSup,
                sub: valueSub
              } = group;
              const base = buildGroup(valueBase, options);
              let supm;
              let subm;
              const metrics = options.fontMetrics();
              let supShift = 0;
              let subShift = 0;
              const isCharacterBox2 = valueBase && utils.isCharacterBox(valueBase);
              if (valueSup) {
                const newOptions = options.havingStyle(options.style.sup());
                supm = buildGroup(valueSup, newOptions, options);
                if (!isCharacterBox2) {
                  supShift = base.height - newOptions.fontMetrics().supDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              if (valueSub) {
                const newOptions = options.havingStyle(options.style.sub());
                subm = buildGroup(valueSub, newOptions, options);
                if (!isCharacterBox2) {
                  subShift = base.depth + newOptions.fontMetrics().subDrop * newOptions.sizeMultiplier / options.sizeMultiplier;
                }
              }
              let minSupShift;
              if (options.style === src_Style.DISPLAY) {
                minSupShift = metrics.sup1;
              } else if (options.style.cramped) {
                minSupShift = metrics.sup3;
              } else {
                minSupShift = metrics.sup2;
              }
              const multiplier = options.sizeMultiplier;
              const marginRight = makeEm(0.5 / metrics.ptPerEm / multiplier);
              let marginLeft = null;
              if (subm) {
                const isOiint = group.base && group.base.type === "op" && group.base.name && (group.base.name === "\\oiint" || group.base.name === "\\oiiint");
                if (base instanceof SymbolNode || isOiint) {
                  marginLeft = makeEm(-base.italic);
                }
              }
              let supsub;
              if (supm && subm) {
                supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                subShift = Math.max(subShift, metrics.sub2);
                const ruleWidth = metrics.defaultRuleThickness;
                const maxWidth = 4 * ruleWidth;
                if (supShift - supm.depth - (subm.height - subShift) < maxWidth) {
                  subShift = maxWidth - (supShift - supm.depth) + subm.height;
                  const psi = 0.8 * metrics.xHeight - (supShift - supm.depth);
                  if (psi > 0) {
                    supShift += psi;
                    subShift -= psi;
                  }
                }
                const vlistElem = [{
                  type: "elem",
                  elem: subm,
                  shift: subShift,
                  marginRight,
                  marginLeft
                }, {
                  type: "elem",
                  elem: supm,
                  shift: -supShift,
                  marginRight
                }];
                supsub = buildCommon.makeVList({
                  positionType: "individualShift",
                  children: vlistElem
                }, options);
              } else if (subm) {
                subShift = Math.max(subShift, metrics.sub1, subm.height - 0.8 * metrics.xHeight);
                const vlistElem = [{
                  type: "elem",
                  elem: subm,
                  marginLeft,
                  marginRight
                }];
                supsub = buildCommon.makeVList({
                  positionType: "shift",
                  positionData: subShift,
                  children: vlistElem
                }, options);
              } else if (supm) {
                supShift = Math.max(supShift, minSupShift, supm.depth + 0.25 * metrics.xHeight);
                supsub = buildCommon.makeVList({
                  positionType: "shift",
                  positionData: -supShift,
                  children: [{
                    type: "elem",
                    elem: supm,
                    marginRight
                  }]
                }, options);
              } else {
                throw new Error("supsub must have either sup or sub.");
              }
              const mclass = getTypeOfDomTree(base, "right") || "mord";
              return buildCommon.makeSpan([mclass], [base, buildCommon.makeSpan(["msupsub"], [supsub])], options);
            },
            mathmlBuilder(group, options) {
              let isBrace = false;
              let isOver;
              let isSup;
              if (group.base && group.base.type === "horizBrace") {
                isSup = !!group.sup;
                if (isSup === group.base.isOver) {
                  isBrace = true;
                  isOver = group.base.isOver;
                }
              }
              if (group.base && (group.base.type === "op" || group.base.type === "operatorname")) {
                group.base.parentIsSupSub = true;
              }
              const children = [buildMathML_buildGroup(group.base, options)];
              if (group.sub) {
                children.push(buildMathML_buildGroup(group.sub, options));
              }
              if (group.sup) {
                children.push(buildMathML_buildGroup(group.sup, options));
              }
              let nodeType;
              if (isBrace) {
                nodeType = isOver ? "mover" : "munder";
              } else if (!group.sub) {
                const base = group.base;
                if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
                  nodeType = "mover";
                } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
                  nodeType = "mover";
                } else {
                  nodeType = "msup";
                }
              } else if (!group.sup) {
                const base = group.base;
                if (base && base.type === "op" && base.limits && (options.style === src_Style.DISPLAY || base.alwaysHandleSupSub)) {
                  nodeType = "munder";
                } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (base.limits || options.style === src_Style.DISPLAY)) {
                  nodeType = "munder";
                } else {
                  nodeType = "msub";
                }
              } else {
                const base = group.base;
                if (base && base.type === "op" && base.limits && options.style === src_Style.DISPLAY) {
                  nodeType = "munderover";
                } else if (base && base.type === "operatorname" && base.alwaysHandleSupSub && (options.style === src_Style.DISPLAY || base.limits)) {
                  nodeType = "munderover";
                } else {
                  nodeType = "msubsup";
                }
              }
              return new mathMLTree.MathNode(nodeType, children);
            }
          });
          defineFunctionBuilders({
            type: "atom",
            htmlBuilder(group, options) {
              return buildCommon.mathsym(group.text, group.mode, options, ["m" + group.family]);
            },
            mathmlBuilder(group, options) {
              const node = new mathMLTree.MathNode("mo", [makeText(group.text, group.mode)]);
              if (group.family === "bin") {
                const variant = getVariant(group, options);
                if (variant === "bold-italic") {
                  node.setAttribute("mathvariant", variant);
                }
              } else if (group.family === "punct") {
                node.setAttribute("separator", "true");
              } else if (group.family === "open" || group.family === "close") {
                node.setAttribute("stretchy", "false");
              }
              return node;
            }
          });
          const defaultVariant = {
            "mi": "italic",
            "mn": "normal",
            "mtext": "normal"
          };
          defineFunctionBuilders({
            type: "mathord",
            htmlBuilder(group, options) {
              return buildCommon.makeOrd(group, options, "mathord");
            },
            mathmlBuilder(group, options) {
              const node = new mathMLTree.MathNode("mi", [makeText(group.text, group.mode, options)]);
              const variant = getVariant(group, options) || "italic";
              if (variant !== defaultVariant[node.type]) {
                node.setAttribute("mathvariant", variant);
              }
              return node;
            }
          });
          defineFunctionBuilders({
            type: "textord",
            htmlBuilder(group, options) {
              return buildCommon.makeOrd(group, options, "textord");
            },
            mathmlBuilder(group, options) {
              const text = makeText(group.text, group.mode, options);
              const variant = getVariant(group, options) || "normal";
              let node;
              if (group.mode === "text") {
                node = new mathMLTree.MathNode("mtext", [text]);
              } else if (/[0-9]/.test(group.text)) {
                node = new mathMLTree.MathNode("mn", [text]);
              } else if (group.text === "\\prime") {
                node = new mathMLTree.MathNode("mo", [text]);
              } else {
                node = new mathMLTree.MathNode("mi", [text]);
              }
              if (variant !== defaultVariant[node.type]) {
                node.setAttribute("mathvariant", variant);
              }
              return node;
            }
          });
          const cssSpace = {
            "\\nobreak": "nobreak",
            "\\allowbreak": "allowbreak"
          };
          const regularSpace = {
            " ": {},
            "\\ ": {},
            "~": {
              className: "nobreak"
            },
            "\\space": {},
            "\\nobreakspace": {
              className: "nobreak"
            }
          };
          defineFunctionBuilders({
            type: "spacing",
            htmlBuilder(group, options) {
              if (regularSpace.hasOwnProperty(group.text)) {
                const className = regularSpace[group.text].className || "";
                if (group.mode === "text") {
                  const ord = buildCommon.makeOrd(group, options, "textord");
                  ord.classes.push(className);
                  return ord;
                } else {
                  return buildCommon.makeSpan(["mspace", className], [buildCommon.mathsym(group.text, group.mode, options)], options);
                }
              } else if (cssSpace.hasOwnProperty(group.text)) {
                return buildCommon.makeSpan(["mspace", cssSpace[group.text]], [], options);
              } else {
                throw new src_ParseError('Unknown type of space "' + group.text + '"');
              }
            },
            mathmlBuilder(group, options) {
              let node;
              if (regularSpace.hasOwnProperty(group.text)) {
                node = new mathMLTree.MathNode("mtext", [new mathMLTree.TextNode(" ")]);
              } else if (cssSpace.hasOwnProperty(group.text)) {
                return new mathMLTree.MathNode("mspace");
              } else {
                throw new src_ParseError('Unknown type of space "' + group.text + '"');
              }
              return node;
            }
          });
          const pad = () => {
            const padNode = new mathMLTree.MathNode("mtd", []);
            padNode.setAttribute("width", "50%");
            return padNode;
          };
          defineFunctionBuilders({
            type: "tag",
            mathmlBuilder(group, options) {
              const table = new mathMLTree.MathNode("mtable", [new mathMLTree.MathNode("mtr", [pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.body, options)]), pad(), new mathMLTree.MathNode("mtd", [buildExpressionRow(group.tag, options)])])]);
              table.setAttribute("width", "100%");
              return table;
            }
          });
          const textFontFamilies = {
            "\\text": void 0,
            "\\textrm": "textrm",
            "\\textsf": "textsf",
            "\\texttt": "texttt",
            "\\textnormal": "textrm"
          };
          const textFontWeights = {
            "\\textbf": "textbf",
            "\\textmd": "textmd"
          };
          const textFontShapes = {
            "\\textit": "textit",
            "\\textup": "textup"
          };
          const optionsWithFont = (group, options) => {
            const font = group.font;
            if (!font) {
              return options;
            } else if (textFontFamilies[font]) {
              return options.withTextFontFamily(textFontFamilies[font]);
            } else if (textFontWeights[font]) {
              return options.withTextFontWeight(textFontWeights[font]);
            } else if (font === "\\emph") {
              return options.fontShape === "textit" ? options.withTextFontShape("textup") : options.withTextFontShape("textit");
            }
            return options.withTextFontShape(textFontShapes[font]);
          };
          defineFunction({
            type: "text",
            names: [
              // Font families
              "\\text",
              "\\textrm",
              "\\textsf",
              "\\texttt",
              "\\textnormal",
              // Font weights
              "\\textbf",
              "\\textmd",
              // Font Shapes
              "\\textit",
              "\\textup",
              "\\emph"
            ],
            props: {
              numArgs: 1,
              argTypes: ["text"],
              allowedInArgument: true,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser,
                funcName
              } = _ref;
              const body = args[0];
              return {
                type: "text",
                mode: parser.mode,
                body: ordargument(body),
                font: funcName
              };
            },
            htmlBuilder(group, options) {
              const newOptions = optionsWithFont(group, options);
              const inner2 = buildExpression(group.body, newOptions, true);
              return buildCommon.makeSpan(["mord", "text"], inner2, newOptions);
            },
            mathmlBuilder(group, options) {
              const newOptions = optionsWithFont(group, options);
              return buildExpressionRow(group.body, newOptions);
            }
          });
          defineFunction({
            type: "underline",
            names: ["\\underline"],
            props: {
              numArgs: 1,
              allowedInText: true
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              return {
                type: "underline",
                mode: parser.mode,
                body: args[0]
              };
            },
            htmlBuilder(group, options) {
              const innerGroup = buildGroup(group.body, options);
              const line = buildCommon.makeLineSpan("underline-line", options);
              const defaultRuleThickness = options.fontMetrics().defaultRuleThickness;
              const vlist = buildCommon.makeVList({
                positionType: "top",
                positionData: innerGroup.height,
                children: [{
                  type: "kern",
                  size: defaultRuleThickness
                }, {
                  type: "elem",
                  elem: line
                }, {
                  type: "kern",
                  size: 3 * defaultRuleThickness
                }, {
                  type: "elem",
                  elem: innerGroup
                }]
              }, options);
              return buildCommon.makeSpan(["mord", "underline"], [vlist], options);
            },
            mathmlBuilder(group, options) {
              const operator = new mathMLTree.MathNode("mo", [new mathMLTree.TextNode("‾")]);
              operator.setAttribute("stretchy", "true");
              const node = new mathMLTree.MathNode("munder", [buildMathML_buildGroup(group.body, options), operator]);
              node.setAttribute("accentunder", "true");
              return node;
            }
          });
          defineFunction({
            type: "vcenter",
            names: ["\\vcenter"],
            props: {
              numArgs: 1,
              argTypes: ["original"],
              // In LaTeX, \vcenter can act only on a box.
              allowedInText: false
            },
            handler(_ref, args) {
              let {
                parser
              } = _ref;
              return {
                type: "vcenter",
                mode: parser.mode,
                body: args[0]
              };
            },
            htmlBuilder(group, options) {
              const body = buildGroup(group.body, options);
              const axisHeight = options.fontMetrics().axisHeight;
              const dy = 0.5 * (body.height - axisHeight - (body.depth + axisHeight));
              return buildCommon.makeVList({
                positionType: "shift",
                positionData: dy,
                children: [{
                  type: "elem",
                  elem: body
                }]
              }, options);
            },
            mathmlBuilder(group, options) {
              return new mathMLTree.MathNode("mpadded", [buildMathML_buildGroup(group.body, options)], ["vcenter"]);
            }
          });
          defineFunction({
            type: "verb",
            names: ["\\verb"],
            props: {
              numArgs: 0,
              allowedInText: true
            },
            handler(context, args, optArgs) {
              throw new src_ParseError("\\verb ended by end of line instead of matching delimiter");
            },
            htmlBuilder(group, options) {
              const text = makeVerb(group);
              const body = [];
              const newOptions = options.havingStyle(options.style.text());
              for (let i2 = 0; i2 < text.length; i2++) {
                let c2 = text[i2];
                if (c2 === "~") {
                  c2 = "\\textasciitilde";
                }
                body.push(buildCommon.makeSymbol(c2, "Typewriter-Regular", group.mode, newOptions, ["mord", "texttt"]));
              }
              return buildCommon.makeSpan(["mord", "text"].concat(newOptions.sizingClasses(options)), buildCommon.tryCombineChars(body), newOptions);
            },
            mathmlBuilder(group, options) {
              const text = new mathMLTree.TextNode(makeVerb(group));
              const node = new mathMLTree.MathNode("mtext", [text]);
              node.setAttribute("mathvariant", "monospace");
              return node;
            }
          });
          const makeVerb = (group) => group.body.replace(/ /g, group.star ? "␣" : " ");
          const functions = _functions;
          var src_functions = functions;
          const spaceRegexString = "[ \r\n	]";
          const controlWordRegexString = "\\\\[a-zA-Z@]+";
          const controlSymbolRegexString = "\\\\[^\uD800-\uDFFF]";
          const controlWordWhitespaceRegexString = "(" + controlWordRegexString + ")" + spaceRegexString + "*";
          const controlSpaceRegexString = "\\\\(\n|[ \r	]+\n?)[ \r	]*";
          const combiningDiacriticalMarkString = "[̀-ͯ]";
          const combiningDiacriticalMarksEndRegex = new RegExp(combiningDiacriticalMarkString + "+$");
          const tokenRegexString = "(" + spaceRegexString + "+)|" + // whitespace
          (controlSpaceRegexString + "|") + // \whitespace
          "([!-\\[\\]-‧‪-퟿豈-￿]" + // single codepoint
          (combiningDiacriticalMarkString + "*") + // ...plus accents
          "|[\uD800-\uDBFF][\uDC00-\uDFFF]" + // surrogate pair
          (combiningDiacriticalMarkString + "*") + // ...plus accents
          "|\\\\verb\\*([^]).*?\\4|\\\\verb([^*a-zA-Z]).*?\\5" + // \verb unstarred
          ("|" + controlWordWhitespaceRegexString) + // \macroName + spaces
          ("|" + controlSymbolRegexString + ")");
          class Lexer {
            // Category codes. The lexer only supports comment characters (14) for now.
            // MacroExpander additionally distinguishes active (13).
            constructor(input, settings) {
              this.input = void 0;
              this.settings = void 0;
              this.tokenRegex = void 0;
              this.catcodes = void 0;
              this.input = input;
              this.settings = settings;
              this.tokenRegex = new RegExp(tokenRegexString, "g");
              this.catcodes = {
                "%": 14,
                // comment character
                "~": 13
                // active character
              };
            }
            setCatcode(char, code) {
              this.catcodes[char] = code;
            }
            /**
             * This function lexes a single token.
             */
            lex() {
              const input = this.input;
              const pos = this.tokenRegex.lastIndex;
              if (pos === input.length) {
                return new Token("EOF", new SourceLocation(this, pos, pos));
              }
              const match = this.tokenRegex.exec(input);
              if (match === null || match.index !== pos) {
                throw new src_ParseError("Unexpected character: '" + input[pos] + "'", new Token(input[pos], new SourceLocation(this, pos, pos + 1)));
              }
              const text = match[6] || match[3] || (match[2] ? "\\ " : " ");
              if (this.catcodes[text] === 14) {
                const nlIndex = input.indexOf("\n", this.tokenRegex.lastIndex);
                if (nlIndex === -1) {
                  this.tokenRegex.lastIndex = input.length;
                  this.settings.reportNonstrict("commentAtEnd", "% comment has no terminating newline; LaTeX would fail because of commenting the end of math mode (e.g. $)");
                } else {
                  this.tokenRegex.lastIndex = nlIndex + 1;
                }
                return this.lex();
              }
              return new Token(text, new SourceLocation(this, pos, this.tokenRegex.lastIndex));
            }
          }
          class Namespace {
            /**
             * Both arguments are optional.  The first argument is an object of
             * built-in mappings which never change.  The second argument is an object
             * of initial (global-level) mappings, which will constantly change
             * according to any global/top-level `set`s done.
             */
            constructor(builtins, globalMacros) {
              if (builtins === void 0) {
                builtins = {};
              }
              if (globalMacros === void 0) {
                globalMacros = {};
              }
              this.current = void 0;
              this.builtins = void 0;
              this.undefStack = void 0;
              this.current = globalMacros;
              this.builtins = builtins;
              this.undefStack = [];
            }
            /**
             * Start a new nested group, affecting future local `set`s.
             */
            beginGroup() {
              this.undefStack.push({});
            }
            /**
             * End current nested group, restoring values before the group began.
             */
            endGroup() {
              if (this.undefStack.length === 0) {
                throw new src_ParseError("Unbalanced namespace destruction: attempt to pop global namespace; please report this as a bug");
              }
              const undefs = this.undefStack.pop();
              for (const undef in undefs) {
                if (undefs.hasOwnProperty(undef)) {
                  if (undefs[undef] == null) {
                    delete this.current[undef];
                  } else {
                    this.current[undef] = undefs[undef];
                  }
                }
              }
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              while (this.undefStack.length > 0) {
                this.endGroup();
              }
            }
            /**
             * Detect whether `name` has a definition.  Equivalent to
             * `get(name) != null`.
             */
            has(name) {
              return this.current.hasOwnProperty(name) || this.builtins.hasOwnProperty(name);
            }
            /**
             * Get the current value of a name, or `undefined` if there is no value.
             *
             * Note: Do not use `if (namespace.get(...))` to detect whether a macro
             * is defined, as the definition may be the empty string which evaluates
             * to `false` in JavaScript.  Use `if (namespace.get(...) != null)` or
             * `if (namespace.has(...))`.
             */
            get(name) {
              if (this.current.hasOwnProperty(name)) {
                return this.current[name];
              } else {
                return this.builtins[name];
              }
            }
            /**
             * Set the current value of a name, and optionally set it globally too.
             * Local set() sets the current value and (when appropriate) adds an undo
             * operation to the undo stack.  Global set() may change the undo
             * operation at every level, so takes time linear in their number.
             * A value of undefined means to delete existing definitions.
             */
            set(name, value, global2) {
              if (global2 === void 0) {
                global2 = false;
              }
              if (global2) {
                for (let i2 = 0; i2 < this.undefStack.length; i2++) {
                  delete this.undefStack[i2][name];
                }
                if (this.undefStack.length > 0) {
                  this.undefStack[this.undefStack.length - 1][name] = value;
                }
              } else {
                const top = this.undefStack[this.undefStack.length - 1];
                if (top && !top.hasOwnProperty(name)) {
                  top[name] = this.current[name];
                }
              }
              if (value == null) {
                delete this.current[name];
              } else {
                this.current[name] = value;
              }
            }
          }
          const macros = _macros;
          var src_macros = macros;
          defineMacro("\\noexpand", function(context) {
            const t2 = context.popToken();
            if (context.isExpandable(t2.text)) {
              t2.noexpand = true;
              t2.treatAsRelax = true;
            }
            return {
              tokens: [t2],
              numArgs: 0
            };
          });
          defineMacro("\\expandafter", function(context) {
            const t2 = context.popToken();
            context.expandOnce(true);
            return {
              tokens: [t2],
              numArgs: 0
            };
          });
          defineMacro("\\@firstoftwo", function(context) {
            const args = context.consumeArgs(2);
            return {
              tokens: args[0],
              numArgs: 0
            };
          });
          defineMacro("\\@secondoftwo", function(context) {
            const args = context.consumeArgs(2);
            return {
              tokens: args[1],
              numArgs: 0
            };
          });
          defineMacro("\\@ifnextchar", function(context) {
            const args = context.consumeArgs(3);
            context.consumeSpaces();
            const nextToken = context.future();
            if (args[0].length === 1 && args[0][0].text === nextToken.text) {
              return {
                tokens: args[1],
                numArgs: 0
              };
            } else {
              return {
                tokens: args[2],
                numArgs: 0
              };
            }
          });
          defineMacro("\\@ifstar", "\\@ifnextchar *{\\@firstoftwo{#1}}");
          defineMacro("\\TextOrMath", function(context) {
            const args = context.consumeArgs(2);
            if (context.mode === "text") {
              return {
                tokens: args[0],
                numArgs: 0
              };
            } else {
              return {
                tokens: args[1],
                numArgs: 0
              };
            }
          });
          const digitToNumber = {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
            "a": 10,
            "A": 10,
            "b": 11,
            "B": 11,
            "c": 12,
            "C": 12,
            "d": 13,
            "D": 13,
            "e": 14,
            "E": 14,
            "f": 15,
            "F": 15
          };
          defineMacro("\\char", function(context) {
            let token = context.popToken();
            let base;
            let number = "";
            if (token.text === "'") {
              base = 8;
              token = context.popToken();
            } else if (token.text === '"') {
              base = 16;
              token = context.popToken();
            } else if (token.text === "`") {
              token = context.popToken();
              if (token.text[0] === "\\") {
                number = token.text.charCodeAt(1);
              } else if (token.text === "EOF") {
                throw new src_ParseError("\\char` missing argument");
              } else {
                number = token.text.charCodeAt(0);
              }
            } else {
              base = 10;
            }
            if (base) {
              number = digitToNumber[token.text];
              if (number == null || number >= base) {
                throw new src_ParseError("Invalid base-" + base + " digit " + token.text);
              }
              let digit;
              while ((digit = digitToNumber[context.future().text]) != null && digit < base) {
                number *= base;
                number += digit;
                context.popToken();
              }
            }
            return "\\@char{" + number + "}";
          });
          const newcommand = (context, existsOK, nonexistsOK) => {
            let arg = context.consumeArg().tokens;
            if (arg.length !== 1) {
              throw new src_ParseError("\\newcommand's first argument must be a macro name");
            }
            const name = arg[0].text;
            const exists = context.isDefined(name);
            if (exists && !existsOK) {
              throw new src_ParseError("\\newcommand{" + name + "} attempting to redefine " + (name + "; use \\renewcommand"));
            }
            if (!exists && !nonexistsOK) {
              throw new src_ParseError("\\renewcommand{" + name + "} when command " + name + " does not yet exist; use \\newcommand");
            }
            let numArgs = 0;
            arg = context.consumeArg().tokens;
            if (arg.length === 1 && arg[0].text === "[") {
              let argText = "";
              let token = context.expandNextToken();
              while (token.text !== "]" && token.text !== "EOF") {
                argText += token.text;
                token = context.expandNextToken();
              }
              if (!argText.match(/^\s*[0-9]+\s*$/)) {
                throw new src_ParseError("Invalid number of arguments: " + argText);
              }
              numArgs = parseInt(argText);
              arg = context.consumeArg().tokens;
            }
            context.macros.set(name, {
              tokens: arg,
              numArgs
            });
            return "";
          };
          defineMacro("\\newcommand", (context) => newcommand(context, false, true));
          defineMacro("\\renewcommand", (context) => newcommand(context, true, false));
          defineMacro("\\providecommand", (context) => newcommand(context, true, true));
          defineMacro("\\message", (context) => {
            const arg = context.consumeArgs(1)[0];
            console.log(arg.reverse().map((token) => token.text).join(""));
            return "";
          });
          defineMacro("\\errmessage", (context) => {
            const arg = context.consumeArgs(1)[0];
            console.error(arg.reverse().map((token) => token.text).join(""));
            return "";
          });
          defineMacro("\\show", (context) => {
            const tok = context.popToken();
            const name = tok.text;
            console.log(tok, context.macros.get(name), src_functions[name], src_symbols.math[name], src_symbols.text[name]);
            return "";
          });
          defineMacro("\\bgroup", "{");
          defineMacro("\\egroup", "}");
          defineMacro("~", "\\nobreakspace");
          defineMacro("\\lq", "`");
          defineMacro("\\rq", "'");
          defineMacro("\\aa", "\\r a");
          defineMacro("\\AA", "\\r A");
          defineMacro("\\textcopyright", "\\html@mathml{\\textcircled{c}}{\\char`©}");
          defineMacro("\\copyright", "\\TextOrMath{\\textcopyright}{\\text{\\textcopyright}}");
          defineMacro("\\textregistered", "\\html@mathml{\\textcircled{\\scriptsize R}}{\\char`®}");
          defineMacro("ℬ", "\\mathscr{B}");
          defineMacro("ℰ", "\\mathscr{E}");
          defineMacro("ℱ", "\\mathscr{F}");
          defineMacro("ℋ", "\\mathscr{H}");
          defineMacro("ℐ", "\\mathscr{I}");
          defineMacro("ℒ", "\\mathscr{L}");
          defineMacro("ℳ", "\\mathscr{M}");
          defineMacro("ℛ", "\\mathscr{R}");
          defineMacro("ℭ", "\\mathfrak{C}");
          defineMacro("ℌ", "\\mathfrak{H}");
          defineMacro("ℨ", "\\mathfrak{Z}");
          defineMacro("\\Bbbk", "\\Bbb{k}");
          defineMacro("·", "\\cdotp");
          defineMacro("\\llap", "\\mathllap{\\textrm{#1}}");
          defineMacro("\\rlap", "\\mathrlap{\\textrm{#1}}");
          defineMacro("\\clap", "\\mathclap{\\textrm{#1}}");
          defineMacro("\\mathstrut", "\\vphantom{(}");
          defineMacro("\\underbar", "\\underline{\\text{#1}}");
          defineMacro("\\not", '\\html@mathml{\\mathrel{\\mathrlap\\@not}}{\\char"338}');
          defineMacro("\\neq", "\\html@mathml{\\mathrel{\\not=}}{\\mathrel{\\char`≠}}");
          defineMacro("\\ne", "\\neq");
          defineMacro("≠", "\\neq");
          defineMacro("\\notin", "\\html@mathml{\\mathrel{{\\in}\\mathllap{/\\mskip1mu}}}{\\mathrel{\\char`∉}}");
          defineMacro("∉", "\\notin");
          defineMacro("≘", "\\html@mathml{\\mathrel{=\\kern{-1em}\\raisebox{0.4em}{$\\scriptsize\\frown$}}}{\\mathrel{\\char`≘}}");
          defineMacro("≙", "\\html@mathml{\\stackrel{\\tiny\\wedge}{=}}{\\mathrel{\\char`≘}}");
          defineMacro("≚", "\\html@mathml{\\stackrel{\\tiny\\vee}{=}}{\\mathrel{\\char`≚}}");
          defineMacro("≛", "\\html@mathml{\\stackrel{\\scriptsize\\star}{=}}{\\mathrel{\\char`≛}}");
          defineMacro("≝", "\\html@mathml{\\stackrel{\\tiny\\mathrm{def}}{=}}{\\mathrel{\\char`≝}}");
          defineMacro("≞", "\\html@mathml{\\stackrel{\\tiny\\mathrm{m}}{=}}{\\mathrel{\\char`≞}}");
          defineMacro("≟", "\\html@mathml{\\stackrel{\\tiny?}{=}}{\\mathrel{\\char`≟}}");
          defineMacro("⟂", "\\perp");
          defineMacro("‼", "\\mathclose{!\\mkern-0.8mu!}");
          defineMacro("∌", "\\notni");
          defineMacro("⌜", "\\ulcorner");
          defineMacro("⌝", "\\urcorner");
          defineMacro("⌞", "\\llcorner");
          defineMacro("⌟", "\\lrcorner");
          defineMacro("©", "\\copyright");
          defineMacro("®", "\\textregistered");
          defineMacro("️", "\\textregistered");
          defineMacro("\\ulcorner", '\\html@mathml{\\@ulcorner}{\\mathop{\\char"231c}}');
          defineMacro("\\urcorner", '\\html@mathml{\\@urcorner}{\\mathop{\\char"231d}}');
          defineMacro("\\llcorner", '\\html@mathml{\\@llcorner}{\\mathop{\\char"231e}}');
          defineMacro("\\lrcorner", '\\html@mathml{\\@lrcorner}{\\mathop{\\char"231f}}');
          defineMacro("\\vdots", "{\\varvdots\\rule{0pt}{15pt}}");
          defineMacro("⋮", "\\vdots");
          defineMacro("\\varGamma", "\\mathit{\\Gamma}");
          defineMacro("\\varDelta", "\\mathit{\\Delta}");
          defineMacro("\\varTheta", "\\mathit{\\Theta}");
          defineMacro("\\varLambda", "\\mathit{\\Lambda}");
          defineMacro("\\varXi", "\\mathit{\\Xi}");
          defineMacro("\\varPi", "\\mathit{\\Pi}");
          defineMacro("\\varSigma", "\\mathit{\\Sigma}");
          defineMacro("\\varUpsilon", "\\mathit{\\Upsilon}");
          defineMacro("\\varPhi", "\\mathit{\\Phi}");
          defineMacro("\\varPsi", "\\mathit{\\Psi}");
          defineMacro("\\varOmega", "\\mathit{\\Omega}");
          defineMacro("\\substack", "\\begin{subarray}{c}#1\\end{subarray}");
          defineMacro("\\colon", "\\nobreak\\mskip2mu\\mathpunct{}\\mathchoice{\\mkern-3mu}{\\mkern-3mu}{}{}{:}\\mskip6mu\\relax");
          defineMacro("\\boxed", "\\fbox{$\\displaystyle{#1}$}");
          defineMacro("\\iff", "\\DOTSB\\;\\Longleftrightarrow\\;");
          defineMacro("\\implies", "\\DOTSB\\;\\Longrightarrow\\;");
          defineMacro("\\impliedby", "\\DOTSB\\;\\Longleftarrow\\;");
          defineMacro("\\dddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ...}}{#1}}");
          defineMacro("\\ddddot", "{\\overset{\\raisebox{-0.1ex}{\\normalsize ....}}{#1}}");
          const dotsByToken = {
            ",": "\\dotsc",
            "\\not": "\\dotsb",
            // \keybin@ checks for the following:
            "+": "\\dotsb",
            "=": "\\dotsb",
            "<": "\\dotsb",
            ">": "\\dotsb",
            "-": "\\dotsb",
            "*": "\\dotsb",
            ":": "\\dotsb",
            // Symbols whose definition starts with \DOTSB:
            "\\DOTSB": "\\dotsb",
            "\\coprod": "\\dotsb",
            "\\bigvee": "\\dotsb",
            "\\bigwedge": "\\dotsb",
            "\\biguplus": "\\dotsb",
            "\\bigcap": "\\dotsb",
            "\\bigcup": "\\dotsb",
            "\\prod": "\\dotsb",
            "\\sum": "\\dotsb",
            "\\bigotimes": "\\dotsb",
            "\\bigoplus": "\\dotsb",
            "\\bigodot": "\\dotsb",
            "\\bigsqcup": "\\dotsb",
            "\\And": "\\dotsb",
            "\\longrightarrow": "\\dotsb",
            "\\Longrightarrow": "\\dotsb",
            "\\longleftarrow": "\\dotsb",
            "\\Longleftarrow": "\\dotsb",
            "\\longleftrightarrow": "\\dotsb",
            "\\Longleftrightarrow": "\\dotsb",
            "\\mapsto": "\\dotsb",
            "\\longmapsto": "\\dotsb",
            "\\hookrightarrow": "\\dotsb",
            "\\doteq": "\\dotsb",
            // Symbols whose definition starts with \mathbin:
            "\\mathbin": "\\dotsb",
            // Symbols whose definition starts with \mathrel:
            "\\mathrel": "\\dotsb",
            "\\relbar": "\\dotsb",
            "\\Relbar": "\\dotsb",
            "\\xrightarrow": "\\dotsb",
            "\\xleftarrow": "\\dotsb",
            // Symbols whose definition starts with \DOTSI:
            "\\DOTSI": "\\dotsi",
            "\\int": "\\dotsi",
            "\\oint": "\\dotsi",
            "\\iint": "\\dotsi",
            "\\iiint": "\\dotsi",
            "\\iiiint": "\\dotsi",
            "\\idotsint": "\\dotsi",
            // Symbols whose definition starts with \DOTSX:
            "\\DOTSX": "\\dotsx"
          };
          defineMacro("\\dots", function(context) {
            let thedots = "\\dotso";
            const next = context.expandAfterFuture().text;
            if (next in dotsByToken) {
              thedots = dotsByToken[next];
            } else if (next.slice(0, 4) === "\\not") {
              thedots = "\\dotsb";
            } else if (next in src_symbols.math) {
              if (utils.contains(["bin", "rel"], src_symbols.math[next].group)) {
                thedots = "\\dotsb";
              }
            }
            return thedots;
          });
          const spaceAfterDots = {
            // \rightdelim@ checks for the following:
            ")": true,
            "]": true,
            "\\rbrack": true,
            "\\}": true,
            "\\rbrace": true,
            "\\rangle": true,
            "\\rceil": true,
            "\\rfloor": true,
            "\\rgroup": true,
            "\\rmoustache": true,
            "\\right": true,
            "\\bigr": true,
            "\\biggr": true,
            "\\Bigr": true,
            "\\Biggr": true,
            // \extra@ also tests for the following:
            "$": true,
            // \extrap@ checks for the following:
            ";": true,
            ".": true,
            ",": true
          };
          defineMacro("\\dotso", function(context) {
            const next = context.future().text;
            if (next in spaceAfterDots) {
              return "\\ldots\\,";
            } else {
              return "\\ldots";
            }
          });
          defineMacro("\\dotsc", function(context) {
            const next = context.future().text;
            if (next in spaceAfterDots && next !== ",") {
              return "\\ldots\\,";
            } else {
              return "\\ldots";
            }
          });
          defineMacro("\\cdots", function(context) {
            const next = context.future().text;
            if (next in spaceAfterDots) {
              return "\\@cdots\\,";
            } else {
              return "\\@cdots";
            }
          });
          defineMacro("\\dotsb", "\\cdots");
          defineMacro("\\dotsm", "\\cdots");
          defineMacro("\\dotsi", "\\!\\cdots");
          defineMacro("\\dotsx", "\\ldots\\,");
          defineMacro("\\DOTSI", "\\relax");
          defineMacro("\\DOTSB", "\\relax");
          defineMacro("\\DOTSX", "\\relax");
          defineMacro("\\tmspace", "\\TextOrMath{\\kern#1#3}{\\mskip#1#2}\\relax");
          defineMacro("\\,", "\\tmspace+{3mu}{.1667em}");
          defineMacro("\\thinspace", "\\,");
          defineMacro("\\>", "\\mskip{4mu}");
          defineMacro("\\:", "\\tmspace+{4mu}{.2222em}");
          defineMacro("\\medspace", "\\:");
          defineMacro("\\;", "\\tmspace+{5mu}{.2777em}");
          defineMacro("\\thickspace", "\\;");
          defineMacro("\\!", "\\tmspace-{3mu}{.1667em}");
          defineMacro("\\negthinspace", "\\!");
          defineMacro("\\negmedspace", "\\tmspace-{4mu}{.2222em}");
          defineMacro("\\negthickspace", "\\tmspace-{5mu}{.277em}");
          defineMacro("\\enspace", "\\kern.5em ");
          defineMacro("\\enskip", "\\hskip.5em\\relax");
          defineMacro("\\quad", "\\hskip1em\\relax");
          defineMacro("\\qquad", "\\hskip2em\\relax");
          defineMacro("\\tag", "\\@ifstar\\tag@literal\\tag@paren");
          defineMacro("\\tag@paren", "\\tag@literal{({#1})}");
          defineMacro("\\tag@literal", (context) => {
            if (context.macros.get("\\df@tag")) {
              throw new src_ParseError("Multiple \\tag");
            }
            return "\\gdef\\df@tag{\\text{#1}}";
          });
          defineMacro("\\bmod", "\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}\\mathbin{\\rm mod}\\mathchoice{\\mskip1mu}{\\mskip1mu}{\\mskip5mu}{\\mskip5mu}");
          defineMacro("\\pod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern8mu}{\\mkern8mu}{\\mkern8mu}(#1)");
          defineMacro("\\pmod", "\\pod{{\\rm mod}\\mkern6mu#1}");
          defineMacro("\\mod", "\\allowbreak\\mathchoice{\\mkern18mu}{\\mkern12mu}{\\mkern12mu}{\\mkern12mu}{\\rm mod}\\,\\,#1");
          defineMacro("\\newline", "\\\\\\relax");
          defineMacro("\\TeX", "\\textrm{\\html@mathml{T\\kern-.1667em\\raisebox{-.5ex}{E}\\kern-.125emX}{TeX}}");
          const latexRaiseA = makeEm(fontMetricsData["Main-Regular"]["T".charCodeAt(0)][1] - 0.7 * fontMetricsData["Main-Regular"]["A".charCodeAt(0)][1]);
          defineMacro("\\LaTeX", "\\textrm{\\html@mathml{" + ("L\\kern-.36em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{LaTeX}}");
          defineMacro("\\KaTeX", "\\textrm{\\html@mathml{" + ("K\\kern-.17em\\raisebox{" + latexRaiseA + "}{\\scriptstyle A}") + "\\kern-.15em\\TeX}{KaTeX}}");
          defineMacro("\\hspace", "\\@ifstar\\@hspacer\\@hspace");
          defineMacro("\\@hspace", "\\hskip #1\\relax");
          defineMacro("\\@hspacer", "\\rule{0pt}{0pt}\\hskip #1\\relax");
          defineMacro("\\ordinarycolon", ":");
          defineMacro("\\vcentcolon", "\\mathrel{\\mathop\\ordinarycolon}");
          defineMacro("\\dblcolon", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-.9mu}\\vcentcolon}}{\\mathop{\\char"2237}}');
          defineMacro("\\coloneqq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2254}}');
          defineMacro("\\Coloneqq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}=}}{\\mathop{\\char"2237\\char"3d}}');
          defineMacro("\\coloneq", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"3a\\char"2212}}');
          defineMacro("\\Coloneq", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\mathrel{-}}}{\\mathop{\\char"2237\\char"2212}}');
          defineMacro("\\eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2255}}');
          defineMacro("\\Eqqcolon", '\\html@mathml{\\mathrel{=\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"3d\\char"2237}}');
          defineMacro("\\eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\vcentcolon}}{\\mathop{\\char"2239}}');
          defineMacro("\\Eqcolon", '\\html@mathml{\\mathrel{\\mathrel{-}\\mathrel{\\mkern-1.2mu}\\dblcolon}}{\\mathop{\\char"2212\\char"2237}}');
          defineMacro("\\colonapprox", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"3a\\char"2248}}');
          defineMacro("\\Colonapprox", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\approx}}{\\mathop{\\char"2237\\char"2248}}');
          defineMacro("\\colonsim", '\\html@mathml{\\mathrel{\\vcentcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"3a\\char"223c}}');
          defineMacro("\\Colonsim", '\\html@mathml{\\mathrel{\\dblcolon\\mathrel{\\mkern-1.2mu}\\sim}}{\\mathop{\\char"2237\\char"223c}}');
          defineMacro("∷", "\\dblcolon");
          defineMacro("∹", "\\eqcolon");
          defineMacro("≔", "\\coloneqq");
          defineMacro("≕", "\\eqqcolon");
          defineMacro("⩴", "\\Coloneqq");
          defineMacro("\\ratio", "\\vcentcolon");
          defineMacro("\\coloncolon", "\\dblcolon");
          defineMacro("\\colonequals", "\\coloneqq");
          defineMacro("\\coloncolonequals", "\\Coloneqq");
          defineMacro("\\equalscolon", "\\eqqcolon");
          defineMacro("\\equalscoloncolon", "\\Eqqcolon");
          defineMacro("\\colonminus", "\\coloneq");
          defineMacro("\\coloncolonminus", "\\Coloneq");
          defineMacro("\\minuscolon", "\\eqcolon");
          defineMacro("\\minuscoloncolon", "\\Eqcolon");
          defineMacro("\\coloncolonapprox", "\\Colonapprox");
          defineMacro("\\coloncolonsim", "\\Colonsim");
          defineMacro("\\simcolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
          defineMacro("\\simcoloncolon", "\\mathrel{\\sim\\mathrel{\\mkern-1.2mu}\\dblcolon}");
          defineMacro("\\approxcolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\vcentcolon}");
          defineMacro("\\approxcoloncolon", "\\mathrel{\\approx\\mathrel{\\mkern-1.2mu}\\dblcolon}");
          defineMacro("\\notni", "\\html@mathml{\\not\\ni}{\\mathrel{\\char`∌}}");
          defineMacro("\\limsup", "\\DOTSB\\operatorname*{lim\\,sup}");
          defineMacro("\\liminf", "\\DOTSB\\operatorname*{lim\\,inf}");
          defineMacro("\\injlim", "\\DOTSB\\operatorname*{inj\\,lim}");
          defineMacro("\\projlim", "\\DOTSB\\operatorname*{proj\\,lim}");
          defineMacro("\\varlimsup", "\\DOTSB\\operatorname*{\\overline{lim}}");
          defineMacro("\\varliminf", "\\DOTSB\\operatorname*{\\underline{lim}}");
          defineMacro("\\varinjlim", "\\DOTSB\\operatorname*{\\underrightarrow{lim}}");
          defineMacro("\\varprojlim", "\\DOTSB\\operatorname*{\\underleftarrow{lim}}");
          defineMacro("\\gvertneqq", "\\html@mathml{\\@gvertneqq}{≩}");
          defineMacro("\\lvertneqq", "\\html@mathml{\\@lvertneqq}{≨}");
          defineMacro("\\ngeqq", "\\html@mathml{\\@ngeqq}{≱}");
          defineMacro("\\ngeqslant", "\\html@mathml{\\@ngeqslant}{≱}");
          defineMacro("\\nleqq", "\\html@mathml{\\@nleqq}{≰}");
          defineMacro("\\nleqslant", "\\html@mathml{\\@nleqslant}{≰}");
          defineMacro("\\nshortmid", "\\html@mathml{\\@nshortmid}{∤}");
          defineMacro("\\nshortparallel", "\\html@mathml{\\@nshortparallel}{∦}");
          defineMacro("\\nsubseteqq", "\\html@mathml{\\@nsubseteqq}{⊈}");
          defineMacro("\\nsupseteqq", "\\html@mathml{\\@nsupseteqq}{⊉}");
          defineMacro("\\varsubsetneq", "\\html@mathml{\\@varsubsetneq}{⊊}");
          defineMacro("\\varsubsetneqq", "\\html@mathml{\\@varsubsetneqq}{⫋}");
          defineMacro("\\varsupsetneq", "\\html@mathml{\\@varsupsetneq}{⊋}");
          defineMacro("\\varsupsetneqq", "\\html@mathml{\\@varsupsetneqq}{⫌}");
          defineMacro("\\imath", "\\html@mathml{\\@imath}{ı}");
          defineMacro("\\jmath", "\\html@mathml{\\@jmath}{ȷ}");
          defineMacro("\\llbracket", "\\html@mathml{\\mathopen{[\\mkern-3.2mu[}}{\\mathopen{\\char`⟦}}");
          defineMacro("\\rrbracket", "\\html@mathml{\\mathclose{]\\mkern-3.2mu]}}{\\mathclose{\\char`⟧}}");
          defineMacro("⟦", "\\llbracket");
          defineMacro("⟧", "\\rrbracket");
          defineMacro("\\lBrace", "\\html@mathml{\\mathopen{\\{\\mkern-3.2mu[}}{\\mathopen{\\char`⦃}}");
          defineMacro("\\rBrace", "\\html@mathml{\\mathclose{]\\mkern-3.2mu\\}}}{\\mathclose{\\char`⦄}}");
          defineMacro("⦃", "\\lBrace");
          defineMacro("⦄", "\\rBrace");
          defineMacro("\\minuso", "\\mathbin{\\html@mathml{{\\mathrlap{\\mathchoice{\\kern{0.145em}}{\\kern{0.145em}}{\\kern{0.1015em}}{\\kern{0.0725em}}\\circ}{-}}}{\\char`⦵}}");
          defineMacro("⦵", "\\minuso");
          defineMacro("\\darr", "\\downarrow");
          defineMacro("\\dArr", "\\Downarrow");
          defineMacro("\\Darr", "\\Downarrow");
          defineMacro("\\lang", "\\langle");
          defineMacro("\\rang", "\\rangle");
          defineMacro("\\uarr", "\\uparrow");
          defineMacro("\\uArr", "\\Uparrow");
          defineMacro("\\Uarr", "\\Uparrow");
          defineMacro("\\N", "\\mathbb{N}");
          defineMacro("\\R", "\\mathbb{R}");
          defineMacro("\\Z", "\\mathbb{Z}");
          defineMacro("\\alef", "\\aleph");
          defineMacro("\\alefsym", "\\aleph");
          defineMacro("\\Alpha", "\\mathrm{A}");
          defineMacro("\\Beta", "\\mathrm{B}");
          defineMacro("\\bull", "\\bullet");
          defineMacro("\\Chi", "\\mathrm{X}");
          defineMacro("\\clubs", "\\clubsuit");
          defineMacro("\\cnums", "\\mathbb{C}");
          defineMacro("\\Complex", "\\mathbb{C}");
          defineMacro("\\Dagger", "\\ddagger");
          defineMacro("\\diamonds", "\\diamondsuit");
          defineMacro("\\empty", "\\emptyset");
          defineMacro("\\Epsilon", "\\mathrm{E}");
          defineMacro("\\Eta", "\\mathrm{H}");
          defineMacro("\\exist", "\\exists");
          defineMacro("\\harr", "\\leftrightarrow");
          defineMacro("\\hArr", "\\Leftrightarrow");
          defineMacro("\\Harr", "\\Leftrightarrow");
          defineMacro("\\hearts", "\\heartsuit");
          defineMacro("\\image", "\\Im");
          defineMacro("\\infin", "\\infty");
          defineMacro("\\Iota", "\\mathrm{I}");
          defineMacro("\\isin", "\\in");
          defineMacro("\\Kappa", "\\mathrm{K}");
          defineMacro("\\larr", "\\leftarrow");
          defineMacro("\\lArr", "\\Leftarrow");
          defineMacro("\\Larr", "\\Leftarrow");
          defineMacro("\\lrarr", "\\leftrightarrow");
          defineMacro("\\lrArr", "\\Leftrightarrow");
          defineMacro("\\Lrarr", "\\Leftrightarrow");
          defineMacro("\\Mu", "\\mathrm{M}");
          defineMacro("\\natnums", "\\mathbb{N}");
          defineMacro("\\Nu", "\\mathrm{N}");
          defineMacro("\\Omicron", "\\mathrm{O}");
          defineMacro("\\plusmn", "\\pm");
          defineMacro("\\rarr", "\\rightarrow");
          defineMacro("\\rArr", "\\Rightarrow");
          defineMacro("\\Rarr", "\\Rightarrow");
          defineMacro("\\real", "\\Re");
          defineMacro("\\reals", "\\mathbb{R}");
          defineMacro("\\Reals", "\\mathbb{R}");
          defineMacro("\\Rho", "\\mathrm{P}");
          defineMacro("\\sdot", "\\cdot");
          defineMacro("\\sect", "\\S");
          defineMacro("\\spades", "\\spadesuit");
          defineMacro("\\sub", "\\subset");
          defineMacro("\\sube", "\\subseteq");
          defineMacro("\\supe", "\\supseteq");
          defineMacro("\\Tau", "\\mathrm{T}");
          defineMacro("\\thetasym", "\\vartheta");
          defineMacro("\\weierp", "\\wp");
          defineMacro("\\Zeta", "\\mathrm{Z}");
          defineMacro("\\argmin", "\\DOTSB\\operatorname*{arg\\,min}");
          defineMacro("\\argmax", "\\DOTSB\\operatorname*{arg\\,max}");
          defineMacro("\\plim", "\\DOTSB\\mathop{\\operatorname{plim}}\\limits");
          defineMacro("\\bra", "\\mathinner{\\langle{#1}|}");
          defineMacro("\\ket", "\\mathinner{|{#1}\\rangle}");
          defineMacro("\\braket", "\\mathinner{\\langle{#1}\\rangle}");
          defineMacro("\\Bra", "\\left\\langle#1\\right|");
          defineMacro("\\Ket", "\\left|#1\\right\\rangle");
          const braketHelper = (one) => (context) => {
            const left = context.consumeArg().tokens;
            const middle = context.consumeArg().tokens;
            const middleDouble = context.consumeArg().tokens;
            const right = context.consumeArg().tokens;
            const oldMiddle = context.macros.get("|");
            const oldMiddleDouble = context.macros.get("\\|");
            context.macros.beginGroup();
            const midMacro = (double) => (context2) => {
              if (one) {
                context2.macros.set("|", oldMiddle);
                if (middleDouble.length) {
                  context2.macros.set("\\|", oldMiddleDouble);
                }
              }
              let doubled = double;
              if (!double && middleDouble.length) {
                const nextToken = context2.future();
                if (nextToken.text === "|") {
                  context2.popToken();
                  doubled = true;
                }
              }
              return {
                tokens: doubled ? middleDouble : middle,
                numArgs: 0
              };
            };
            context.macros.set("|", midMacro(false));
            if (middleDouble.length) {
              context.macros.set("\\|", midMacro(true));
            }
            const arg = context.consumeArg().tokens;
            const expanded = context.expandTokens([
              ...right,
              ...arg,
              ...left
              // reversed
            ]);
            context.macros.endGroup();
            return {
              tokens: expanded.reverse(),
              numArgs: 0
            };
          };
          defineMacro("\\bra@ket", braketHelper(false));
          defineMacro("\\bra@set", braketHelper(true));
          defineMacro("\\Braket", "\\bra@ket{\\left\\langle}{\\,\\middle\\vert\\,}{\\,\\middle\\vert\\,}{\\right\\rangle}");
          defineMacro("\\Set", "\\bra@set{\\left\\{\\:}{\\;\\middle\\vert\\;}{\\;\\middle\\Vert\\;}{\\:\\right\\}}");
          defineMacro("\\set", "\\bra@set{\\{\\,}{\\mid}{}{\\,\\}}");
          defineMacro("\\angln", "{\\angl n}");
          defineMacro("\\blue", "\\textcolor{##6495ed}{#1}");
          defineMacro("\\orange", "\\textcolor{##ffa500}{#1}");
          defineMacro("\\pink", "\\textcolor{##ff00af}{#1}");
          defineMacro("\\red", "\\textcolor{##df0030}{#1}");
          defineMacro("\\green", "\\textcolor{##28ae7b}{#1}");
          defineMacro("\\gray", "\\textcolor{gray}{#1}");
          defineMacro("\\purple", "\\textcolor{##9d38bd}{#1}");
          defineMacro("\\blueA", "\\textcolor{##ccfaff}{#1}");
          defineMacro("\\blueB", "\\textcolor{##80f6ff}{#1}");
          defineMacro("\\blueC", "\\textcolor{##63d9ea}{#1}");
          defineMacro("\\blueD", "\\textcolor{##11accd}{#1}");
          defineMacro("\\blueE", "\\textcolor{##0c7f99}{#1}");
          defineMacro("\\tealA", "\\textcolor{##94fff5}{#1}");
          defineMacro("\\tealB", "\\textcolor{##26edd5}{#1}");
          defineMacro("\\tealC", "\\textcolor{##01d1c1}{#1}");
          defineMacro("\\tealD", "\\textcolor{##01a995}{#1}");
          defineMacro("\\tealE", "\\textcolor{##208170}{#1}");
          defineMacro("\\greenA", "\\textcolor{##b6ffb0}{#1}");
          defineMacro("\\greenB", "\\textcolor{##8af281}{#1}");
          defineMacro("\\greenC", "\\textcolor{##74cf70}{#1}");
          defineMacro("\\greenD", "\\textcolor{##1fab54}{#1}");
          defineMacro("\\greenE", "\\textcolor{##0d923f}{#1}");
          defineMacro("\\goldA", "\\textcolor{##ffd0a9}{#1}");
          defineMacro("\\goldB", "\\textcolor{##ffbb71}{#1}");
          defineMacro("\\goldC", "\\textcolor{##ff9c39}{#1}");
          defineMacro("\\goldD", "\\textcolor{##e07d10}{#1}");
          defineMacro("\\goldE", "\\textcolor{##a75a05}{#1}");
          defineMacro("\\redA", "\\textcolor{##fca9a9}{#1}");
          defineMacro("\\redB", "\\textcolor{##ff8482}{#1}");
          defineMacro("\\redC", "\\textcolor{##f9685d}{#1}");
          defineMacro("\\redD", "\\textcolor{##e84d39}{#1}");
          defineMacro("\\redE", "\\textcolor{##bc2612}{#1}");
          defineMacro("\\maroonA", "\\textcolor{##ffbde0}{#1}");
          defineMacro("\\maroonB", "\\textcolor{##ff92c6}{#1}");
          defineMacro("\\maroonC", "\\textcolor{##ed5fa6}{#1}");
          defineMacro("\\maroonD", "\\textcolor{##ca337c}{#1}");
          defineMacro("\\maroonE", "\\textcolor{##9e034e}{#1}");
          defineMacro("\\purpleA", "\\textcolor{##ddd7ff}{#1}");
          defineMacro("\\purpleB", "\\textcolor{##c6b9fc}{#1}");
          defineMacro("\\purpleC", "\\textcolor{##aa87ff}{#1}");
          defineMacro("\\purpleD", "\\textcolor{##7854ab}{#1}");
          defineMacro("\\purpleE", "\\textcolor{##543b78}{#1}");
          defineMacro("\\mintA", "\\textcolor{##f5f9e8}{#1}");
          defineMacro("\\mintB", "\\textcolor{##edf2df}{#1}");
          defineMacro("\\mintC", "\\textcolor{##e0e5cc}{#1}");
          defineMacro("\\grayA", "\\textcolor{##f6f7f7}{#1}");
          defineMacro("\\grayB", "\\textcolor{##f0f1f2}{#1}");
          defineMacro("\\grayC", "\\textcolor{##e3e5e6}{#1}");
          defineMacro("\\grayD", "\\textcolor{##d6d8da}{#1}");
          defineMacro("\\grayE", "\\textcolor{##babec2}{#1}");
          defineMacro("\\grayF", "\\textcolor{##888d93}{#1}");
          defineMacro("\\grayG", "\\textcolor{##626569}{#1}");
          defineMacro("\\grayH", "\\textcolor{##3b3e40}{#1}");
          defineMacro("\\grayI", "\\textcolor{##21242c}{#1}");
          defineMacro("\\kaBlue", "\\textcolor{##314453}{#1}");
          defineMacro("\\kaGreen", "\\textcolor{##71B307}{#1}");
          const implicitCommands = {
            "^": true,
            // Parser.js
            "_": true,
            // Parser.js
            "\\limits": true,
            // Parser.js
            "\\nolimits": true
            // Parser.js
          };
          class MacroExpander {
            constructor(input, settings, mode) {
              this.settings = void 0;
              this.expansionCount = void 0;
              this.lexer = void 0;
              this.macros = void 0;
              this.stack = void 0;
              this.mode = void 0;
              this.settings = settings;
              this.expansionCount = 0;
              this.feed(input);
              this.macros = new Namespace(src_macros, settings.macros);
              this.mode = mode;
              this.stack = [];
            }
            /**
             * Feed a new input string to the same MacroExpander
             * (with existing macros etc.).
             */
            feed(input) {
              this.lexer = new Lexer(input, this.settings);
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(newMode) {
              this.mode = newMode;
            }
            /**
             * Start a new group nesting within all namespaces.
             */
            beginGroup() {
              this.macros.beginGroup();
            }
            /**
             * End current group nesting within all namespaces.
             */
            endGroup() {
              this.macros.endGroup();
            }
            /**
             * Ends all currently nested groups (if any), restoring values before the
             * groups began.  Useful in case of an error in the middle of parsing.
             */
            endGroups() {
              this.macros.endGroups();
            }
            /**
             * Returns the topmost token on the stack, without expanding it.
             * Similar in behavior to TeX's `\futurelet`.
             */
            future() {
              if (this.stack.length === 0) {
                this.pushToken(this.lexer.lex());
              }
              return this.stack[this.stack.length - 1];
            }
            /**
             * Remove and return the next unexpanded token.
             */
            popToken() {
              this.future();
              return this.stack.pop();
            }
            /**
             * Add a given token to the token stack.  In particular, this get be used
             * to put back a token returned from one of the other methods.
             */
            pushToken(token) {
              this.stack.push(token);
            }
            /**
             * Append an array of tokens to the token stack.
             */
            pushTokens(tokens) {
              this.stack.push(...tokens);
            }
            /**
             * Find an macro argument without expanding tokens and append the array of
             * tokens to the token stack. Uses Token as a container for the result.
             */
            scanArgument(isOptional) {
              let start;
              let end;
              let tokens;
              if (isOptional) {
                this.consumeSpaces();
                if (this.future().text !== "[") {
                  return null;
                }
                start = this.popToken();
                ({
                  tokens,
                  end
                } = this.consumeArg(["]"]));
              } else {
                ({
                  tokens,
                  start,
                  end
                } = this.consumeArg());
              }
              this.pushToken(new Token("EOF", end.loc));
              this.pushTokens(tokens);
              return start.range(end, "");
            }
            /**
             * Consume all following space tokens, without expansion.
             */
            consumeSpaces() {
              for (; ; ) {
                const token = this.future();
                if (token.text === " ") {
                  this.stack.pop();
                } else {
                  break;
                }
              }
            }
            /**
             * Consume an argument from the token stream, and return the resulting array
             * of tokens and start/end token.
             */
            consumeArg(delims) {
              const tokens = [];
              const isDelimited = delims && delims.length > 0;
              if (!isDelimited) {
                this.consumeSpaces();
              }
              const start = this.future();
              let tok;
              let depth = 0;
              let match = 0;
              do {
                tok = this.popToken();
                tokens.push(tok);
                if (tok.text === "{") {
                  ++depth;
                } else if (tok.text === "}") {
                  --depth;
                  if (depth === -1) {
                    throw new src_ParseError("Extra }", tok);
                  }
                } else if (tok.text === "EOF") {
                  throw new src_ParseError("Unexpected end of input in a macro argument, expected '" + (delims && isDelimited ? delims[match] : "}") + "'", tok);
                }
                if (delims && isDelimited) {
                  if ((depth === 0 || depth === 1 && delims[match] === "{") && tok.text === delims[match]) {
                    ++match;
                    if (match === delims.length) {
                      tokens.splice(-match, match);
                      break;
                    }
                  } else {
                    match = 0;
                  }
                }
              } while (depth !== 0 || isDelimited);
              if (start.text === "{" && tokens[tokens.length - 1].text === "}") {
                tokens.pop();
                tokens.shift();
              }
              tokens.reverse();
              return {
                tokens,
                start,
                end: tok
              };
            }
            /**
             * Consume the specified number of (delimited) arguments from the token
             * stream and return the resulting array of arguments.
             */
            consumeArgs(numArgs, delimiters2) {
              if (delimiters2) {
                if (delimiters2.length !== numArgs + 1) {
                  throw new src_ParseError("The length of delimiters doesn't match the number of args!");
                }
                const delims = delimiters2[0];
                for (let i2 = 0; i2 < delims.length; i2++) {
                  const tok = this.popToken();
                  if (delims[i2] !== tok.text) {
                    throw new src_ParseError("Use of the macro doesn't match its definition", tok);
                  }
                }
              }
              const args = [];
              for (let i2 = 0; i2 < numArgs; i2++) {
                args.push(this.consumeArg(delimiters2 && delimiters2[i2 + 1]).tokens);
              }
              return args;
            }
            /**
             * Increment `expansionCount` by the specified amount.
             * Throw an error if it exceeds `maxExpand`.
             */
            countExpansion(amount) {
              this.expansionCount += amount;
              if (this.expansionCount > this.settings.maxExpand) {
                throw new src_ParseError("Too many expansions: infinite loop or need to increase maxExpand setting");
              }
            }
            /**
             * Expand the next token only once if possible.
             *
             * If the token is expanded, the resulting tokens will be pushed onto
             * the stack in reverse order, and the number of such tokens will be
             * returned.  This number might be zero or positive.
             *
             * If not, the return value is `false`, and the next token remains at the
             * top of the stack.
             *
             * In either case, the next token will be on the top of the stack,
             * or the stack will be empty (in case of empty expansion
             * and no other tokens).
             *
             * Used to implement `expandAfterFuture` and `expandNextToken`.
             *
             * If expandableOnly, only expandable tokens are expanded and
             * an undefined control sequence results in an error.
             */
            expandOnce(expandableOnly) {
              const topToken = this.popToken();
              const name = topToken.text;
              const expansion = !topToken.noexpand ? this._getExpansion(name) : null;
              if (expansion == null || expandableOnly && expansion.unexpandable) {
                if (expandableOnly && expansion == null && name[0] === "\\" && !this.isDefined(name)) {
                  throw new src_ParseError("Undefined control sequence: " + name);
                }
                this.pushToken(topToken);
                return false;
              }
              this.countExpansion(1);
              let tokens = expansion.tokens;
              const args = this.consumeArgs(expansion.numArgs, expansion.delimiters);
              if (expansion.numArgs) {
                tokens = tokens.slice();
                for (let i2 = tokens.length - 1; i2 >= 0; --i2) {
                  let tok = tokens[i2];
                  if (tok.text === "#") {
                    if (i2 === 0) {
                      throw new src_ParseError("Incomplete placeholder at end of macro body", tok);
                    }
                    tok = tokens[--i2];
                    if (tok.text === "#") {
                      tokens.splice(i2 + 1, 1);
                    } else if (/^[1-9]$/.test(tok.text)) {
                      tokens.splice(i2, 2, ...args[+tok.text - 1]);
                    } else {
                      throw new src_ParseError("Not a valid argument number", tok);
                    }
                  }
                }
              }
              this.pushTokens(tokens);
              return tokens.length;
            }
            /**
             * Expand the next token only once (if possible), and return the resulting
             * top token on the stack (without removing anything from the stack).
             * Similar in behavior to TeX's `\expandafter\futurelet`.
             * Equivalent to expandOnce() followed by future().
             */
            expandAfterFuture() {
              this.expandOnce();
              return this.future();
            }
            /**
             * Recursively expand first token, then return first non-expandable token.
             */
            expandNextToken() {
              for (; ; ) {
                if (this.expandOnce() === false) {
                  const token = this.stack.pop();
                  if (token.treatAsRelax) {
                    token.text = "\\relax";
                  }
                  return token;
                }
              }
              throw new Error();
            }
            /**
             * Fully expand the given macro name and return the resulting list of
             * tokens, or return `undefined` if no such macro is defined.
             */
            expandMacro(name) {
              return this.macros.has(name) ? this.expandTokens([new Token(name)]) : void 0;
            }
            /**
             * Fully expand the given token stream and return the resulting list of
             * tokens.  Note that the input tokens are in reverse order, but the
             * output tokens are in forward order.
             */
            expandTokens(tokens) {
              const output = [];
              const oldStackLength = this.stack.length;
              this.pushTokens(tokens);
              while (this.stack.length > oldStackLength) {
                if (this.expandOnce(true) === false) {
                  const token = this.stack.pop();
                  if (token.treatAsRelax) {
                    token.noexpand = false;
                    token.treatAsRelax = false;
                  }
                  output.push(token);
                }
              }
              this.countExpansion(output.length);
              return output;
            }
            /**
             * Fully expand the given macro name and return the result as a string,
             * or return `undefined` if no such macro is defined.
             */
            expandMacroAsText(name) {
              const tokens = this.expandMacro(name);
              if (tokens) {
                return tokens.map((token) => token.text).join("");
              } else {
                return tokens;
              }
            }
            /**
             * Returns the expanded macro as a reversed array of tokens and a macro
             * argument count.  Or returns `null` if no such macro.
             */
            _getExpansion(name) {
              const definition = this.macros.get(name);
              if (definition == null) {
                return definition;
              }
              if (name.length === 1) {
                const catcode = this.lexer.catcodes[name];
                if (catcode != null && catcode !== 13) {
                  return;
                }
              }
              const expansion = typeof definition === "function" ? definition(this) : definition;
              if (typeof expansion === "string") {
                let numArgs = 0;
                if (expansion.indexOf("#") !== -1) {
                  const stripped = expansion.replace(/##/g, "");
                  while (stripped.indexOf("#" + (numArgs + 1)) !== -1) {
                    ++numArgs;
                  }
                }
                const bodyLexer = new Lexer(expansion, this.settings);
                const tokens = [];
                let tok = bodyLexer.lex();
                while (tok.text !== "EOF") {
                  tokens.push(tok);
                  tok = bodyLexer.lex();
                }
                tokens.reverse();
                const expanded = {
                  tokens,
                  numArgs
                };
                return expanded;
              }
              return expansion;
            }
            /**
             * Determine whether a command is currently "defined" (has some
             * functionality), meaning that it's a macro (in the current group),
             * a function, a symbol, or one of the special commands listed in
             * `implicitCommands`.
             */
            isDefined(name) {
              return this.macros.has(name) || src_functions.hasOwnProperty(name) || src_symbols.math.hasOwnProperty(name) || src_symbols.text.hasOwnProperty(name) || implicitCommands.hasOwnProperty(name);
            }
            /**
             * Determine whether a command is expandable.
             */
            isExpandable(name) {
              const macro = this.macros.get(name);
              return macro != null ? typeof macro === "string" || typeof macro === "function" || !macro.unexpandable : src_functions.hasOwnProperty(name) && !src_functions[name].primitive;
            }
          }
          const unicodeSubRegEx = /^[₊₋₌₍₎₀₁₂₃₄₅₆₇₈₉ₐₑₕᵢⱼₖₗₘₙₒₚᵣₛₜᵤᵥₓᵦᵧᵨᵩᵪ]/;
          const uSubsAndSups = Object.freeze({
            "₊": "+",
            "₋": "-",
            "₌": "=",
            "₍": "(",
            "₎": ")",
            "₀": "0",
            "₁": "1",
            "₂": "2",
            "₃": "3",
            "₄": "4",
            "₅": "5",
            "₆": "6",
            "₇": "7",
            "₈": "8",
            "₉": "9",
            "ₐ": "a",
            "ₑ": "e",
            "ₕ": "h",
            "ᵢ": "i",
            "ⱼ": "j",
            "ₖ": "k",
            "ₗ": "l",
            "ₘ": "m",
            "ₙ": "n",
            "ₒ": "o",
            "ₚ": "p",
            "ᵣ": "r",
            "ₛ": "s",
            "ₜ": "t",
            "ᵤ": "u",
            "ᵥ": "v",
            "ₓ": "x",
            "ᵦ": "β",
            "ᵧ": "γ",
            "ᵨ": "ρ",
            "ᵩ": "ϕ",
            "ᵪ": "χ",
            "⁺": "+",
            "⁻": "-",
            "⁼": "=",
            "⁽": "(",
            "⁾": ")",
            "⁰": "0",
            "¹": "1",
            "²": "2",
            "³": "3",
            "⁴": "4",
            "⁵": "5",
            "⁶": "6",
            "⁷": "7",
            "⁸": "8",
            "⁹": "9",
            "ᴬ": "A",
            "ᴮ": "B",
            "ᴰ": "D",
            "ᴱ": "E",
            "ᴳ": "G",
            "ᴴ": "H",
            "ᴵ": "I",
            "ᴶ": "J",
            "ᴷ": "K",
            "ᴸ": "L",
            "ᴹ": "M",
            "ᴺ": "N",
            "ᴼ": "O",
            "ᴾ": "P",
            "ᴿ": "R",
            "ᵀ": "T",
            "ᵁ": "U",
            "ⱽ": "V",
            "ᵂ": "W",
            "ᵃ": "a",
            "ᵇ": "b",
            "ᶜ": "c",
            "ᵈ": "d",
            "ᵉ": "e",
            "ᶠ": "f",
            "ᵍ": "g",
            "ʰ": "h",
            "ⁱ": "i",
            "ʲ": "j",
            "ᵏ": "k",
            "ˡ": "l",
            "ᵐ": "m",
            "ⁿ": "n",
            "ᵒ": "o",
            "ᵖ": "p",
            "ʳ": "r",
            "ˢ": "s",
            "ᵗ": "t",
            "ᵘ": "u",
            "ᵛ": "v",
            "ʷ": "w",
            "ˣ": "x",
            "ʸ": "y",
            "ᶻ": "z",
            "ᵝ": "β",
            "ᵞ": "γ",
            "ᵟ": "δ",
            "ᵠ": "ϕ",
            "ᵡ": "χ",
            "ᶿ": "θ"
          });
          const unicodeAccents = {
            "́": {
              "text": "\\'",
              "math": "\\acute"
            },
            "̀": {
              "text": "\\`",
              "math": "\\grave"
            },
            "̈": {
              "text": '\\"',
              "math": "\\ddot"
            },
            "̃": {
              "text": "\\~",
              "math": "\\tilde"
            },
            "̄": {
              "text": "\\=",
              "math": "\\bar"
            },
            "̆": {
              "text": "\\u",
              "math": "\\breve"
            },
            "̌": {
              "text": "\\v",
              "math": "\\check"
            },
            "̂": {
              "text": "\\^",
              "math": "\\hat"
            },
            "̇": {
              "text": "\\.",
              "math": "\\dot"
            },
            "̊": {
              "text": "\\r",
              "math": "\\mathring"
            },
            "̋": {
              "text": "\\H"
            },
            "̧": {
              "text": "\\c"
            }
          };
          const unicodeSymbols = {
            "á": "á",
            "à": "à",
            "ä": "ä",
            "ǟ": "ǟ",
            "ã": "ã",
            "ā": "ā",
            "ă": "ă",
            "ắ": "ắ",
            "ằ": "ằ",
            "ẵ": "ẵ",
            "ǎ": "ǎ",
            "â": "â",
            "ấ": "ấ",
            "ầ": "ầ",
            "ẫ": "ẫ",
            "ȧ": "ȧ",
            "ǡ": "ǡ",
            "å": "å",
            "ǻ": "ǻ",
            "ḃ": "ḃ",
            "ć": "ć",
            "ḉ": "ḉ",
            "č": "č",
            "ĉ": "ĉ",
            "ċ": "ċ",
            "ç": "ç",
            "ď": "ď",
            "ḋ": "ḋ",
            "ḑ": "ḑ",
            "é": "é",
            "è": "è",
            "ë": "ë",
            "ẽ": "ẽ",
            "ē": "ē",
            "ḗ": "ḗ",
            "ḕ": "ḕ",
            "ĕ": "ĕ",
            "ḝ": "ḝ",
            "ě": "ě",
            "ê": "ê",
            "ế": "ế",
            "ề": "ề",
            "ễ": "ễ",
            "ė": "ė",
            "ȩ": "ȩ",
            "ḟ": "ḟ",
            "ǵ": "ǵ",
            "ḡ": "ḡ",
            "ğ": "ğ",
            "ǧ": "ǧ",
            "ĝ": "ĝ",
            "ġ": "ġ",
            "ģ": "ģ",
            "ḧ": "ḧ",
            "ȟ": "ȟ",
            "ĥ": "ĥ",
            "ḣ": "ḣ",
            "ḩ": "ḩ",
            "í": "í",
            "ì": "ì",
            "ï": "ï",
            "ḯ": "ḯ",
            "ĩ": "ĩ",
            "ī": "ī",
            "ĭ": "ĭ",
            "ǐ": "ǐ",
            "î": "î",
            "ǰ": "ǰ",
            "ĵ": "ĵ",
            "ḱ": "ḱ",
            "ǩ": "ǩ",
            "ķ": "ķ",
            "ĺ": "ĺ",
            "ľ": "ľ",
            "ļ": "ļ",
            "ḿ": "ḿ",
            "ṁ": "ṁ",
            "ń": "ń",
            "ǹ": "ǹ",
            "ñ": "ñ",
            "ň": "ň",
            "ṅ": "ṅ",
            "ņ": "ņ",
            "ó": "ó",
            "ò": "ò",
            "ö": "ö",
            "ȫ": "ȫ",
            "õ": "õ",
            "ṍ": "ṍ",
            "ṏ": "ṏ",
            "ȭ": "ȭ",
            "ō": "ō",
            "ṓ": "ṓ",
            "ṑ": "ṑ",
            "ŏ": "ŏ",
            "ǒ": "ǒ",
            "ô": "ô",
            "ố": "ố",
            "ồ": "ồ",
            "ỗ": "ỗ",
            "ȯ": "ȯ",
            "ȱ": "ȱ",
            "ő": "ő",
            "ṕ": "ṕ",
            "ṗ": "ṗ",
            "ŕ": "ŕ",
            "ř": "ř",
            "ṙ": "ṙ",
            "ŗ": "ŗ",
            "ś": "ś",
            "ṥ": "ṥ",
            "š": "š",
            "ṧ": "ṧ",
            "ŝ": "ŝ",
            "ṡ": "ṡ",
            "ş": "ş",
            "ẗ": "ẗ",
            "ť": "ť",
            "ṫ": "ṫ",
            "ţ": "ţ",
            "ú": "ú",
            "ù": "ù",
            "ü": "ü",
            "ǘ": "ǘ",
            "ǜ": "ǜ",
            "ǖ": "ǖ",
            "ǚ": "ǚ",
            "ũ": "ũ",
            "ṹ": "ṹ",
            "ū": "ū",
            "ṻ": "ṻ",
            "ŭ": "ŭ",
            "ǔ": "ǔ",
            "û": "û",
            "ů": "ů",
            "ű": "ű",
            "ṽ": "ṽ",
            "ẃ": "ẃ",
            "ẁ": "ẁ",
            "ẅ": "ẅ",
            "ŵ": "ŵ",
            "ẇ": "ẇ",
            "ẘ": "ẘ",
            "ẍ": "ẍ",
            "ẋ": "ẋ",
            "ý": "ý",
            "ỳ": "ỳ",
            "ÿ": "ÿ",
            "ỹ": "ỹ",
            "ȳ": "ȳ",
            "ŷ": "ŷ",
            "ẏ": "ẏ",
            "ẙ": "ẙ",
            "ź": "ź",
            "ž": "ž",
            "ẑ": "ẑ",
            "ż": "ż",
            "Á": "Á",
            "À": "À",
            "Ä": "Ä",
            "Ǟ": "Ǟ",
            "Ã": "Ã",
            "Ā": "Ā",
            "Ă": "Ă",
            "Ắ": "Ắ",
            "Ằ": "Ằ",
            "Ẵ": "Ẵ",
            "Ǎ": "Ǎ",
            "Â": "Â",
            "Ấ": "Ấ",
            "Ầ": "Ầ",
            "Ẫ": "Ẫ",
            "Ȧ": "Ȧ",
            "Ǡ": "Ǡ",
            "Å": "Å",
            "Ǻ": "Ǻ",
            "Ḃ": "Ḃ",
            "Ć": "Ć",
            "Ḉ": "Ḉ",
            "Č": "Č",
            "Ĉ": "Ĉ",
            "Ċ": "Ċ",
            "Ç": "Ç",
            "Ď": "Ď",
            "Ḋ": "Ḋ",
            "Ḑ": "Ḑ",
            "É": "É",
            "È": "È",
            "Ë": "Ë",
            "Ẽ": "Ẽ",
            "Ē": "Ē",
            "Ḗ": "Ḗ",
            "Ḕ": "Ḕ",
            "Ĕ": "Ĕ",
            "Ḝ": "Ḝ",
            "Ě": "Ě",
            "Ê": "Ê",
            "Ế": "Ế",
            "Ề": "Ề",
            "Ễ": "Ễ",
            "Ė": "Ė",
            "Ȩ": "Ȩ",
            "Ḟ": "Ḟ",
            "Ǵ": "Ǵ",
            "Ḡ": "Ḡ",
            "Ğ": "Ğ",
            "Ǧ": "Ǧ",
            "Ĝ": "Ĝ",
            "Ġ": "Ġ",
            "Ģ": "Ģ",
            "Ḧ": "Ḧ",
            "Ȟ": "Ȟ",
            "Ĥ": "Ĥ",
            "Ḣ": "Ḣ",
            "Ḩ": "Ḩ",
            "Í": "Í",
            "Ì": "Ì",
            "Ï": "Ï",
            "Ḯ": "Ḯ",
            "Ĩ": "Ĩ",
            "Ī": "Ī",
            "Ĭ": "Ĭ",
            "Ǐ": "Ǐ",
            "Î": "Î",
            "İ": "İ",
            "Ĵ": "Ĵ",
            "Ḱ": "Ḱ",
            "Ǩ": "Ǩ",
            "Ķ": "Ķ",
            "Ĺ": "Ĺ",
            "Ľ": "Ľ",
            "Ļ": "Ļ",
            "Ḿ": "Ḿ",
            "Ṁ": "Ṁ",
            "Ń": "Ń",
            "Ǹ": "Ǹ",
            "Ñ": "Ñ",
            "Ň": "Ň",
            "Ṅ": "Ṅ",
            "Ņ": "Ņ",
            "Ó": "Ó",
            "Ò": "Ò",
            "Ö": "Ö",
            "Ȫ": "Ȫ",
            "Õ": "Õ",
            "Ṍ": "Ṍ",
            "Ṏ": "Ṏ",
            "Ȭ": "Ȭ",
            "Ō": "Ō",
            "Ṓ": "Ṓ",
            "Ṑ": "Ṑ",
            "Ŏ": "Ŏ",
            "Ǒ": "Ǒ",
            "Ô": "Ô",
            "Ố": "Ố",
            "Ồ": "Ồ",
            "Ỗ": "Ỗ",
            "Ȯ": "Ȯ",
            "Ȱ": "Ȱ",
            "Ő": "Ő",
            "Ṕ": "Ṕ",
            "Ṗ": "Ṗ",
            "Ŕ": "Ŕ",
            "Ř": "Ř",
            "Ṙ": "Ṙ",
            "Ŗ": "Ŗ",
            "Ś": "Ś",
            "Ṥ": "Ṥ",
            "Š": "Š",
            "Ṧ": "Ṧ",
            "Ŝ": "Ŝ",
            "Ṡ": "Ṡ",
            "Ş": "Ş",
            "Ť": "Ť",
            "Ṫ": "Ṫ",
            "Ţ": "Ţ",
            "Ú": "Ú",
            "Ù": "Ù",
            "Ü": "Ü",
            "Ǘ": "Ǘ",
            "Ǜ": "Ǜ",
            "Ǖ": "Ǖ",
            "Ǚ": "Ǚ",
            "Ũ": "Ũ",
            "Ṹ": "Ṹ",
            "Ū": "Ū",
            "Ṻ": "Ṻ",
            "Ŭ": "Ŭ",
            "Ǔ": "Ǔ",
            "Û": "Û",
            "Ů": "Ů",
            "Ű": "Ű",
            "Ṽ": "Ṽ",
            "Ẃ": "Ẃ",
            "Ẁ": "Ẁ",
            "Ẅ": "Ẅ",
            "Ŵ": "Ŵ",
            "Ẇ": "Ẇ",
            "Ẍ": "Ẍ",
            "Ẋ": "Ẋ",
            "Ý": "Ý",
            "Ỳ": "Ỳ",
            "Ÿ": "Ÿ",
            "Ỹ": "Ỹ",
            "Ȳ": "Ȳ",
            "Ŷ": "Ŷ",
            "Ẏ": "Ẏ",
            "Ź": "Ź",
            "Ž": "Ž",
            "Ẑ": "Ẑ",
            "Ż": "Ż",
            "ά": "ά",
            "ὰ": "ὰ",
            "ᾱ": "ᾱ",
            "ᾰ": "ᾰ",
            "έ": "έ",
            "ὲ": "ὲ",
            "ή": "ή",
            "ὴ": "ὴ",
            "ί": "ί",
            "ὶ": "ὶ",
            "ϊ": "ϊ",
            "ΐ": "ΐ",
            "ῒ": "ῒ",
            "ῑ": "ῑ",
            "ῐ": "ῐ",
            "ό": "ό",
            "ὸ": "ὸ",
            "ύ": "ύ",
            "ὺ": "ὺ",
            "ϋ": "ϋ",
            "ΰ": "ΰ",
            "ῢ": "ῢ",
            "ῡ": "ῡ",
            "ῠ": "ῠ",
            "ώ": "ώ",
            "ὼ": "ὼ",
            "Ύ": "Ύ",
            "Ὺ": "Ὺ",
            "Ϋ": "Ϋ",
            "Ῡ": "Ῡ",
            "Ῠ": "Ῠ",
            "Ώ": "Ώ",
            "Ὼ": "Ὼ"
          };
          class Parser {
            constructor(input, settings) {
              this.mode = void 0;
              this.gullet = void 0;
              this.settings = void 0;
              this.leftrightDepth = void 0;
              this.nextToken = void 0;
              this.mode = "math";
              this.gullet = new MacroExpander(input, settings, this.mode);
              this.settings = settings;
              this.leftrightDepth = 0;
            }
            /**
             * Checks a result to make sure it has the right type, and throws an
             * appropriate error otherwise.
             */
            expect(text, consume) {
              if (consume === void 0) {
                consume = true;
              }
              if (this.fetch().text !== text) {
                throw new src_ParseError("Expected '" + text + "', got '" + this.fetch().text + "'", this.fetch());
              }
              if (consume) {
                this.consume();
              }
            }
            /**
             * Discards the current lookahead token, considering it consumed.
             */
            consume() {
              this.nextToken = null;
            }
            /**
             * Return the current lookahead token, or if there isn't one (at the
             * beginning, or if the previous lookahead token was consume()d),
             * fetch the next token as the new lookahead token and return it.
             */
            fetch() {
              if (this.nextToken == null) {
                this.nextToken = this.gullet.expandNextToken();
              }
              return this.nextToken;
            }
            /**
             * Switches between "text" and "math" modes.
             */
            switchMode(newMode) {
              this.mode = newMode;
              this.gullet.switchMode(newMode);
            }
            /**
             * Main parsing function, which parses an entire input.
             */
            parse() {
              if (!this.settings.globalGroup) {
                this.gullet.beginGroup();
              }
              if (this.settings.colorIsTextColor) {
                this.gullet.macros.set("\\color", "\\textcolor");
              }
              try {
                const parse2 = this.parseExpression(false);
                this.expect("EOF");
                if (!this.settings.globalGroup) {
                  this.gullet.endGroup();
                }
                return parse2;
              } finally {
                this.gullet.endGroups();
              }
            }
            /**
             * Fully parse a separate sequence of tokens as a separate job.
             * Tokens should be specified in reverse order, as in a MacroDefinition.
             */
            subparse(tokens) {
              const oldToken = this.nextToken;
              this.consume();
              this.gullet.pushToken(new Token("}"));
              this.gullet.pushTokens(tokens);
              const parse2 = this.parseExpression(false);
              this.expect("}");
              this.nextToken = oldToken;
              return parse2;
            }
            /**
             * Parses an "expression", which is a list of atoms.
             *
             * `breakOnInfix`: Should the parsing stop when we hit infix nodes? This
             *                 happens when functions have higher precedence han infix
             *                 nodes in implicit parses.
             *
             * `breakOnTokenText`: The text of the token that the expression should end
             *                     with, or `null` if something else should end the
             *                     expression.
             */
            parseExpression(breakOnInfix, breakOnTokenText) {
              const body = [];
              while (true) {
                if (this.mode === "math") {
                  this.consumeSpaces();
                }
                const lex = this.fetch();
                if (Parser.endOfExpression.indexOf(lex.text) !== -1) {
                  break;
                }
                if (breakOnTokenText && lex.text === breakOnTokenText) {
                  break;
                }
                if (breakOnInfix && src_functions[lex.text] && src_functions[lex.text].infix) {
                  break;
                }
                const atom = this.parseAtom(breakOnTokenText);
                if (!atom) {
                  break;
                } else if (atom.type === "internal") {
                  continue;
                }
                body.push(atom);
              }
              if (this.mode === "text") {
                this.formLigatures(body);
              }
              return this.handleInfixNodes(body);
            }
            /**
             * Rewrites infix operators such as \over with corresponding commands such
             * as \frac.
             *
             * There can only be one infix operator per group.  If there's more than one
             * then the expression is ambiguous.  This can be resolved by adding {}.
             */
            handleInfixNodes(body) {
              let overIndex = -1;
              let funcName;
              for (let i2 = 0; i2 < body.length; i2++) {
                if (body[i2].type === "infix") {
                  if (overIndex !== -1) {
                    throw new src_ParseError("only one infix operator per group", body[i2].token);
                  }
                  overIndex = i2;
                  funcName = body[i2].replaceWith;
                }
              }
              if (overIndex !== -1 && funcName) {
                let numerNode;
                let denomNode;
                const numerBody = body.slice(0, overIndex);
                const denomBody = body.slice(overIndex + 1);
                if (numerBody.length === 1 && numerBody[0].type === "ordgroup") {
                  numerNode = numerBody[0];
                } else {
                  numerNode = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: numerBody
                  };
                }
                if (denomBody.length === 1 && denomBody[0].type === "ordgroup") {
                  denomNode = denomBody[0];
                } else {
                  denomNode = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: denomBody
                  };
                }
                let node;
                if (funcName === "\\\\abovefrac") {
                  node = this.callFunction(funcName, [numerNode, body[overIndex], denomNode], []);
                } else {
                  node = this.callFunction(funcName, [numerNode, denomNode], []);
                }
                return [node];
              } else {
                return body;
              }
            }
            /**
             * Handle a subscript or superscript with nice errors.
             */
            handleSupSubscript(name) {
              const symbolToken = this.fetch();
              const symbol = symbolToken.text;
              this.consume();
              this.consumeSpaces();
              const group = this.parseGroup(name);
              if (!group) {
                throw new src_ParseError("Expected group after '" + symbol + "'", symbolToken);
              }
              return group;
            }
            /**
             * Converts the textual input of an unsupported command into a text node
             * contained within a color node whose color is determined by errorColor
             */
            formatUnsupportedCmd(text) {
              const textordArray = [];
              for (let i2 = 0; i2 < text.length; i2++) {
                textordArray.push({
                  type: "textord",
                  mode: "text",
                  text: text[i2]
                });
              }
              const textNode = {
                type: "text",
                mode: this.mode,
                body: textordArray
              };
              const colorNode = {
                type: "color",
                mode: this.mode,
                color: this.settings.errorColor,
                body: [textNode]
              };
              return colorNode;
            }
            /**
             * Parses a group with optional super/subscripts.
             */
            parseAtom(breakOnTokenText) {
              const base = this.parseGroup("atom", breakOnTokenText);
              if (this.mode === "text") {
                return base;
              }
              let superscript;
              let subscript;
              while (true) {
                this.consumeSpaces();
                const lex = this.fetch();
                if (lex.text === "\\limits" || lex.text === "\\nolimits") {
                  if (base && base.type === "op") {
                    const limits = lex.text === "\\limits";
                    base.limits = limits;
                    base.alwaysHandleSupSub = true;
                  } else if (base && base.type === "operatorname") {
                    if (base.alwaysHandleSupSub) {
                      base.limits = lex.text === "\\limits";
                    }
                  } else {
                    throw new src_ParseError("Limit controls must follow a math operator", lex);
                  }
                  this.consume();
                } else if (lex.text === "^") {
                  if (superscript) {
                    throw new src_ParseError("Double superscript", lex);
                  }
                  superscript = this.handleSupSubscript("superscript");
                } else if (lex.text === "_") {
                  if (subscript) {
                    throw new src_ParseError("Double subscript", lex);
                  }
                  subscript = this.handleSupSubscript("subscript");
                } else if (lex.text === "'") {
                  if (superscript) {
                    throw new src_ParseError("Double superscript", lex);
                  }
                  const prime = {
                    type: "textord",
                    mode: this.mode,
                    text: "\\prime"
                  };
                  const primes = [prime];
                  this.consume();
                  while (this.fetch().text === "'") {
                    primes.push(prime);
                    this.consume();
                  }
                  if (this.fetch().text === "^") {
                    primes.push(this.handleSupSubscript("superscript"));
                  }
                  superscript = {
                    type: "ordgroup",
                    mode: this.mode,
                    body: primes
                  };
                } else if (uSubsAndSups[lex.text]) {
                  const isSub = unicodeSubRegEx.test(lex.text);
                  const subsupTokens = [];
                  subsupTokens.push(new Token(uSubsAndSups[lex.text]));
                  this.consume();
                  while (true) {
                    const token = this.fetch().text;
                    if (!uSubsAndSups[token]) {
                      break;
                    }
                    if (unicodeSubRegEx.test(token) !== isSub) {
                      break;
                    }
                    subsupTokens.unshift(new Token(uSubsAndSups[token]));
                    this.consume();
                  }
                  const body = this.subparse(subsupTokens);
                  if (isSub) {
                    subscript = {
                      type: "ordgroup",
                      mode: "math",
                      body
                    };
                  } else {
                    superscript = {
                      type: "ordgroup",
                      mode: "math",
                      body
                    };
                  }
                } else {
                  break;
                }
              }
              if (superscript || subscript) {
                return {
                  type: "supsub",
                  mode: this.mode,
                  base,
                  sup: superscript,
                  sub: subscript
                };
              } else {
                return base;
              }
            }
            /**
             * Parses an entire function, including its base and all of its arguments.
             */
            parseFunction(breakOnTokenText, name) {
              const token = this.fetch();
              const func = token.text;
              const funcData = src_functions[func];
              if (!funcData) {
                return null;
              }
              this.consume();
              if (name && name !== "atom" && !funcData.allowedInArgument) {
                throw new src_ParseError("Got function '" + func + "' with no arguments" + (name ? " as " + name : ""), token);
              } else if (this.mode === "text" && !funcData.allowedInText) {
                throw new src_ParseError("Can't use function '" + func + "' in text mode", token);
              } else if (this.mode === "math" && funcData.allowedInMath === false) {
                throw new src_ParseError("Can't use function '" + func + "' in math mode", token);
              }
              const {
                args,
                optArgs
              } = this.parseArguments(func, funcData);
              return this.callFunction(func, args, optArgs, token, breakOnTokenText);
            }
            /**
             * Call a function handler with a suitable context and arguments.
             */
            callFunction(name, args, optArgs, token, breakOnTokenText) {
              const context = {
                funcName: name,
                parser: this,
                token,
                breakOnTokenText
              };
              const func = src_functions[name];
              if (func && func.handler) {
                return func.handler(context, args, optArgs);
              } else {
                throw new src_ParseError("No function handler for " + name);
              }
            }
            /**
             * Parses the arguments of a function or environment
             */
            parseArguments(func, funcData) {
              const totalArgs = funcData.numArgs + funcData.numOptionalArgs;
              if (totalArgs === 0) {
                return {
                  args: [],
                  optArgs: []
                };
              }
              const args = [];
              const optArgs = [];
              for (let i2 = 0; i2 < totalArgs; i2++) {
                let argType = funcData.argTypes && funcData.argTypes[i2];
                const isOptional = i2 < funcData.numOptionalArgs;
                if (funcData.primitive && argType == null || // \sqrt expands into primitive if optional argument doesn't exist
                funcData.type === "sqrt" && i2 === 1 && optArgs[0] == null) {
                  argType = "primitive";
                }
                const arg = this.parseGroupOfType("argument to '" + func + "'", argType, isOptional);
                if (isOptional) {
                  optArgs.push(arg);
                } else if (arg != null) {
                  args.push(arg);
                } else {
                  throw new src_ParseError("Null argument, please report this as a bug");
                }
              }
              return {
                args,
                optArgs
              };
            }
            /**
             * Parses a group when the mode is changing.
             */
            parseGroupOfType(name, type, optional) {
              switch (type) {
                case "color":
                  return this.parseColorGroup(optional);
                case "size":
                  return this.parseSizeGroup(optional);
                case "url":
                  return this.parseUrlGroup(optional);
                case "math":
                case "text":
                  return this.parseArgumentGroup(optional, type);
                case "hbox": {
                  const group = this.parseArgumentGroup(optional, "text");
                  return group != null ? {
                    type: "styling",
                    mode: group.mode,
                    body: [group],
                    style: "text"
                    // simulate \textstyle
                  } : null;
                }
                case "raw": {
                  const token = this.parseStringGroup("raw", optional);
                  return token != null ? {
                    type: "raw",
                    mode: "text",
                    string: token.text
                  } : null;
                }
                case "primitive": {
                  if (optional) {
                    throw new src_ParseError("A primitive argument cannot be optional");
                  }
                  const group = this.parseGroup(name);
                  if (group == null) {
                    throw new src_ParseError("Expected group as " + name, this.fetch());
                  }
                  return group;
                }
                case "original":
                case null:
                case void 0:
                  return this.parseArgumentGroup(optional);
                default:
                  throw new src_ParseError("Unknown group type as " + name, this.fetch());
              }
            }
            /**
             * Discard any space tokens, fetching the next non-space token.
             */
            consumeSpaces() {
              while (this.fetch().text === " ") {
                this.consume();
              }
            }
            /**
             * Parses a group, essentially returning the string formed by the
             * brace-enclosed tokens plus some position information.
             */
            parseStringGroup(modeName, optional) {
              const argToken = this.gullet.scanArgument(optional);
              if (argToken == null) {
                return null;
              }
              let str = "";
              let nextToken;
              while ((nextToken = this.fetch()).text !== "EOF") {
                str += nextToken.text;
                this.consume();
              }
              this.consume();
              argToken.text = str;
              return argToken;
            }
            /**
             * Parses a regex-delimited group: the largest sequence of tokens
             * whose concatenated strings match `regex`. Returns the string
             * formed by the tokens plus some position information.
             */
            parseRegexGroup(regex, modeName) {
              const firstToken = this.fetch();
              let lastToken = firstToken;
              let str = "";
              let nextToken;
              while ((nextToken = this.fetch()).text !== "EOF" && regex.test(str + nextToken.text)) {
                lastToken = nextToken;
                str += lastToken.text;
                this.consume();
              }
              if (str === "") {
                throw new src_ParseError("Invalid " + modeName + ": '" + firstToken.text + "'", firstToken);
              }
              return firstToken.range(lastToken, str);
            }
            /**
             * Parses a color description.
             */
            parseColorGroup(optional) {
              const res = this.parseStringGroup("color", optional);
              if (res == null) {
                return null;
              }
              const match = /^(#[a-f0-9]{3}|#?[a-f0-9]{6}|[a-z]+)$/i.exec(res.text);
              if (!match) {
                throw new src_ParseError("Invalid color: '" + res.text + "'", res);
              }
              let color = match[0];
              if (/^[0-9a-f]{6}$/i.test(color)) {
                color = "#" + color;
              }
              return {
                type: "color-token",
                mode: this.mode,
                color
              };
            }
            /**
             * Parses a size specification, consisting of magnitude and unit.
             */
            parseSizeGroup(optional) {
              let res;
              let isBlank = false;
              this.gullet.consumeSpaces();
              if (!optional && this.gullet.future().text !== "{") {
                res = this.parseRegexGroup(/^[-+]? *(?:$|\d+|\d+\.\d*|\.\d*) *[a-z]{0,2} *$/, "size");
              } else {
                res = this.parseStringGroup("size", optional);
              }
              if (!res) {
                return null;
              }
              if (!optional && res.text.length === 0) {
                res.text = "0pt";
                isBlank = true;
              }
              const match = /([-+]?) *(\d+(?:\.\d*)?|\.\d+) *([a-z]{2})/.exec(res.text);
              if (!match) {
                throw new src_ParseError("Invalid size: '" + res.text + "'", res);
              }
              const data = {
                number: +(match[1] + match[2]),
                // sign + magnitude, cast to number
                unit: match[3]
              };
              if (!validUnit(data)) {
                throw new src_ParseError("Invalid unit: '" + data.unit + "'", res);
              }
              return {
                type: "size",
                mode: this.mode,
                value: data,
                isBlank
              };
            }
            /**
             * Parses an URL, checking escaped letters and allowed protocols,
             * and setting the catcode of % as an active character (as in \hyperref).
             */
            parseUrlGroup(optional) {
              this.gullet.lexer.setCatcode("%", 13);
              this.gullet.lexer.setCatcode("~", 12);
              const res = this.parseStringGroup("url", optional);
              this.gullet.lexer.setCatcode("%", 14);
              this.gullet.lexer.setCatcode("~", 13);
              if (res == null) {
                return null;
              }
              const url = res.text.replace(/\\([#$%&~_^{}])/g, "$1");
              return {
                type: "url",
                mode: this.mode,
                url
              };
            }
            /**
             * Parses an argument with the mode specified.
             */
            parseArgumentGroup(optional, mode) {
              const argToken = this.gullet.scanArgument(optional);
              if (argToken == null) {
                return null;
              }
              const outerMode = this.mode;
              if (mode) {
                this.switchMode(mode);
              }
              this.gullet.beginGroup();
              const expression = this.parseExpression(false, "EOF");
              this.expect("EOF");
              this.gullet.endGroup();
              const result = {
                type: "ordgroup",
                mode: this.mode,
                loc: argToken.loc,
                body: expression
              };
              if (mode) {
                this.switchMode(outerMode);
              }
              return result;
            }
            /**
             * Parses an ordinary group, which is either a single nucleus (like "x")
             * or an expression in braces (like "{x+y}") or an implicit group, a group
             * that starts at the current position, and ends right before a higher explicit
             * group ends, or at EOF.
             */
            parseGroup(name, breakOnTokenText) {
              const firstToken = this.fetch();
              const text = firstToken.text;
              let result;
              if (text === "{" || text === "\\begingroup") {
                this.consume();
                const groupEnd = text === "{" ? "}" : "\\endgroup";
                this.gullet.beginGroup();
                const expression = this.parseExpression(false, groupEnd);
                const lastToken = this.fetch();
                this.expect(groupEnd);
                this.gullet.endGroup();
                result = {
                  type: "ordgroup",
                  mode: this.mode,
                  loc: SourceLocation.range(firstToken, lastToken),
                  body: expression,
                  // A group formed by \begingroup...\endgroup is a semi-simple group
                  // which doesn't affect spacing in math mode, i.e., is transparent.
                  // https://tex.stackexchange.com/questions/1930/when-should-one-
                  // use-begingroup-instead-of-bgroup
                  semisimple: text === "\\begingroup" || void 0
                };
              } else {
                result = this.parseFunction(breakOnTokenText, name) || this.parseSymbol();
                if (result == null && text[0] === "\\" && !implicitCommands.hasOwnProperty(text)) {
                  if (this.settings.throwOnError) {
                    throw new src_ParseError("Undefined control sequence: " + text, firstToken);
                  }
                  result = this.formatUnsupportedCmd(text);
                  this.consume();
                }
              }
              return result;
            }
            /**
             * Form ligature-like combinations of characters for text mode.
             * This includes inputs like "--", "---", "``" and "''".
             * The result will simply replace multiple textord nodes with a single
             * character in each value by a single textord node having multiple
             * characters in its value.  The representation is still ASCII source.
             * The group will be modified in place.
             */
            formLigatures(group) {
              let n2 = group.length - 1;
              for (let i2 = 0; i2 < n2; ++i2) {
                const a2 = group[i2];
                const v2 = a2.text;
                if (v2 === "-" && group[i2 + 1].text === "-") {
                  if (i2 + 1 < n2 && group[i2 + 2].text === "-") {
                    group.splice(i2, 3, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation.range(a2, group[i2 + 2]),
                      text: "---"
                    });
                    n2 -= 2;
                  } else {
                    group.splice(i2, 2, {
                      type: "textord",
                      mode: "text",
                      loc: SourceLocation.range(a2, group[i2 + 1]),
                      text: "--"
                    });
                    n2 -= 1;
                  }
                }
                if ((v2 === "'" || v2 === "`") && group[i2 + 1].text === v2) {
                  group.splice(i2, 2, {
                    type: "textord",
                    mode: "text",
                    loc: SourceLocation.range(a2, group[i2 + 1]),
                    text: v2 + v2
                  });
                  n2 -= 1;
                }
              }
            }
            /**
             * Parse a single symbol out of the string. Here, we handle single character
             * symbols and special functions like \verb.
             */
            parseSymbol() {
              const nucleus = this.fetch();
              let text = nucleus.text;
              if (/^\\verb[^a-zA-Z]/.test(text)) {
                this.consume();
                let arg = text.slice(5);
                const star = arg.charAt(0) === "*";
                if (star) {
                  arg = arg.slice(1);
                }
                if (arg.length < 2 || arg.charAt(0) !== arg.slice(-1)) {
                  throw new src_ParseError("\\verb assertion failed --\n                    please report what input caused this bug");
                }
                arg = arg.slice(1, -1);
                return {
                  type: "verb",
                  mode: "text",
                  body: arg,
                  star
                };
              }
              if (unicodeSymbols.hasOwnProperty(text[0]) && !src_symbols[this.mode][text[0]]) {
                if (this.settings.strict && this.mode === "math") {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Accented Unicode text character "' + text[0] + '" used in math mode', nucleus);
                }
                text = unicodeSymbols[text[0]] + text.slice(1);
              }
              const match = combiningDiacriticalMarksEndRegex.exec(text);
              if (match) {
                text = text.substring(0, match.index);
                if (text === "i") {
                  text = "ı";
                } else if (text === "j") {
                  text = "ȷ";
                }
              }
              let symbol;
              if (src_symbols[this.mode][text]) {
                if (this.settings.strict && this.mode === "math" && extraLatin.indexOf(text) >= 0) {
                  this.settings.reportNonstrict("unicodeTextInMathMode", 'Latin-1/Unicode text character "' + text[0] + '" used in math mode', nucleus);
                }
                const group = src_symbols[this.mode][text].group;
                const loc = SourceLocation.range(nucleus);
                let s2;
                if (ATOMS.hasOwnProperty(group)) {
                  const family = group;
                  s2 = {
                    type: "atom",
                    mode: this.mode,
                    family,
                    loc,
                    text
                  };
                } else {
                  s2 = {
                    type: group,
                    mode: this.mode,
                    loc,
                    text
                  };
                }
                symbol = s2;
              } else if (text.charCodeAt(0) >= 128) {
                if (this.settings.strict) {
                  if (!supportedCodepoint(text.charCodeAt(0))) {
                    this.settings.reportNonstrict("unknownSymbol", 'Unrecognized Unicode character "' + text[0] + '"' + (" (" + text.charCodeAt(0) + ")"), nucleus);
                  } else if (this.mode === "math") {
                    this.settings.reportNonstrict("unicodeTextInMathMode", 'Unicode text character "' + text[0] + '" used in math mode', nucleus);
                  }
                }
                symbol = {
                  type: "textord",
                  mode: "text",
                  loc: SourceLocation.range(nucleus),
                  text
                };
              } else {
                return null;
              }
              this.consume();
              if (match) {
                for (let i2 = 0; i2 < match[0].length; i2++) {
                  const accent2 = match[0][i2];
                  if (!unicodeAccents[accent2]) {
                    throw new src_ParseError("Unknown accent ' " + accent2 + "'", nucleus);
                  }
                  const command = unicodeAccents[accent2][this.mode] || unicodeAccents[accent2].text;
                  if (!command) {
                    throw new src_ParseError("Accent " + accent2 + " unsupported in " + this.mode + " mode", nucleus);
                  }
                  symbol = {
                    type: "accent",
                    mode: this.mode,
                    loc: SourceLocation.range(nucleus),
                    label: command,
                    isStretchy: false,
                    isShifty: true,
                    // $FlowFixMe
                    base: symbol
                  };
                }
              }
              return symbol;
            }
          }
          Parser.endOfExpression = ["}", "\\endgroup", "\\end", "\\right", "&"];
          const parseTree = function(toParse, settings) {
            if (!(typeof toParse === "string" || toParse instanceof String)) {
              throw new TypeError("KaTeX can only parse string typed expression");
            }
            const parser = new Parser(toParse, settings);
            delete parser.gullet.macros.current["\\df@tag"];
            let tree = parser.parse();
            delete parser.gullet.macros.current["\\current@color"];
            delete parser.gullet.macros.current["\\color"];
            if (parser.gullet.macros.get("\\df@tag")) {
              if (!settings.displayMode) {
                throw new src_ParseError("\\tag works only in display equations");
              }
              tree = [{
                type: "tag",
                mode: "text",
                body: tree,
                tag: parser.subparse([new Token("\\df@tag")])
              }];
            }
            return tree;
          };
          var src_parseTree = parseTree;
          let render = function(expression, baseNode, options) {
            baseNode.textContent = "";
            const node = renderToDomTree(expression, options).toNode();
            baseNode.appendChild(node);
          };
          if (typeof document !== "undefined") {
            if (document.compatMode !== "CSS1Compat") {
              typeof console !== "undefined" && console.warn("Warning: KaTeX doesn't work in quirks mode. Make sure your website has a suitable doctype.");
              render = function() {
                throw new src_ParseError("KaTeX doesn't work in quirks mode.");
              };
            }
          }
          const renderToString = function(expression, options) {
            const markup = renderToDomTree(expression, options).toMarkup();
            return markup;
          };
          const generateParseTree = function(expression, options) {
            const settings = new Settings(options);
            return src_parseTree(expression, settings);
          };
          const renderError = function(error, expression, options) {
            if (options.throwOnError || !(error instanceof src_ParseError)) {
              throw error;
            }
            const node = buildCommon.makeSpan(["katex-error"], [new SymbolNode(expression)]);
            node.setAttribute("title", error.toString());
            node.setAttribute("style", "color:" + options.errorColor);
            return node;
          };
          const renderToDomTree = function(expression, options) {
            const settings = new Settings(options);
            try {
              const tree = src_parseTree(expression, settings);
              return buildTree(tree, expression, settings);
            } catch (error) {
              return renderError(error, expression, settings);
            }
          };
          const renderToHTMLTree = function(expression, options) {
            const settings = new Settings(options);
            try {
              const tree = src_parseTree(expression, settings);
              return buildHTMLTree(tree, expression, settings);
            } catch (error) {
              return renderError(error, expression, settings);
            }
          };
          const version = "0.16.19";
          const __domTree = {
            Span,
            Anchor: Anchor2,
            SymbolNode,
            SvgNode,
            PathNode,
            LineNode
          };
          var katex2 = {
            /**
             * Current KaTeX version
             */
            version,
            /**
             * Renders the given LaTeX into an HTML+MathML combination, and adds
             * it as a child to the specified DOM node.
             */
            render,
            /**
             * Renders the given LaTeX into an HTML+MathML combination string,
             * for sending to the client.
             */
            renderToString,
            /**
             * KaTeX error, usually during parsing.
             */
            ParseError: src_ParseError,
            /**
             * The schema of Settings
             */
            SETTINGS_SCHEMA,
            /**
             * Parses the given LaTeX into KaTeX's internal parse tree structure,
             * without rendering to HTML or MathML.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __parse: generateParseTree,
            /**
             * Renders the given LaTeX into an HTML+MathML internal DOM tree
             * representation, without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToDomTree: renderToDomTree,
            /**
             * Renders the given LaTeX into an HTML internal DOM tree representation,
             * without MathML and without flattening that representation to a string.
             *
             * NOTE: This method is not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __renderToHTMLTree: renderToHTMLTree,
            /**
             * extends internal font metrics object with a new object
             * each key in the new object represents a font name
            */
            __setFontMetrics: setFontMetrics,
            /**
             * adds a new symbol to builtin symbols table
             */
            __defineSymbol: defineSymbol,
            /**
             * adds a new function to builtin function list,
             * which directly produce parse tree elements
             * and have their own html/mathml builders
             */
            __defineFunction: defineFunction,
            /**
             * adds a new macro to builtin macro list
             */
            __defineMacro: defineMacro,
            /**
             * Expose the dom tree node types, which can be useful for type checking nodes.
             *
             * NOTE: These methods are not currently recommended for public use.
             * The internal tree representation is unstable and is very likely
             * to change. Use at your own risk.
             */
            __domTree
          };
          var katex_webpack = katex2;
          __webpack_exports__ = __webpack_exports__["default"];
          return __webpack_exports__;
        }()
      );
    });
  })(katex);
  return katex.exports;
}
(function(module, exports) {
  (function(global2, factory) {
    factory(exports, reactExports, propTypesExports, requireKatex());
  })(commonjsGlobal, function(exports2, _react, _propTypes, _katex) {
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function _export(target, all) {
      for (var name in all) Object.defineProperty(target, name, {
        enumerable: true,
        get: all[name]
      });
    }
    _export(exports2, {
      BlockMath: () => BlockMath,
      InlineMath: () => InlineMath
    });
    _react = /* @__PURE__ */ _interopRequireWildcard(_react);
    _propTypes = /* @__PURE__ */ _interopRequireDefault(_propTypes);
    _katex = /* @__PURE__ */ _interopRequireDefault(_katex);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    function _getRequireWildcardCache(nodeInterop) {
      if (typeof WeakMap !== "function") return null;
      var cacheBabelInterop = /* @__PURE__ */ new WeakMap();
      var cacheNodeInterop = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function(nodeInterop2) {
        return nodeInterop2 ? cacheNodeInterop : cacheBabelInterop;
      })(nodeInterop);
    }
    function _interopRequireWildcard(obj, nodeInterop) {
      if (obj && obj.__esModule) {
        return obj;
      }
      if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
          default: obj
        };
      }
      var cache = _getRequireWildcardCache(nodeInterop);
      if (cache && cache.has(obj)) {
        return cache.get(obj);
      }
      var newObj = {};
      var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var key in obj) {
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
          var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
          if (desc && (desc.get || desc.set)) {
            Object.defineProperty(newObj, key, desc);
          } else {
            newObj[key] = obj[key];
          }
        }
      }
      newObj.default = obj;
      if (cache) {
        cache.set(obj, newObj);
      }
      return newObj;
    }
    const createMathComponent = (Component, { displayMode }) => {
      const MathComponent = ({ children, errorColor, math, renderError }) => {
        const formula = math !== null && math !== void 0 ? math : children;
        const { html, error } = (0, _react.useMemo)(() => {
          try {
            const html2 = _katex.default.renderToString(formula, {
              displayMode,
              errorColor,
              throwOnError: !!renderError
            });
            return {
              html: html2,
              error: void 0
            };
          } catch (error2) {
            if (error2 instanceof _katex.default.ParseError || error2 instanceof TypeError) {
              return {
                error: error2
              };
            }
            throw error2;
          }
        }, [
          formula,
          errorColor,
          renderError
        ]);
        if (error) {
          return renderError ? renderError(error) : /* @__PURE__ */ _react.default.createElement(Component, {
            html: `${error.message}`
          });
        }
        return /* @__PURE__ */ _react.default.createElement(Component, {
          html
        });
      };
      MathComponent.propTypes = {
        children: _propTypes.default.string,
        errorColor: _propTypes.default.string,
        math: _propTypes.default.string,
        renderError: _propTypes.default.func
      };
      return MathComponent;
    };
    const InternalPathComponentPropTypes = {
      html: _propTypes.default.string.isRequired
    };
    const InternalBlockMath = ({ html }) => {
      return /* @__PURE__ */ _react.default.createElement("div", {
        "data-testid": "react-katex",
        dangerouslySetInnerHTML: {
          __html: html
        }
      });
    };
    InternalBlockMath.propTypes = InternalPathComponentPropTypes;
    const InternalInlineMath = ({ html }) => {
      return /* @__PURE__ */ _react.default.createElement("span", {
        "data-testid": "react-katex",
        dangerouslySetInnerHTML: {
          __html: html
        }
      });
    };
    InternalInlineMath.propTypes = InternalPathComponentPropTypes;
    const BlockMath = createMathComponent(InternalBlockMath, {
      displayMode: true
    });
    const InlineMath = createMathComponent(InternalInlineMath, {
      displayMode: false
    });
  });
})(reactKatex, reactKatex.exports);
var reactKatexExports = reactKatex.exports;
const GapInfo = ({ children }) => {
  const { t: t2 } = useTranslation("ShellSortGapsInfo");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex h-0 flex-auto flex-col items-center justify-center text-lg", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: t2("usedFunction") }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children })
  ] });
};
const ShellGapInfo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GapInfo, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactKatexExports.BlockMath, { math: String.raw`\frac{N}{2^k}` }) });
};
const HibbardGapInfo = () => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GapInfo, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(reactKatexExports.BlockMath, { math: String.raw`2^k - 1` }) });
};
const SedgewickGapInfo = () => {
  const { t: t2 } = useTranslation("ShellSortGapsInfo");
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GapInfo, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    reactKatexExports.BlockMath,
    {
      math: String.raw`
          \left\{
          \begin{array}{ll}
          9 \cdot (2^k - 2^\frac{k}{2}) + 1 & \text{${t2("for")} } k \leq 0 \\
          8 \cdot (2^{k} - 6 \cdot 2^\frac{k+1}{2}) + 1 & \text{${t2("for")} } k \geq 1
          \end{array}
          \right.
          `
    }
  ) });
};
const variants = [
  {
    info: {
      best: "O(n log n)",
      average: "O(n^(4/3))",
      worst: "O(n^(2))",
      memory: "O(1)",
      stable: false
    },
    code: shellSortShellCode,
    AdditionalInfo: /* @__PURE__ */ jsxRuntimeExports.jsx(ShellGapInfo, {}),
    variables: {
      gapFunction: gapShell
    }
  },
  {
    info: {
      best: "O(n log n)",
      average: "O(n^(4/3))",
      worst: "O(n^(3/2))",
      memory: "O(1)",
      stable: false
    },
    code: shellSortHibbardCode,
    AdditionalInfo: /* @__PURE__ */ jsxRuntimeExports.jsx(HibbardGapInfo, {}),
    variables: {
      gapFunction: gapHibbard
    }
  },
  {
    info: {
      best: "O(n log n)",
      average: "O(n^(4/3))",
      worst: "O(n^(4/3))",
      memory: "O(1)",
      stable: false
    },
    code: shellSortSedgewickCode,
    AdditionalInfo: /* @__PURE__ */ jsxRuntimeExports.jsx(SedgewickGapInfo, {}),
    variables: {
      gapFunction: gapSedgewick
    }
  }
];
const useShellSort = (variant = 0) => {
  const { chartDataRef, chartCompareCounterRef } = useChartInfo();
  const generatorRef = reactExports.useRef(
    shellSort(chartDataRef, chartCompareCounterRef, variants[variant])
  );
  const reset = reactExports.useCallback(() => {
    generatorRef.current = shellSort(
      chartDataRef,
      chartCompareCounterRef,
      variants[variant]
    );
  }, [chartCompareCounterRef, chartDataRef, variant]);
  return {
    sortFunctionGeneratorRef: generatorRef,
    reset,
    info: variants[variant].info,
    code: variants[variant].code,
    AdditionalInfo: variants[variant].AdditionalInfo
  };
};
const CHART_ACTION = {
  DEFAULT: "DEFAULT",
  COMPARE: "COMPARE",
  ANIMATE_SWAP: "ANIMATE_SWAP",
  SWAP: "SWAP",
  ANIMATE_REPLACE: "ANIMATE_REPLACE",
  REPLACE: "REPLACE",
  FINISHED: "FINISHED"
};
const SORTING_ALGORITHM = {
  SELECTION_SORT: () => useSelectionSort(),
  BUBBLE_SORT: () => useBubbleSort(),
  INSERTION_SORT: () => useInsertionSort(),
  SHELL_SORT: () => useShellSort(),
  SHELL_SORT_HIBBARD: () => useShellSort(1),
  SHELL_SORT_SEDGEWICK: () => useShellSort(2),
  MERGE_SORT_TOP_BOTTOM: () => useMergeSort(),
  MERGE_SORT_BOTTOM_UP: () => useMergeSort(1),
  HEAP_SORT: () => useHeapSort(),
  QUICK_SORT_LOMUTO_LAST_AS_PIVOT: () => useQuickSort(),
  QUICK_SORT_LOMUTO_MEDIAN_OF_THREE_AS_PIVOT: () => useQuickSort(1),
  QUICK_SORT_HOARE_FIRST_AS_PIVOT: () => useQuickSort(2),
  QUICK_SORT_HOARE_MIDDLE_AS_PIVOT: () => useQuickSort(3)
};
const DRAG_ITEM_TYPE = {
  CHART_CARD: "CHART_CARD",
  CONTEXT_ITEM: "CONTEXT_ITEM"
};
const DRAG_CONTAINER_LAYOUT = {
  HORIZONTAL: "HORIZONTAL",
  VERTICAL: "VERTICAL",
  GRID: "GRID",
  HANDLE: "HANDLE"
};
function numbersToChartData(numbers) {
  return {
    fields: numbers.map((number, index2) => ({
      key: index2,
      number
    })),
    visualization: { action: CHART_ACTION.DEFAULT, numbers: [] }
  };
}
function generateInitialDefaultChartData() {
  const numbers = exampleData[30].unsorted;
  return numbersToChartData(numbers);
}
const initialDefaultChartData = generateInitialDefaultChartData();
const CUSTOM_DATA_FORM_HIGHEST_NUMBER = 100;
const CUSTOM_DATA_FORM_MAX_NUMBERS = 100;
const DURATION_MS = 250;
const GlobalChartsInfoContext = reactExports.createContext(void 0);
function GlobalChartsInfoProvider({
  children
}) {
  const defaultChartDataRef = reactExports.useRef(initialDefaultChartData);
  const globalChartsInfoDataRef = reactExports.useRef([]);
  const globalChartActionCounterRef = reactExports.useRef(0);
  const globalMaxChartActionCounterRef = reactExports.useRef(0);
  const globalChartCompareCounterRef = reactExports.useRef(0);
  const globalMaxChartCompareCounterRef = reactExports.useRef(0);
  const durationRef = reactExports.useRef(DURATION_MS);
  const directionForwardRef = reactExports.useRef(true);
  const compareAsStepRef = reactExports.useRef(false);
  const [defaultChartDataState, setDefaultChartDataState] = reactExports.useState(
    initialDefaultChartData
  );
  const [
    globalMaxChartActionCounterState,
    setGlobalMaxChartActionCounterState
  ] = reactExports.useState(0);
  const [
    globalMaxChartCompareCounterState,
    setGlobalMaxChartCompareCounterState
  ] = reactExports.useState(0);
  const setDefaultChartData = reactExports.useCallback((numbers) => {
    defaultChartDataRef.current = numbersToChartData(numbers);
    setDefaultChartDataState(defaultChartDataRef.current);
  }, []);
  const addChartInfoData = reactExports.useCallback(
    (addedData) => {
      globalChartsInfoDataRef.current.push(addedData);
      const newGlobalMaxChartActionCounter = Math.max(
        globalMaxChartActionCounterRef.current,
        addedData.current.maxChartActionCounterRef.current
      );
      globalMaxChartActionCounterRef.current = newGlobalMaxChartActionCounter;
      setGlobalMaxChartActionCounterState(newGlobalMaxChartActionCounter);
      globalChartActionCounterRef.current = Math.min(
        globalMaxChartActionCounterRef.current,
        globalChartActionCounterRef.current
      );
      const newGlobalMaxChartCompareCounter = Math.max(
        globalMaxChartCompareCounterRef.current,
        addedData.current.maxChartCompareCounterRef.current
      );
      globalMaxChartCompareCounterRef.current = newGlobalMaxChartCompareCounter;
      setGlobalMaxChartCompareCounterState(newGlobalMaxChartCompareCounter);
      globalChartCompareCounterRef.current = Math.min(
        globalMaxChartCompareCounterRef.current,
        globalChartCompareCounterRef.current
      );
    },
    []
  );
  const removeChartInfoData = reactExports.useCallback(
    (removedData) => {
      globalChartsInfoDataRef.current = globalChartsInfoDataRef.current.filter(
        (data) => data !== removedData
      );
      const newGlobalMaxChartActionCounter = globalChartsInfoDataRef.current.reduce(
        (acc, data) => Math.max(acc, data.current.maxChartActionCounterRef.current),
        0
      );
      globalMaxChartActionCounterRef.current = newGlobalMaxChartActionCounter;
      setGlobalMaxChartActionCounterState(newGlobalMaxChartActionCounter);
      globalChartActionCounterRef.current = Math.min(
        globalMaxChartActionCounterRef.current,
        globalChartActionCounterRef.current
      );
      const newGlobalMaxChartCompareCounter = globalChartsInfoDataRef.current.reduce(
        (acc, data) => Math.max(acc, data.current.maxChartCompareCounterRef.current),
        0
      );
      globalMaxChartCompareCounterRef.current = newGlobalMaxChartCompareCounter;
      setGlobalMaxChartCompareCounterState(newGlobalMaxChartCompareCounter);
      globalChartCompareCounterRef.current = Math.min(
        globalMaxChartCompareCounterRef.current,
        globalChartCompareCounterRef.current
      );
    },
    []
  );
  const value = {
    defaultChartDataRef,
    globalChartsInfoDataRef,
    globalChartActionCounterRef,
    globalMaxChartActionCounterRef,
    globalChartCompareCounterRef,
    globalMaxChartCompareCounterRef,
    durationRef,
    directionForwardRef,
    compareAsStepRef,
    defaultChartDataState,
    setDefaultChartData,
    globalMaxChartActionCounterState,
    globalMaxChartCompareCounterState,
    addChartInfoData,
    removeChartInfoData
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalChartsInfoContext.Provider, { value, children });
}
function useGlobalChartsInfo() {
  const context = reactExports.useContext(GlobalChartsInfoContext);
  if (!context) {
    throw new Error(
      "useGlobalChartsInfo must be used within GlobalChartsInfoProvider"
    );
  }
  return context;
}
var CHECKBOX_NAME = "Checkbox";
var [createCheckboxContext, createCheckboxScope] = createContextScope(CHECKBOX_NAME);
var [CheckboxProvider, useCheckboxContext] = createCheckboxContext(CHECKBOX_NAME);
var Checkbox$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeCheckbox,
      name,
      checked: checkedProp,
      defaultChecked,
      required,
      disabled,
      value = "on",
      onCheckedChange,
      form,
      ...checkboxProps
    } = props;
    const [button, setButton] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setButton(node));
    const hasConsumerStoppedPropagationRef = reactExports.useRef(false);
    const isFormControl = button ? form || !!button.closest("form") : true;
    const [checked = false, setChecked] = useControllableState({
      prop: checkedProp,
      defaultProp: defaultChecked,
      onChange: onCheckedChange
    });
    const initialCheckedStateRef = reactExports.useRef(checked);
    reactExports.useEffect(() => {
      const form2 = button?.form;
      if (form2) {
        const reset = () => setChecked(initialCheckedStateRef.current);
        form2.addEventListener("reset", reset);
        return () => form2.removeEventListener("reset", reset);
      }
    }, [button, setChecked]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(CheckboxProvider, { scope: __scopeCheckbox, state: checked, disabled, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Primitive.button,
        {
          type: "button",
          role: "checkbox",
          "aria-checked": isIndeterminate(checked) ? "mixed" : checked,
          "aria-required": required,
          "data-state": getState(checked),
          "data-disabled": disabled ? "" : void 0,
          disabled,
          value,
          ...checkboxProps,
          ref: composedRefs,
          onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
            if (event.key === "Enter") event.preventDefault();
          }),
          onClick: composeEventHandlers(props.onClick, (event) => {
            setChecked((prevChecked) => isIndeterminate(prevChecked) ? true : !prevChecked);
            if (isFormControl) {
              hasConsumerStoppedPropagationRef.current = event.isPropagationStopped();
              if (!hasConsumerStoppedPropagationRef.current) event.stopPropagation();
            }
          })
        }
      ),
      isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
        BubbleInput$1,
        {
          control: button,
          bubbles: !hasConsumerStoppedPropagationRef.current,
          name,
          value,
          checked,
          required,
          disabled,
          form,
          style: { transform: "translateX(-100%)" },
          defaultChecked: isIndeterminate(defaultChecked) ? false : defaultChecked
        }
      )
    ] });
  }
);
Checkbox$1.displayName = CHECKBOX_NAME;
var INDICATOR_NAME = "CheckboxIndicator";
var CheckboxIndicator = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeCheckbox, forceMount, ...indicatorProps } = props;
    const context = useCheckboxContext(INDICATOR_NAME, __scopeCheckbox);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(Presence, { present: forceMount || isIndeterminate(context.state) || context.state === true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-state": getState(context.state),
        "data-disabled": context.disabled ? "" : void 0,
        ...indicatorProps,
        ref: forwardedRef,
        style: { pointerEvents: "none", ...props.style }
      }
    ) });
  }
);
CheckboxIndicator.displayName = INDICATOR_NAME;
var BubbleInput$1 = (props) => {
  const { control, checked, bubbles = true, defaultChecked, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevChecked = usePrevious(checked);
  const controlSize = useSize(control);
  reactExports.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "checked");
    const setChecked = descriptor.set;
    if (prevChecked !== checked && setChecked) {
      const event = new Event("click", { bubbles });
      input.indeterminate = isIndeterminate(checked);
      setChecked.call(input, isIndeterminate(checked) ? false : checked);
      input.dispatchEvent(event);
    }
  }, [prevChecked, checked, bubbles]);
  const defaultCheckedRef = reactExports.useRef(isIndeterminate(checked) ? false : checked);
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "input",
    {
      type: "checkbox",
      "aria-hidden": true,
      defaultChecked: defaultChecked ?? defaultCheckedRef.current,
      ...inputProps,
      tabIndex: -1,
      ref,
      style: {
        ...props.style,
        ...controlSize,
        position: "absolute",
        pointerEvents: "none",
        opacity: 0,
        margin: 0
      }
    }
  );
};
function isIndeterminate(checked) {
  return checked === "indeterminate";
}
function getState(checked) {
  return isIndeterminate(checked) ? "indeterminate" : checked ? "checked" : "unchecked";
}
var Root$2 = Checkbox$1;
var Indicator = CheckboxIndicator;
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const toKebabCase = (string) => string.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
const mergeClasses = (...classes) => classes.filter((className, index2, array) => {
  return Boolean(className) && array.indexOf(className) === index2;
}).join(" ");
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
var defaultAttributes = {
  xmlns: "http://www.w3.org/2000/svg",
  width: 24,
  height: 24,
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  strokeWidth: 2,
  strokeLinecap: "round",
  strokeLinejoin: "round"
};
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Icon = reactExports.forwardRef(
  ({
    color = "currentColor",
    size: size2 = 24,
    strokeWidth = 2,
    absoluteStrokeWidth,
    className = "",
    children,
    iconNode,
    ...rest
  }, ref) => {
    return reactExports.createElement(
      "svg",
      {
        ref,
        ...defaultAttributes,
        width: size2,
        height: size2,
        stroke: color,
        strokeWidth: absoluteStrokeWidth ? Number(strokeWidth) * 24 / Number(size2) : strokeWidth,
        className: mergeClasses("lucide", className),
        ...rest
      },
      [
        ...iconNode.map(([tag, attrs]) => reactExports.createElement(tag, attrs)),
        ...Array.isArray(children) ? children : [children]
      ]
    );
  }
);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const createLucideIcon = (iconName, iconNode) => {
  const Component = reactExports.forwardRef(
    ({ className, ...props }, ref) => reactExports.createElement(Icon, {
      ref,
      iconNode,
      className: mergeClasses(`lucide-${toKebabCase(iconName)}`, className),
      ...props
    })
  );
  Component.displayName = `${iconName}`;
  return Component;
};
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Check = createLucideIcon("Check", [["path", { d: "M20 6 9 17l-5-5", key: "1gmf2c" }]]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronLeft = createLucideIcon("ChevronLeft", [
  ["path", { d: "m15 18-6-6 6-6", key: "1wnfg3" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const ChevronRight = createLucideIcon("ChevronRight", [
  ["path", { d: "m9 18 6-6-6-6", key: "mthhwq" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const GripVertical = createLucideIcon("GripVertical", [
  ["circle", { cx: "9", cy: "12", r: "1", key: "1vctgf" }],
  ["circle", { cx: "9", cy: "5", r: "1", key: "hp0tcf" }],
  ["circle", { cx: "9", cy: "19", r: "1", key: "fkjjf6" }],
  ["circle", { cx: "15", cy: "12", r: "1", key: "1tmaij" }],
  ["circle", { cx: "15", cy: "5", r: "1", key: "19l28e" }],
  ["circle", { cx: "15", cy: "19", r: "1", key: "f4zoj3" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Moon = createLucideIcon("Moon", [
  ["path", { d: "M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z", key: "a7tn18" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Pause = createLucideIcon("Pause", [
  ["rect", { x: "14", y: "4", width: "4", height: "16", rx: "1", key: "zuxfzm" }],
  ["rect", { x: "6", y: "4", width: "4", height: "16", rx: "1", key: "1okwgv" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Play = createLucideIcon("Play", [
  ["polygon", { points: "6 3 20 12 6 21 6 3", key: "1oa8hb" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Plus = createLucideIcon("Plus", [
  ["path", { d: "M5 12h14", key: "1ays0h" }],
  ["path", { d: "M12 5v14", key: "s699le" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const RotateCcw = createLucideIcon("RotateCcw", [
  ["path", { d: "M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8", key: "1357e3" }],
  ["path", { d: "M3 3v5h5", key: "1xhq8a" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const SkipForward = createLucideIcon("SkipForward", [
  ["polygon", { points: "5 4 15 12 5 20 5 4", key: "16p6eg" }],
  ["line", { x1: "19", x2: "19", y1: "5", y2: "19", key: "futhcm" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const Sun = createLucideIcon("Sun", [
  ["circle", { cx: "12", cy: "12", r: "4", key: "4exip2" }],
  ["path", { d: "M12 2v2", key: "tus03m" }],
  ["path", { d: "M12 20v2", key: "1lh1kg" }],
  ["path", { d: "m4.93 4.93 1.41 1.41", key: "149t6j" }],
  ["path", { d: "m17.66 17.66 1.41 1.41", key: "ptbguv" }],
  ["path", { d: "M2 12h2", key: "1t8f8n" }],
  ["path", { d: "M20 12h2", key: "1q8mjw" }],
  ["path", { d: "m6.34 17.66-1.41 1.41", key: "1m8zz5" }],
  ["path", { d: "m19.07 4.93-1.41 1.41", key: "1shlcs" }]
]);
/**
 * @license lucide-react v0.451.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */
const X = createLucideIcon("X", [
  ["path", { d: "M18 6 6 18", key: "1bl5f8" }],
  ["path", { d: "m6 6 12 12", key: "d8bk6v" }]
]);
const Checkbox = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$2,
  {
    ref,
    className: cn(
      "peer h-4 w-4 shrink-0 rounded-sm border border-primary shadow focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50 data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground",
      className
    ),
    ...props,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx(
      Indicator,
      {
        className: cn("flex items-center justify-center text-current"),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Check, { className: "h-4 w-4" })
      }
    )
  }
));
Checkbox.displayName = Root$2.displayName;
var NAME = "Label";
var Label$1 = reactExports.forwardRef((props, forwardedRef) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Primitive.label,
    {
      ...props,
      ref: forwardedRef,
      onMouseDown: (event) => {
        const target = event.target;
        if (target.closest("button, input, select, textarea")) return;
        props.onMouseDown?.(event);
        if (!event.defaultPrevented && event.detail > 1) event.preventDefault();
      }
    }
  );
});
Label$1.displayName = NAME;
var Root$1 = Label$1;
const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
);
const Label = reactExports.forwardRef(({ className, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  Root$1,
  {
    ref,
    className: cn(labelVariants(), className),
    ...props
  }
));
Label.displayName = Root$1.displayName;
var PAGE_KEYS = ["PageUp", "PageDown"];
var ARROW_KEYS = ["ArrowUp", "ArrowDown", "ArrowLeft", "ArrowRight"];
var BACK_KEYS = {
  "from-left": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-right": ["Home", "PageDown", "ArrowDown", "ArrowRight"],
  "from-bottom": ["Home", "PageDown", "ArrowDown", "ArrowLeft"],
  "from-top": ["Home", "PageDown", "ArrowUp", "ArrowLeft"]
};
var SLIDER_NAME = "Slider";
var [Collection, useCollection, createCollectionScope] = createCollection(SLIDER_NAME);
var [createSliderContext, createSliderScope] = createContextScope(SLIDER_NAME, [
  createCollectionScope
]);
var [SliderProvider, useSliderContext] = createSliderContext(SLIDER_NAME);
var Slider$1 = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      name,
      min: min2 = 0,
      max: max2 = 100,
      step = 1,
      orientation = "horizontal",
      disabled = false,
      minStepsBetweenThumbs = 0,
      defaultValue = [min2],
      value,
      onValueChange = () => {
      },
      onValueCommit = () => {
      },
      inverted = false,
      form,
      ...sliderProps
    } = props;
    const thumbRefs = reactExports.useRef(/* @__PURE__ */ new Set());
    const valueIndexToChangeRef = reactExports.useRef(0);
    const isHorizontal = orientation === "horizontal";
    const SliderOrientation = isHorizontal ? SliderHorizontal : SliderVertical;
    const [values = [], setValues] = useControllableState({
      prop: value,
      defaultProp: defaultValue,
      onChange: (value2) => {
        const thumbs = [...thumbRefs.current];
        thumbs[valueIndexToChangeRef.current]?.focus();
        onValueChange(value2);
      }
    });
    const valuesBeforeSlideStartRef = reactExports.useRef(values);
    function handleSlideStart(value2) {
      const closestIndex = getClosestValueIndex(values, value2);
      updateValues(value2, closestIndex);
    }
    function handleSlideMove(value2) {
      updateValues(value2, valueIndexToChangeRef.current);
    }
    function handleSlideEnd() {
      const prevValue = valuesBeforeSlideStartRef.current[valueIndexToChangeRef.current];
      const nextValue = values[valueIndexToChangeRef.current];
      const hasChanged = nextValue !== prevValue;
      if (hasChanged) onValueCommit(values);
    }
    function updateValues(value2, atIndex, { commit } = { commit: false }) {
      const decimalCount = getDecimalCount(step);
      const snapToStep = roundValue(Math.round((value2 - min2) / step) * step + min2, decimalCount);
      const nextValue = clamp$1(snapToStep, [min2, max2]);
      setValues((prevValues = []) => {
        const nextValues = getNextSortedValues(prevValues, nextValue, atIndex);
        if (hasMinStepsBetweenValues(nextValues, minStepsBetweenThumbs * step)) {
          valueIndexToChangeRef.current = nextValues.indexOf(nextValue);
          const hasChanged = String(nextValues) !== String(prevValues);
          if (hasChanged && commit) onValueCommit(nextValues);
          return hasChanged ? nextValues : prevValues;
        } else {
          return prevValues;
        }
      });
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderProvider,
      {
        scope: props.__scopeSlider,
        name,
        disabled,
        min: min2,
        max: max2,
        valueIndexToChangeRef,
        thumbs: thumbRefs.current,
        values,
        orientation,
        form,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Provider, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.Slot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderOrientation,
          {
            "aria-disabled": disabled,
            "data-disabled": disabled ? "" : void 0,
            ...sliderProps,
            ref: forwardedRef,
            onPointerDown: composeEventHandlers(sliderProps.onPointerDown, () => {
              if (!disabled) valuesBeforeSlideStartRef.current = values;
            }),
            min: min2,
            max: max2,
            inverted,
            onSlideStart: disabled ? void 0 : handleSlideStart,
            onSlideMove: disabled ? void 0 : handleSlideMove,
            onSlideEnd: disabled ? void 0 : handleSlideEnd,
            onHomeKeyDown: () => !disabled && updateValues(min2, 0, { commit: true }),
            onEndKeyDown: () => !disabled && updateValues(max2, values.length - 1, { commit: true }),
            onStepKeyDown: ({ event, direction: stepDirection }) => {
              if (!disabled) {
                const isPageKey = PAGE_KEYS.includes(event.key);
                const isSkipKey = isPageKey || event.shiftKey && ARROW_KEYS.includes(event.key);
                const multiplier = isSkipKey ? 10 : 1;
                const atIndex = valueIndexToChangeRef.current;
                const value2 = values[atIndex];
                const stepInDirection = step * multiplier * stepDirection;
                updateValues(value2 + stepInDirection, atIndex, { commit: true });
              }
            }
          }
        ) }) })
      }
    );
  }
);
Slider$1.displayName = SLIDER_NAME;
var [SliderOrientationProvider, useSliderOrientationContext] = createSliderContext(SLIDER_NAME, {
  startEdge: "left",
  endEdge: "right",
  size: "width",
  direction: 1
});
var SliderHorizontal = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      dir,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const [slider, setSlider] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setSlider(node));
    const rectRef = reactExports.useRef();
    const direction = useDirection(dir);
    const isDirectionLTR = direction === "ltr";
    const isSlidingFromLeft = isDirectionLTR && !inverted || !isDirectionLTR && inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || slider.getBoundingClientRect();
      const input = [0, rect.width];
      const output = isSlidingFromLeft ? [min2, max2] : [max2, min2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.left);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromLeft ? "left" : "right",
        endEdge: isSlidingFromLeft ? "right" : "left",
        direction: isSlidingFromLeft ? 1 : -1,
        size: "width",
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            dir: direction,
            "data-orientation": "horizontal",
            ...sliderProps,
            ref: composedRefs,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateX(-50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientX);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromLeft ? "from-left" : "from-right";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderVertical = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      min: min2,
      max: max2,
      inverted,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const sliderRef = reactExports.useRef(null);
    const ref = useComposedRefs(forwardedRef, sliderRef);
    const rectRef = reactExports.useRef();
    const isSlidingFromBottom = !inverted;
    function getValueFromPointer(pointerPosition) {
      const rect = rectRef.current || sliderRef.current.getBoundingClientRect();
      const input = [0, rect.height];
      const output = isSlidingFromBottom ? [max2, min2] : [min2, max2];
      const value = linearScale(input, output);
      rectRef.current = rect;
      return value(pointerPosition - rect.top);
    }
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      SliderOrientationProvider,
      {
        scope: props.__scopeSlider,
        startEdge: isSlidingFromBottom ? "bottom" : "top",
        endEdge: isSlidingFromBottom ? "top" : "bottom",
        size: "height",
        direction: isSlidingFromBottom ? 1 : -1,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          SliderImpl,
          {
            "data-orientation": "vertical",
            ...sliderProps,
            ref,
            style: {
              ...sliderProps.style,
              ["--radix-slider-thumb-transform"]: "translateY(50%)"
            },
            onSlideStart: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideStart?.(value);
            },
            onSlideMove: (event) => {
              const value = getValueFromPointer(event.clientY);
              onSlideMove?.(value);
            },
            onSlideEnd: () => {
              rectRef.current = void 0;
              onSlideEnd?.();
            },
            onStepKeyDown: (event) => {
              const slideDirection = isSlidingFromBottom ? "from-bottom" : "from-top";
              const isBackKey = BACK_KEYS[slideDirection].includes(event.key);
              onStepKeyDown?.({ event, direction: isBackKey ? -1 : 1 });
            }
          }
        )
      }
    );
  }
);
var SliderImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const {
      __scopeSlider,
      onSlideStart,
      onSlideMove,
      onSlideEnd,
      onHomeKeyDown,
      onEndKeyDown,
      onStepKeyDown,
      ...sliderProps
    } = props;
    const context = useSliderContext(SLIDER_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        ...sliderProps,
        ref: forwardedRef,
        onKeyDown: composeEventHandlers(props.onKeyDown, (event) => {
          if (event.key === "Home") {
            onHomeKeyDown(event);
            event.preventDefault();
          } else if (event.key === "End") {
            onEndKeyDown(event);
            event.preventDefault();
          } else if (PAGE_KEYS.concat(ARROW_KEYS).includes(event.key)) {
            onStepKeyDown(event);
            event.preventDefault();
          }
        }),
        onPointerDown: composeEventHandlers(props.onPointerDown, (event) => {
          const target = event.target;
          target.setPointerCapture(event.pointerId);
          event.preventDefault();
          if (context.thumbs.has(target)) {
            target.focus();
          } else {
            onSlideStart(event);
          }
        }),
        onPointerMove: composeEventHandlers(props.onPointerMove, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) onSlideMove(event);
        }),
        onPointerUp: composeEventHandlers(props.onPointerUp, (event) => {
          const target = event.target;
          if (target.hasPointerCapture(event.pointerId)) {
            target.releasePointerCapture(event.pointerId);
            onSlideEnd(event);
          }
        })
      }
    );
  }
);
var TRACK_NAME = "SliderTrack";
var SliderTrack = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...trackProps } = props;
    const context = useSliderContext(TRACK_NAME, __scopeSlider);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-disabled": context.disabled ? "" : void 0,
        "data-orientation": context.orientation,
        ...trackProps,
        ref: forwardedRef
      }
    );
  }
);
SliderTrack.displayName = TRACK_NAME;
var RANGE_NAME = "SliderRange";
var SliderRange = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, ...rangeProps } = props;
    const context = useSliderContext(RANGE_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(RANGE_NAME, __scopeSlider);
    const ref = reactExports.useRef(null);
    const composedRefs = useComposedRefs(forwardedRef, ref);
    const valuesCount = context.values.length;
    const percentages = context.values.map(
      (value) => convertValueToPercentage(value, context.min, context.max)
    );
    const offsetStart = valuesCount > 1 ? Math.min(...percentages) : 0;
    const offsetEnd = 100 - Math.max(...percentages);
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      Primitive.span,
      {
        "data-orientation": context.orientation,
        "data-disabled": context.disabled ? "" : void 0,
        ...rangeProps,
        ref: composedRefs,
        style: {
          ...props.style,
          [orientation.startEdge]: offsetStart + "%",
          [orientation.endEdge]: offsetEnd + "%"
        }
      }
    );
  }
);
SliderRange.displayName = RANGE_NAME;
var THUMB_NAME = "SliderThumb";
var SliderThumb = reactExports.forwardRef(
  (props, forwardedRef) => {
    const getItems = useCollection(props.__scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const index2 = reactExports.useMemo(
      () => thumb ? getItems().findIndex((item) => item.ref.current === thumb) : -1,
      [getItems, thumb]
    );
    return /* @__PURE__ */ jsxRuntimeExports.jsx(SliderThumbImpl, { ...props, ref: composedRefs, index: index2 });
  }
);
var SliderThumbImpl = reactExports.forwardRef(
  (props, forwardedRef) => {
    const { __scopeSlider, index: index2, name, ...thumbProps } = props;
    const context = useSliderContext(THUMB_NAME, __scopeSlider);
    const orientation = useSliderOrientationContext(THUMB_NAME, __scopeSlider);
    const [thumb, setThumb] = reactExports.useState(null);
    const composedRefs = useComposedRefs(forwardedRef, (node) => setThumb(node));
    const isFormControl = thumb ? context.form || !!thumb.closest("form") : true;
    const size2 = useSize(thumb);
    const value = context.values[index2];
    const percent = value === void 0 ? 0 : convertValueToPercentage(value, context.min, context.max);
    const label = getLabel(index2, context.values.length);
    const orientationSize = size2?.[orientation.size];
    const thumbInBoundsOffset = orientationSize ? getThumbInBoundsOffset(orientationSize, percent, orientation.direction) : 0;
    reactExports.useEffect(() => {
      if (thumb) {
        context.thumbs.add(thumb);
        return () => {
          context.thumbs.delete(thumb);
        };
      }
    }, [thumb, context.thumbs]);
    return /* @__PURE__ */ jsxRuntimeExports.jsxs(
      "span",
      {
        style: {
          transform: "var(--radix-slider-thumb-transform)",
          position: "absolute",
          [orientation.startEdge]: `calc(${percent}% + ${thumbInBoundsOffset}px)`
        },
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(Collection.ItemSlot, { scope: props.__scopeSlider, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            Primitive.span,
            {
              role: "slider",
              "aria-label": props["aria-label"] || label,
              "aria-valuemin": context.min,
              "aria-valuenow": value,
              "aria-valuemax": context.max,
              "aria-orientation": context.orientation,
              "data-orientation": context.orientation,
              "data-disabled": context.disabled ? "" : void 0,
              tabIndex: context.disabled ? void 0 : 0,
              ...thumbProps,
              ref: composedRefs,
              style: value === void 0 ? { display: "none" } : props.style,
              onFocus: composeEventHandlers(props.onFocus, () => {
                context.valueIndexToChangeRef.current = index2;
              })
            }
          ) }),
          isFormControl && /* @__PURE__ */ jsxRuntimeExports.jsx(
            BubbleInput,
            {
              name: name ?? (context.name ? context.name + (context.values.length > 1 ? "[]" : "") : void 0),
              form: context.form,
              value
            },
            index2
          )
        ]
      }
    );
  }
);
SliderThumb.displayName = THUMB_NAME;
var BubbleInput = (props) => {
  const { value, ...inputProps } = props;
  const ref = reactExports.useRef(null);
  const prevValue = usePrevious(value);
  reactExports.useEffect(() => {
    const input = ref.current;
    const inputProto = window.HTMLInputElement.prototype;
    const descriptor = Object.getOwnPropertyDescriptor(inputProto, "value");
    const setValue = descriptor.set;
    if (prevValue !== value && setValue) {
      const event = new Event("input", { bubbles: true });
      setValue.call(input, value);
      input.dispatchEvent(event);
    }
  }, [prevValue, value]);
  return /* @__PURE__ */ jsxRuntimeExports.jsx("input", { style: { display: "none" }, ...inputProps, ref, defaultValue: value });
};
function getNextSortedValues(prevValues = [], nextValue, atIndex) {
  const nextValues = [...prevValues];
  nextValues[atIndex] = nextValue;
  return nextValues.sort((a2, b2) => a2 - b2);
}
function convertValueToPercentage(value, min2, max2) {
  const maxSteps = max2 - min2;
  const percentPerStep = 100 / maxSteps;
  const percentage = percentPerStep * (value - min2);
  return clamp$1(percentage, [0, 100]);
}
function getLabel(index2, totalValues) {
  if (totalValues > 2) {
    return `Value ${index2 + 1} of ${totalValues}`;
  } else if (totalValues === 2) {
    return ["Minimum", "Maximum"][index2];
  } else {
    return void 0;
  }
}
function getClosestValueIndex(values, nextValue) {
  if (values.length === 1) return 0;
  const distances = values.map((value) => Math.abs(value - nextValue));
  const closestDistance = Math.min(...distances);
  return distances.indexOf(closestDistance);
}
function getThumbInBoundsOffset(width, left, direction) {
  const halfWidth = width / 2;
  const halfPercent = 50;
  const offset2 = linearScale([0, halfPercent], [0, halfWidth]);
  return (halfWidth - offset2(left) * direction) * direction;
}
function getStepsBetweenValues(values) {
  return values.slice(0, -1).map((value, index2) => values[index2 + 1] - value);
}
function hasMinStepsBetweenValues(values, minStepsBetweenValues) {
  if (minStepsBetweenValues > 0) {
    const stepsBetweenValues = getStepsBetweenValues(values);
    const actualMinStepsBetweenValues = Math.min(...stepsBetweenValues);
    return actualMinStepsBetweenValues >= minStepsBetweenValues;
  }
  return true;
}
function linearScale(input, output) {
  return (value) => {
    if (input[0] === input[1] || output[0] === output[1]) return output[0];
    const ratio = (output[1] - output[0]) / (input[1] - input[0]);
    return output[0] + ratio * (value - input[0]);
  };
}
function getDecimalCount(value) {
  return (String(value).split(".")[1] || "").length;
}
function roundValue(value, decimalCount) {
  const rounder = Math.pow(10, decimalCount);
  return Math.round(value * rounder) / rounder;
}
var Root = Slider$1;
var Track = SliderTrack;
var Range = SliderRange;
var Thumb = SliderThumb;
const Slider = reactExports.forwardRef(({ className, rangeClassName, ...props }, ref) => /* @__PURE__ */ jsxRuntimeExports.jsxs(
  Root,
  {
    ref,
    className: cn(
      "relative flex w-full touch-none select-none items-center",
      className
    ),
    ...props,
    children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Track, { className: "relative h-1.5 w-full grow overflow-hidden rounded-full bg-primary/20", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        Range,
        {
          className: cn("absolute h-full bg-primary", rangeClassName)
        }
      ) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Thumb, { className: "block h-4 w-4 rounded-full border border-primary/50 bg-background shadow transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50" })
    ]
  }
));
Slider.displayName = Root.displayName;
function generateInitialAlgorithmsVisibility() {
  return Object.keys(SORTING_ALGORITHM).map((algorithm) => ({
    algorithm,
    visible: false
  }));
}
function generateInitialDraggablesTransitionState() {
  return Object.values(DRAG_ITEM_TYPE).reduce((acc, key) => {
    acc[key] = false;
    return acc;
  }, {});
}
const initialAlgorithmsVisibility = generateInitialAlgorithmsVisibility();
const initialDraggablesTransitionState = generateInitialDraggablesTransitionState();
const AlgorithmsVisibilityContext = reactExports.createContext(void 0);
function AlgorithmsVisibilityProvider({
  children
}) {
  const [algorithmsVisibilityData, setAlgorithmsVisibilityData] = reactExports.useState(initialAlgorithmsVisibility);
  const draggablesTransitionStateRef = reactExports.useRef(
    initialDraggablesTransitionState
  );
  const setAlgorithmsVisibility = reactExports.useCallback(
    (algorithm, state) => setAlgorithmsVisibilityData((prev) => {
      const position = prev.findIndex((data) => data.algorithm === algorithm);
      if (position < 0) {
        return prev;
      }
      return prev.map(
        (data, index2) => index2 === position ? { ...data, visible: state } : data
      );
    }),
    []
  );
  const setAlgorithmPosition = reactExports.useCallback(
    (algorithm, newPosition) => setAlgorithmsVisibilityData((prev) => {
      const position = prev.findIndex((data) => data.algorithm === algorithm);
      if (position < 0 || position === newPosition) {
        return prev;
      }
      return prev.map(
        (data, index2) => index2 === position ? { ...prev[newPosition] } : index2 === newPosition ? { ...prev[position] } : data
      );
    }),
    []
  );
  const moveAlgorithmPositionLeft = reactExports.useCallback(
    (algorithm) => setAlgorithmsVisibilityData((prev) => {
      const position = prev.findIndex((data) => data.algorithm === algorithm);
      let newPosition = -1;
      for (let i2 = position - 1; i2 >= 0; i2--) {
        if (prev[i2].visible === true) {
          newPosition = i2;
          break;
        }
      }
      if (newPosition < 0) {
        return prev;
      }
      return prev.map(
        (data, index2) => index2 === position ? { ...prev[newPosition] } : index2 === newPosition ? { ...prev[position] } : data
      );
    }),
    []
  );
  const moveAlgorithmPositionRight = reactExports.useCallback(
    (algorithm) => setAlgorithmsVisibilityData((prev) => {
      const position = prev.findIndex((data) => data.algorithm === algorithm);
      let newPosition = -1;
      for (let i2 = position + 1; i2 < prev.length; i2++) {
        if (prev[i2].visible === true) {
          newPosition = i2;
          break;
        }
      }
      if (newPosition < 0) {
        return prev;
      }
      return prev.map(
        (data, index2) => index2 === position ? { ...prev[newPosition] } : index2 === newPosition ? { ...prev[position] } : data
      );
    }),
    []
  );
  const swapAlgorithmsPosition = reactExports.useCallback(
    (a2, b2) => setAlgorithmsVisibilityData((prev) => {
      const aIndex = prev.findIndex((data) => data.algorithm === a2);
      const bIndex = prev.findIndex((data) => data.algorithm === b2);
      return prev.map(
        (data, index2) => index2 == aIndex ? { ...prev[bIndex] } : index2 === bIndex ? { ...prev[aIndex] } : data
      );
    }),
    []
  );
  const value = {
    algorithmsVisibilityData,
    setAlgorithmsVisibility,
    setAlgorithmPosition,
    moveAlgorithmPositionLeft,
    moveAlgorithmPositionRight,
    swapAlgorithmsPosition,
    draggablesTransitionStateRef
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(AlgorithmsVisibilityContext.Provider, { value, children });
}
function useAlgorithmsVisibility() {
  const context = reactExports.useContext(AlgorithmsVisibilityContext);
  if (!context) {
    throw new Error(
      "useAlgorithmsVisibility must be used within AlgorithmsVisibilityProvider"
    );
  }
  return context;
}
function useChartControls() {
  const {
    globalChartsInfoDataRef,
    durationRef,
    globalChartActionCounterRef,
    globalMaxChartActionCounterRef,
    globalChartCompareCounterRef,
    globalMaxChartCompareCounterRef,
    defaultChartDataState,
    directionForwardRef,
    compareAsStepRef
  } = useGlobalChartsInfo();
  const { algorithmsVisibilityData } = useAlgorithmsVisibility();
  const [globalChartActionCounterState, setGlobalChartActionCounterState] = reactExports.useState(() => globalChartActionCounterRef.current);
  const [globalChartCompareCounterState, setGlobalChartCompareCounterState] = reactExports.useState(() => globalChartCompareCounterRef.current);
  const [durationState, setDurationState] = reactExports.useState(
    () => durationRef.current
  );
  const [compareAsStepState, setCompareAsStepState] = reactExports.useState(
    () => compareAsStepRef.current
  );
  const intervalRef = reactExports.useRef(null);
  const isRunningRef = reactExports.useRef(false);
  const [isRunningState, setIsRunningState] = reactExports.useState(false);
  const setCompareStepAll = reactExports.useCallback(
    (step) => {
      if (step > globalMaxChartCompareCounterRef.current) {
        directionForwardRef.current = true;
        globalChartCompareCounterRef.current = globalMaxChartCompareCounterRef.current + 1;
        setGlobalChartCompareCounterState(
          globalMaxChartCompareCounterRef.current + 1
        );
        globalChartActionCounterRef.current = globalMaxChartActionCounterRef.current;
        setGlobalChartActionCounterState(globalMaxChartActionCounterRef.current);
      } else {
        const newGlobalChartCompareCounter = Math.max(
          0,
          Math.min(step, globalMaxChartCompareCounterRef.current)
        );
        directionForwardRef.current = newGlobalChartCompareCounter > globalChartCompareCounterRef.current;
        globalChartCompareCounterRef.current = newGlobalChartCompareCounter;
        setGlobalChartCompareCounterState(newGlobalChartCompareCounter);
        globalChartActionCounterRef.current = 0;
        setGlobalChartActionCounterState(0);
      }
    },
    [
      directionForwardRef,
      globalChartActionCounterRef,
      globalChartCompareCounterRef,
      globalMaxChartActionCounterRef,
      globalMaxChartCompareCounterRef
    ]
  );
  const setStepAll = reactExports.useCallback(
    (step) => {
      if (compareAsStepRef.current) {
        setCompareStepAll(step);
      } else {
        const newGlobalChartActionCounter = Math.max(
          0,
          Math.min(step, globalMaxChartActionCounterRef.current)
        );
        directionForwardRef.current = newGlobalChartActionCounter > globalChartActionCounterRef.current;
        globalChartActionCounterRef.current = newGlobalChartActionCounter;
        setGlobalChartActionCounterState(newGlobalChartActionCounter);
      }
      let areAllSorted = true;
      globalChartsInfoDataRef.current.forEach((data) => {
        compareAsStepRef.current ? data.current.setCompareStep() : data.current.setStep();
        if (data.current.chartActionRef.current !== CHART_ACTION.FINISHED) {
          areAllSorted = false;
        }
      });
      return areAllSorted;
    },
    [
      compareAsStepRef,
      globalChartsInfoDataRef,
      setCompareStepAll,
      globalMaxChartActionCounterRef,
      directionForwardRef,
      globalChartActionCounterRef
    ]
  );
  const handleStop = reactExports.useCallback(() => {
    if (intervalRef.current) {
      isRunningRef.current = false;
      setIsRunningState(isRunningRef.current);
      clearTimeout(intervalRef.current);
    }
  }, []);
  const continueSort = reactExports.useCallback(
    (delay = durationRef.current) => {
      const isAnyAnimationRunning = globalChartsInfoDataRef.current.some(
        (algorithm) => algorithm.current.isRunningRef.current
      );
      intervalRef.current = setTimeout(() => {
        if (isAnyAnimationRunning) {
          continueSort(50);
          return;
        }
        isRunningRef.current = true;
        setIsRunningState(isRunningRef.current);
        const areAllSorted = setStepAll(
          compareAsStepRef.current ? globalChartCompareCounterRef.current + 1 : globalChartActionCounterRef.current + 1
        );
        if (areAllSorted) {
          handleStop();
        } else {
          continueSort();
        }
      }, delay);
    },
    [
      compareAsStepRef,
      durationRef,
      globalChartActionCounterRef,
      globalChartCompareCounterRef,
      globalChartsInfoDataRef,
      handleStop,
      setStepAll
    ]
  );
  const handleStart = reactExports.useCallback(() => {
    handleStop();
    isRunningRef.current = true;
    setIsRunningState(isRunningRef.current);
    setStepAll(
      compareAsStepRef.current ? globalChartCompareCounterRef.current + 1 : globalChartActionCounterRef.current + 1
    );
    continueSort();
  }, [
    compareAsStepRef,
    continueSort,
    globalChartActionCounterRef,
    globalChartCompareCounterRef,
    handleStop,
    setStepAll
  ]);
  const handleReset = reactExports.useCallback(() => {
    handleStop();
    setStepAll(0);
  }, [handleStop, setStepAll]);
  const handleSetStep = reactExports.useCallback(
    (step) => {
      handleStop();
      setStepAll(step);
    },
    [handleStop, setStepAll]
  );
  const handleDurationChange = reactExports.useCallback(
    (duration) => {
      durationRef.current = 250 / duration;
      setDurationState(250 / duration);
      if (isRunningRef.current) {
        handleStop();
        continueSort();
      }
    },
    [continueSort, durationRef, handleStop]
  );
  const handleCompareAsStepChange = reactExports.useCallback(() => {
    const newCompareAsStep = !compareAsStepRef.current;
    compareAsStepRef.current = newCompareAsStep;
    setCompareAsStepState(newCompareAsStep);
    handleReset();
  }, [compareAsStepRef, handleReset]);
  const handlePrevious = reactExports.useCallback(() => {
    handleStop();
    setStepAll(
      compareAsStepRef.current ? globalChartCompareCounterRef.current - 1 : globalChartActionCounterRef.current - 1
    );
  }, [
    compareAsStepRef,
    globalChartActionCounterRef,
    globalChartCompareCounterRef,
    handleStop,
    setStepAll
  ]);
  const handleNext = reactExports.useCallback(() => {
    handleStop();
    setStepAll(
      compareAsStepRef.current ? globalChartCompareCounterRef.current + 1 : globalChartActionCounterRef.current + 1
    );
  }, [
    compareAsStepRef,
    globalChartActionCounterRef,
    globalChartCompareCounterRef,
    handleStop,
    setStepAll
  ]);
  reactExports.useEffect(() => {
    handleReset();
  }, [defaultChartDataState, handleReset]);
  reactExports.useEffect(() => {
    if (algorithmsVisibilityData.every(({ visible }) => visible === false)) {
      handleStop();
    }
    setGlobalChartActionCounterState(globalChartActionCounterRef.current);
    setGlobalChartCompareCounterState(globalChartCompareCounterRef.current);
  }, [
    algorithmsVisibilityData,
    globalChartActionCounterRef,
    globalChartCompareCounterRef,
    handleStop
  ]);
  return {
    handleStart,
    handleStop,
    handleReset,
    handleSetStep,
    handleDurationChange,
    isRunningState,
    globalChartActionCounterState,
    globalChartCompareCounterState,
    handlePrevious,
    handleNext,
    durationState,
    compareAsStepState,
    handleCompareAsStepChange
  };
}
function ChartControls() {
  const {
    globalMaxChartActionCounterState,
    globalMaxChartCompareCounterState
  } = useGlobalChartsInfo();
  const {
    handleStart,
    handleStop,
    handleReset,
    handleDurationChange,
    isRunningState,
    globalChartActionCounterState,
    handlePrevious,
    handleNext,
    handleSetStep,
    durationState,
    compareAsStepState,
    handleCompareAsStepChange,
    globalChartCompareCounterState
  } = useChartControls();
  const allHidden = globalMaxChartActionCounterState ? false : true;
  const onSpeedValueChange = reactExports.useCallback(
    (value) => handleDurationChange(Number(value)),
    [handleDurationChange]
  );
  const { t: t2 } = useTranslation("ChatControls");
  let sliderValue;
  if (!allHidden) {
    if (compareAsStepState) {
      sliderValue = globalChartActionCounterState === globalMaxChartActionCounterState ? globalChartCompareCounterState + 1 : globalChartCompareCounterState;
    } else {
      sliderValue = globalChartActionCounterState;
    }
  } else {
    sliderValue = 0;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: () => handlePrevious(),
        variant: "ghost",
        className: `p-0 ${allHidden && "opacity-50"}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronLeft, {})
      }
    ),
    isRunningState ? /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: handleStop,
        variant: "ghost",
        className: `p-0 ${allHidden && "opacity-50"}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Pause, {})
      }
    ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: handleStart,
        variant: "ghost",
        className: `p-0 ${allHidden && "opacity-50"}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(Play, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: () => handleNext(),
        variant: "ghost",
        className: `p-0 ${allHidden && "opacity-50"}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChevronRight, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: handleReset,
        variant: "ghost",
        className: `p-0 ${allHidden && "opacity-50"}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(RotateCcw, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Button,
      {
        onClick: () => handleSetStep(
          compareAsStepState ? globalMaxChartCompareCounterState + 1 : globalMaxChartActionCounterState
        ),
        variant: "ghost",
        className: `p-0 ${allHidden && "opacity-50"}`,
        children: /* @__PURE__ */ jsxRuntimeExports.jsx(SkipForward, {})
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Slider,
      {
        className: `h-4 w-1/2 ${allHidden && "opacity-50"}`,
        rangeClassName: `${globalChartActionCounterState === globalMaxChartActionCounterState && "bg-red-400"}`,
        value: [sliderValue],
        max: compareAsStepState ? globalMaxChartCompareCounterState + 1 : globalMaxChartActionCounterState,
        onValueChange: (value) => handleSetStep(value[0]),
        step: 1
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      SpeedToggleButton,
      {
        duration: durationState,
        onValueChange: onSpeedValueChange
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Checkbox,
      {
        id: "compareAsStep",
        checked: compareAsStepState,
        onClick: () => handleCompareAsStepChange()
      }
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "whitespace-pre text-balance", htmlFor: "compareAsStep", children: t2("compareAsStep") })
  ] });
}
function Footer() {
  return /* @__PURE__ */ jsxRuntimeExports.jsx("footer", { className: "flex h-16 items-center justify-center gap-4 border-t px-1 py-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(ChartControls, {}) });
}
/*! @license Rematrix v0.2.2

	Copyright 2018 Fisssion LLC.

	Permission is hereby granted, free of charge, to any person obtaining a copy
	of this software and associated documentation files (the "Software"), to deal
	in the Software without restriction, including without limitation the rights
	to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
	copies of the Software, and to permit persons to whom the Software is
	furnished to do so, subject to the following conditions:

	The above copyright notice and this permission notice shall be included in
	all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
	IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
	FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
	AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
	LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
	OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
	THE SOFTWARE.
*/
function format(source) {
  if (source.constructor !== Array) {
    throw new TypeError("Expected array.");
  }
  if (source.length === 16) {
    return source;
  }
  if (source.length === 6) {
    var matrix = identity();
    matrix[0] = source[0];
    matrix[1] = source[1];
    matrix[4] = source[2];
    matrix[5] = source[3];
    matrix[12] = source[4];
    matrix[13] = source[5];
    return matrix;
  }
  throw new RangeError("Expected array with either 6 or 16 values.");
}
function identity() {
  var matrix = [];
  for (var i2 = 0; i2 < 16; i2++) {
    i2 % 5 == 0 ? matrix.push(1) : matrix.push(0);
  }
  return matrix;
}
function multiply(m2, x2) {
  var fm = format(m2);
  var fx = format(x2);
  var product = [];
  for (var i2 = 0; i2 < 4; i2++) {
    var row = [fm[i2], fm[i2 + 4], fm[i2 + 8], fm[i2 + 12]];
    for (var j = 0; j < 4; j++) {
      var k2 = j * 4;
      var col = [fx[k2], fx[k2 + 1], fx[k2 + 2], fx[k2 + 3]];
      var result = row[0] * col[0] + row[1] * col[1] + row[2] * col[2] + row[3] * col[3];
      product[i2 + k2] = result;
    }
  }
  return product;
}
function parse(source) {
  if (typeof source === "string") {
    var match = source.match(/matrix(3d)?\(([^)]+)\)/);
    if (match) {
      var raw = match[2].split(", ").map(parseFloat);
      return format(raw);
    }
  }
  return identity();
}
function scaleX(scalar) {
  var matrix = identity();
  matrix[0] = scalar;
  return matrix;
}
function scaleY(scalar) {
  var matrix = identity();
  matrix[5] = scalar;
  return matrix;
}
function translateX(distance) {
  var matrix = identity();
  matrix[12] = distance;
  return matrix;
}
function translateY(distance) {
  var matrix = identity();
  matrix[13] = distance;
  return matrix;
}
var e = function(t2) {
  return "number" == typeof t2;
}, i$1 = function(t2) {
  return "function" == typeof t2;
}, n$1 = function(t2) {
  return "[object Object]" === Object.prototype.toString.call(t2);
}, r$1 = function(t2) {
  return Array.prototype.slice.apply(t2);
}, s$2 = function(t2) {
  var e2 = t2.reduce(function(t3, e3) {
    return t3[e3] = (t3[e3] || 0) + 1, t3;
  }, {});
  return Object.keys(e2).filter(function(t3) {
    return e2[t3] > 1;
  });
};
function a(t2) {
  return [].slice.call(arguments, 1).forEach(function(e2) {
    if (e2) for (var i2 in e2) Object.prototype.hasOwnProperty.call(e2, i2) && (t2[i2] = e2[i2]);
  }), t2;
}
var o$1, l = function(t2, e2, i2) {
  return t2 + (e2 - t2) * i2;
}, p = { __proto__: null, isNumber: e, isFunction: i$1, isObject: n$1, toArray: r$1, getDuplicateValsAsStrings: s$2, assign: a, tweenProp: l }, c$1 = "data-flip-id", u$1 = "data-inverse-flip-id", d$1 = "data-portal-key", f$1 = "data-exit-container", h$1 = { __proto__: null, DATA_FLIP_ID: c$1, DATA_INVERSE_FLIP_ID: u$1, DATA_FLIP_COMPONENT_ID: "data-flip-component-id", DATA_FLIP_CONFIG: "data-flip-config", DATA_PORTAL_KEY: d$1, DATA_EXIT_CONTAINER: f$1 }, g$1 = { noWobble: { stiffness: 200, damping: 26 }, gentle: { stiffness: 120, damping: 14 }, veryGentle: { stiffness: 130, damping: 17 }, wobbly: { stiffness: 180, damping: 12 }, stiff: { stiffness: 260, damping: 26 } }, m$1 = function(t2) {
  return n$1(t2) ? t2 : Object.keys(g$1).indexOf(t2) > -1 ? g$1[t2] : {};
};
"undefined" != typeof window && (o$1 = window.requestAnimationFrame);
var v$1 = o$1 = o$1 || function(t2) {
  window.setTimeout(t2, 1e3 / 60);
}, y$1 = Date.now(), _ = "object" == typeof performance && "function" == typeof performance.now ? function() {
  return performance.now();
} : function() {
  return Date.now() - y$1;
};
function S(t2, e2) {
  var i2 = t2.indexOf(e2);
  -1 !== i2 && t2.splice(i2, 1);
}
var E = /* @__PURE__ */ function() {
  function t2() {
  }
  return t2.prototype.run = function() {
    var t3 = this;
    v$1(function() {
      t3.springSystem.loop(_());
    });
  }, t2;
}(), A = function() {
  this.position = 0, this.velocity = 0;
}, C = 0, b = 1e-3, I = /* @__PURE__ */ function() {
  function t2(t3) {
    this._id = "s" + C++, this._springSystem = t3, this.listeners = [], this._startValue = 0, this._currentState = new A(), this._displacementFromRestThreshold = 1e-3, this._endValue = 0, this._overshootClampingEnabled = false, this._previousState = new A(), this._restSpeedThreshold = 1e-3, this._tempState = new A(), this._timeAccumulator = 0, this._wasAtRest = true, this._cachedSpringConfig = {};
  }
  var e2 = t2.prototype;
  return e2.getId = function() {
    return this._id;
  }, e2.destroy = function() {
    this.listeners = [], this._springSystem.deregisterSpring(this);
  }, e2.setSpringConfig = function(t3) {
    return this._springConfig = t3, this;
  }, e2.getCurrentValue = function() {
    return this._currentState.position;
  }, e2.getDisplacementDistanceForState = function(t3) {
    return Math.abs(this._endValue - t3.position);
  }, e2.setEndValue = function(t3) {
    if (t3 === this._endValue) return this;
    if (this.prevEndValue = t3, this._endValue === t3 && this.isAtRest()) return this;
    this._startValue = this.getCurrentValue(), this._endValue = t3, this._springSystem.activateSpring(this.getId());
    for (var e3 = 0, i2 = this.listeners.length; e3 < i2; e3++) {
      var n2 = this.listeners[e3].onSpringEndStateChange;
      n2 && n2(this);
    }
    return this;
  }, e2.setVelocity = function(t3) {
    return t3 === this._currentState.velocity || (this._currentState.velocity = t3, this._springSystem.activateSpring(this.getId())), this;
  }, e2.setCurrentValue = function(t3) {
    this._startValue = t3, this._currentState.position = t3;
    for (var e3 = 0, i2 = this.listeners.length; e3 < i2; e3++) {
      var n2 = this.listeners[e3];
      n2.onSpringUpdate && n2.onSpringUpdate(this);
    }
    return this;
  }, e2.setAtRest = function() {
    return this._endValue = this._currentState.position, this._tempState.position = this._currentState.position, this._currentState.velocity = 0, this;
  }, e2.setOvershootClampingEnabled = function(t3) {
    return this._overshootClampingEnabled = t3, this;
  }, e2.isOvershooting = function() {
    var t3 = this._startValue, e3 = this._endValue;
    return this._springConfig.tension > 0 && (t3 < e3 && this.getCurrentValue() > e3 || t3 > e3 && this.getCurrentValue() < e3);
  }, e2.advance = function(t3, e3) {
    var i2 = this.isAtRest();
    if (!i2 || !this._wasAtRest) {
      var n2 = e3;
      e3 > 0.064 && (n2 = 0.064), this._timeAccumulator += n2;
      for (var r2, s2, a2, o2, l2, p2, c2 = this._springConfig.tension, u2 = this._springConfig.friction, d2 = this._currentState.position, f2 = this._currentState.velocity, h2 = this._tempState.position, g2 = this._tempState.velocity; this._timeAccumulator >= b; ) this._timeAccumulator -= b, this._timeAccumulator < b && (this._previousState.position = d2, this._previousState.velocity = f2), s2 = c2 * (this._endValue - h2) - u2 * f2, o2 = c2 * (this._endValue - (h2 = d2 + (r2 = f2) * b * 0.5)) - u2 * (g2 = f2 + s2 * b * 0.5), p2 = c2 * (this._endValue - (h2 = d2 + (a2 = g2) * b * 0.5)) - u2 * (g2 = f2 + o2 * b * 0.5), h2 = d2 + (l2 = g2) * b, d2 += 1 / 6 * (r2 + 2 * (a2 + l2) + (g2 = f2 + p2 * b)) * b, f2 += 1 / 6 * (s2 + 2 * (o2 + p2) + (c2 * (this._endValue - h2) - u2 * g2)) * b;
      this._tempState.position = h2, this._tempState.velocity = g2, this._currentState.position = d2, this._currentState.velocity = f2, this._timeAccumulator > 0 && this._interpolate(this._timeAccumulator / b), (this.isAtRest() || this._overshootClampingEnabled && this.isOvershooting()) && (this._springConfig.tension > 0 ? (this._startValue = this._endValue, this._currentState.position = this._endValue) : (this._endValue = this._currentState.position, this._startValue = this._endValue), this.setVelocity(0), i2 = true);
      var m2 = false;
      this._wasAtRest && (this._wasAtRest = false, m2 = true);
      var v2 = false;
      i2 && (this._wasAtRest = true, v2 = true), this.notifyPositionUpdated(m2, v2);
    }
  }, e2.notifyPositionUpdated = function(t3, e3) {
    var i2 = this;
    this.listeners.filter(Boolean).forEach(function(n2) {
      t3 && n2.onSpringActivate && !i2._onActivateCalled && (n2.onSpringActivate(i2), i2._onActivateCalled = true), n2.onSpringUpdate && n2.onSpringUpdate(i2), e3 && n2.onSpringAtRest && n2.onSpringAtRest(i2);
    });
  }, e2.systemShouldAdvance = function() {
    return !this.isAtRest() || !this.wasAtRest();
  }, e2.wasAtRest = function() {
    return this._wasAtRest;
  }, e2.isAtRest = function() {
    return Math.abs(this._currentState.velocity) < this._restSpeedThreshold && (this.getDisplacementDistanceForState(this._currentState) <= this._displacementFromRestThreshold || 0 === this._springConfig.tension);
  }, e2._interpolate = function(t3) {
    this._currentState.position = this._currentState.position * t3 + this._previousState.position * (1 - t3), this._currentState.velocity = this._currentState.velocity * t3 + this._previousState.velocity * (1 - t3);
  }, e2.addListener = function(t3) {
    return this.listeners.push(t3), this;
  }, e2.addOneTimeListener = function(t3) {
    var e3 = this;
    return Object.keys(t3).forEach(function(i2) {
      var n2;
      t3[i2] = (n2 = t3[i2], function() {
        n2.apply(void 0, [].slice.call(arguments)), e3.removeListener(t3);
      });
    }), this.listeners.push(t3), this;
  }, e2.removeListener = function(t3) {
    return S(this.listeners, t3), this;
  }, t2;
}(), w = /* @__PURE__ */ function() {
  function t2(t3) {
    this.looper = t3 || new E(), this.looper.springSystem = this, this.listeners = [], this._activeSprings = [], this._idleSpringIndices = [], this._isIdle = true, this._lastTimeMillis = -1, this._springRegistry = {};
  }
  var e2 = t2.prototype;
  return e2.createSpring = function(t3, e3) {
    return this.createSpringWithConfig({ tension: t3, friction: e3 });
  }, e2.createSpringWithConfig = function(t3) {
    var e3 = new I(this);
    return this.registerSpring(e3), e3.setSpringConfig(t3), e3;
  }, e2.getIsIdle = function() {
    return this._isIdle;
  }, e2.registerSpring = function(t3) {
    this._springRegistry[t3.getId()] = t3;
  }, e2.deregisterSpring = function(t3) {
    S(this._activeSprings, t3), delete this._springRegistry[t3.getId()];
  }, e2.advance = function(t3, e3) {
    for (var i2 = this; this._idleSpringIndices.length > 0; ) this._idleSpringIndices.pop();
    for (this._activeSprings.filter(Boolean).forEach(function(n3) {
      n3.systemShouldAdvance() ? n3.advance(t3 / 1e3, e3 / 1e3) : i2._idleSpringIndices.push(i2._activeSprings.indexOf(n3));
    }); this._idleSpringIndices.length > 0; ) {
      var n2 = this._idleSpringIndices.pop();
      n2 >= 0 && this._activeSprings.splice(n2, 1);
    }
  }, e2.loop = function(t3) {
    var e3;
    -1 === this._lastTimeMillis && (this._lastTimeMillis = t3 - 1);
    var i2 = t3 - this._lastTimeMillis;
    this._lastTimeMillis = t3;
    var n2 = 0, r2 = this.listeners.length;
    for (n2 = 0; n2 < r2; n2++) (e3 = this.listeners[n2]).onBeforeIntegrate && e3.onBeforeIntegrate(this);
    for (this.advance(t3, i2), 0 === this._activeSprings.length && (this._isIdle = true, this._lastTimeMillis = -1), n2 = 0; n2 < r2; n2++) (e3 = this.listeners[n2]).onAfterIntegrate && e3.onAfterIntegrate(this);
    this._isIdle || this.looper.run();
  }, e2.activateSpring = function(t3) {
    var e3 = this._springRegistry[t3];
    -1 === this._activeSprings.indexOf(e3) && this._activeSprings.push(e3), this.getIsIdle() && (this._isIdle = false, this.looper.run());
  }, t2;
}(), O = new w(), x = function(t2) {
  var e2 = t2.springConfig, i2 = e2.overshootClamping, n2 = t2.getOnUpdateFunc, r2 = t2.onAnimationEnd, s2 = t2.onSpringActivate, a2 = O.createSpring(e2.stiffness, e2.damping);
  a2.setOvershootClampingEnabled(!!i2);
  var o2 = { onSpringActivate: s2, onSpringAtRest: function() {
    a2.destroy(), r2();
  }, onSpringUpdate: n2({ spring: a2, onAnimationEnd: r2 }) };
  return a2.addListener(o2), a2;
}, U = function(t2) {
  var e2 = x(t2);
  return e2.setEndValue(1), e2;
}, V = function(t2, e2) {
  if (void 0 === e2 && (e2 = {}), t2 && t2.length) {
    e2.reverse && t2.reverse();
    var i2, n2 = "number" != typeof (i2 = e2.speed) ? 1.1 : 1 + Math.min(Math.max(5 * i2, 0), 5), r2 = 1 / Math.max(Math.min(t2.length, 100), 10), s2 = t2.map(function(t3, e3) {
      var i3 = t3.getOnUpdateFunc;
      return t3.getOnUpdateFunc = function(t4) {
        var a2 = i3(t4);
        return function(t5) {
          var i4 = t5.getCurrentValue();
          (i4 = i4 < 0.01 ? 0 : i4 > 0.99 ? 1 : i4) >= r2 && s2[e3 + 1] && s2[e3 + 1](Math.max(Math.min(i4 * n2, 1), 0)), a2(t5);
        };
      }, t3;
    }).map(function(t3) {
      var e3 = x(t3);
      if (e3) return e3.setEndValue.bind(e3);
    }).filter(Boolean);
    s2[0] && s2[0](1);
  }
}, F = function(t2) {
  return [0, 1, 4, 5, 12, 13].map(function(e2) {
    return t2[e2];
  });
}, P = function(t2) {
  return t2.top < window.innerHeight && t2.bottom > 0 && t2.left < window.innerWidth && t2.right > 0;
};
function D(t2) {
  return JSON.parse(t2.dataset.flipConfig || "{}");
}
var R = function(t2, e2) {
  var i2;
  return a(t2, ((i2 = {})[e2[0]] = e2[1], i2));
}, T = function(t2, e2) {
  return r$1(e2 ? document.querySelectorAll("[" + d$1 + '="' + e2 + '"]') : t2.querySelectorAll("[" + c$1 + "]"));
}, M = function(t2) {
  return t2.map(function(t3) {
    return [t3, t3.getBoundingClientRect()];
  });
}, L = function(n2) {
  var o2 = n2.cachedOrderedFlipIds, p2 = void 0 === o2 ? [] : o2, f2 = n2.inProgressAnimations, h2 = void 0 === f2 ? {} : f2, v2 = n2.flippedElementPositionsBeforeUpdate, y2 = void 0 === v2 ? {} : v2, _2 = n2.flipCallbacks, S2 = void 0 === _2 ? {} : _2, E2 = n2.containerEl, A2 = n2.applyTransformOrigin, C2 = n2.spring, b2 = n2.debug, I2 = n2.portalKey, w2 = n2.staggerConfig, O2 = void 0 === w2 ? {} : w2, x2 = n2.decisionData, j = void 0 === x2 ? {} : x2, B2 = n2.handleEnterUpdateDelete, N2 = n2.onComplete, L2 = n2.onStart;
  if (!window.matchMedia("(prefers-reduced-motion: reduce)").matches) {
    var q2, X2 = M(T((q2 = { element: E2, portalKey: I2 }).element, q2.portalKey)).map(function(t2) {
      var e2 = t2[0], i2 = t2[1], n3 = window.getComputedStyle(e2);
      return [e2.dataset.flipId, { element: e2, rect: i2, opacity: parseFloat(n3.opacity), transform: n3.transform }];
    }).reduce(R, {}), Y2 = function(t2) {
      var e2 = t2.containerEl, i2 = t2.portalKey;
      return i2 ? /* @__PURE__ */ function(t3) {
        return function(e3) {
          return r$1(document.querySelectorAll("[" + d$1 + '="' + t3 + '"]' + e3));
        };
      }(i2) : e2 ? function(t3) {
        var e3 = Math.random().toFixed(5);
        return t3.dataset.flipperId = e3, function(i3) {
          return r$1(t3.querySelectorAll('[data-flipper-id="' + e3 + '"] ' + i3));
        };
      }(e2) : function() {
        return [];
      };
    }({ containerEl: E2, portalKey: I2 }), W2 = /* @__PURE__ */ function(t2) {
      return function(e2) {
        return t2("[" + c$1 + '="' + e2 + '"]')[0];
      };
    }(Y2), K2 = function(t2) {
      return y2[t2] && X2[t2];
    }, H2 = Object.keys(y2).concat(Object.keys(X2)).filter(function(t2) {
      return !K2(t2);
    }), J2 = { flipCallbacks: S2, getElement: W2, flippedElementPositionsBeforeUpdate: y2, flippedElementPositionsAfterUpdate: X2, inProgressAnimations: h2, decisionData: j }, z2 = function(t2) {
      var e2, i2 = t2.unflippedIds, n3 = t2.flipCallbacks, r2 = t2.getElement, s2 = t2.flippedElementPositionsBeforeUpdate, a2 = t2.flippedElementPositionsAfterUpdate, o3 = t2.inProgressAnimations, l2 = t2.decisionData, p3 = i2.filter(function(t3) {
        return a2[t3];
      }).filter(function(t3) {
        return n3[t3] && n3[t3].onAppear;
      }), c2 = i2.filter(function(t3) {
        return s2[t3] && n3[t3] && n3[t3].onExit;
      }), u2 = new Promise(function(t3) {
        e2 = t3;
      }), d2 = [], f3 = 0, h3 = c2.map(function(t3, i3) {
        var r3 = s2[t3].domDataForExitAnimations, a3 = r3.element, p4 = r3.parent, c3 = r3.childPosition, u3 = c3.top, h4 = c3.left, g2 = c3.width, m2 = c3.height;
        "static" === getComputedStyle(p4).position && (p4.style.position = "relative"), a3.style.transform = "matrix(1, 0, 0, 1, 0, 0)", a3.style.position = "absolute", a3.style.top = u3 + "px", a3.style.left = h4 + "px", a3.style.height = m2 + "px", a3.style.width = g2 + "px";
        var v3 = d2.filter(function(t4) {
          return t4[0] === p4;
        })[0];
        v3 || (v3 = [p4, document.createDocumentFragment()], d2.push(v3)), v3[1].appendChild(a3), f3 += 1;
        var y3 = function() {
          try {
            p4.removeChild(a3);
          } catch (t4) {
          } finally {
            0 == (f3 -= 1) && e2();
          }
        };
        return o3[t3] = { stop: y3 }, function() {
          return n3[t3].onExit(a3, i3, y3, l2);
        };
      });
      return d2.forEach(function(t3) {
        t3[0].appendChild(t3[1]);
      }), h3.length || e2(), { hideEnteringElements: function() {
        p3.forEach(function(t3) {
          var e3 = r2(t3);
          e3 && (e3.style.opacity = "0");
        });
      }, animateEnteringElements: function() {
        p3.forEach(function(t3, e3) {
          var i3 = r2(t3);
          i3 && n3[t3].onAppear(i3, e3, l2);
        });
      }, animateExitingElements: function() {
        return h3.forEach(function(t3) {
          return t3();
        }), u2;
      } };
    }(a({}, J2, { unflippedIds: H2 })), G2 = z2.hideEnteringElements, Q2 = z2.animateEnteringElements, Z2 = z2.animateExitingElements, $ = a({}, J2, { containerEl: E2, flippedIds: p2.filter(K2), applyTransformOrigin: A2, spring: C2, debug: b2, staggerConfig: O2, scopedSelector: Y2, onComplete: N2 });
    L2 && L2(E2, j);
    var tt = function(n3) {
      var o3, p3 = n3.flippedIds, c2 = n3.flipCallbacks, d2 = n3.inProgressAnimations, f3 = n3.flippedElementPositionsBeforeUpdate, h3 = n3.flippedElementPositionsAfterUpdate, v3 = n3.applyTransformOrigin, y3 = n3.spring, _3 = n3.getElement, S3 = n3.debug, E3 = n3.staggerConfig, A3 = void 0 === E3 ? {} : E3, C3 = n3.decisionData, b3 = void 0 === C3 ? {} : C3, I3 = n3.onComplete, w3 = n3.containerEl, O3 = new Promise(function(t2) {
        o3 = t2;
      });
      if (I3 && O3.then(function() {
        return I3(w3, b3);
      }), !p3.length) return function() {
        return o3([]), O3;
      };
      var x3 = [], R2 = _3(p3[0]), T2 = R2 ? R2.ownerDocument.querySelector("body") : document.querySelector("body");
      s$2(p3);
      var M2 = p3.map(function(n4) {
        var s2 = f3[n4].rect, p4 = h3[n4].rect, _4 = f3[n4].opacity, S4 = h3[n4].opacity, E4 = p4.width < 1 || p4.height < 1, A4 = h3[n4].element;
        if (!P(s2) && !P(p4)) return false;
        if (!A4) return false;
        var C4, I4, w4, O4 = D(A4), U2 = (w4 = (I4 = void 0 === (C4 = { flipperSpring: y3, flippedSpring: O4.spring }) ? {} : C4).flippedSpring, a({}, g$1.noWobble, m$1(I4.flipperSpring), m$1(w4))), V2 = true === O4.stagger ? "default" : O4.stagger, R3 = { element: A4, id: n4, stagger: V2, springConfig: U2 };
        if (c2[n4] && c2[n4].shouldFlip && !c2[n4].shouldFlip(b3.previous, b3.current)) return false;
        var k3 = Math.abs(s2.left - p4.left) + Math.abs(s2.top - p4.top), j3 = Math.abs(s2.width - p4.width) + Math.abs(s2.height - p4.height), B4 = Math.abs(S4 - _4);
        if (0 === s2.height && 0 === p4.height || 0 === s2.width && 0 === p4.width || k3 < 0.5 && j3 < 0.5 && B4 < 0.01) return false;
        var N4 = parse(h3[n4].transform), L4 = { matrix: N4 }, q4 = { matrix: [] }, X3 = [N4];
        O4.translate && (X3.push(translateX(s2.left - p4.left)), X3.push(translateY(s2.top - p4.top))), O4.scale && (X3.push(scaleX(Math.max(s2.width, 1) / Math.max(p4.width, 1))), X3.push(scaleY(Math.max(s2.height, 1) / Math.max(p4.height, 1)))), O4.opacity && (q4.opacity = _4, L4.opacity = S4);
        var Y3 = [];
        if (!c2[n4] || !c2[n4].shouldInvert || c2[n4].shouldInvert(b3.previous, b3.current)) {
          var W3 = function(t2, e2) {
            return r$1(t2.querySelectorAll("[" + u$1 + '="' + e2 + '"]'));
          }(A4, n4);
          Y3 = W3.map(function(t2) {
            return [t2, D(t2)];
          });
        }
        q4.matrix = F(X3.reduce(multiply)), L4.matrix = F(L4.matrix);
        var K3, H3 = function(t2) {
          var i2 = t2.element, n5 = t2.invertedChildren, r2 = t2.body;
          return function(t3) {
            var s3 = t3.matrix, a2 = t3.opacity, o4 = t3.forceMinVals;
            if (e(a2) && (i2.style.opacity = a2 + ""), o4 && (i2.style.minHeight = "1px", i2.style.minWidth = "1px"), s3) {
              var l2 = function(t4) {
                return "matrix(" + t4.join(", ") + ")";
              }(s3);
              i2.style.transform = l2, n5 && function(t4) {
                var e2 = t4.matrix, i3 = t4.body;
                t4.invertedChildren.forEach(function(t5) {
                  var n6 = t5[0], r3 = t5[1];
                  if (i3.contains(n6)) {
                    var s4 = e2[0], a3 = e2[3], o5 = e2[5], l3 = { translateX: 0, translateY: 0, scaleX: 1, scaleY: 1 }, p5 = "";
                    r3.translate && (l3.translateX = -e2[4] / s4, l3.translateY = -o5 / a3, p5 += "translate(" + l3.translateX + "px, " + l3.translateY + "px)"), r3.scale && (l3.scaleX = 1 / s4, l3.scaleY = 1 / a3, p5 += " scale(" + l3.scaleX + ", " + l3.scaleY + ")"), n6.style.transform = p5;
                  }
                });
              }({ invertedChildren: n5, matrix: s3, body: r2 });
            }
          };
        }({ element: A4, invertedChildren: Y3, body: T2 });
        if (c2[n4] && c2[n4].onComplete) {
          var J3 = c2[n4].onComplete;
          K3 = function() {
            return J3(A4, b3);
          };
        }
        var z3 = e(q4.opacity) && e(L4.opacity) && q4.opacity !== L4.opacity, G3 = false;
        return a({}, R3, { stagger: V2, springConfig: U2, getOnUpdateFunc: function(t2) {
          var e2 = t2.spring, i2 = t2.onAnimationEnd;
          return d2[n4] = { destroy: e2.destroy.bind(e2), onAnimationEnd: i2 }, function(t3) {
            c2[n4] && c2[n4].onSpringUpdate && c2[n4].onSpringUpdate(t3.getCurrentValue()), G3 || (G3 = true, c2[n4] && c2[n4].onStart && c2[n4].onStart(A4, b3));
            var e3 = t3.getCurrentValue();
            if (T2.contains(A4)) {
              var i3 = { matrix: [] };
              i3.matrix = q4.matrix.map(function(t4, i4) {
                return l(t4, L4.matrix[i4], e3);
              }), z3 && (i3.opacity = l(q4.opacity, L4.opacity, e3)), H3(i3);
            } else t3.destroy();
          };
        }, initializeFlip: function() {
          H3({ matrix: q4.matrix, opacity: z3 ? q4.opacity : void 0, forceMinVals: E4 }), c2[n4] && c2[n4].onStartImmediate && c2[n4].onStartImmediate(A4, b3), O4.transformOrigin ? A4.style.transformOrigin = O4.transformOrigin : v3 && (A4.style.transformOrigin = "0 0"), Y3.forEach(function(t2) {
            var e2 = t2[0], i2 = t2[1];
            i2.transformOrigin ? e2.style.transformOrigin = i2.transformOrigin : v3 && (e2.style.transformOrigin = "0 0");
          });
        }, onAnimationEnd: function(t2) {
          delete d2[n4], i$1(K3) && K3(), A4.style.transform = "", Y3.forEach(function(t3) {
            t3[0].style.transform = "";
          }), E4 && A4 && (A4.style.minHeight = "", A4.style.minWidth = ""), t2 || (x3.push(n4), x3.length >= M2.length && o3(x3));
        }, delayUntil: O4.delayUntil });
      }).filter(Boolean);
      if (M2.forEach(function(t2) {
        return (0, t2.initializeFlip)();
      }), S3) return function() {
      };
      var k2 = M2.filter(function(t2) {
        return t2.delayUntil && (e2 = t2.delayUntil, M2.filter(function(t3) {
          return t3.id === e2;
        }).length);
        var e2;
      }), j2 = {}, B3 = {}, N3 = {};
      k2.forEach(function(t2) {
        t2.stagger ? (N3[t2.stagger] = true, B3[t2.delayUntil] ? B3[t2.delayUntil].push(t2.stagger) : B3[t2.delayUntil] = [t2.stagger]) : j2[t2.delayUntil] ? j2[t2.delayUntil].push(t2) : j2[t2.delayUntil] = [t2];
      });
      var L3 = M2.filter(function(t2) {
        return t2.stagger;
      }).reduce(function(t2, e2) {
        return t2[e2.stagger] ? t2[e2.stagger].push(e2) : t2[e2.stagger] = [e2], t2;
      }, {}), q3 = M2.filter(function(t2) {
        return -1 === k2.indexOf(t2);
      });
      return q3.forEach(function(t2) {
        t2.onSpringActivate = function() {
          j2[t2.id] && j2[t2.id].forEach(U), B3[t2.id] && Object.keys(B3[t2.id].reduce(function(t3, e2) {
            var i2;
            return a(t3, ((i2 = {})[e2] = true, i2));
          }, {})).forEach(function(t3) {
            V(L3[t3], A3[t3]);
          });
        };
      }), function() {
        return M2.length || o3([]), q3.filter(function(t2) {
          return !t2.stagger;
        }).forEach(U), Object.keys(L3).forEach(function(t2) {
          N3[t2] || V(L3[t2], A3[t2]);
        }), O3;
      };
    }($);
    B2 ? B2({ hideEnteringElements: G2, animateEnteringElements: Q2, animateExitingElements: Z2, animateFlippedElements: tt }) : (G2(), Z2().then(Q2), tt());
  }
}, q = function(t2) {
  var e2 = t2.element, i2 = t2.flipCallbacks, n2 = void 0 === i2 ? {} : i2, s2 = t2.inProgressAnimations, o2 = void 0 === s2 ? {} : s2, l2 = T(e2, t2.portalKey), p2 = r$1(e2.querySelectorAll("[" + u$1 + "]")), c2 = {}, d2 = [], h2 = {};
  l2.filter(function(t3) {
    return n2 && n2[t3.dataset.flipId] && n2[t3.dataset.flipId].onExit;
  }).forEach(function(t3) {
    var e3 = t3.parentNode;
    if (t3.closest) {
      var i3 = t3.closest("[" + f$1 + "]");
      i3 && (e3 = i3);
    }
    var n3 = d2.findIndex(function(t4) {
      return t4[0] === e3;
    });
    -1 === n3 && (d2.push([e3, e3.getBoundingClientRect()]), n3 = d2.length - 1), c2[t3.dataset.flipId] = d2[n3][1], h2[t3.dataset.flipId] = e3;
  });
  var g2 = M(l2), m2 = g2.map(function(t3) {
    var e3 = t3[0], i3 = t3[1], r2 = {};
    if (n2 && n2[e3.dataset.flipId] && n2[e3.dataset.flipId].onExit) {
      var s3 = c2[e3.dataset.flipId];
      a(r2, { element: e3, parent: h2[e3.dataset.flipId], childPosition: { top: i3.top - s3.top, left: i3.left - s3.left, width: i3.width, height: i3.height } });
    }
    return [e3.dataset.flipId, { rect: i3, opacity: parseFloat(window.getComputedStyle(e3).opacity || "1"), domDataForExitAnimations: r2 }];
  }).reduce(R, {});
  return function(t3, e3) {
    Object.keys(t3).forEach(function(e4) {
      t3[e4].destroy && t3[e4].destroy(), t3[e4].onAnimationEnd && t3[e4].onAnimationEnd(true), delete t3[e4];
    }), e3.forEach(function(t4) {
      t4.style.transform = "", t4.style.opacity = "";
    });
  }(o2, l2.concat(p2)), { flippedElementPositions: m2, cachedOrderedFlipIds: g2.map(function(t3) {
    return t3[0].dataset.flipId;
  }) };
};
new w();
function s$1() {
  return s$1 = Object.assign ? Object.assign.bind() : function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var r2 = arguments[t2];
      for (var n2 in r2) Object.prototype.hasOwnProperty.call(r2, n2) && (e2[n2] = r2[n2]);
    }
    return e2;
  }, s$1.apply(this, arguments);
}
function c(e2, t2) {
  return c = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(e3, t3) {
    return e3.__proto__ = t3, e3;
  }, c(e2, t2);
}
function d(e2, t2) {
  if (null == e2) return {};
  var r2, n2, i2 = {}, o2 = Object.keys(e2);
  for (n2 = 0; n2 < o2.length; n2++) t2.indexOf(r2 = o2[n2]) >= 0 || (i2[r2] = e2[r2]);
  return i2;
}
var f = /* @__PURE__ */ reactExports.createContext({}), u = /* @__PURE__ */ reactExports.createContext("portal"), h = /* @__PURE__ */ function(r2) {
  var n2, o2;
  function p2() {
    for (var e2, t2 = arguments.length, n3 = new Array(t2), i2 = 0; i2 < t2; i2++) n3[i2] = arguments[i2];
    return (e2 = r2.call.apply(r2, [this].concat(n3)) || this).inProgressAnimations = {}, e2.flipCallbacks = {}, e2.el = void 0, e2;
  }
  o2 = r2, (n2 = p2).prototype = Object.create(o2.prototype), n2.prototype.constructor = n2, c(n2, o2);
  var l2 = p2.prototype;
  return l2.getSnapshotBeforeUpdate = function(t2) {
    return t2.flipKey !== this.props.flipKey && this.el ? q({ element: this.el, flipCallbacks: this.flipCallbacks, inProgressAnimations: this.inProgressAnimations, portalKey: this.props.portalKey }) : null;
  }, l2.componentDidUpdate = function(e2, r3, n3) {
    this.props.flipKey !== e2.flipKey && this.el && L({ flippedElementPositionsBeforeUpdate: n3.flippedElementPositions, cachedOrderedFlipIds: n3.cachedOrderedFlipIds, containerEl: this.el, inProgressAnimations: this.inProgressAnimations, flipCallbacks: this.flipCallbacks, applyTransformOrigin: this.props.applyTransformOrigin, spring: this.props.spring, debug: this.props.debug, portalKey: this.props.portalKey, staggerConfig: this.props.staggerConfig, handleEnterUpdateDelete: this.props.handleEnterUpdateDelete, decisionData: { previous: e2.decisionData, current: this.props.decisionData }, onComplete: this.props.onComplete, onStart: this.props.onStart });
  }, l2.render = function() {
    var e2 = this, t2 = this.props, r3 = t2.portalKey, n3 = /* @__PURE__ */ React.createElement(f.Provider, { value: this.flipCallbacks }, /* @__PURE__ */ React.createElement(t2.element, { className: t2.className, ref: function(t3) {
      return e2.el = t3;
    } }, this.props.children));
    return r3 && (n3 = /* @__PURE__ */ React.createElement(u.Provider, { value: r3 }, n3)), n3;
  }, p2;
}(reactExports.Component);
h.defaultProps = { applyTransformOrigin: true, element: "div" };
var m = ["children", "flipId", "inverseFlipId", "portalKey"], y = ["children", "flipId", "shouldFlip", "shouldInvert", "onAppear", "onStart", "onStartImmediate", "onComplete", "onExit", "onSpringUpdate"], g = function(e2) {
  var t2, i2 = e2.children, o2 = e2.flipId, p$12 = e2.inverseFlipId, s2 = e2.portalKey, c2 = d(e2, m), f2 = i2, u2 = /* @__PURE__ */ function(e3) {
    return "function" == typeof e3;
  }(f2);
  if (!u2) try {
    f2 = reactExports.Children.only(i2);
  } catch (e3) {
    throw new Error("Each Flipped component must wrap a single child");
  }
  c2.scale || c2.translate || c2.opacity || p.assign(c2, { translate: true, scale: true, opacity: true });
  var h2 = ((t2 = {})[h$1.DATA_FLIP_CONFIG] = JSON.stringify(c2), t2);
  return void 0 !== o2 ? h2[h$1.DATA_FLIP_ID] = String(o2) : p$12 && (h2[h$1.DATA_INVERSE_FLIP_ID] = String(p$12)), void 0 !== s2 && (h2[h$1.DATA_PORTAL_KEY] = s2), u2 ? f2(h2) : /* @__PURE__ */ reactExports.cloneElement(f2, h2);
}, v = function(e2) {
  var t2 = e2.children, n2 = e2.flipId, o2 = e2.shouldFlip, p$12 = e2.shouldInvert, l2 = e2.onAppear, a2 = e2.onStart, c2 = e2.onStartImmediate, h2 = e2.onComplete, m2 = e2.onExit, v2 = e2.onSpringUpdate, I2 = d(e2, y);
  return t2 ? I2.inverseFlipId ? /* @__PURE__ */ React.createElement(g, s$1({}, I2), t2) : /* @__PURE__ */ React.createElement(u.Consumer, null, function(e3) {
    return React.createElement(f.Consumer, null, function(d2) {
      return p.isObject(d2) && n2 && (d2[n2] = { shouldFlip: o2, shouldInvert: p$12, onAppear: l2, onStart: a2, onStartImmediate: c2, onComplete: h2, onExit: m2, onSpringUpdate: v2 }), /* @__PURE__ */ React.createElement(g, s$1({ flipId: n2 }, I2, { portalKey: e3 }), t2);
    });
  }) : null;
};
v.displayName = "Flipped";
function useDragAlgorithm(ITEM_TYPE, algorithm, containerLayout = DRAG_CONTAINER_LAYOUT.GRID) {
  const ref = reactExports.useRef(null);
  const { swapAlgorithmsPosition, draggablesTransitionStateRef } = useAlgorithmsVisibility();
  const [{ isDragging }, drag, preview] = useDrag({
    type: ITEM_TYPE,
    item: () => ({ algorithm }),
    collect: (monitor) => ({
      isDragging: monitor.isDragging()
    })
  });
  const [{ handlerId }, drop] = useDrop({
    accept: ITEM_TYPE,
    collect(monitor) {
      return {
        handlerId: monitor.getHandlerId()
      };
    },
    hover: (item, monitor) => {
      if (!ref.current) {
        return;
      }
      if (item.algorithm === algorithm) {
        return;
      }
      if (draggablesTransitionStateRef.current[ITEM_TYPE]) {
        return;
      }
      const hoverBoundingRect = ref.current?.getBoundingClientRect();
      const xSwapTreshold = 0.5;
      const ySwapTreshold = 0.5;
      const clientOffset = monitor.getClientOffset();
      const hoverClientX = clientOffset.x - hoverBoundingRect.left;
      const hoverClientY = clientOffset.y - hoverBoundingRect.top;
      const minX = hoverBoundingRect.width / 2 * xSwapTreshold;
      const maxX = hoverBoundingRect.width / 2 * (1 + xSwapTreshold);
      const isCursorNearCenterX = hoverClientX > minX && hoverClientX < maxX;
      const minY = hoverBoundingRect.height / 2 * ySwapTreshold;
      const maxY = hoverBoundingRect.height / 2 * (1 + ySwapTreshold);
      const isCursorNearCenterY = hoverClientY > minY && hoverClientY < maxY;
      if ((containerLayout === DRAG_CONTAINER_LAYOUT.HORIZONTAL || containerLayout === DRAG_CONTAINER_LAYOUT.GRID) && !isCursorNearCenterX) {
        return;
      }
      if ((containerLayout === DRAG_CONTAINER_LAYOUT.VERTICAL || containerLayout === DRAG_CONTAINER_LAYOUT.GRID) && !isCursorNearCenterY) {
        return;
      }
      swapAlgorithmsPosition(item.algorithm, algorithm);
    }
  });
  drag(drop(ref));
  return { isDragging, ref, handlerId, preview };
}
function AlgorithmsVisibilityButtonItem({
  algorithm,
  visible,
  flippedProps
}) {
  const { setAlgorithmsVisibility } = useAlgorithmsVisibility();
  const { isDragging, ref, handlerId, preview } = useDragAlgorithm(
    DRAG_ITEM_TYPE.CONTEXT_ITEM,
    algorithm,
    DRAG_CONTAINER_LAYOUT.HANDLE
  );
  const { t: t2 } = useTranslation("AlgorithmsNames");
  const id2 = reactExports.useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    "div",
    {
      className: `flex items-center justify-between rounded border p-2 ${isDragging ? "opacity-50" : "opacity-100"}`,
      ref: preview,
      "data-handler-id": handlerId,
      ...flippedProps,
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-center gap-x-2", children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            Checkbox,
            {
              checked: visible,
              onClick: (e2) => {
                e2.preventDefault();
                setAlgorithmsVisibility(
                  algorithm,
                  !visible
                );
              },
              id: id2
            }
          ),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Label, { className: "text-lg", htmlFor: id2, children: t2(algorithm) })
        ] }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, children: /* @__PURE__ */ jsxRuntimeExports.jsx(GripVertical, {}) })
      ]
    }
  );
}
function AlgorithmsVisibilityButton() {
  const { algorithmsVisibilityData, draggablesTransitionStateRef } = useAlgorithmsVisibility();
  const { t: t2 } = useTranslation("AlgorithmsVisibilityButton");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", children: t2("button") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogContent, { className: "flex h-3/6 min-h-64 w-96 flex-col", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: t2("title") }),
        /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogDescription, { children: [
          t2("description"),
          "."
        ] })
      ] }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-0 flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col gap-y-2 pr-5", children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        h,
        {
          className: "contents",
          flipKey: `algorithmsVisibilityButton${algorithmsVisibilityData.map(({ algorithm }) => algorithm).join("")}`,
          children: algorithmsVisibilityData.map(({ algorithm, visible }) => /* @__PURE__ */ jsxRuntimeExports.jsx(
            v,
            {
              flipId: `algorithmsVisibilityButtonItem${algorithm}`,
              onStart: () => draggablesTransitionStateRef.current[DRAG_ITEM_TYPE.CONTEXT_ITEM] = true,
              onComplete: () => draggablesTransitionStateRef.current[DRAG_ITEM_TYPE.CONTEXT_ITEM] = false,
              children: (flippedProps) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                AlgorithmsVisibilityButtonItem,
                {
                  algorithm,
                  visible,
                  flippedProps
                }
              )
            },
            `algorithmsVisibilityButtonItem${algorithm}`
          ))
        }
      ) }) })
    ] })
  ] });
}
var isCheckBoxInput = (element) => element.type === "checkbox";
var isDateObject = (value) => value instanceof Date;
var isNullOrUndefined = (value) => value == null;
const isObjectType = (value) => typeof value === "object";
var isObject = (value) => !isNullOrUndefined(value) && !Array.isArray(value) && isObjectType(value) && !isDateObject(value);
var getEventValue = (event) => isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;
var getNodeParentName = (name) => name.substring(0, name.search(/\.\d+(\.|$)/)) || name;
var isNameInFieldArray = (names, name) => names.has(getNodeParentName(name));
var isPlainObject = (tempObject) => {
  const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;
  return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty("isPrototypeOf");
};
var isWeb = typeof window !== "undefined" && typeof window.HTMLElement !== "undefined" && typeof document !== "undefined";
function cloneObject(data) {
  let copy2;
  const isArray = Array.isArray(data);
  if (data instanceof Date) {
    copy2 = new Date(data);
  } else if (data instanceof Set) {
    copy2 = new Set(data);
  } else if (!(isWeb && (data instanceof Blob || data instanceof FileList)) && (isArray || isObject(data))) {
    copy2 = isArray ? [] : {};
    if (!isArray && !isPlainObject(data)) {
      copy2 = data;
    } else {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          copy2[key] = cloneObject(data[key]);
        }
      }
    }
  } else {
    return data;
  }
  return copy2;
}
var compact = (value) => Array.isArray(value) ? value.filter(Boolean) : [];
var isUndefined = (val) => val === void 0;
var get = (object, path2, defaultValue) => {
  if (!path2 || !isObject(object)) {
    return defaultValue;
  }
  const result = compact(path2.split(/[,[\].]+?/)).reduce((result2, key) => isNullOrUndefined(result2) ? result2 : result2[key], object);
  return isUndefined(result) || result === object ? isUndefined(object[path2]) ? defaultValue : object[path2] : result;
};
var isBoolean = (value) => typeof value === "boolean";
var isKey = (value) => /^\w*$/.test(value);
var stringToPath = (input) => compact(input.replace(/["|']|\]/g, "").split(/\.|\[/));
var set = (object, path2, value) => {
  let index2 = -1;
  const tempPath = isKey(path2) ? [path2] : stringToPath(path2);
  const length = tempPath.length;
  const lastIndex = length - 1;
  while (++index2 < length) {
    const key = tempPath[index2];
    let newValue = value;
    if (index2 !== lastIndex) {
      const objValue = object[key];
      newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index2 + 1]) ? [] : {};
    }
    if (key === "__proto__") {
      return;
    }
    object[key] = newValue;
    object = object[key];
  }
  return object;
};
const EVENTS = {
  BLUR: "blur",
  FOCUS_OUT: "focusout",
  CHANGE: "change"
};
const VALIDATION_MODE = {
  onBlur: "onBlur",
  onChange: "onChange",
  onSubmit: "onSubmit",
  onTouched: "onTouched",
  all: "all"
};
const INPUT_VALIDATION_RULES = {
  max: "max",
  min: "min",
  maxLength: "maxLength",
  minLength: "minLength",
  pattern: "pattern",
  required: "required",
  validate: "validate"
};
const HookFormContext = React.createContext(null);
const useFormContext = () => React.useContext(HookFormContext);
const FormProvider = (props) => {
  const { children, ...data } = props;
  return React.createElement(HookFormContext.Provider, { value: data }, children);
};
var getProxyFormState = (formState, control, localProxyFormState, isRoot = true) => {
  const result = {
    defaultValues: control._defaultValues
  };
  for (const key in formState) {
    Object.defineProperty(result, key, {
      get: () => {
        const _key = key;
        if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {
          control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;
        }
        localProxyFormState && (localProxyFormState[_key] = true);
        return formState[_key];
      }
    });
  }
  return result;
};
var isEmptyObject = (value) => isObject(value) && !Object.keys(value).length;
var shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot) => {
  updateFormState(formStateData);
  const { name, ...formState } = formStateData;
  return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key) => _proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));
};
var convertToArrayPayload = (value) => Array.isArray(value) ? value : [value];
var shouldSubscribeByName = (name, signalName, exact) => !name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName) => currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));
function useSubscribe(props) {
  const _props = React.useRef(props);
  _props.current = props;
  React.useEffect(() => {
    const subscription = !props.disabled && _props.current.subject && _props.current.subject.subscribe({
      next: _props.current.next
    });
    return () => {
      subscription && subscription.unsubscribe();
    };
  }, [props.disabled]);
}
function useFormState(props) {
  const methods = useFormContext();
  const { control = methods.control, disabled, name, exact } = props || {};
  const [formState, updateFormState] = React.useState(control._formState);
  const _mounted = React.useRef(true);
  const _localProxyFormState = React.useRef({
    isDirty: false,
    isLoading: false,
    dirtyFields: false,
    touchedFields: false,
    validatingFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  });
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    next: (value) => _mounted.current && shouldSubscribeByName(_name.current, value.name, exact) && shouldRenderFormState(value, _localProxyFormState.current, control._updateFormState) && updateFormState({
      ...control._formState,
      ...value
    }),
    subject: control._subjects.state
  });
  React.useEffect(() => {
    _mounted.current = true;
    _localProxyFormState.current.isValid && control._updateValid(true);
    return () => {
      _mounted.current = false;
    };
  }, [control]);
  return getProxyFormState(formState, control, _localProxyFormState.current, false);
}
var isString = (value) => typeof value === "string";
var generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue) => {
  if (isString(names)) {
    isGlobal && _names.watch.add(names);
    return get(formValues, names, defaultValue);
  }
  if (Array.isArray(names)) {
    return names.map((fieldName) => (isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));
  }
  isGlobal && (_names.watchAll = true);
  return formValues;
};
function useWatch(props) {
  const methods = useFormContext();
  const { control = methods.control, name, defaultValue, disabled, exact } = props || {};
  const _name = React.useRef(name);
  _name.current = name;
  useSubscribe({
    disabled,
    subject: control._subjects.values,
    next: (formState) => {
      if (shouldSubscribeByName(_name.current, formState.name, exact)) {
        updateValue(cloneObject(generateWatchOutput(_name.current, control._names, formState.values || control._formValues, false, defaultValue)));
      }
    }
  });
  const [value, updateValue] = React.useState(control._getWatch(name, defaultValue));
  React.useEffect(() => control._removeUnmounted());
  return value;
}
function useController(props) {
  const methods = useFormContext();
  const { name, disabled, control = methods.control, shouldUnregister } = props;
  const isArrayField = isNameInFieldArray(control._names.array, name);
  const value = useWatch({
    control,
    name,
    defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),
    exact: true
  });
  const formState = useFormState({
    control,
    name,
    exact: true
  });
  const _registerProps = React.useRef(control.register(name, {
    ...props.rules,
    value,
    ...isBoolean(props.disabled) ? { disabled: props.disabled } : {}
  }));
  React.useEffect(() => {
    const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;
    const updateMounted = (name2, value2) => {
      const field = get(control._fields, name2);
      if (field && field._f) {
        field._f.mount = value2;
      }
    };
    updateMounted(name, true);
    if (_shouldUnregisterField) {
      const value2 = cloneObject(get(control._options.defaultValues, name));
      set(control._defaultValues, name, value2);
      if (isUndefined(get(control._formValues, name))) {
        set(control._formValues, name, value2);
      }
    }
    return () => {
      (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);
    };
  }, [name, control, isArrayField, shouldUnregister]);
  React.useEffect(() => {
    if (get(control._fields, name)) {
      control._updateDisabledField({
        disabled,
        fields: control._fields,
        name,
        value: get(control._fields, name)._f.value
      });
    }
  }, [disabled, name, control]);
  return {
    field: {
      name,
      value,
      ...isBoolean(disabled) || formState.disabled ? { disabled: formState.disabled || disabled } : {},
      onChange: React.useCallback((event) => _registerProps.current.onChange({
        target: {
          value: getEventValue(event),
          name
        },
        type: EVENTS.CHANGE
      }), [name]),
      onBlur: React.useCallback(() => _registerProps.current.onBlur({
        target: {
          value: get(control._formValues, name),
          name
        },
        type: EVENTS.BLUR
      }), [name, control]),
      ref: React.useCallback((elm) => {
        const field = get(control._fields, name);
        if (field && elm) {
          field._f.ref = {
            focus: () => elm.focus(),
            select: () => elm.select(),
            setCustomValidity: (message) => elm.setCustomValidity(message),
            reportValidity: () => elm.reportValidity()
          };
        }
      }, [control._fields, name])
    },
    formState,
    fieldState: Object.defineProperties({}, {
      invalid: {
        enumerable: true,
        get: () => !!get(formState.errors, name)
      },
      isDirty: {
        enumerable: true,
        get: () => !!get(formState.dirtyFields, name)
      },
      isTouched: {
        enumerable: true,
        get: () => !!get(formState.touchedFields, name)
      },
      isValidating: {
        enumerable: true,
        get: () => !!get(formState.validatingFields, name)
      },
      error: {
        enumerable: true,
        get: () => get(formState.errors, name)
      }
    })
  };
}
const Controller = (props) => props.render(useController(props));
var appendErrors = (name, validateAllFieldCriteria, errors, type, message) => validateAllFieldCriteria ? {
  ...errors[name],
  types: {
    ...errors[name] && errors[name].types ? errors[name].types : {},
    [type]: message || true
  }
} : {};
var generateId = () => {
  const d2 = typeof performance === "undefined" ? Date.now() : performance.now() * 1e3;
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c2) => {
    const r2 = (Math.random() * 16 + d2) % 16 | 0;
    return (c2 == "x" ? r2 : r2 & 3 | 8).toString(16);
  });
};
var getFocusFieldName = (name, index2, options = {}) => options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || `${name}.${isUndefined(options.focusIndex) ? index2 : options.focusIndex}.` : "";
var getValidationModes = (mode) => ({
  isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,
  isOnBlur: mode === VALIDATION_MODE.onBlur,
  isOnChange: mode === VALIDATION_MODE.onChange,
  isOnAll: mode === VALIDATION_MODE.all,
  isOnTouch: mode === VALIDATION_MODE.onTouched
});
var isWatched = (name, _names, isBlurEvent) => !isBlurEvent && (_names.watchAll || _names.watch.has(name) || [..._names.watch].some((watchName) => name.startsWith(watchName) && /^\.\w+/.test(name.slice(watchName.length))));
const iterateFieldsByAction = (fields, action, fieldsNames, abortEarly) => {
  for (const key of fieldsNames || Object.keys(fields)) {
    const field = get(fields, key);
    if (field) {
      const { _f, ...currentField } = field;
      if (_f) {
        if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {
          return true;
        } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {
          return true;
        } else {
          if (iterateFieldsByAction(currentField, action)) {
            break;
          }
        }
      } else if (isObject(currentField)) {
        if (iterateFieldsByAction(currentField, action)) {
          break;
        }
      }
    }
  }
  return;
};
var updateFieldArrayRootError = (errors, error, name) => {
  const fieldArrayErrors = convertToArrayPayload(get(errors, name));
  set(fieldArrayErrors, "root", error[name]);
  set(errors, name, fieldArrayErrors);
  return errors;
};
var isFileInput = (element) => element.type === "file";
var isFunction = (value) => typeof value === "function";
var isHTMLElement = (value) => {
  if (!isWeb) {
    return false;
  }
  const owner = value ? value.ownerDocument : 0;
  return value instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);
};
var isMessage = (value) => isString(value);
var isRadioInput = (element) => element.type === "radio";
var isRegex = (value) => value instanceof RegExp;
const defaultResult = {
  value: false,
  isValid: false
};
const validResult = { value: true, isValid: true };
var getCheckboxValue = (options) => {
  if (Array.isArray(options)) {
    if (options.length > 1) {
      const values = options.filter((option) => option && option.checked && !option.disabled).map((option) => option.value);
      return { value: values, isValid: !!values.length };
    }
    return options[0].checked && !options[0].disabled ? (
      // @ts-expect-error expected to work in the browser
      options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === "" ? validResult : { value: options[0].value, isValid: true } : validResult
    ) : defaultResult;
  }
  return defaultResult;
};
const defaultReturn = {
  isValid: false,
  value: null
};
var getRadioValue = (options) => Array.isArray(options) ? options.reduce((previous, option) => option && option.checked && !option.disabled ? {
  isValid: true,
  value: option.value
} : previous, defaultReturn) : defaultReturn;
function getValidateError(result, ref, type = "validate") {
  if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {
    return {
      type,
      message: isMessage(result) ? result : "",
      ref
    };
  }
}
var getValueAndMessage = (validationData) => isObject(validationData) && !isRegex(validationData) ? validationData : {
  value: validationData,
  message: ""
};
var validateField = async (field, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray) => {
  const { ref, refs, required, maxLength, minLength, min: min2, max: max2, pattern, validate, name, valueAsNumber, mount, disabled } = field._f;
  const inputValue = get(formValues, name);
  if (!mount || disabled) {
    return {};
  }
  const inputRef = refs ? refs[0] : ref;
  const setCustomValidity = (message) => {
    if (shouldUseNativeValidation && inputRef.reportValidity) {
      inputRef.setCustomValidity(isBoolean(message) ? "" : message || "");
      inputRef.reportValidity();
    }
  };
  const error = {};
  const isRadio = isRadioInput(ref);
  const isCheckBox = isCheckBoxInput(ref);
  const isRadioOrCheckbox2 = isRadio || isCheckBox;
  const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === "" || inputValue === "" || Array.isArray(inputValue) && !inputValue.length;
  const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);
  const getMinMaxMessage = (exceedMax, maxLengthMessage, minLengthMessage, maxType = INPUT_VALIDATION_RULES.maxLength, minType = INPUT_VALIDATION_RULES.minLength) => {
    const message = exceedMax ? maxLengthMessage : minLengthMessage;
    error[name] = {
      type: exceedMax ? maxType : minType,
      message,
      ref,
      ...appendErrorsCurry(exceedMax ? maxType : minType, message)
    };
  };
  if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox2 && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {
    const { value, message } = isMessage(required) ? { value: !!required, message: required } : getValueAndMessage(required);
    if (value) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.required,
        message,
        ref: inputRef,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (!isEmpty && (!isNullOrUndefined(min2) || !isNullOrUndefined(max2))) {
    let exceedMax;
    let exceedMin;
    const maxOutput = getValueAndMessage(max2);
    const minOutput = getValueAndMessage(min2);
    if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {
      const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);
      if (!isNullOrUndefined(maxOutput.value)) {
        exceedMax = valueNumber > maxOutput.value;
      }
      if (!isNullOrUndefined(minOutput.value)) {
        exceedMin = valueNumber < minOutput.value;
      }
    } else {
      const valueDate = ref.valueAsDate || new Date(inputValue);
      const convertTimeToDate = (time) => /* @__PURE__ */ new Date((/* @__PURE__ */ new Date()).toDateString() + " " + time);
      const isTime = ref.type == "time";
      const isWeek = ref.type == "week";
      if (isString(maxOutput.value) && inputValue) {
        exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);
      }
      if (isString(minOutput.value) && inputValue) {
        exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);
      }
    }
    if (exceedMax || exceedMin) {
      getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {
    const maxLengthOutput = getValueAndMessage(maxLength);
    const minLengthOutput = getValueAndMessage(minLength);
    const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;
    const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;
    if (exceedMax || exceedMin) {
      getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);
      if (!validateAllFieldCriteria) {
        setCustomValidity(error[name].message);
        return error;
      }
    }
  }
  if (pattern && !isEmpty && isString(inputValue)) {
    const { value: patternValue, message } = getValueAndMessage(pattern);
    if (isRegex(patternValue) && !inputValue.match(patternValue)) {
      error[name] = {
        type: INPUT_VALIDATION_RULES.pattern,
        message,
        ref,
        ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)
      };
      if (!validateAllFieldCriteria) {
        setCustomValidity(message);
        return error;
      }
    }
  }
  if (validate) {
    if (isFunction(validate)) {
      const result = await validate(inputValue, formValues);
      const validateError = getValidateError(result, inputRef);
      if (validateError) {
        error[name] = {
          ...validateError,
          ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)
        };
        if (!validateAllFieldCriteria) {
          setCustomValidity(validateError.message);
          return error;
        }
      }
    } else if (isObject(validate)) {
      let validationResult = {};
      for (const key in validate) {
        if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {
          break;
        }
        const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);
        if (validateError) {
          validationResult = {
            ...validateError,
            ...appendErrorsCurry(key, validateError.message)
          };
          setCustomValidity(validateError.message);
          if (validateAllFieldCriteria) {
            error[name] = validationResult;
          }
        }
      }
      if (!isEmptyObject(validationResult)) {
        error[name] = {
          ref: inputRef,
          ...validationResult
        };
        if (!validateAllFieldCriteria) {
          return error;
        }
      }
    }
  }
  setCustomValidity(true);
  return error;
};
var appendAt = (data, value) => [
  ...data,
  ...convertToArrayPayload(value)
];
var fillEmptyArray = (value) => Array.isArray(value) ? value.map(() => void 0) : void 0;
function insert(data, index2, value) {
  return [
    ...data.slice(0, index2),
    ...convertToArrayPayload(value),
    ...data.slice(index2)
  ];
}
var moveArrayAt = (data, from, to) => {
  if (!Array.isArray(data)) {
    return [];
  }
  if (isUndefined(data[to])) {
    data[to] = void 0;
  }
  data.splice(to, 0, data.splice(from, 1)[0]);
  return data;
};
var prependAt = (data, value) => [
  ...convertToArrayPayload(value),
  ...convertToArrayPayload(data)
];
function removeAtIndexes(data, indexes) {
  let i2 = 0;
  const temp = [...data];
  for (const index2 of indexes) {
    temp.splice(index2 - i2, 1);
    i2++;
  }
  return compact(temp).length ? temp : [];
}
var removeArrayAt = (data, index2) => isUndefined(index2) ? [] : removeAtIndexes(data, convertToArrayPayload(index2).sort((a2, b2) => a2 - b2));
var swapArrayAt = (data, indexA, indexB) => {
  [data[indexA], data[indexB]] = [data[indexB], data[indexA]];
};
function baseGet(object, updatePath) {
  const length = updatePath.slice(0, -1).length;
  let index2 = 0;
  while (index2 < length) {
    object = isUndefined(object) ? index2++ : object[updatePath[index2++]];
  }
  return object;
}
function isEmptyArray(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {
      return false;
    }
  }
  return true;
}
function unset(object, path2) {
  const paths = Array.isArray(path2) ? path2 : isKey(path2) ? [path2] : stringToPath(path2);
  const childObject = paths.length === 1 ? object : baseGet(object, paths);
  const index2 = paths.length - 1;
  const key = paths[index2];
  if (childObject) {
    delete childObject[key];
  }
  if (index2 !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {
    unset(object, paths.slice(0, -1));
  }
  return object;
}
var updateAt = (fieldValues, index2, value) => {
  fieldValues[index2] = value;
  return fieldValues;
};
function useFieldArray(props) {
  const methods = useFormContext();
  const { control = methods.control, name, keyName = "id", shouldUnregister } = props;
  const [fields, setFields] = React.useState(control._getFieldArray(name));
  const ids = React.useRef(control._getFieldArray(name).map(generateId));
  const _fieldIds = React.useRef(fields);
  const _name = React.useRef(name);
  const _actioned = React.useRef(false);
  _name.current = name;
  _fieldIds.current = fields;
  control._names.array.add(name);
  props.rules && control.register(name, props.rules);
  useSubscribe({
    next: ({ values, name: fieldArrayName }) => {
      if (fieldArrayName === _name.current || !fieldArrayName) {
        const fieldValues = get(values, _name.current);
        if (Array.isArray(fieldValues)) {
          setFields(fieldValues);
          ids.current = fieldValues.map(generateId);
        }
      }
    },
    subject: control._subjects.array
  });
  const updateValues = React.useCallback((updatedFieldArrayValues) => {
    _actioned.current = true;
    control._updateFieldArray(name, updatedFieldArrayValues);
  }, [control, name]);
  const append = (value, options) => {
    const appendValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);
    control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);
    ids.current = appendAt(ids.current, appendValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, appendAt, {
      argA: fillEmptyArray(value)
    });
  };
  const prepend = (value, options) => {
    const prependValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);
    control._names.focus = getFocusFieldName(name, 0, options);
    ids.current = prependAt(ids.current, prependValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, prependAt, {
      argA: fillEmptyArray(value)
    });
  };
  const remove = (index2) => {
    const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index2);
    ids.current = removeArrayAt(ids.current, index2);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, removeArrayAt, {
      argA: index2
    });
  };
  const insert$1 = (index2, value, options) => {
    const insertValue = convertToArrayPayload(cloneObject(value));
    const updatedFieldArrayValues = insert(control._getFieldArray(name), index2, insertValue);
    control._names.focus = getFocusFieldName(name, index2, options);
    ids.current = insert(ids.current, index2, insertValue.map(generateId));
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, insert, {
      argA: index2,
      argB: fillEmptyArray(value)
    });
  };
  const swap = (indexA, indexB) => {
    const updatedFieldArrayValues = control._getFieldArray(name);
    swapArrayAt(updatedFieldArrayValues, indexA, indexB);
    swapArrayAt(ids.current, indexA, indexB);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, swapArrayAt, {
      argA: indexA,
      argB: indexB
    }, false);
  };
  const move = (from, to) => {
    const updatedFieldArrayValues = control._getFieldArray(name);
    moveArrayAt(updatedFieldArrayValues, from, to);
    moveArrayAt(ids.current, from, to);
    updateValues(updatedFieldArrayValues);
    setFields(updatedFieldArrayValues);
    control._updateFieldArray(name, updatedFieldArrayValues, moveArrayAt, {
      argA: from,
      argB: to
    }, false);
  };
  const update = (index2, value) => {
    const updateValue = cloneObject(value);
    const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index2, updateValue);
    ids.current = [...updatedFieldArrayValues].map((item, i2) => !item || i2 === index2 ? generateId() : ids.current[i2]);
    updateValues(updatedFieldArrayValues);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(name, updatedFieldArrayValues, updateAt, {
      argA: index2,
      argB: updateValue
    }, true, false);
  };
  const replace = (value) => {
    const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value));
    ids.current = updatedFieldArrayValues.map(generateId);
    updateValues([...updatedFieldArrayValues]);
    setFields([...updatedFieldArrayValues]);
    control._updateFieldArray(name, [...updatedFieldArrayValues], (data) => data, {}, true, false);
  };
  React.useEffect(() => {
    control._state.action = false;
    isWatched(name, control._names) && control._subjects.state.next({
      ...control._formState
    });
    if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted)) {
      if (control._options.resolver) {
        control._executeSchema([name]).then((result) => {
          const error = get(result.errors, name);
          const existingError = get(control._formState.errors, name);
          if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {
            error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);
            control._subjects.state.next({
              errors: control._formState.errors
            });
          }
        });
      } else {
        const field = get(control._fields, name);
        if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {
          validateField(field, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error) => !isEmptyObject(error) && control._subjects.state.next({
            errors: updateFieldArrayRootError(control._formState.errors, error, name)
          }));
        }
      }
    }
    control._subjects.values.next({
      name,
      values: { ...control._formValues }
    });
    control._names.focus && iterateFieldsByAction(control._fields, (ref, key) => {
      if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {
        ref.focus();
        return 1;
      }
      return;
    });
    control._names.focus = "";
    control._updateValid();
    _actioned.current = false;
  }, [fields, name, control]);
  React.useEffect(() => {
    !get(control._formValues, name) && control._updateFieldArray(name);
    return () => {
      (control._options.shouldUnregister || shouldUnregister) && control.unregister(name);
    };
  }, [name, control, keyName, shouldUnregister]);
  return {
    swap: React.useCallback(swap, [updateValues, name, control]),
    move: React.useCallback(move, [updateValues, name, control]),
    prepend: React.useCallback(prepend, [updateValues, name, control]),
    append: React.useCallback(append, [updateValues, name, control]),
    remove: React.useCallback(remove, [updateValues, name, control]),
    insert: React.useCallback(insert$1, [updateValues, name, control]),
    update: React.useCallback(update, [updateValues, name, control]),
    replace: React.useCallback(replace, [updateValues, name, control]),
    fields: React.useMemo(() => fields.map((field, index2) => ({
      ...field,
      [keyName]: ids.current[index2] || generateId()
    })), [fields, keyName])
  };
}
var createSubject = () => {
  let _observers = [];
  const next = (value) => {
    for (const observer of _observers) {
      observer.next && observer.next(value);
    }
  };
  const subscribe = (observer) => {
    _observers.push(observer);
    return {
      unsubscribe: () => {
        _observers = _observers.filter((o2) => o2 !== observer);
      }
    };
  };
  const unsubscribe = () => {
    _observers = [];
  };
  return {
    get observers() {
      return _observers;
    },
    next,
    subscribe,
    unsubscribe
  };
};
var isPrimitive = (value) => isNullOrUndefined(value) || !isObjectType(value);
function deepEqual(object1, object2) {
  if (isPrimitive(object1) || isPrimitive(object2)) {
    return object1 === object2;
  }
  if (isDateObject(object1) && isDateObject(object2)) {
    return object1.getTime() === object2.getTime();
  }
  const keys1 = Object.keys(object1);
  const keys2 = Object.keys(object2);
  if (keys1.length !== keys2.length) {
    return false;
  }
  for (const key of keys1) {
    const val1 = object1[key];
    if (!keys2.includes(key)) {
      return false;
    }
    if (key !== "ref") {
      const val2 = object2[key];
      if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {
        return false;
      }
    }
  }
  return true;
}
var isMultipleSelect = (element) => element.type === `select-multiple`;
var isRadioOrCheckbox = (ref) => isRadioInput(ref) || isCheckBoxInput(ref);
var live = (ref) => isHTMLElement(ref) && ref.isConnected;
var objectHasFunction = (data) => {
  for (const key in data) {
    if (isFunction(data[key])) {
      return true;
    }
  }
  return false;
};
function markFieldsDirty(data, fields = {}) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        fields[key] = Array.isArray(data[key]) ? [] : {};
        markFieldsDirty(data[key], fields[key]);
      } else if (!isNullOrUndefined(data[key])) {
        fields[key] = true;
      }
    }
  }
  return fields;
}
function getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {
  const isParentNodeArray = Array.isArray(data);
  if (isObject(data) || isParentNodeArray) {
    for (const key in data) {
      if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {
        if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {
          dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : { ...markFieldsDirty(data[key]) };
        } else {
          getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);
        }
      } else {
        dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);
      }
    }
  }
  return dirtyFieldsFromValues;
}
var getDirtyFields = (defaultValues, formValues) => getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));
var getFieldValueAs = (value, { valueAsNumber, valueAsDate, setValueAs }) => isUndefined(value) ? value : valueAsNumber ? value === "" ? NaN : value ? +value : value : valueAsDate && isString(value) ? new Date(value) : setValueAs ? setValueAs(value) : value;
function getFieldValue(_f) {
  const ref = _f.ref;
  if (_f.refs ? _f.refs.every((ref2) => ref2.disabled) : ref.disabled) {
    return;
  }
  if (isFileInput(ref)) {
    return ref.files;
  }
  if (isRadioInput(ref)) {
    return getRadioValue(_f.refs).value;
  }
  if (isMultipleSelect(ref)) {
    return [...ref.selectedOptions].map(({ value }) => value);
  }
  if (isCheckBoxInput(ref)) {
    return getCheckboxValue(_f.refs).value;
  }
  return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);
}
var getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation) => {
  const fields = {};
  for (const name of fieldsNames) {
    const field = get(_fields, name);
    field && set(fields, name, field._f);
  }
  return {
    criteriaMode,
    names: [...fieldsNames],
    fields,
    shouldUseNativeValidation
  };
};
var getRuleValue = (rule) => isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;
const ASYNC_FUNCTION = "AsyncFunction";
var hasPromiseValidation = (fieldReference) => (!fieldReference || !fieldReference.validate) && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction) => validateFunction.constructor.name === ASYNC_FUNCTION));
var hasValidation = (options) => options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);
function schemaErrorLookup(errors, _fields, name) {
  const error = get(errors, name);
  if (error || isKey(name)) {
    return {
      error,
      name
    };
  }
  const names = name.split(".");
  while (names.length) {
    const fieldName = names.join(".");
    const field = get(_fields, fieldName);
    const foundError = get(errors, fieldName);
    if (field && !Array.isArray(field) && name !== fieldName) {
      return { name };
    }
    if (foundError && foundError.type) {
      return {
        name: fieldName,
        error: foundError
      };
    }
    names.pop();
  }
  return {
    name
  };
}
var skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode) => {
  if (mode.isOnAll) {
    return false;
  } else if (!isSubmitted && mode.isOnTouch) {
    return !(isTouched || isBlurEvent);
  } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {
    return !isBlurEvent;
  } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {
    return isBlurEvent;
  }
  return true;
};
var unsetEmptyArray = (ref, name) => !compact(get(ref, name)).length && unset(ref, name);
const defaultOptions = {
  mode: VALIDATION_MODE.onSubmit,
  reValidateMode: VALIDATION_MODE.onChange,
  shouldFocusError: true
};
function createFormControl(props = {}) {
  let _options = {
    ...defaultOptions,
    ...props
  };
  let _formState = {
    submitCount: 0,
    isDirty: false,
    isLoading: isFunction(_options.defaultValues),
    isValidating: false,
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    touchedFields: {},
    dirtyFields: {},
    validatingFields: {},
    errors: _options.errors || {},
    disabled: _options.disabled || false
  };
  let _fields = {};
  let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};
  let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);
  let _state = {
    action: false,
    mount: false,
    watch: false
  };
  let _names = {
    mount: /* @__PURE__ */ new Set(),
    unMount: /* @__PURE__ */ new Set(),
    array: /* @__PURE__ */ new Set(),
    watch: /* @__PURE__ */ new Set()
  };
  let delayErrorCallback;
  let timer = 0;
  const _proxyFormState = {
    isDirty: false,
    dirtyFields: false,
    validatingFields: false,
    touchedFields: false,
    isValidating: false,
    isValid: false,
    errors: false
  };
  const _subjects = {
    values: createSubject(),
    array: createSubject(),
    state: createSubject()
  };
  const validationModeBeforeSubmit = getValidationModes(_options.mode);
  const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);
  const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;
  const debounce = (callback) => (wait) => {
    clearTimeout(timer);
    timer = setTimeout(callback, wait);
  };
  const _updateValid = async (shouldUpdateValid) => {
    if (!props.disabled && (_proxyFormState.isValid || shouldUpdateValid)) {
      const isValid2 = _options.resolver ? isEmptyObject((await _executeSchema()).errors) : await executeBuiltInValidation(_fields, true);
      if (isValid2 !== _formState.isValid) {
        _subjects.state.next({
          isValid: isValid2
        });
      }
    }
  };
  const _updateIsValidating = (names, isValidating) => {
    if (!props.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields)) {
      (names || Array.from(_names.mount)).forEach((name) => {
        if (name) {
          isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);
        }
      });
      _subjects.state.next({
        validatingFields: _formState.validatingFields,
        isValidating: !isEmptyObject(_formState.validatingFields)
      });
    }
  };
  const _updateFieldArray = (name, values = [], method, args, shouldSetValues = true, shouldUpdateFieldsAndState = true) => {
    if (args && method && !props.disabled) {
      _state.action = true;
      if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {
        const fieldValues = method(get(_fields, name), args.argA, args.argB);
        shouldSetValues && set(_fields, name, fieldValues);
      }
      if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {
        const errors = method(get(_formState.errors, name), args.argA, args.argB);
        shouldSetValues && set(_formState.errors, name, errors);
        unsetEmptyArray(_formState.errors, name);
      }
      if (_proxyFormState.touchedFields && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {
        const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);
        shouldSetValues && set(_formState.touchedFields, name, touchedFields);
      }
      if (_proxyFormState.dirtyFields) {
        _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);
      }
      _subjects.state.next({
        name,
        isDirty: _getDirty(name, values),
        dirtyFields: _formState.dirtyFields,
        errors: _formState.errors,
        isValid: _formState.isValid
      });
    } else {
      set(_formValues, name, values);
    }
  };
  const updateErrors = (name, error) => {
    set(_formState.errors, name, error);
    _subjects.state.next({
      errors: _formState.errors
    });
  };
  const _setErrors = (errors) => {
    _formState.errors = errors;
    _subjects.state.next({
      errors: _formState.errors,
      isValid: false
    });
  };
  const updateValidAndValue = (name, shouldSkipSetValueAs, value, ref) => {
    const field = get(_fields, name);
    if (field) {
      const defaultValue = get(_formValues, name, isUndefined(value) ? get(_defaultValues, name) : value);
      isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);
      _state.mount && _updateValid();
    }
  };
  const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender) => {
    let shouldUpdateField = false;
    let isPreviousDirty = false;
    const output = {
      name
    };
    if (!props.disabled) {
      const disabledField = !!(get(_fields, name) && get(_fields, name)._f && get(_fields, name)._f.disabled);
      if (!isBlurEvent || shouldDirty) {
        if (_proxyFormState.isDirty) {
          isPreviousDirty = _formState.isDirty;
          _formState.isDirty = output.isDirty = _getDirty();
          shouldUpdateField = isPreviousDirty !== output.isDirty;
        }
        const isCurrentFieldPristine = disabledField || deepEqual(get(_defaultValues, name), fieldValue);
        isPreviousDirty = !!(!disabledField && get(_formState.dirtyFields, name));
        isCurrentFieldPristine || disabledField ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);
        output.dirtyFields = _formState.dirtyFields;
        shouldUpdateField = shouldUpdateField || _proxyFormState.dirtyFields && isPreviousDirty !== !isCurrentFieldPristine;
      }
      if (isBlurEvent) {
        const isPreviousFieldTouched = get(_formState.touchedFields, name);
        if (!isPreviousFieldTouched) {
          set(_formState.touchedFields, name, isBlurEvent);
          output.touchedFields = _formState.touchedFields;
          shouldUpdateField = shouldUpdateField || _proxyFormState.touchedFields && isPreviousFieldTouched !== isBlurEvent;
        }
      }
      shouldUpdateField && shouldRender && _subjects.state.next(output);
    }
    return shouldUpdateField ? output : {};
  };
  const shouldRenderByError = (name, isValid2, error, fieldState) => {
    const previousFieldError = get(_formState.errors, name);
    const shouldUpdateValid = _proxyFormState.isValid && isBoolean(isValid2) && _formState.isValid !== isValid2;
    if (props.delayError && error) {
      delayErrorCallback = debounce(() => updateErrors(name, error));
      delayErrorCallback(props.delayError);
    } else {
      clearTimeout(timer);
      delayErrorCallback = null;
      error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
    }
    if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {
      const updatedFormState = {
        ...fieldState,
        ...shouldUpdateValid && isBoolean(isValid2) ? { isValid: isValid2 } : {},
        errors: _formState.errors,
        name
      };
      _formState = {
        ..._formState,
        ...updatedFormState
      };
      _subjects.state.next(updatedFormState);
    }
  };
  const _executeSchema = async (name) => {
    _updateIsValidating(name, true);
    const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));
    _updateIsValidating(name);
    return result;
  };
  const executeSchemaAndUpdateState = async (names) => {
    const { errors } = await _executeSchema(names);
    if (names) {
      for (const name of names) {
        const error = get(errors, name);
        error ? set(_formState.errors, name, error) : unset(_formState.errors, name);
      }
    } else {
      _formState.errors = errors;
    }
    return errors;
  };
  const executeBuiltInValidation = async (fields, shouldOnlyCheckValid, context = {
    valid: true
  }) => {
    for (const name in fields) {
      const field = fields[name];
      if (field) {
        const { _f, ...fieldValue } = field;
        if (_f) {
          const isFieldArrayRoot = _names.array.has(_f.name);
          const isPromiseFunction = field._f && hasPromiseValidation(field._f);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name], true);
          }
          const fieldError = await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);
          if (isPromiseFunction && _proxyFormState.validatingFields) {
            _updateIsValidating([name]);
          }
          if (fieldError[_f.name]) {
            context.valid = false;
            if (shouldOnlyCheckValid) {
              break;
            }
          }
          !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));
        }
        !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);
      }
    }
    return context.valid;
  };
  const _removeUnmounted = () => {
    for (const name of _names.unMount) {
      const field = get(_fields, name);
      field && (field._f.refs ? field._f.refs.every((ref) => !live(ref)) : !live(field._f.ref)) && unregister(name);
    }
    _names.unMount = /* @__PURE__ */ new Set();
  };
  const _getDirty = (name, data) => !props.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));
  const _getWatch = (names, defaultValue, isGlobal) => generateWatchOutput(names, _names, {
    ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? { [names]: defaultValue } : defaultValue
  }, isGlobal, defaultValue);
  const _getFieldArray = (name) => compact(get(_state.mount ? _formValues : _defaultValues, name, props.shouldUnregister ? get(_defaultValues, name, []) : []));
  const setFieldValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    let fieldValue = value;
    if (field) {
      const fieldReference = field._f;
      if (fieldReference) {
        !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value, fieldReference));
        fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value) ? "" : value;
        if (isMultipleSelect(fieldReference.ref)) {
          [...fieldReference.ref.options].forEach((optionRef) => optionRef.selected = fieldValue.includes(optionRef.value));
        } else if (fieldReference.refs) {
          if (isCheckBoxInput(fieldReference.ref)) {
            fieldReference.refs.length > 1 ? fieldReference.refs.forEach((checkboxRef) => (!checkboxRef.defaultChecked || !checkboxRef.disabled) && (checkboxRef.checked = Array.isArray(fieldValue) ? !!fieldValue.find((data) => data === checkboxRef.value) : fieldValue === checkboxRef.value)) : fieldReference.refs[0] && (fieldReference.refs[0].checked = !!fieldValue);
          } else {
            fieldReference.refs.forEach((radioRef) => radioRef.checked = radioRef.value === fieldValue);
          }
        } else if (isFileInput(fieldReference.ref)) {
          fieldReference.ref.value = "";
        } else {
          fieldReference.ref.value = fieldValue;
          if (!fieldReference.ref.type) {
            _subjects.values.next({
              name,
              values: { ..._formValues }
            });
          }
        }
      }
    }
    (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);
    options.shouldValidate && trigger(name);
  };
  const setValues = (name, value, options) => {
    for (const fieldKey in value) {
      const fieldValue = value[fieldKey];
      const fieldName = `${name}.${fieldKey}`;
      const field = get(_fields, fieldName);
      (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);
    }
  };
  const setValue = (name, value, options = {}) => {
    const field = get(_fields, name);
    const isFieldArray = _names.array.has(name);
    const cloneValue = cloneObject(value);
    set(_formValues, name, cloneValue);
    if (isFieldArray) {
      _subjects.array.next({
        name,
        values: { ..._formValues }
      });
      if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields) && options.shouldDirty) {
        _subjects.state.next({
          name,
          dirtyFields: getDirtyFields(_defaultValues, _formValues),
          isDirty: _getDirty(name, cloneValue)
        });
      }
    } else {
      field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);
    }
    isWatched(name, _names) && _subjects.state.next({ ..._formState });
    _subjects.values.next({
      name: _state.mount ? name : void 0,
      values: { ..._formValues }
    });
  };
  const onChange = async (event) => {
    _state.mount = true;
    const target = event.target;
    let name = target.name;
    let isFieldValueUpdated = true;
    const field = get(_fields, name);
    const getCurrentFieldValue = () => target.type ? getFieldValue(field._f) : getEventValue(event);
    const _updateIsFieldValueUpdated = (fieldValue) => {
      isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));
    };
    if (field) {
      let error;
      let isValid2;
      const fieldValue = getCurrentFieldValue();
      const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;
      const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);
      const watched = isWatched(name, _names, isBlurEvent);
      set(_formValues, name, fieldValue);
      if (isBlurEvent) {
        field._f.onBlur && field._f.onBlur(event);
        delayErrorCallback && delayErrorCallback(0);
      } else if (field._f.onChange) {
        field._f.onChange(event);
      }
      const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent, false);
      const shouldRender = !isEmptyObject(fieldState) || watched;
      !isBlurEvent && _subjects.values.next({
        name,
        type: event.type,
        values: { ..._formValues }
      });
      if (shouldSkipValidation) {
        if (_proxyFormState.isValid) {
          if (props.mode === "onBlur") {
            if (isBlurEvent) {
              _updateValid();
            }
          } else {
            _updateValid();
          }
        }
        return shouldRender && _subjects.state.next({ name, ...watched ? {} : fieldState });
      }
      !isBlurEvent && watched && _subjects.state.next({ ..._formState });
      if (_options.resolver) {
        const { errors } = await _executeSchema([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);
          const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);
          error = errorLookupResult.error;
          name = errorLookupResult.name;
          isValid2 = isEmptyObject(errors);
        }
      } else {
        _updateIsValidating([name], true);
        error = (await validateField(field, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];
        _updateIsValidating([name]);
        _updateIsFieldValueUpdated(fieldValue);
        if (isFieldValueUpdated) {
          if (error) {
            isValid2 = false;
          } else if (_proxyFormState.isValid) {
            isValid2 = await executeBuiltInValidation(_fields, true);
          }
        }
      }
      if (isFieldValueUpdated) {
        field._f.deps && trigger(field._f.deps);
        shouldRenderByError(name, isValid2, error, fieldState);
      }
    }
  };
  const _focusInput = (ref, key) => {
    if (get(_formState.errors, key) && ref.focus) {
      ref.focus();
      return 1;
    }
    return;
  };
  const trigger = async (name, options = {}) => {
    let isValid2;
    let validationResult;
    const fieldNames = convertToArrayPayload(name);
    if (_options.resolver) {
      const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);
      isValid2 = isEmptyObject(errors);
      validationResult = name ? !fieldNames.some((name2) => get(errors, name2)) : isValid2;
    } else if (name) {
      validationResult = (await Promise.all(fieldNames.map(async (fieldName) => {
        const field = get(_fields, fieldName);
        return await executeBuiltInValidation(field && field._f ? { [fieldName]: field } : field);
      }))).every(Boolean);
      !(!validationResult && !_formState.isValid) && _updateValid();
    } else {
      validationResult = isValid2 = await executeBuiltInValidation(_fields);
    }
    _subjects.state.next({
      ...!isString(name) || _proxyFormState.isValid && isValid2 !== _formState.isValid ? {} : { name },
      ..._options.resolver || !name ? { isValid: isValid2 } : {},
      errors: _formState.errors
    });
    options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);
    return validationResult;
  };
  const getValues = (fieldNames) => {
    const values = {
      ..._state.mount ? _formValues : _defaultValues
    };
    return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name) => get(values, name));
  };
  const getFieldState = (name, formState) => ({
    invalid: !!get((formState || _formState).errors, name),
    isDirty: !!get((formState || _formState).dirtyFields, name),
    error: get((formState || _formState).errors, name),
    isValidating: !!get(_formState.validatingFields, name),
    isTouched: !!get((formState || _formState).touchedFields, name)
  });
  const clearErrors = (name) => {
    name && convertToArrayPayload(name).forEach((inputName) => unset(_formState.errors, inputName));
    _subjects.state.next({
      errors: name ? _formState.errors : {}
    });
  };
  const setError = (name, error, options) => {
    const ref = (get(_fields, name, { _f: {} })._f || {}).ref;
    const currentError = get(_formState.errors, name) || {};
    const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;
    set(_formState.errors, name, {
      ...restOfErrorTree,
      ...error,
      ref
    });
    _subjects.state.next({
      name,
      errors: _formState.errors,
      isValid: false
    });
    options && options.shouldFocus && ref && ref.focus && ref.focus();
  };
  const watch = (name, defaultValue) => isFunction(name) ? _subjects.values.subscribe({
    next: (payload) => name(_getWatch(void 0, defaultValue), payload)
  }) : _getWatch(name, defaultValue, true);
  const unregister = (name, options = {}) => {
    for (const fieldName of name ? convertToArrayPayload(name) : _names.mount) {
      _names.mount.delete(fieldName);
      _names.array.delete(fieldName);
      if (!options.keepValue) {
        unset(_fields, fieldName);
        unset(_formValues, fieldName);
      }
      !options.keepError && unset(_formState.errors, fieldName);
      !options.keepDirty && unset(_formState.dirtyFields, fieldName);
      !options.keepTouched && unset(_formState.touchedFields, fieldName);
      !options.keepIsValidating && unset(_formState.validatingFields, fieldName);
      !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);
    }
    _subjects.values.next({
      values: { ..._formValues }
    });
    _subjects.state.next({
      ..._formState,
      ...!options.keepDirty ? {} : { isDirty: _getDirty() }
    });
    !options.keepIsValid && _updateValid();
  };
  const _updateDisabledField = ({ disabled, name, field, fields, value }) => {
    if (isBoolean(disabled) && _state.mount || !!disabled) {
      const inputValue = disabled ? void 0 : isUndefined(value) ? getFieldValue(field ? field._f : get(fields, name)._f) : value;
      set(_formValues, name, inputValue);
      updateTouchAndDirty(name, inputValue, false, false, true);
    }
  };
  const register = (name, options = {}) => {
    let field = get(_fields, name);
    const disabledIsDefined = isBoolean(options.disabled) || isBoolean(props.disabled);
    set(_fields, name, {
      ...field || {},
      _f: {
        ...field && field._f ? field._f : { ref: { name } },
        name,
        mount: true,
        ...options
      }
    });
    _names.mount.add(name);
    if (field) {
      _updateDisabledField({
        field,
        disabled: isBoolean(options.disabled) ? options.disabled : props.disabled,
        name,
        value: options.value
      });
    } else {
      updateValidAndValue(name, true, options.value);
    }
    return {
      ...disabledIsDefined ? { disabled: options.disabled || props.disabled } : {},
      ..._options.progressive ? {
        required: !!options.required,
        min: getRuleValue(options.min),
        max: getRuleValue(options.max),
        minLength: getRuleValue(options.minLength),
        maxLength: getRuleValue(options.maxLength),
        pattern: getRuleValue(options.pattern)
      } : {},
      name,
      onChange,
      onBlur: onChange,
      ref: (ref) => {
        if (ref) {
          register(name, options);
          field = get(_fields, name);
          const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll("input,select,textarea")[0] || ref : ref : ref;
          const radioOrCheckbox = isRadioOrCheckbox(fieldRef);
          const refs = field._f.refs || [];
          if (radioOrCheckbox ? refs.find((option) => option === fieldRef) : fieldRef === field._f.ref) {
            return;
          }
          set(_fields, name, {
            _f: {
              ...field._f,
              ...radioOrCheckbox ? {
                refs: [
                  ...refs.filter(live),
                  fieldRef,
                  ...Array.isArray(get(_defaultValues, name)) ? [{}] : []
                ],
                ref: { type: fieldRef.type, name }
              } : { ref: fieldRef }
            }
          });
          updateValidAndValue(name, false, void 0, fieldRef);
        } else {
          field = get(_fields, name, {});
          if (field._f) {
            field._f.mount = false;
          }
          (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);
        }
      }
    };
  };
  const _focusError = () => _options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);
  const _disableForm = (disabled) => {
    if (isBoolean(disabled)) {
      _subjects.state.next({ disabled });
      iterateFieldsByAction(_fields, (ref, name) => {
        const currentField = get(_fields, name);
        if (currentField) {
          ref.disabled = currentField._f.disabled || disabled;
          if (Array.isArray(currentField._f.refs)) {
            currentField._f.refs.forEach((inputRef) => {
              inputRef.disabled = currentField._f.disabled || disabled;
            });
          }
        }
      }, 0, false);
    }
  };
  const handleSubmit = (onValid, onInvalid) => async (e2) => {
    let onValidError = void 0;
    if (e2) {
      e2.preventDefault && e2.preventDefault();
      e2.persist && e2.persist();
    }
    let fieldValues = cloneObject(_formValues);
    _subjects.state.next({
      isSubmitting: true
    });
    if (_options.resolver) {
      const { errors, values } = await _executeSchema();
      _formState.errors = errors;
      fieldValues = values;
    } else {
      await executeBuiltInValidation(_fields);
    }
    unset(_formState.errors, "root");
    if (isEmptyObject(_formState.errors)) {
      _subjects.state.next({
        errors: {}
      });
      try {
        await onValid(fieldValues, e2);
      } catch (error) {
        onValidError = error;
      }
    } else {
      if (onInvalid) {
        await onInvalid({ ..._formState.errors }, e2);
      }
      _focusError();
      setTimeout(_focusError);
    }
    _subjects.state.next({
      isSubmitted: true,
      isSubmitting: false,
      isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,
      submitCount: _formState.submitCount + 1,
      errors: _formState.errors
    });
    if (onValidError) {
      throw onValidError;
    }
  };
  const resetField = (name, options = {}) => {
    if (get(_fields, name)) {
      if (isUndefined(options.defaultValue)) {
        setValue(name, cloneObject(get(_defaultValues, name)));
      } else {
        setValue(name, options.defaultValue);
        set(_defaultValues, name, cloneObject(options.defaultValue));
      }
      if (!options.keepTouched) {
        unset(_formState.touchedFields, name);
      }
      if (!options.keepDirty) {
        unset(_formState.dirtyFields, name);
        _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();
      }
      if (!options.keepError) {
        unset(_formState.errors, name);
        _proxyFormState.isValid && _updateValid();
      }
      _subjects.state.next({ ..._formState });
    }
  };
  const _reset = (formValues, keepStateOptions = {}) => {
    const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;
    const cloneUpdatedValues = cloneObject(updatedValues);
    const isEmptyResetValues = isEmptyObject(formValues);
    const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;
    if (!keepStateOptions.keepDefaultValues) {
      _defaultValues = updatedValues;
    }
    if (!keepStateOptions.keepValues) {
      if (keepStateOptions.keepDirtyValues) {
        const fieldsToCheck = /* @__PURE__ */ new Set([
          ..._names.mount,
          ...Object.keys(getDirtyFields(_defaultValues, _formValues))
        ]);
        for (const fieldName of Array.from(fieldsToCheck)) {
          get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));
        }
      } else {
        if (isWeb && isUndefined(formValues)) {
          for (const name of _names.mount) {
            const field = get(_fields, name);
            if (field && field._f) {
              const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;
              if (isHTMLElement(fieldReference)) {
                const form = fieldReference.closest("form");
                if (form) {
                  form.reset();
                  break;
                }
              }
            }
          }
        }
        _fields = {};
      }
      _formValues = props.shouldUnregister ? keepStateOptions.keepDefaultValues ? cloneObject(_defaultValues) : {} : cloneObject(values);
      _subjects.array.next({
        values: { ...values }
      });
      _subjects.values.next({
        values: { ...values }
      });
    }
    _names = {
      mount: keepStateOptions.keepDirtyValues ? _names.mount : /* @__PURE__ */ new Set(),
      unMount: /* @__PURE__ */ new Set(),
      array: /* @__PURE__ */ new Set(),
      watch: /* @__PURE__ */ new Set(),
      watchAll: false,
      focus: ""
    };
    _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;
    _state.watch = !!props.shouldUnregister;
    _subjects.state.next({
      submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,
      isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),
      isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,
      dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},
      touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},
      errors: keepStateOptions.keepErrors ? _formState.errors : {},
      isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,
      isSubmitting: false
    });
  };
  const reset = (formValues, keepStateOptions) => _reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);
  const setFocus = (name, options = {}) => {
    const field = get(_fields, name);
    const fieldReference = field && field._f;
    if (fieldReference) {
      const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;
      if (fieldRef.focus) {
        fieldRef.focus();
        options.shouldSelect && fieldRef.select();
      }
    }
  };
  const _updateFormState = (updatedFormState) => {
    _formState = {
      ..._formState,
      ...updatedFormState
    };
  };
  const _resetDefaultValues = () => isFunction(_options.defaultValues) && _options.defaultValues().then((values) => {
    reset(values, _options.resetOptions);
    _subjects.state.next({
      isLoading: false
    });
  });
  return {
    control: {
      register,
      unregister,
      getFieldState,
      handleSubmit,
      setError,
      _executeSchema,
      _getWatch,
      _getDirty,
      _updateValid,
      _removeUnmounted,
      _updateFieldArray,
      _updateDisabledField,
      _getFieldArray,
      _reset,
      _resetDefaultValues,
      _updateFormState,
      _disableForm,
      _subjects,
      _proxyFormState,
      _setErrors,
      get _fields() {
        return _fields;
      },
      get _formValues() {
        return _formValues;
      },
      get _state() {
        return _state;
      },
      set _state(value) {
        _state = value;
      },
      get _defaultValues() {
        return _defaultValues;
      },
      get _names() {
        return _names;
      },
      set _names(value) {
        _names = value;
      },
      get _formState() {
        return _formState;
      },
      set _formState(value) {
        _formState = value;
      },
      get _options() {
        return _options;
      },
      set _options(value) {
        _options = {
          ..._options,
          ...value
        };
      }
    },
    trigger,
    register,
    handleSubmit,
    watch,
    setValue,
    getValues,
    reset,
    resetField,
    clearErrors,
    unregister,
    setError,
    setFocus,
    getFieldState
  };
}
function useForm(props = {}) {
  const _formControl = React.useRef();
  const _values = React.useRef();
  const [formState, updateFormState] = React.useState({
    isDirty: false,
    isValidating: false,
    isLoading: isFunction(props.defaultValues),
    isSubmitted: false,
    isSubmitting: false,
    isSubmitSuccessful: false,
    isValid: false,
    submitCount: 0,
    dirtyFields: {},
    touchedFields: {},
    validatingFields: {},
    errors: props.errors || {},
    disabled: props.disabled || false,
    defaultValues: isFunction(props.defaultValues) ? void 0 : props.defaultValues
  });
  if (!_formControl.current) {
    _formControl.current = {
      ...createFormControl(props),
      formState
    };
  }
  const control = _formControl.current.control;
  control._options = props;
  useSubscribe({
    subject: control._subjects.state,
    next: (value) => {
      if (shouldRenderFormState(value, control._proxyFormState, control._updateFormState, true)) {
        updateFormState({ ...control._formState });
      }
    }
  });
  React.useEffect(() => control._disableForm(props.disabled), [control, props.disabled]);
  React.useEffect(() => {
    if (control._proxyFormState.isDirty) {
      const isDirty2 = control._getDirty();
      if (isDirty2 !== formState.isDirty) {
        control._subjects.state.next({
          isDirty: isDirty2
        });
      }
    }
  }, [control, formState.isDirty]);
  React.useEffect(() => {
    if (props.values && !deepEqual(props.values, _values.current)) {
      control._reset(props.values, control._options.resetOptions);
      _values.current = props.values;
      updateFormState((state) => ({ ...state }));
    } else {
      control._resetDefaultValues();
    }
  }, [props.values, control]);
  React.useEffect(() => {
    if (props.errors) {
      control._setErrors(props.errors);
    }
  }, [props.errors, control]);
  React.useEffect(() => {
    if (!control._state.mount) {
      control._updateValid();
      control._state.mount = true;
    }
    if (control._state.watch) {
      control._state.watch = false;
      control._subjects.state.next({ ...control._formState });
    }
    control._removeUnmounted();
  });
  React.useEffect(() => {
    props.shouldUnregister && control._subjects.values.next({
      values: control._getWatch()
    });
  }, [props.shouldUnregister, control]);
  React.useEffect(() => {
    if (_formControl.current) {
      _formControl.current.watch = _formControl.current.watch.bind({});
    }
  }, [formState]);
  _formControl.current.formState = getProxyFormState(formState, control);
  return _formControl.current;
}
const Form = FormProvider;
const FormFieldContext = reactExports.createContext(
  {}
);
const FormField = ({
  ...props
}) => {
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormFieldContext.Provider, { value: { name: props.name }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Controller, { ...props }) });
};
const useFormField = () => {
  const fieldContext = reactExports.useContext(FormFieldContext);
  const itemContext = reactExports.useContext(FormItemContext);
  const { getFieldState, formState } = useFormContext();
  const fieldState = getFieldState(fieldContext.name, formState);
  if (!fieldContext) {
    throw new Error("useFormField should be used within <FormField>");
  }
  const { id: id2 } = itemContext;
  return {
    id: id2,
    name: fieldContext.name,
    formItemId: `${id2}-form-item`,
    formDescriptionId: `${id2}-form-item-description`,
    formMessageId: `${id2}-form-item-message`,
    ...fieldState
  };
};
const FormItemContext = reactExports.createContext(
  {}
);
const FormItem = reactExports.forwardRef(({ className, ...props }, ref) => {
  const id2 = reactExports.useId();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(FormItemContext.Provider, { value: { id: id2 }, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { ref, className: cn("space-y-2", className), ...props }) });
});
FormItem.displayName = "FormItem";
const FormLabel = reactExports.forwardRef(({ className, ...props }, ref) => {
  const { error, formItemId } = useFormField();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Label,
    {
      ref,
      className: cn(error && "text-destructive", className),
      htmlFor: formItemId,
      ...props
    }
  );
});
FormLabel.displayName = "FormLabel";
const FormControl = reactExports.forwardRef(({ ...props }, ref) => {
  const { error, formItemId, formDescriptionId, formMessageId } = useFormField();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    Slot,
    {
      ref,
      id: formItemId,
      "aria-describedby": !error ? `${formDescriptionId}` : `${formDescriptionId} ${formMessageId}`,
      "aria-invalid": !!error,
      ...props
    }
  );
});
FormControl.displayName = "FormControl";
const FormDescription = reactExports.forwardRef(({ className, ...props }, ref) => {
  const { formDescriptionId } = useFormField();
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "p",
    {
      ref,
      id: formDescriptionId,
      className: cn("text-[0.8rem] text-muted-foreground", className),
      ...props
    }
  );
});
FormDescription.displayName = "FormDescription";
const FormMessage = reactExports.forwardRef(({ className, children, ...props }, ref) => {
  const { error, formMessageId } = useFormField();
  const body = error ? String(error?.message || error?.root?.message || "") : children;
  if (!body) {
    return null;
  }
  return /* @__PURE__ */ jsxRuntimeExports.jsx(
    "p",
    {
      ref,
      id: formMessageId,
      className: cn("text-[0.8rem] font-medium text-destructive", className),
      ...props,
      children: body
    }
  );
});
FormMessage.displayName = "FormMessage";
const Input = reactExports.forwardRef(
  ({ className, type, ...props }, ref) => {
    return /* @__PURE__ */ jsxRuntimeExports.jsx(
      "input",
      {
        type,
        className: cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        ),
        ref,
        ...props
      }
    );
  }
);
Input.displayName = "Input";
const s = (e2, s2, o2) => {
  if (e2 && "reportValidity" in e2) {
    const r2 = get(o2, s2);
    e2.setCustomValidity(r2 && r2.message || ""), e2.reportValidity();
  }
}, o = (t2, e2) => {
  for (const o2 in e2.fields) {
    const r2 = e2.fields[o2];
    r2 && r2.ref && "reportValidity" in r2.ref ? s(r2.ref, o2, t2) : r2.refs && r2.refs.forEach((e3) => s(e3, o2, t2));
  }
}, r = (s2, r2) => {
  r2.shouldUseNativeValidation && o(s2, r2);
  const f2 = {};
  for (const o2 in s2) {
    const n2 = get(r2.fields, o2), a2 = Object.assign(s2[o2] || {}, { ref: n2 && n2.ref });
    if (i(r2.names || Object.keys(s2), o2)) {
      const s3 = Object.assign({}, get(f2, o2));
      set(s3, "root", a2), set(f2, o2, s3);
    } else set(f2, o2, a2);
  }
  return f2;
}, i = (t2, e2) => t2.some((t3) => t3.startsWith(e2 + "."));
var n = function(r2, e2) {
  for (var n2 = {}; r2.length; ) {
    var t2 = r2[0], s2 = t2.code, i2 = t2.message, a2 = t2.path.join(".");
    if (!n2[a2]) if ("unionErrors" in t2) {
      var u2 = t2.unionErrors[0].errors[0];
      n2[a2] = { message: u2.message, type: u2.code };
    } else n2[a2] = { message: i2, type: s2 };
    if ("unionErrors" in t2 && t2.unionErrors.forEach(function(e3) {
      return e3.errors.forEach(function(e4) {
        return r2.push(e4);
      });
    }), e2) {
      var c2 = n2[a2].types, f2 = c2 && c2[t2.code];
      n2[a2] = appendErrors(a2, e2, n2, s2, f2 ? [].concat(f2, t2.message) : t2.message);
    }
    r2.shift();
  }
  return n2;
}, t = function(o$12, t2, s2) {
  return void 0 === s2 && (s2 = {}), function(i2, a2, u2) {
    try {
      return Promise.resolve(function(e2, n2) {
        try {
          var a3 = Promise.resolve(o$12["sync" === s2.mode ? "parse" : "parseAsync"](i2, t2)).then(function(e3) {
            return u2.shouldUseNativeValidation && o({}, u2), { errors: {}, values: s2.raw ? i2 : e3 };
          });
        } catch (r2) {
          return n2(r2);
        }
        return a3 && a3.then ? a3.then(void 0, n2) : a3;
      }(0, function(r$12) {
        if (function(r2) {
          return Array.isArray(null == r2 ? void 0 : r2.errors);
        }(r$12)) return { values: {}, errors: r(n(r$12.errors, !u2.shouldUseNativeValidation && "all" === u2.criteriaMode), u2) };
        throw r$12;
      }));
    } catch (r2) {
      return Promise.reject(r2);
    }
  };
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k2) => typeof obj[obj[k2]] !== "number");
    const filtered = {};
    for (const k2 of validKeys) {
      filtered[k2] = obj[k2];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e2) {
      return obj[e2];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_2, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
const ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
const getParsedType = (data) => {
  const t2 = typeof data;
  switch (t2) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
const ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
const quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i2 = 0;
          while (i2 < issue.path.length) {
            const el2 = issue.path[i2];
            const terminal = i2 === issue.path.length - 1;
            if (!terminal) {
              curr[el2] = curr[el2] || { _errors: [] };
            } else {
              curr[el2] = curr[el2] || { _errors: [] };
              curr[el2]._errors.push(mapper(issue));
            }
            curr = curr[el2];
            i2++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
const errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
let overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
const makeIssue = (params) => {
  const { data, path: path2, errorMaps, issueData } = params;
  const fullPath = [...path2, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m2) => !!m2).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
const EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x2) => !!x2)
  });
  ctx.common.issues.push(issue);
}
class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s2 of results) {
      if (s2.status === "aborted")
        return INVALID;
      if (s2.status === "dirty")
        status.dirty();
      arrayValue.push(s2.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
const INVALID = Object.freeze({
  status: "aborted"
});
const DIRTY = (value) => ({ status: "dirty", value });
const OK = (value) => ({ status: "valid", value });
const isAborted = (x2) => x2.status === "aborted";
const isDirty = (x2) => x2.status === "dirty";
const isValid = (x2) => x2.status === "valid";
const isAsync = (x2) => typeof Promise !== "undefined" && x2 instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f2) {
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f2) {
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return state.set(receiver, value), value;
}
typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
  var e2 = new Error(message);
  return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
};
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache, _ZodNativeEnum_cache;
class ParseInputLazyPath {
  constructor(parent, value, path2, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path2;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
const handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
const cuidRegex = /^c[^\s-]{8,}$/i;
const cuid2Regex = /^[0-9a-z]+$/;
const ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
const uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
const nanoidRegex = /^[a-z0-9_-]{21}$/i;
const durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
const emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
const _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
let emojiRegex;
const ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
const ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
const base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
const dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
const dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch2) => ch2.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch2) => ch2.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch2) => ch2.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch2) => ch2.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch2) => ch2.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch2) => ch2.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch2) => ch2.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch2) => ch2.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch2) => ch2.kind === "base64");
  }
  get minLength() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch2) => ch2.kind === "int" || ch2.kind === "multipleOf" && util.isInteger(ch2.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "finite" || ch2.kind === "int" || ch2.kind === "multipleOf") {
        return true;
      } else if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      } else if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "min") {
        if (min2 === null || ch2.value > min2)
          min2 = ch2.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch2 of this._def.checks) {
      if (ch2.kind === "max") {
        if (max2 === null || ch2.value < max2)
          max2 = ch2.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i2) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i2) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i2));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index2) {
    return new ZodObject({
      ...this._def,
      catchall: index2
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
const getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}
function mergeValues(a2, b2) {
  const aType = getParsedType(a2);
  const bType = getParsedType(b2);
  if (a2 === b2) {
    return { valid: true, data: a2 };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b2);
    const sharedKeys = util.objectKeys(a2).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a2, ...b2 };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a2[key], b2[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a2.length !== b2.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index2 = 0; index2 < a2.length; index2++) {
      const itemA = a2[index2];
      const itemB = b2[index2];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a2 === +b2) {
    return { valid: true, data: a2 };
  } else {
    return { valid: false };
  }
}
class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x2) => !!x2);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}
class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index2) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index2, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index2, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i2) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i2)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x2) => !!x2),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me2 = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me2._def.args.parseAsync(args, params).catch((e2) => {
          error.addIssue(makeArgsIssue(args, e2));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me2._def.returns._def.type.parseAsync(result, params).catch((e2) => {
          error.addIssue(makeReturnsIssue(result, e2));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me2 = this;
      return OK(function(...args) {
        const parsedArgs = me2._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me2._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}
class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
class ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache)) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values));
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache).has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
}
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
class ZodNativeEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache)) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)));
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache).has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
const BRAND = Symbol("zod_brand");
class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}
class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a2, b2) {
    return new ZodPipeline({
      in: a2,
      out: b2,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}
class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p2 = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p2.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p22 = typeof p2 === "string" ? { message: p2 } : p2;
        ctx.addIssue({ code: "custom", ...p22, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
const late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
const instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
const stringType = ZodString.create;
const numberType = ZodNumber.create;
const nanType = ZodNaN.create;
const bigIntType = ZodBigInt.create;
const booleanType = ZodBoolean.create;
const dateType = ZodDate.create;
const symbolType = ZodSymbol.create;
const undefinedType = ZodUndefined.create;
const nullType = ZodNull.create;
const anyType = ZodAny.create;
const unknownType = ZodUnknown.create;
const neverType = ZodNever.create;
const voidType = ZodVoid.create;
const arrayType = ZodArray.create;
const objectType = ZodObject.create;
const strictObjectType = ZodObject.strictCreate;
const unionType = ZodUnion.create;
const discriminatedUnionType = ZodDiscriminatedUnion.create;
const intersectionType = ZodIntersection.create;
const tupleType = ZodTuple.create;
const recordType = ZodRecord.create;
const mapType = ZodMap.create;
const setType = ZodSet.create;
const functionType = ZodFunction.create;
const lazyType = ZodLazy.create;
const literalType = ZodLiteral.create;
const enumType = ZodEnum.create;
const nativeEnumType = ZodNativeEnum.create;
const promiseType = ZodPromise.create;
const effectsType = ZodEffects.create;
const optionalType = ZodOptional.create;
const nullableType = ZodNullable.create;
const preprocessType = ZodEffects.createWithPreprocess;
const pipelineType = ZodPipeline.create;
const ostring = () => stringType().optional();
const onumber = () => numberType().optional();
const oboolean = () => booleanType().optional();
const coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
const NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});
function useCustomDataForm() {
  const { defaultChartDataRef, setDefaultChartData } = useGlobalChartsInfo();
  const { t: t$12 } = useTranslation("useCustomDataForm");
  const values = {
    numbers: defaultChartDataRef.current.fields.map(({ number }) => ({
      number
    }))
  };
  const numberObj = z.object({
    number: z.coerce.number().int({ message: t$12("integer") }).positive({ message: t$12("positive") }).max(CUSTOM_DATA_FORM_HIGHEST_NUMBER, {
      message: t$12("highest", { number: CUSTOM_DATA_FORM_HIGHEST_NUMBER })
    })
  });
  const CustomDataSchema = z.object({
    numbers: z.array(numberObj).min(5, { message: t$12("min") }).max(CUSTOM_DATA_FORM_MAX_NUMBERS, {
      message: t$12("max", { number: CUSTOM_DATA_FORM_MAX_NUMBERS })
    })
  });
  const form = useForm({
    resolver: t(CustomDataSchema),
    values,
    mode: "all"
  });
  const { fields, remove, insert: insert2 } = useFieldArray({
    control: form.control,
    name: "numbers"
  });
  const onSubmit = (values2) => {
    const validatedValues = CustomDataSchema.safeParse(values2);
    if (validatedValues.success) {
      setDefaultChartData(values2.numbers.map(({ number }) => number));
    }
  };
  return { form, onSubmit, fields, remove, insert: insert2 };
}
function CustomDataButton() {
  const { form, onSubmit, fields, remove, insert: insert2 } = useCustomDataForm();
  const { t: t2 } = useTranslation("CustomDataButton");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(Dialog, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTrigger, { asChild: true, children: /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { variant: "outline", children: t2("button") }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs(
      DialogContent,
      {
        className: "flex h-3/6 min-h-64 w-96 flex-col",
        onCloseAutoFocus: () => form.reset(),
        children: [
          /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogHeader, { children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogTitle, { children: t2("title") }),
            /* @__PURE__ */ jsxRuntimeExports.jsx(DialogDescription, { children: t2("description") })
          ] }),
          /* @__PURE__ */ jsxRuntimeExports.jsx(Form, { ...form, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(
            "form",
            {
              onSubmit: form.handleSubmit(onSubmit),
              className: "flex flex-auto flex-col",
              children: [
                /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-0 flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-col space-y-2 p-1 pr-5", children: fields.map((field, index2) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                  FormField,
                  {
                    control: form.control,
                    name: `numbers.${index2}.number`,
                    render: ({ field: field2 }) => /* @__PURE__ */ jsxRuntimeExports.jsx(FormItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex min-h-10 items-center justify-between gap-2", children: [
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex items-end gap-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsxs("p", { className: "w-8", children: [
                          index2 + 1,
                          "."
                        ] }),
                        /* @__PURE__ */ jsxRuntimeExports.jsx(FormControl, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Input,
                          {
                            className: "w-16 [appearance:textfield] [&::-webkit-inner-spin-button]:appearance-none [&::-webkit-outer-spin-button]:appearance-none",
                            type: "number",
                            placeholder: "number",
                            ...field2
                          }
                        ) })
                      ] }),
                      /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {}),
                      /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex justify-center gap-2", children: [
                        /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Button,
                          {
                            asChild: true,
                            variant: "outline",
                            className: "p-0",
                            onClick: () => {
                              insert2(index2 + 1, {
                                number: Math.floor(Math.random() * 51 + 1)
                              });
                              form.trigger();
                            },
                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(Plus, {})
                          }
                        ),
                        fields.length > 1 && /* @__PURE__ */ jsxRuntimeExports.jsx(
                          Button,
                          {
                            asChild: true,
                            variant: "outline",
                            className: "p-0",
                            onClick: () => {
                              fields.length > 1 && remove(index2);
                              form.trigger();
                            },
                            children: /* @__PURE__ */ jsxRuntimeExports.jsx(X, {})
                          }
                        )
                      ] })
                    ] }) })
                  },
                  field.id
                )) }) }),
                /* @__PURE__ */ jsxRuntimeExports.jsxs(DialogFooter, { className: "pt-2 sm:justify-between", children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsx(
                    FormField,
                    {
                      control: form.control,
                      name: `numbers`,
                      render: () => /* @__PURE__ */ jsxRuntimeExports.jsx(FormItem, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(FormMessage, {}) })
                    }
                  ),
                  /* @__PURE__ */ jsxRuntimeExports.jsx(Button, { type: "submit", variant: "outline", children: t2("save") })
                ] })
              ]
            }
          ) })
        ]
      }
    )
  ] });
}
function LocaleToggleButton() {
  const { i18n, t: t2 } = useTranslation("LocaleToggleButton");
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Select,
    {
      defaultValue: i18n.language,
      onValueChange: (value) => i18n.changeLanguage(value),
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectTrigger, { className: "w-28", children: /* @__PURE__ */ jsxRuntimeExports.jsx(SelectValue, {}) }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(SelectContent, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(SelectGroup, { children: [
          /* @__PURE__ */ jsxRuntimeExports.jsx(SelectLabel, { children: t2("label") }),
          Object.entries(supportedLngs).map(([code, name]) => /* @__PURE__ */ jsxRuntimeExports.jsx(SelectItem, { value: code, children: name }, code))
        ] }) })
      ]
    }
  );
}
const initialState = {
  theme: "system",
  setTheme: () => null
};
const ThemeProviderContext = reactExports.createContext(initialState);
function ThemeProvider({
  children,
  defaultTheme = "system",
  storageKey = "vite-ui-theme",
  ...props
}) {
  const [theme, setTheme] = reactExports.useState(
    () => localStorage.getItem(storageKey) || defaultTheme
  );
  reactExports.useEffect(() => {
    const root = window.document.documentElement;
    root.classList.remove("light", "dark");
    if (theme === "system") {
      const systemTheme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "dark" : "light";
      root.classList.add(systemTheme);
      return;
    }
    root.classList.add(theme);
  }, [theme]);
  const value = {
    theme,
    setTheme: (theme2) => {
      localStorage.setItem(storageKey, theme2);
      setTheme(theme2);
    }
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProviderContext.Provider, { ...props, value, children });
}
const useTheme = () => {
  const context = reactExports.useContext(ThemeProviderContext);
  if (context === void 0)
    throw new Error("useTheme must be used within a ThemeProvider");
  return context;
};
function ThemeToggleButton() {
  const { setTheme, theme } = useTheme();
  return /* @__PURE__ */ jsxRuntimeExports.jsxs(
    Button,
    {
      onClick: () => setTheme(theme === "dark" ? "light" : "dark"),
      variant: "outline",
      size: "icon",
      children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(Sun, { className: "h-[1.2rem] w-[1.2rem] rotate-0 scale-100 transition-all dark:-rotate-90 dark:scale-0" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx(Moon, { className: "absolute h-[1.2rem] w-[1.2rem] rotate-90 scale-0 transition-all dark:rotate-0 dark:scale-100" }),
        /* @__PURE__ */ jsxRuntimeExports.jsx("span", { className: "sr-only", children: "Toggle theme" })
      ]
    }
  );
}
function Header() {
  return /* @__PURE__ */ jsxRuntimeExports.jsxs("header", { className: "flex h-12 items-center justify-between border-b px-1 py-5", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex flex-1 gap-x-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeToggleButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(LocaleToggleButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex gap-x-2", children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(CustomDataButton, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ExampleDataButton, {})
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: "flex flex-1 justify-end gap-x-2", children: /* @__PURE__ */ jsxRuntimeExports.jsx(AlgorithmsVisibilityButton, {}) })
  ] });
}
const TanStackRouterDevtools = () => null;
const Route2 = createRootRoute({
  component: () => /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: "flex min-h-dvh flex-col font-sans", children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(DndProvider, { backend: HTML5Backend, children: /* @__PURE__ */ jsxRuntimeExports.jsx(ThemeProvider, { defaultTheme: "dark", storageKey: "vite-ui-theme", children: /* @__PURE__ */ jsxRuntimeExports.jsx(GlobalChartsInfoProvider, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs(AlgorithmsVisibilityProvider, { children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(Header, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(ScrollArea, { className: "h-0 flex-auto", children: /* @__PURE__ */ jsxRuntimeExports.jsx("main", { className: "h-full w-full select-none", children: /* @__PURE__ */ jsxRuntimeExports.jsx(Outlet, {}) }) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(Footer, {})
    ] }) }) }) }),
    /* @__PURE__ */ jsxRuntimeExports.jsx(reactExports.Suspense, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(TanStackRouterDevtools, { position: "top-right" }) })
  ] })
});
const IndexLazyImport = createFileRoute("/")();
const IndexLazyRoute = IndexLazyImport.update({
  path: "/",
  getParentRoute: () => Route2
}).lazy(() => __vitePreload(() => import("./index.lazy-BTq1Ngg5.js"), true ? [] : void 0, import.meta.url).then((d2) => d2.Route));
const rootRouteChildren = {
  IndexLazyRoute
};
const routeTree = Route2._addFileChildren(rootRouteChildren)._addFileTypes();
const memoryHistory = createMemoryHistory({
  initialEntries: ["/"]
});
const router = createRouter({ routeTree, history: memoryHistory });
const rootElement = document.getElementById("root");
if (!rootElement.innerHTML) {
  const root = client.createRoot(rootElement);
  root.render(
    /* @__PURE__ */ jsxRuntimeExports.jsx(React.StrictMode, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(RouterProvider, { router }) })
  );
}
export {
  v as $,
  Anchor as A,
  useDragAlgorithm as B,
  Content$1 as C,
  DismissableLayer as D,
  DRAG_CONTAINER_LAYOUT as E,
  FocusScope as F,
  DRAG_ITEM_TYPE as G,
  useTranslation as H,
  CHART_ACTION as I,
  useGlobalChartsInfo as J,
  React as K,
  getDefaultExportFromCjs as L,
  useTheme as M,
  ScrollArea as N,
  Button as O,
  Primitive as P,
  ChevronLeft as Q,
  ReactRemoveScroll as R,
  Slot as S,
  ChevronRight as T,
  useChartInfo as U,
  visualizeChartDataFields as V,
  ChartInfoProvider as W,
  X,
  SORTING_ALGORITHM as Y,
  createLazyFileRoute as Z,
  h as _,
  createCollection as a,
  createContextScope$1 as b,
  createLucideIcon as c,
  useDirection as d,
  useControllableState as e,
  useCallbackRef$1 as f,
  composeEventHandlers as g,
  useId as h,
  createContextScope as i,
  jsxRuntimeExports as j,
  createPopperScope as k,
  Presence as l,
  hideOthers as m,
  useFocusGuards as n,
  Arrow as o,
  composeRefs as p,
  dispatchDiscreteCustomEvent as q,
  reactExports as r,
  Root2$1 as s,
  Portal$2 as t,
  useComposedRefs as u,
  cn as v,
  ChevronRightIcon as w,
  CheckIcon as x,
  DotFilledIcon as y,
  useAlgorithmsVisibility as z
};
